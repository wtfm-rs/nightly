rd_("CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa60ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60110011001100CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa6000CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60CmLoads 8 double-precision (64-bit) floating-point elements \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa60ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa60CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa60ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa60CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa60CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa6000CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa60CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa60CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa60CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa60CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa60CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa60<<;;::CkPerforms an affine transformation on the packed bytes in x.0CiMultiply the lower complex number in a by the complex \xe2\x80\xa60CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa60CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa60CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa60CiMultiply the lower complex number in a by the complex \xe2\x80\xa60CiNormalize the mantissas of the lower double-precision \xe2\x80\xa60CgNormalize the mantissas of the lower half-precision \xe2\x80\xa60CiNormalize the mantissas of the lower single-precision \xe2\x80\xa60CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60CkChecks that the preconditions of an unsafe function are \xe2\x80\xa60CgReturns mutable references to many indices at once, \xe2\x80\xa60DjAttempts to get mutable references to <code>N</code> values in the map \xe2\x80\xa6CnSaturating conversion of the two double-precision floating \xe2\x80\xa600CcCheck for the presence of a CPU feature at runtime.0DhLike <code>panic_nounwind</code>, but also inhibits showing a backtrace.DkPrefetch the cache line containing <code>ptr</code> for a single future \xe2\x80\xa60DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa60CjReorders the slice with a key extraction function such \xe2\x80\xa60CnWhen specified, sets the following flags on the STARTUPINFO\xe2\x80\xa6666CnReturns the smallest power of two greater than or equal to \xe2\x80\xa600000000000CnAfter a line ending with \xe2\x80\x99&#39;, multiple lines are skipped.ClReturn a pointer containing a randomly generated logical \xe2\x80\xa6CmBroadcasts 128 bits of integer data from a to all 128-bit \xe2\x80\xa60CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa60CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa60CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa601100110011001100ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa60ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa60CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa60ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CkReduce the packed 8-bit integers in a by addition using \xe2\x80\xa60CnReduce the packed 8-bit integers in a by bitwise AND using \xe2\x80\xa60CjReduce the packed 8-bit integers in a by maximum using \xe2\x80\xa60CmReduce the packed unsigned 8-bit integers in a by maximum \xe2\x80\xa60CjReduce the packed 8-bit integers in a by minimum using \xe2\x80\xa60CmReduce the packed unsigned 8-bit integers in a by minimum \xe2\x80\xa60CkReduce the packed 8-bit integers in a by multiplication \xe2\x80\xa60CnReduce the packed 16-bit integers in a by bitwise OR using \xe2\x80\xa60CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa60CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa60CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa60ClZero extend packed unsigned 16-bit integers in the low 8 \xe2\x80\xa60CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa60CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa60DhPermutes packed 32-bit integers from <code>a</code> according to the \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa60CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa60CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa60CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa601100110011001100ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa60ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa60CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa60CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa60ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa60ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60ClGather 32-bit integers from memory using 32-bit indices. \xe2\x80\xa60ClGather 64-bit integers from memory using 32-bit indices. \xe2\x80\xa60CnStores 8 double-precision (64-bit) floating-point elements \xe2\x80\xa60ClGather 32-bit integers from memory using 64-bit indices. \xe2\x80\xa60ClGather 64-bit integers from memory using 64-bit indices. \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CnReduce the packed 32-bit integers in a by bitwise OR using \xe2\x80\xa60CnReduce the packed 64-bit integers in a by bitwise OR using \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa60CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa60CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa6000CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa60CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa60ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60CiBitwise ternary logic that provides the capability to \xe2\x80\xa6000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa60CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa60CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa6099CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60DkConverts a Vec&lt;u8&gt; to a <code>CString</code> without checking the \xe2\x80\xa60CiInteger extended pairwise addition producing extended \xe2\x80\xa600000000000CcCheck for the presence of a CPU feature at runtime.000DkPrefetch the cache line containing <code>ptr</code> for a single future \xe2\x80\xa60DdPublic API used by rustdoc to display the <code>total</code> and \xe2\x80\xa6333333CnVector Find Any Element Equal or Zero Index with Condition \xe2\x80\xa6ChVector Find Any Element Not Equal or Zero Index with \xe2\x80\xa6DeCreates an empty <code>HashMap</code> with at least the specified \xe2\x80\xa6DeCreates an empty <code>HashSet</code> with at least the specified \xe2\x80\xa6CmConverts an address back to a mutable pointer, picking up \xe2\x80\xa60CiZero-sized type used to mark a lifetime as contravariant.0EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa60CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6055ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60443322771100443322771100443322771100443322CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa60CnStores 8 32-bit integer elements from a to memory starting \xe2\x80\xa60CnStores 4 64-bit integer elements from a to memory starting \xe2\x80\xa60CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa6011CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60ClReduce the packed 16-bit integers in a by addition using \xe2\x80\xa60CiReduce the packed 16-bit integers in a by bitwise AND \xe2\x80\xa60CkReduce the packed 16-bit integers in a by maximum using \xe2\x80\xa60CnReduce the packed unsigned 16-bit integers in a by maximum \xe2\x80\xa60CkReduce the packed 16-bit integers in a by minimum using \xe2\x80\xa60CnReduce the packed unsigned 16-bit integers in a by minimum \xe2\x80\xa60ClReduce the packed 16-bit integers in a by multiplication \xe2\x80\xa60CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa60CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa60CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CkLoads 8 32-bit integer elements from memory starting at \xe2\x80\xa60CkLoads 4 64-bit integer elements from memory starting at \xe2\x80\xa60CkLoads 4 32-bit integer elements from memory starting at \xe2\x80\xa6011CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa60EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa608877CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa60CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6055ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60443322771100443322771100443322771100443322CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CkScatter 32-bit integers from a into memory using 32-bit \xe2\x80\xa60CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa60CkScatter 32-bit integers from a into memory using 64-bit \xe2\x80\xa60CkScatter 64-bit integers from a into memory using 64-bit \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60ClReduce the packed 32-bit integers in a by addition using \xe2\x80\xa60ClReduce the packed 64-bit integers in a by addition using \xe2\x80\xa60CiReduce the packed 32-bit integers in a by bitwise AND \xe2\x80\xa6011ClReduce the packed signed 32-bit integers in a by maximum \xe2\x80\xa60ClReduce the packed signed 64-bit integers in a by maximum \xe2\x80\xa60CnReduce the packed unsigned 32-bit integers in a by maximum \xe2\x80\xa60CnReduce the packed unsigned 64-bit integers in a by maximum \xe2\x80\xa6033221122ClReduce the packed 32-bit integers in a by multiplication \xe2\x80\xa60ClReduce the packed 64-bit integers in a by multiplication \xe2\x80\xa60CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa60CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa60CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa60CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa60ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa60CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa60CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa60CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa60ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa60665544CiBitwise ternary logic that provides the capability to \xe2\x80\xa6000DhConverts bytes to an <code>OsString</code> without checking that the \xe2\x80\xa6CkConverts a slice of bytes to an OS string slice without \xe2\x80\xa6EgConsumes the <code>Box</code>, returning a wrapped <code>NonNull</code> pointer and \xe2\x80\xa60CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa60CkPartially sorts the slice in ascending order with a key \xe2\x80\xa60BmReceives data and ancillary data from socket.0BlSends data and ancillary data on the socket.0ChCreates a vector of pointers from a vector of addresses.0DgWhen true, sets the <code>STARTF_UNTRUSTEDSOURCE</code> flag on the \xe2\x80\xa6DhChecks if the <code>Request</code> would be satisfied if provided with a0BgRaw \xe2\x80\x98\\r\xe2\x80\x99 encountered in raw string.CkPerforms an affine transformation on the packed bytes in x.0ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa60ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa60CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa60CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60CkPerforms an affine transformation on the packed bytes in x.0CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60000000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CkLoads 8 64-bit integer elements from memory starting at \xe2\x80\xa60ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa60CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60ClPerforms an affine transformation on the inverted packed \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa60CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa60ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa60CfUnsafely creates a C string wrapper from a byte slice.0BgCreates a layout, bypassing all checks.00BbA relaxed dot-product instruction.00CcCheck for the presence of a CPU feature at runtime.000CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa60222m\xe2\x80\x98\\u{_12}\xe2\x80\x99D`Builder for constructing a <code>ProcThreadAttributeList</code>.CaNegates results only before the end of the string0CbDo not negate results before the end of the string0ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa60CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60CiBitwise ternary logic that provides the capability to \xe2\x80\xa6000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa6099CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa60<<ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6011ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa601122CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60000000CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa60ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa60CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa60CnStores 8 64-bit integer elements from a to memory starting \xe2\x80\xa60CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60CiBitwise ternary logic that provides the capability to \xe2\x80\xa6000ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60000000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa60CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa60EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa60DjA guard for <code>std::mem::uninitialized</code>. This will statically \xe2\x80\xa60DcA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> \xe2\x80\xa600DcA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> \xe2\x80\xa600DhChecks if the <code>Request</code> would be satisfied if provided with a0CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa60554433CiBitwise ternary logic that provides the capability to \xe2\x80\xa600066554433CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000000000002222222288ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa6088CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa60>>==<<8888ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CkPerforms an affine transformation on the packed bytes in x.0CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa60CfSends data and ancillary data on the socket to the \xe2\x80\xa6AoVector Search String Until ZeroClPerforms an affine transformation on the inverted packed \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa6066554433221100CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60??>>>>==CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa6EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa607766554433221100DiSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the \xe2\x80\xa6009BmReceives data and ancillary data from socket.111ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CkPerforms an affine transformation on the packed bytes in x.0885544443322110088ClPerforms an affine transformation on the inverted packed \xe2\x80\xa60CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa604433332244333322110DeEquivalent to the appropriate <code>llvm.memcpy.p0i8.0i8.*</code> \xe2\x80\xa602222122221")