rd_("ClPowerPC-specific 128-bit wide vector mask of four packed \xe2\x80\xa60Cjs390x-specific 128-bit wide vector mask of four packed \xe2\x80\xa6ClFloating-point fused multiply-add to accumulator Arm\xe2\x80\x99s \xe2\x80\xa600000CiFloating-point fused Multiply-Add Long to accumulator \xe2\x80\xa60CdFloating-point fused Multiply-Subtract Long from \xe2\x80\xa60ClFloating-point fused multiply-subtract to accumulator Arm\xe2\x80\xa6CnFloating-point fused multiply-subtract from accumulator Arm\xe2\x80\xa60111CjLookup table read with 2-bit indices Arm\xe2\x80\x99s documentation00000CjLookup table read with 4-bit indices Arm\xe2\x80\x99s documentation00CkVector widening multiply accumulate with scalar Arm\xe2\x80\x99s \xe2\x80\xa60000000CbVector multiply accumulate with scalar Arm\xe2\x80\x99s \xe2\x80\xa6000000000CiVector widening multiply subtract with scalar Arm\xe2\x80\x99s \xe2\x80\xa60000000CjVector multiply subtract with scalar Arm\xe2\x80\x99s documentation000000000BmFloating-point multiply Arm\xe2\x80\x99s documentation0CdVector long multiply by scalar Arm\xe2\x80\x99s documentation00000001111AnMultiply Arm\xe2\x80\x99s documentation00000002CfFloating-point multiply extended Arm\xe2\x80\x99s documentation00000000CfSigned saturating extract narrow Arm\xe2\x80\x99s documentation00000CjVector saturating rounding doubling multiply high with \xe2\x80\xa6000ClSigned saturating rounded shift right unsigned narrow Arm\xe2\x80\xa600CkSHA256 schedule update accelerator, first part. Arm\xe2\x80\x99s \xe2\x80\xa60ClSHA256 schedule update accelerator, second part. Arm\xe2\x80\x99s \xe2\x80\xa60BnSHA512 schedule update 0 Arm\xe2\x80\x99s documentationBnSHA512 schedule update 1 Arm\xe2\x80\x99s documentationBlSigned shift left long Arm\xe2\x80\x99s documentation0AoSM3PARTW1 Arm\xe2\x80\x99s documentationAoSM3PARTW2 Arm\xe2\x80\x99s documentationCdSubtract returning high narrow Arm\xe2\x80\x99s documentation00000000000ClDot product index form with signed and unsigned integers \xe2\x80\xa60ClDot product index form with unsigned and signed integers \xe2\x80\xa60ChWaits on this condition variable for a notification, \xe2\x80\xa6CfPerforms an arithmetic add reduction on the values \xe2\x80\xa6CkPerforms a logical and reduction on the unsigned values \xe2\x80\xa6CmPerforms an arithmetic max reduction on the signed values \xe2\x80\xa6CmPerforms an arithmetic min reduction on the signed values \xe2\x80\xa6CkPerforms a logical xor reduction on the unsigned values \xe2\x80\xa6CdAcquires a mutable reference to the contained value.CdAdds a signed offset to a pointer using wrapping \xe2\x80\xa60CgCalculates the offset from a pointer using wrapping \xe2\x80\xa60110000CmOverwrites a memory location with the given value without \xe2\x80\xa600000CmAn <code>AtomicBool</code> initialized to <code>false</code>.0CjA nonexistent interface was requested or the requested \xe2\x80\xa6CnA simple wrapper around a type to assert that it is unwind \xe2\x80\xa60CnError due to the computed capacity exceeding the collection\xe2\x80\xa60EhThe error type returned when a conversion from <code>u32</code> to <code>char</code> \xe2\x80\xa60fU+005E0CkAn error that can be returned when decoding UTF-16 code \xe2\x80\xa60fU+00110fU+00120CmCompiler-internal trait used to indicate the type of enum \xe2\x80\xa60CdThe literal failed to be escaped, take a look at \xe2\x80\xa6CbAn index provided was out-of-bounds for the slice.00fU+007B0DkAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can \xe2\x80\xa600BdData provided is not nul terminated.000CjThe operation lacked the necessary privileges to complete.CkZero-sized type used to mark a type parameter as covariant.0CkZero-sized type used to mark a type parameter as invariant.0ClTrait that indicates that this is a pointer or a wrapper \xe2\x80\xa60CgCreated with the method <code>rsplit_terminator</code>.00CmA range only bounded inclusively above (<code>..=end</code>).0CnA range only bounded inclusively above (<code>..=last</code>).110CmThis enumeration is the list of possible errors that made \xe2\x80\xa6EfAn error returned from the <code>recv_timeout</code> or <code>recv_deadline</code> \xe2\x80\xa6fU+00290CmRAII structure used to release the exclusive write access \xe2\x80\xa600ClAn owned permission to join on a scoped thread (block on \xe2\x80\xa6ClAn error returned from the <code>send_timeout</code> method.DhAn error returned from <code>Path::strip_prefix</code> if the prefix \xe2\x80\xa6CjThe error type returned when a checked char conversion \xe2\x80\xa60eFalse0Biround down and do not suppress exceptions0Bgtruncate and do not suppress exceptions0AkSee <code>_mm_setcsr</code>000CfFor each character in <code>a</code>, determine if \xe2\x80\xa60CkTransaction abort due to the transaction using too much \xe2\x80\xa60CkTransaction abort due to a memory conflict with another \xe2\x80\xa60CmTransaction explicitly aborted with xabort. The parameter \xe2\x80\xa60EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa600ClShift 16-bit mask a left by count bits while shifting in \xe2\x80\xa60CgShift the bits of 32-bit mask a left by count while \xe2\x80\xa60CgShift the bits of 64-bit mask a left by count while \xe2\x80\xa60CmShift 16-bit mask a right by count bits while shifting in \xe2\x80\xa60ChShift the bits of 32-bit mask a right by count while \xe2\x80\xa60ChShift the bits of 64-bit mask a right by count while \xe2\x80\xa60CkCompute the bitwise AND of 16-bit masks a and b, and if \xe2\x80\xa60CkCompute the bitwise AND of 32-bit masks a and b, and if \xe2\x80\xa60CkCompute the bitwise AND of 64-bit masks a and b, and if \xe2\x80\xa60CmCompute the bitwise NOT of 8-bit mask a and then AND with \xe2\x80\xa60CkCompute the bitwise AND of 8-bit masks a and  b, if the \xe2\x80\xa60DkComputes the absolute values of packed 16-bit integers in <code>a</code>\xe2\x80\xa60DkComputes the absolute values of packed 32-bit integers in <code>a</code>\xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60DaAdds packed 16-bit integers in <code>a</code> and <code>b</code>.0DaAdds packed 32-bit integers in <code>a</code> and <code>b</code>.0DaAdds packed 64-bit integers in <code>a</code> and <code>b</code>.0EaAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.0EbAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using \xe2\x80\xa60ClAlternatively adds and subtracts packed double-precision \xe2\x80\xa60ClAlternatively adds and subtracts packed single-precision \xe2\x80\xa60CnComputes the bitwise AND of 256 bits (representing integer \xe2\x80\xa60CgComputes the bitwise NOT of packed double-precision \xe2\x80\xa60CgComputes the bitwise NOT of packed single-precision \xe2\x80\xa60DnAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.0CjBlends packed double-precision (64-bit) floating-point \xe2\x80\xa60CjBlends packed single-precision (32-bit) floating-point \xe2\x80\xa60DoCast vector of type <code>__m256d</code> to type <code>__m256h</code>. This \xe2\x80\xa60BkCast vector of type __m256d to type __m256.0DoCast vector of type <code>__m256h</code> to type <code>__m256d</code>. This \xe2\x80\xa60EhCast vector of type <code>__m256h</code> to type <code>__m256</code>. This intrinsic \xe2\x80\xa60BkCast vector of type __m256 to type __m256d.0EhCast vector of type <code>__m256</code> to type <code>__m256h</code>. This intrinsic \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CdReturns the first element of the input vector of \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60EeCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns \xe2\x80\xa60EeCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60EfCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa60EfCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CkSet each packed 8-bit integer in dst to all ones or all \xe2\x80\xa60CnMultiplies the low 32-bit integers from each packed 64-bit \xe2\x80\xa60CiMultiplies the low unsigned 32-bit integers from each \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60DgBroadcasts 8-bit integer <code>a</code> to all elements of returned \xe2\x80\xa60CkSets packed 16-bit integers in returned vector with the \xe2\x80\xa60CkSets packed 32-bit integers in returned vector with the \xe2\x80\xa60CiSets packed __m256d returned vector with the supplied \xe2\x80\xa60CiSets packed __m256i returned vector with the supplied \xe2\x80\xa60CjSets packed 8-bit integers in returned vector with the \xe2\x80\xa60ChSets packed __m256 returned vector with the supplied \xe2\x80\xa60DjNegates packed 8-bit integers in <code>a</code> when the corresponding \xe2\x80\xa60EdShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa60EdShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa60EdShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while \xe2\x80\xa60EeShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa60EeShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa602211EeShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while \xe2\x80\xa60CjStores 256-bits (composed of 4 packed double-precision \xe2\x80\xa60ChStore 256-bits (composed of 16 packed half-precision \xe2\x80\xa60CjStores 256-bits (composed of 8 packed single-precision \xe2\x80\xa60CjMoves double-precision values from a 256-bit vector of \xe2\x80\xa60CgMoves single-precision floating point values from a \xe2\x80\xa60DhSubtract packed 16-bit integers in <code>b</code> from packed 16-bit \xe2\x80\xa60DhSubtract packed 32-bit integers in <code>b</code> from packed 32-bit \xe2\x80\xa60DhSubtract packed 64-bit integers in <code>b</code> from packed 64-bit \xe2\x80\xa60DfSubtract packed 8-bit integers in <code>b</code> from packed 8-bit \xe2\x80\xa60DiSubtract packed unsigned 8-bit integers in <code>b</code> from packed \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60CnComputes the bitwise XOR of 256 bits (representing integer \xe2\x80\xa60CmZeroes the upper 128 bits of all YMM registers; the lower \xe2\x80\xa60CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa60DkComputes the absolute values of packed 32-bit integers in <code>a</code>\xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa60CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa60CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CkCompute the bitwise AND of 512 bits (composed of packed \xe2\x80\xa60CmCompute the bitwise AND of 512 bits (representing integer \xe2\x80\xa60CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa60CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa60CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60DoCast vector of type <code>__m512d</code> to type <code>__m512h</code>. This \xe2\x80\xa60CnCast vector of type __m512d to type __m512. This intrinsic \xe2\x80\xa60DoCast vector of type <code>__m512h</code> to type <code>__m512d</code>. This \xe2\x80\xa60EhCast vector of type <code>__m512h</code> to type <code>__m512</code>. This intrinsic \xe2\x80\xa60CnCast vector of type __m512 to type __m512d. This intrinsic \xe2\x80\xa60EhCast vector of type <code>__m512</code> to type <code>__m512h</code>. This intrinsic \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CkCopy the lower double-precision (64-bit) floating-point \xe2\x80\xa60CkCopy the lower single-precision (32-bit) floating-point \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CkSet each packed 8-bit integer in dst to all ones or all \xe2\x80\xa60ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa60CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CaBroadcast 8-bit integer a to all elements of dst.0CkSet packed 16-bit integers in dst with the supplied values.0DeSets packed 32-bit integers in <code>dst</code> with the supplied \xe2\x80\xa60CkSet packed 64-bit integers in dst with the supplied values.0CiShift packed 16-bit integers in a left by count while \xe2\x80\xa60CiShift packed 32-bit integers in a left by count while \xe2\x80\xa60CiShift packed 64-bit integers in a left by count while \xe2\x80\xa60CjShift packed 16-bit integers in a right by count while \xe2\x80\xa60CjShift packed 32-bit integers in a right by count while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa60221100CjStores 512-bits (composed of 8 packed double-precision \xe2\x80\xa60ChStore 512-bits (composed of 32 packed half-precision \xe2\x80\xa60CkStores 512-bits (composed of 16 packed single-precision \xe2\x80\xa60CiStore 512-bits (composed of 8 packed double-precision \xe2\x80\xa60CjStore 512-bits (composed of 16 packed single-precision \xe2\x80\xa60CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa60CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa60CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa60CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa60ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa60CmReturn vector of type __m512 with indeterminate elements. \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60CmCompute the bitwise XOR of 512 bits (representing integer \xe2\x80\xa60CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa60ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa60CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa60ChPerforms one round of an AES decryption flow on data \xe2\x80\xa60ChPerforms one round of an AES encryption flow on data \xe2\x80\xa60DiPerforms the <code>InvMixColumns</code> transformation on <code>a</code>.0CnConcatenate a and b into a 32-byte immediate result, shift \xe2\x80\xa6000CnComputes the bitwise NOT of 128 bits (representing integer \xe2\x80\xa60CiBroadcasts a single-precision (32-bit) floating-point \xe2\x80\xa60DkCasts a 128-bit floating-point vector of <code>[2 x double]</code> into \xe2\x80\xa60DoCast vector of type <code>__m128h</code> to type <code>__m128i</code>. This \xe2\x80\xa60DjCasts a 128-bit floating-point vector of <code>[4 x float]</code> into \xe2\x80\xa60CaCasts a 128-bit integer vector into a 128-bit \xe2\x80\xa60DoCast vector of type <code>__m128i</code> to type <code>__m128h</code>. This \xe2\x80\xa6011CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa60444444BfAlias for <code>_mm_cvttsd_si64</code>CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa60CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa60CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa60CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa6000CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6000ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6000CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa6000EcExtracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. \xe2\x80\xa60DhExtracts the bit range specified by <code>y</code> from the lower 64 \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000EaReturns a new vector where the <code>imm8</code> element of <code>a</code> is \xe2\x80\xa60E`Returns a copy of <code>a</code> with the 32-bit integer from <code>i</code> \xe2\x80\xa60E`Returns a copy of <code>a</code> with the 64-bit integer from <code>i</code> \xe2\x80\xa6DiInserts the <code>len</code> least-significant bits from the lower 64 \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CkLoad a double-precision (64-bit) floating-point element \xe2\x80\xa60CnLoad a half-precision (16-bit) floating-point element from \xe2\x80\xa60CkLoad a single-precision (32-bit) floating-point element \xe2\x80\xa60CkMove the lower double-precision (64-bit) floating-point \xe2\x80\xa60CiMove the lower half-precision (16-bit) floating-point \xe2\x80\xa60CkMove the lower single-precision (32-bit) floating-point \xe2\x80\xa60CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CiCompute the square root of the lower double-precision \xe2\x80\xa60CgCompute the square root of the lower half-precision \xe2\x80\xa60CiCompute the square root of the lower single-precision \xe2\x80\xa60CjStores packed double-precision (64-bit) floating-point \xe2\x80\xa60CjStores packed single-precision (32-bit) floating-point \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa60ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa60CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise AND of packed double-precision \xe2\x80\xa60CfCompute the bitwise AND of packed single-precision \xe2\x80\xa60CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa60CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa60CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60554433221100ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa60ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa60CcCompute the approximate reciprocal of the lower \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60C`Subtract the lower double-precision (64-bit) \xe2\x80\xa60CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Subtract the lower single-precision (32-bit) \xe2\x80\xa60CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa60CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa60CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60221100CnFinds the minimum unsigned 16-bit element in the 128-bit __\xe2\x80\xa60CeSet each bit of mask register k based on the most \xe2\x80\xa60ClSubtracts 8-bit unsigned integer values and computes the \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60ClMultiplies packed 16-bit signed integer values, truncate \xe2\x80\xa60EdConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa60EdConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60DnShuffles bytes from <code>a</code> according to the content of <code>b</code>.0DdStores the lower 64-bit integer <code>a</code> to a memory location.0CnStore 128-bits (composed of 8 packed 16-bit integers) from \xe2\x80\xa60CnStore 128-bits (composed of 4 packed 32-bit integers) from \xe2\x80\xa60CnStore 128-bits (composed of 2 packed 64-bit integers) from \xe2\x80\xa60D`Stores 128-bits of integer data from <code>a</code> into memory.0ChStores a 128-bit integer vector to a 128-bit aligned \xe2\x80\xa60C`Subtract the lower double-precision (64-bit) \xe2\x80\xa60CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Subtract the lower single-precision (32-bit) \xe2\x80\xa60CeReturns vector of type __m128d with indeterminate \xe2\x80\xa60DcReturn vector of type <code>__m128h</code> with indetermination \xe2\x80\xa60CnReturns vector of type __m128 with indeterminate elements. \xe2\x80\xa60CgMoves a row from a tile register to a zmm register, \xe2\x80\xa6CjLoad tile configuration from a 64-byte memory location \xe2\x80\xa6CgPerform matrix multiplication of two tiles a and b, \xe2\x80\xa6CmReturns the ABI-required minimum alignment of the type of \xe2\x80\xa60ChReturns the contents of this address if it is in the \xe2\x80\xa6ClConverts an OS string slice to a byte slice.  To convert \xe2\x80\xa6EgTakes a <code>&amp;mut [[T; N]]</code>, and flattens it to a <code>&amp;mut [T]</code>.0DfYields a mutable reference to the underlying <code>OsString</code> \xe2\x80\xa6CkReturns the two unsafe mutable pointers spanning the slice.0CkReturns a unique reference to the value behind the pointer.CfGet an exclusive reference to the value within the \xe2\x80\xa610CkReturns a shared reference to the value behind the pointer.0DgGet a shared reference to the value within the <code>UnsafeCell</code>.110CmA guard for unsafe functions that cannot ever be executed \xe2\x80\xa60E`Makes a <em>soundness</em> promise to the compiler that <code>cond</code> holds.0BdDrops the contained values in place.BcDrops the contained value in place.10DmReads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The \xe2\x80\xa60DkStores a value if the current value is the same as the <code>old</code> \xe2\x80\xa60CmThis macro uses forward-mode automatic differentiation to \xe2\x80\xa6ClThis macro handles automatic differentiation. This macro \xe2\x80\xa6CmThis macro uses reverse-mode automatic differentiation to \xe2\x80\xa61CjReturns the value that would be obtained by taking the \xe2\x80\xa6000DfBinary searches this <code>VecDeque</code> with a comparator function.CfBinary searches this slice with a comparator function.01CkCalculates the distance between two pointers within the \xe2\x80\xa600000BlCalculates the \xe2\x80\x9cfull multiplication\xe2\x80\x9d \xe2\x80\xa600000000000CjPerforms full-width multiplication and addition with a \xe2\x80\xa61111111111110CmChecking library UB is always enabled when UB-checking is \xe2\x80\xa6DjReturns an iterator over <code>chunk_size</code> elements of the slice \xe2\x80\xa60DaCopies the elements from <code>src</code> into <code>self</code>.0DiStores a value into the <code>bool</code> if the current value is the \xe2\x80\xa6CkStores a value into the pointer if the current value is \xe2\x80\xa6CiStores a value into the atomic integer if the current \xe2\x80\xa600000000000210000000000002100000000000021000000000000BkDeallocates a memory which allocated by \xe2\x80\xa60DhCreates a <code>Formatter</code> that writes its output to the given \xe2\x80\xa600CjProvides a cursor with editing operations at the front \xe2\x80\xa60EdDivides <code>Duration</code> by <code>Duration</code> and returns <code>f32</code>.0EdDivides <code>Duration</code> by <code>Duration</code> and returns <code>f64</code>.0CmParses an integer from an ASCII-byte slice with digits in \xe2\x80\xa600000000000000000000000DeConstructs a box from a <code>NonNull</code> pointer in the given \xe2\x80\xa60DgDecode a native endian UTF-16\xe2\x80\x93encoded slice <code>v</code> into a \xe2\x80\xa60AnReturns the current precision.00CcReturns mutable references to many indices at once.0DjAttempts to get mutable references to <code>N</code> values in the map \xe2\x80\xa6CkAttribute macro applied to a static to register it as a \xe2\x80\xa60CeChecks whether the path ends in a trailing separator.ChHypervisor memory management fence for given virtual \xe2\x80\xa60CnHypervisor memory management fence for given guest address \xe2\x80\xa60CmInvalidate hypervisor translation cache for given virtual \xe2\x80\xa60CkInvalidate hypervisor translation cache for given guest \xe2\x80\xa60ClCreates a new iterator which places an item generated by \xe2\x80\xa600FaConverts a <code>Box&lt;str&gt;</code> into a <code>Box&lt;[u8]&gt;</code> without copying or \xe2\x80\xa6DbConverts this <code>CString</code> into a boxed <code>CStr</code>.0CeConverts the vector into <code>Box&lt;[T]&gt;</code>.DgConverts a <code>Box&lt;T&gt;</code> into a <code>Box&lt;[T]&gt;</code>10CkReturns an iterator which retrieves elements in heap order.0CmChecks if the value is an ASCII control character: U+0000 \xe2\x80\xa6000CmChecks if the value is an ASCII graphic character: U+0021 \xe2\x80\xa6000DgChecks that <code>index</code>-th byte is the first byte in a UTF-8 \xe2\x80\xa60DjReturns <code>true</code> if this address is in a range designated for \xe2\x80\xa60D`Returns <code>true</code> if this is an address reserved for \xe2\x80\xa6110DoDetermines if <code>File</code> has an efficient <code>read_vectored</code> \xe2\x80\xa6EfDetermines if this <code>Read</code>er has an efficient <code>read_vectored</code> \xe2\x80\xa6FdReturns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, \xe2\x80\xa6000ClReturns true for each element if it has a negative sign, \xe2\x80\xa6111100FdReturns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, \xe2\x80\xa6000ClReturns true for each element if it has a positive sign, \xe2\x80\xa6111100CmChecks if the elements of this slice are sorted using the \xe2\x80\xa6ClChecks if the elements of this iterator are sorted using \xe2\x80\xa6010CeCreates a new unsuffixed integer literal with the \xe2\x80\xa6DhReturns the value of the <code>ftLastAccessTime</code> field of this \xe2\x80\xa6CmReturns the ABI-required minimum alignment of the type of \xe2\x80\xa60DgGets the value of the <code>IP_MULTICAST_TTL</code> option for this \xe2\x80\xa6ClConstructs a new atomically reference-counted slice with \xe2\x80\xa6CiConstructs a new boxed slice with uninitialized contents.CaConstructs a new reference-counted slice with \xe2\x80\xa62102CmConstructs a new boxed slice with uninitialized contents, \xe2\x80\xa61301DjIf <code>rhs</code> is positive, calculates the smallest value greater \xe2\x80\xa60000DkCalculates the smallest value greater than or equal to <code>self</code>\xe2\x80\xa6000010111110000010DhFinds the next <code>Reject</code> result. See <code>next_back()</code>.00ChRemoves a trailing separator from the path, if possible.CnProvides a reference computed using a closure. The referee \xe2\x80\xa60DhLike <code>read_at</code>, except that it reads into a slice of buffers.CeReads a number of bytes starting from a given offset.ClDivides one mutable array reference into two at an index \xe2\x80\xa60CmDivides one array reference into two at an index from the \xe2\x80\xa60AoSignal a specific barrier type.BoSets the read timeout to the timeout specified.0BeSets the read timeout for the socket.0BoSets whether the path has a trailing separator.ChSupervisor memory management fence for given virtual \xe2\x80\xa60BbExtracts an element from a vector.0AkReads a vector of pointers.0DkComputes <code>(x*y) + z</code> for each element, non-deterministically \xe2\x80\xa60CmInvalidate supervisor translation cache for given virtual \xe2\x80\xa60ChSorts the slice in ascending order with a comparison \xe2\x80\xa60DjDivides one slice into two at an index, returning <code>None</code> if \xe2\x80\xa6BnDivides one string slice into two at an index.10DfReturns an array reference to the last <code>N</code> items in the \xe2\x80\xa60CkReturns an iterator over substrings of the given string \xe2\x80\xa60BdSplits a string slice by whitespace.0DkConditionally write contiguous elements starting from <code>ptr</code>. \xe2\x80\xa60CmRemoves an element from anywhere in the deque and returns \xe2\x80\xa60CgQueries the metadata about a file without following \xe2\x80\xa60CiA variant optimized for invocation with a static test \xe2\x80\xa6ClRounds toward zero and converts to any primitive integer \xe2\x80\xa6000CmRounds toward zero and converts to the same-width integer \xe2\x80\xa6111100ClReturns a byte slice with leading ASCII whitespace bytes \xe2\x80\xa6ChReturns a string slice with leading ASCII whitespace \xe2\x80\xa610CiReturns a string slice with all suffixes that match a \xe2\x80\xa60ChTry to cast to a pointer of another type by checking \xe2\x80\xa600000CmReturns the type name of the pointed-to value as a string \xe2\x80\xa60EeReturns the contained <code>Some</code> value, consuming the <code>self</code> value,EgReturns the contained <code>Ok</code> value, consuming the <code>self</code> value, \xe2\x80\xa610CeCreates a new unsuffixed integer literal with the \xe2\x80\xa6FcLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that \xe2\x80\xa600FcLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that \xe2\x80\xa600CmLoad a 32-bit element into the low bits of the vector and \xe2\x80\xa600FcLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that \xe2\x80\xa600CmLoad a 64-bit element into the low bits of the vector and \xe2\x80\xa600CjLoad a single element and splat to all lanes of a v128 \xe2\x80\xa600EeStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>00C`Floating-point complex add Arm\xe2\x80\x99s documentation0000CfFloating-point complex multiply accumulate Arm\xe2\x80\x99s \xe2\x80\xa600000000CmInsert vector element from another vector element Arm\xe2\x80\x99s \xe2\x80\xa6000000000BnVector Compare Equal Index with Condition CodeCbVector Compare Not Equal Index with Condition CodeBoVector Compare Ranges Index with Condition CodeB`Vector Galois Field Multiply SumChPowerPC-specific 128-bit wide vector mask of sixteen \xe2\x80\xa60Cms390x-specific 128-bit wide vector mask of sixteen packed \xe2\x80\xa6DaPowerPC-specific 128-bit wide vector mask of two <code>i64</code>0CiFloating-point fused Multiply-Add Long to accumulator \xe2\x80\xa6CdFloating-point fused Multiply-Subtract Long from \xe2\x80\xa6CjLookup table read with 2-bit indices Arm\xe2\x80\x99s documentation00CjLookup table read with 4-bit indices Arm\xe2\x80\x99s documentation00BgMultiply-add long Arm\xe2\x80\x99s documentation000BlMultiply-subtract long Arm\xe2\x80\x99s documentation000BcMultiply long Arm\xe2\x80\x99s documentation000CfFloating-point multiply extended Arm\xe2\x80\x99s documentation00000ChSigned saturating doubling multiply-add long Arm\xe2\x80\x99s \xe2\x80\xa60CkVector widening saturating doubling multiply accumulate \xe2\x80\xa6000CmSigned saturating doubling multiply-subtract long Arm\xe2\x80\x99s \xe2\x80\xa60CnVector widening saturating doubling multiply subtract with \xe2\x80\xa6000CnVector saturating doubling multiply high by scalar Arm\xe2\x80\x99s \xe2\x80\xa60CdSigned saturating doubling multiply long Arm\xe2\x80\x99s \xe2\x80\xa60CnVector saturating doubling long multiply by scalar Arm\xe2\x80\x99s \xe2\x80\xa6000CeSigned saturating extract unsigned narrow Arm\xe2\x80\x99s \xe2\x80\xa600CkRounding Add returning High Narrow (high half). Arm\xe2\x80\x99s \xe2\x80\xa600000000000CcRounding subtract returning high narrow Arm\xe2\x80\x99s \xe2\x80\xa600000BlSigned shift left long Arm\xe2\x80\x99s documentation000BhShift right narrow Arm\xe2\x80\x99s documentation00000ClDot product index form with signed and unsigned integers \xe2\x80\xa600ClDot product index form with unsigned and signed integers \xe2\x80\xa600CnSimultaneously waits for the child to exit and collect all \xe2\x80\xa6ChPerforms an arithmetic max reduction on the unsigned \xe2\x80\xa6ChPerforms an arithmetic min reduction on the unsigned \xe2\x80\xa6DjConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the \xe2\x80\xa6DhCreates an empty <code>BinaryHeap</code> with at least the specified \xe2\x80\xa6DhCreates an empty deque with space for at least <code>capacity</code> \xe2\x80\xa62DeCreates an empty <code>HashMap</code> with at least the specified \xe2\x80\xa62DeCreates an empty <code>HashSet</code> with at least the specified \xe2\x80\xa62ChUses the address value in a new pointer of another type.000DfConverts the cursor into a <code>CursorMutKey</code>, which allows \xe2\x80\xa6000CjAn <code>AtomicIsize</code> initialized to <code>0</code>.0CjAn <code>AtomicUsize</code> initialized to <code>0</code>.0EeA <code>BarrierWaitResult</code> is returned by <code>Barrier::wait()</code> when \xe2\x80\xa6EfAssociated type for <code>&lt;[char; N] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.00EhAssociated type for <code>&lt;&amp;[char] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.00CiThe connection was aborted (terminated) by the remote \xe2\x80\xa6C`The connection was refused by the remote server.fU+00140CfA non-empty directory was specified where an empty \xe2\x80\xa6fU+00040BhAn iterator that knows its exact length.0AgOptions for formatting.00BiConverts something into an async iterator0fU+005B0AiOrganization-Local scope.0fU+007D0CnAn iterator over the mutable subslices of the vector which \xe2\x80\xa600CgNumeric character escape is too short (e.g. \xe2\x80\x98\\x1\xe2\x80\x99).CmThe error type returned when a conversion from a slice to \xe2\x80\xa60DdError type returned by <code>CursorMut::insert_before</code> and \xe2\x80\xa6000CbAn unwind action that triggers undefined behavior.0CiA type indicating whether a timed wait on a condition \xe2\x80\xa6CeA marker trait for primitive types which can be zero.0AkSee <code>_mm_setcsr</code>000Acsuppress exceptions0ointerval [1, 2)0AkDEST = NaN if sign(SRC) = 10A`sign = sign(SRC)0444444CjTranspose the 4x4 matrix formed by 4 rows of __m128 in \xe2\x80\xa60CgLoad an allocation tag from memory, returning a new \xe2\x80\xa6CmCalculate the difference between the address parts of two \xe2\x80\xa6CjStore an allocation tag for the 16-byte granule of memory.CiCompute the bitwise OR of 8-bit masks a and b. If the \xe2\x80\xa60CnCompute the bitwise NOT of 16-bit mask a and then AND with \xe2\x80\xa60CnCompute the bitwise NOT of 32-bit mask a and then AND with \xe2\x80\xa60CnCompute the bitwise NOT of 64-bit mask a and then AND with \xe2\x80\xa60ClCompute the bitwise AND of 16-bit masks a and  b, if the \xe2\x80\xa60ClCompute the bitwise AND of 32-bit masks a and  b, if the \xe2\x80\xa60ClCompute the bitwise AND of 64-bit masks a and  b, if the \xe2\x80\xa60EbAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.0EcAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using \xe2\x80\xa60EaCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.0EeCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.0CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60DiHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> \xe2\x80\xa60DiHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> \xe2\x80\xa60CnHorizontally subtract adjacent pairs of 16-bit integers in \xe2\x80\xa60CnHorizontally subtract adjacent pairs of 32-bit integers in \xe2\x80\xa60CmLoad 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa60CmLoad 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa60CkLoads 256-bits of integer data from memory into result. \xe2\x80\xa60CmLoad 256-bits (composed of 32 packed 8-bit integers) from \xe2\x80\xa60EbMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, \xe2\x80\xa60CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa60CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60ClSet each packed 16-bit integer in dst to all ones or all \xe2\x80\xa60ClSet each packed 32-bit integer in dst to all ones or all \xe2\x80\xa60ClSet each packed 64-bit integer in dst to all ones or all \xe2\x80\xa60CnShuffles double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffles single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000DhBroadcasts 16-bit integer <code>a</code> to all elements of returned \xe2\x80\xa60DhBroadcasts 32-bit integer <code>a</code> to all elements of returned \xe2\x80\xa60CkSets packed 64-bit integers in returned vector with the \xe2\x80\xa60CkSets packed 16-bit integers in returned vector with the \xe2\x80\xa60CkSets packed 32-bit integers in returned vector with the \xe2\x80\xa60CiSets packed __m256d returned vector with the supplied \xe2\x80\xa60CiSets packed __m256i returned vector with the supplied \xe2\x80\xa60CkReturns vector of type __m256d with all elements set to \xe2\x80\xa60CjReturn vector of type __m256h with all elements set to \xe2\x80\xa60CjReturns vector of type __m256 with all elements set to \xe2\x80\xa60>>==DkNegates packed 16-bit integers in <code>a</code> when the corresponding \xe2\x80\xa60DkNegates packed 32-bit integers in <code>a</code> when the corresponding \xe2\x80\xa60EcShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa60EcShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa60EcShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while \xe2\x80\xa60E`Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60DfShifts packed 32-bit integers in <code>a</code> left by the amount \xe2\x80\xa60DfShifts packed 64-bit integers in <code>a</code> left by the amount \xe2\x80\xa60EdShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa60EdShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60DgShifts packed 32-bit integers in <code>a</code> right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa605544EdShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while \xe2\x80\xa60EaShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while \xe2\x80\xa604433DgShifts packed 64-bit integers in <code>a</code> right by the amount \xe2\x80\xa60DhSubtract packed 16-bit integers in <code>b</code> from packed 16-bit \xe2\x80\xa60DjSubtract packed unsigned 16-bit integers in <code>b</code> from packed \xe2\x80\xa60CfComputes the bitwise AND of 256 bits (representing \xe2\x80\xa6000CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa60ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa60CgPerforms an element-by-element conversion of packed \xe2\x80\xa60ClPerforms element-by-element conversion of the lower half \xe2\x80\xa60CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CnLoad 512-bits (composed of 16 packed 32-bit integers) from \xe2\x80\xa60CmLoad 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa60CgLoad 512-bits of integer data from memory into dst. \xe2\x80\xa60CmLoad 512-bits (composed of 64 packed 8-bit integers) from \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa60CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60ClSet each packed 16-bit integer in dst to all ones or all \xe2\x80\xa60ClSet each packed 32-bit integer in dst to all ones or all \xe2\x80\xa60ClSet each packed 64-bit integer in dst to all ones or all \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60DlBroadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.0DlBroadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.0CiSet packed 32-bit integers in dst with the repeated 4 \xe2\x80\xa60CiSet packed 64-bit integers in dst with the repeated 4 \xe2\x80\xa60DeSets packed 32-bit integers in <code>dst</code> with the supplied \xe2\x80\xa60CnSet packed 64-bit integers in dst with the supplied values \xe2\x80\xa60DhReturns vector of type <code>__m512d</code> with all elements set to \xe2\x80\xa60CjReturn vector of type __m512h with all elements set to \xe2\x80\xa60DgReturns vector of type <code>__m512</code> with all elements set to \xe2\x80\xa60>>==ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa60CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa60554433221100CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa60CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa60CnConvert scalar BF16 (16-bit) floating point element stored \xe2\x80\xa60ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa60CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa60CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60DhSign extend packed 8-bit integers in <code>a</code> to packed 16-bit \xe2\x80\xa60DhSign extend packed 8-bit integers in <code>a</code> to packed 32-bit \xe2\x80\xa60DjSign extend packed 8-bit integers in the low 8 bytes of <code>a</code> \xe2\x80\xa60DeZeroes extend packed unsigned 8-bit integers in <code>a</code> to \xe2\x80\xa600000ClConvert packed BF16 (16-bit) floating-point even-indexed \xe2\x80\xa60CkConvert packed BF16 (16-bit) floating-point odd-indexed \xe2\x80\xa60BjCopy the lower 16-bit integer in a to dst.0BmReturns the lowest element of <code>a</code>.00CkCopy 16-bit integer a to the lower elements of dst, and \xe2\x80\xa60DjReturns a vector whose lowest element is <code>a</code> and all higher \xe2\x80\xa600CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa6000CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6000ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6000CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa6000ChReturns the <code>imm8</code> element of <code>a</code>.0DnExtracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code>0DnExtracts an 64-bit integer from <code>a</code> selected with <code>IMM1</code>CmExtracts the specified bits from the lower 64 bits of the \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CnStores 2 double-precision (64-bit) floating-point elements \xe2\x80\xa60CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa6011CnStores 2 single-precision (32-bit) floating-point elements \xe2\x80\xa60CkMultiplies corresponding pairs of packed 8-bit unsigned \xe2\x80\xa60CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa60CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa60CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa60CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa60CgBlend packed half-precision (16-bit) floating-point \xe2\x80\xa60CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa6000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6000ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60554433221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa60CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa601100CnMove packed 8-bit integers from a into dst using writemask \xe2\x80\xa60CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa60CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60000000C`Compute the approximate reciprocal of packed \xe2\x80\xa6000CcCompute the approximate reciprocal of the lower \xe2\x80\xa6000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiCompute the approximate reciprocal square root of the \xe2\x80\xa60CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa60CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa60ClStore a double-precision (64-bit) floating-point element \xe2\x80\xa60CjStore the lower half-precision (16-bit) floating-point \xe2\x80\xa60ClStore a single-precision (32-bit) floating-point element \xe2\x80\xa60CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CkLoad a double-precision (64-bit) floating-point element \xe2\x80\xa60CnLoad a half-precision (16-bit) floating-point element from \xe2\x80\xa60CkLoad a single-precision (32-bit) floating-point element \xe2\x80\xa60CkMove the lower double-precision (64-bit) floating-point \xe2\x80\xa60CiMove the lower half-precision (16-bit) floating-point \xe2\x80\xa60CkMove the lower single-precision (32-bit) floating-point \xe2\x80\xa60CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CiCompute the square root of the lower double-precision \xe2\x80\xa60CgCompute the square root of the lower half-precision \xe2\x80\xa60CiCompute the square root of the lower single-precision \xe2\x80\xa60CnReturns a mask of the most significant bit of each element \xe2\x80\xa60CeSet each bit of mask register k based on the most \xe2\x80\xa60000088CnShuffles double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffles single-precision (32-bit) floating-point elements \xe2\x80\xa60ClReduce the packed half-precision (16-bit) floating-point \xe2\x80\xa60000000CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa60CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa60ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa60BoReturns a vector with all elements set to zero.0EbShuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.0CmThis is one of the two SM3 message scheduling intrinsics. \xe2\x80\xa6000CmThis intrinsic performs four rounds of SM4 key expansion. \xe2\x80\xa60CiCompute the square root of the lower double-precision \xe2\x80\xa60CgCompute the square root of the lower half-precision \xe2\x80\xa60CiCompute the square root of the lower single-precision \xe2\x80\xa60DfTests whether the specified bits in <code>a</code> 128-bit integer \xe2\x80\xa60CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa60ClUnpacks and interleave 8-bit integers from the high half \xe2\x80\xa60CnUnpacks and interleave 8-bit integers from the low half of \xe2\x80\xa60CiPerform matrix multiplication of two tiles containing \xe2\x80\xa60CmStores the current tile configuration to a 64-byte memory \xe2\x80\xa6BbPerforms checked integer addition.0DhAdvances the cursor by asserting that <code>n</code> bytes have been \xe2\x80\xa60ChLowers in MIR to <code>Rvalue::Aggregate</code> with \xe2\x80\xa60DaExtracts the values from an array of <code>MaybeUninit</code> \xe2\x80\xa60EjReturns a <code>&amp;[Cell&lt;T&gt;; N]</code> from a <code>&amp;Cell&lt;[T; N]&gt;</code>0DkEquivalent to <code>CString::as_bytes()</code> except that the returned \xe2\x80\xa60EdReturns a <code>&amp;[Cell&lt;T&gt;]</code> from a <code>&amp;Cell&lt;[T]&gt;</code>0CmA guard for unsafe functions that cannot ever be executed \xe2\x80\xa60ChChecked integer division without remainder. Computes \xe2\x80\xa600000000000000000000000EhConstructs a new <code>Arc&lt;T&gt;</code> with a clone of <code>value</code> in the \xe2\x80\xa6DhAllocates memory in the given allocator then clones <code>src</code> \xe2\x80\xa6EgConstructs a new <code>Rc&lt;T&gt;</code> with a clone of <code>value</code> in the \xe2\x80\xa6210ChSelects which function to call depending on the context.0DcSame as <code>format_args</code>, but can be used in some const \xe2\x80\xa60DgInterns the <code>Vec&lt;T&gt;</code>, making the underlying memory \xe2\x80\xa6CfConvert the allocation this pointer points to into \xe2\x80\xa601FbDivides <code>Duration</code> by <code>Duration</code> and returns <code>u128</code>, rounding \xe2\x80\xa60ChExposes the \xe2\x80\x9cprovenance\xe2\x80\x9d part of the pointer for \xe2\x80\xa600000000000DcClones and appends all elements in a slice to the <code>Vec</code>.0CiA relaxed version of <code>f32x4_max</code> which has \xe2\x80\xa600CiA relaxed version of <code>f32x4_min</code> which has \xe2\x80\xa600CiA relaxed version of <code>f64x2_max</code> which has \xe2\x80\xa600CiA relaxed version of <code>f64x2_min</code> which has \xe2\x80\xa600CjReturns the value that would be obtained by taking the \xe2\x80\xa60000DhCreates a new instance of an <code>Error</code> from a particular OS \xe2\x80\xa6DoCreates a <code>Vec&lt;T, A&gt;</code> directly from a pointer, a length, a \xe2\x80\xa60DdCreates an ASCII character from the byte <code>b</code>, without \xe2\x80\xa60CnAttempts to convert a Vec&lt;u8&gt; to a <code>CString</code>.0DkReads from indices in <code>slice</code> to construct a SIMD vector. If \xe2\x80\xa60ClConditionally read elementwise from pointers into a SIMD \xe2\x80\xa60DhReturns a mutable reference into the given <code>Arc</code>, without \xe2\x80\xa6DkReturns a mutable reference into the given <code>Rc</code>, without any \xe2\x80\xa6DfGet read-write access to the contents of an <code>UnsafePinned</code>.021CmReturns a mutable pointer to the output at this location, \xe2\x80\xa6ClReturns a raw pointer to an element or subslice, without \xe2\x80\xa6CjReturns a mutable reference to an element or subslice, \xe2\x80\xa6CjReturns a mutable, unchecked subslice of <code>str</code>.DeGets a mutable reference to the data inside of this <code>Pin</code>.34321034CiHypervisor memory management fence for guest physical \xe2\x80\xa60CnHypervisor memory management fence for given guest virtual \xe2\x80\xa60CnInvalidate hypervisor translation cache for guest physical \xe2\x80\xa60CkInvalidate hypervisor translation cache for given guest \xe2\x80\xa60CkLane-wise saturating rounding multiplication in Q15 format.00DdConverts this <code>OsString</code> into a boxed <code>OsStr</code>.DjConvert <code>self</code> directly into a <code>TokenStream</code> object.0CbChecks if the value is an ASCII hexadecimal digit:000CnChecks if the value is an ASCII octal digit: U+0030 \xe2\x80\x980\xe2\x80\x99\xe2\x80\xa6000DkReturns <code>true</code> if the address is a globally routable unicast \xe2\x80\xa60E`Determines if <code>File</code> has an efficient <code>write_vectored</code> \xe2\x80\xa6EgDetermines if this <code>Write</code>r has an efficient <code>write_vectored</code> \xe2\x80\xa6DaExecutes an operation of the <code>IP_ADD_MEMBERSHIP</code> type.DcExecutes an operation of the <code>IPV6_ADD_MEMBERSHIP</code> type.CcConstructs a new pin by mapping the interior value.0BgPerforms checked integer multiplication0DhGets the value of the <code>IP_MULTICAST_LOOP</code> option for this \xe2\x80\xa6DjGets the value of the <code>IPV6_MULTICAST_LOOP</code> option for this \xe2\x80\xa6CnReturns the smallest power of two greater than or equal to \xe2\x80\xa600000000000000000000000DiEmits a <code>nontemporal</code> store, which gives a hint to the CPU \xe2\x80\xa60BfAdds a trailing separator to the path.DjReturns an iterator over <code>chunk_size</code> elements of the slice \xe2\x80\xa60ChReads the exact number of bytes required to fill the \xe2\x80\xa6DcGet <code>value</code> from the first active lane in the wavefront.0DjReturns an iterator over substrings of <code>self</code>, separated by \xe2\x80\xa60CeA simple console test runner. Runs provided tests \xe2\x80\xa6C`Sets the write timeout to the timeout specified.0BfSets the write timeout for the socket.0ClCalculates the offset from a pointer vector elementwise, \xe2\x80\xa60AoWrites to a vector of pointers.0DgReturns an array reference to the first <code>N</code> items in the \xe2\x80\xa60DhStrict addition with a signed integer. Computes <code>self + rhs</code>,00000000000DjStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>, \xe2\x80\xa60000DfStrict Euclidean division. Computes <code>self.div_euclid(rhs)</code>.000010111110000010DkStrict Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>, \xe2\x80\xa60000DdStrict Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>.000010111110000010CfStrict subtraction with a signed integer. Computes \xe2\x80\xa600000000000BdPerforms checked integer subtraction0CmRemoves an element from anywhere in the deque and returns \xe2\x80\xa60CjDoes a three-way comparison between the two arguments, \xe2\x80\xa60CiConverts this C string to a byte slice containing the \xe2\x80\xa60CiReturns a string slice with all prefixes that match a \xe2\x80\xa60CdTrims a trailing separator from a path, if possible.CbThe checked version of <code>from_secs_f32</code>.0CbThe checked version of <code>from_secs_f64</code>.0DiConstructs a new <code>Arc</code> with uninitialized contents, in the \xe2\x80\xa6CkConstructs a new box with uninitialized contents in the \xe2\x80\xa6DhConstructs a new <code>Rc</code> with uninitialized contents, in the \xe2\x80\xa6210DkConstructs a new <code>Arc</code> with uninitialized contents, with the \xe2\x80\xa6DkConstructs a new <code>Box</code> with uninitialized contents, with the \xe2\x80\xa6DjConstructs a new <code>Rc</code> with uninitialized contents, with the \xe2\x80\xa6210CfTries to reserve the minimum capacity for at least \xe2\x80\xa60000DhInvokes <code>try_reserve_exact</code> on the underlying instance of \xe2\x80\xa61111EaConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified \xe2\x80\xa6DhCreates an empty deque with space for at least <code>capacity</code> \xe2\x80\xa6DgCreates a new empty <code>String</code> with at least the specified \xe2\x80\xa6201CkReturns the contained <code>Some</code> value or a default.ChReturns the contained <code>Ok</code> value or a default10CjLoad a single element and splat to all lanes of a v128 \xe2\x80\xa600000000EfStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>00EfStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>00EfStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>00C`Floating-point complex add Arm\xe2\x80\x99s documentation00CfFloating-point complex multiply accumulate Arm\xe2\x80\x99s \xe2\x80\xa600000CeFloating-point convert to lower precision Arm\xe2\x80\x99s \xe2\x80\xa6CfFloating-point convert to higher precision Arm\xe2\x80\x99s \xe2\x80\xa6ClFloating-point convert to lower precision narrow Arm\xe2\x80\x99s \xe2\x80\xa6CkFloating-point convert to higher precision long Arm\xe2\x80\x99s \xe2\x80\xa6CfVector Compare Not in Ranges Index with Condition CodeAfVector Copy Until ZeroCmPowerPC-specific 128-bit wide vector mask of eight packed \xe2\x80\xa60Cks390x-specific 128-bit wide vector mask of eight packed \xe2\x80\xa6DdPowerPC-specific 128-bit wide vector of four packed <code>i32</code>0Dbs390x-specific 128-bit wide vector of four packed <code>i32</code>CkVector widening saturating doubling multiply accumulate \xe2\x80\xa60ChSigned saturating doubling multiply-add long Arm\xe2\x80\x99s \xe2\x80\xa60CnVector widening saturating doubling multiply subtract with \xe2\x80\xa60CmSigned saturating doubling multiply-subtract long Arm\xe2\x80\x99s \xe2\x80\xa60CnVector saturating doubling multiply high by scalar Arm\xe2\x80\x99s \xe2\x80\xa6000CnSigned saturating doubling multiply returning high half Arm\xe2\x80\xa6110CnVector saturating doubling long multiply by scalar Arm\xe2\x80\x99s \xe2\x80\xa60CdSigned saturating doubling multiply long Arm\xe2\x80\x99s \xe2\x80\xa60CkSigned saturating rounding doubling multiply accumulate \xe2\x80\xa60CiSigned saturating rounding doubling multiply subtract \xe2\x80\xa60CkVector rounding saturating doubling multiply high by scalar000CjSigned saturating shift right narrow Arm\xe2\x80\x99s documentation00CbUnsigned saturating shift right narrow Arm\xe2\x80\x99s \xe2\x80\xa600CaRounding shift right narrow Arm\xe2\x80\x99s documentation00000ClDot product index form with signed and unsigned integers \xe2\x80\xa6ClDot product index form with unsigned and signed integers \xe2\x80\xa6CnEnsures that a path has a trailing separator, allocating a \xe2\x80\xa6DiRuns the given closure with a <code>BorrowedBuf</code> containing the \xe2\x80\xa60CgAdds an unsigned offset in bytes to a pointer using \xe2\x80\xa6000CnSubtracts an unsigned offset in bytes from a pointer using \xe2\x80\xa6000DeLike <code>write_at</code>, except that it writes from a slice of \xe2\x80\xa6CfWrites a number of bytes starting from a given offset.AiRaw \xe2\x80\x98\\r\xe2\x80\x99 encountered.DhUsed to create a default <code>BuildHasher</code> instance for types \xe2\x80\xa60fU+00130j\xe2\x80\x98\\u{}\xe2\x80\x99AhExecutable file is busy.DdThis is the error type used by <code>HandleOrInvalid</code> when \xe2\x80\xa6C`Trying to convert a literal with the wrong type.CmScope of an IPv6 multicast address as defined in IETF RFC \xe2\x80\xa60ClThe primary separator of path components for the current \xe2\x80\xa6ChThe network containing the remote host is not reachable.CmNon-ascii character in byte literal, byte string literal, \xe2\x80\xa6DfAn internal helper for <code>split_off</code> functions indicating \xe2\x80\xa60BfTwo indices provided were overlapping.00BnBy-value <code>RangeInclusive</code> iterator.0CnThe filesystem or storage medium is read-only, but a write \xe2\x80\xa6CfAn RAII implementation of a \xe2\x80\x9cscoped lock\xe2\x80\x9d of a \xe2\x80\xa6fU+005D0ChStatically guarantees that a lane count is marked as \xe2\x80\xa60AkSee <code>_mm_setcsr</code>00000htruncate0Aainterval [0.5, 1)0Aainterval [0.5, 2)0hsign = 0044EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa6CjCompute the bitwise OR of 16-bit masks a and b. If the \xe2\x80\xa60CjCompute the bitwise OR of 32-bit masks a and b. If the \xe2\x80\xa60CjCompute the bitwise OR of 64-bit masks a and b. If the \xe2\x80\xa60CiCompute the bitwise OR of 8-bit masks a and b. If the \xe2\x80\xa6000EdConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a \xe2\x80\xa60CiConvert scalar half-precision (16-bit) floating-point \xe2\x80\xa60EfBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control \xe2\x80\xa60EfBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control \xe2\x80\xa60ElBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.0CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60EbCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.0EbCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.0EbCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.0DlCompares packed 16-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa60DlCompares packed 32-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa60DlCompares packed 64-bit integers in <code>a</code> and <code>b</code> for \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60CoConverts packed 32-bit integers in <code>a</code> to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6011ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000333333333333ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa60333333CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60CnMultiplies packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60CnMultiplies packed single-precision (32-bit) floating-point \xe2\x80\xa60221100DiHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> \xe2\x80\xa60CnHorizontally subtract adjacent pairs of 16-bit integers in \xe2\x80\xa60EfCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into \xe2\x80\xa60CmCopy a to dst, then insert 128 bits (composed of 4 packed \xe2\x80\xa60CmCopy a to dst, then insert 128 bits (composed of 2 packed \xe2\x80\xa601100CmLoads 256-bits of integer data from unaligned memory into \xe2\x80\xa60CbLoads two 128-bit values (composed of 4 packed \xe2\x80\xa60CnLoad 256-bits (composed of 16 packed 16-bit integers) from \xe2\x80\xa60CmLoad 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa60CmLoad 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa60CkLoads 256-bits of integer data from memory into result. \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise AND of packed double-precision \xe2\x80\xa60CfCompute the bitwise AND of packed single-precision \xe2\x80\xa60CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa60ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa60CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa60CiLoads packed double-precision (64-bit) floating-point \xe2\x80\xa60CiLoads packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa60CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60ChSets each bit of the returned mask based on the most \xe2\x80\xa6000EeMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing0EhMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, \xe2\x80\xa6011EeMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing0EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60EdConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa60EdConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60DhBroadcasts 64-bit integer <code>a</code> to all elements of returned \xe2\x80\xa60CkSets packed 64-bit integers in returned vector with the \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CnStore 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa60CnStore 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa60DdStores 256-bits of integer data from <code>a</code> into memory. \xe2\x80\xa60CnStore 256-bits (composed of 32 packed 8-bit integers) from \xe2\x80\xa60CnComputes the bitwise AND of 256 bits (representing integer \xe2\x80\xa6000CdUnpacks and interleave double-precision (64-bit) \xe2\x80\xa60CdUnpacks and interleave single-precision (32-bit) \xe2\x80\xa601100CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000000000022222222CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmCopy a to dst, then insert 128 bits (composed of 4 packed \xe2\x80\xa60CmCopy a to dst, then insert 256 bits (composed of 8 packed \xe2\x80\xa60CmCopy a to dst, then insert 128 bits (composed of 2 packed \xe2\x80\xa60CmCopy a to dst, then insert 256 bits (composed of 4 packed \xe2\x80\xa6033221100CnLoad 512-bits (composed of 32 packed 16-bit integers) from \xe2\x80\xa60CnLoad 512-bits (composed of 16 packed 32-bit integers) from \xe2\x80\xa60CmLoad 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa60CgLoad 512-bits of integer data from memory into dst. \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000ClFinds the absolute value of each packed double-precision \xe2\x80\xa60ClFinds the absolute value of each packed single-precision \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise AND of packed double-precision \xe2\x80\xa60CfCompute the bitwise AND of packed single-precision \xe2\x80\xa60CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa60ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa60CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa60CnCompute the bitwise OR of packed double-precision (64-bit) \xe2\x80\xa60CnCompute the bitwise OR of packed single-precision (32-bit) \xe2\x80\xa60CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa60ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa60CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa60CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa60EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60CiSet packed 32-bit integers in dst with the repeated 4 \xe2\x80\xa60CiSet packed 64-bit integers in dst with the repeated 4 \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CjStore 512-bits (composed of 16 packed 32-bit integers) \xe2\x80\xa60CnStore 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa60CfStore 512-bits of integer data from a into memory. \xe2\x80\xa60CnStore 512-bits (composed of 64 packed 8-bit integers) from \xe2\x80\xa60CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa60CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa601100DfDecrypt 10 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa60DfDecrypt 14 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa60DfEncrypt 10 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa60DfEncrypt 14 rounds of unsigned 8-bit integers in <code>input</code> \xe2\x80\xa60C`Broadcasts the low double-precision (64-bit) \xe2\x80\xa60C`Broadcasts the low single-precision (32-bit) \xe2\x80\xa60CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa60ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa6000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6000DiSign extend packed 16-bit integers in <code>a</code> to packed 32-bit \xe2\x80\xa60DiSign extend packed 16-bit integers in <code>a</code> to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60DiSign extend packed 32-bit integers in <code>a</code> to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60DfZeroes extend packed unsigned 16-bit integers in <code>a</code> to \xe2\x80\xa6000DfZeroes extend packed unsigned 32-bit integers in <code>a</code> to \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60BmReturns the lowest element of <code>a</code>.DjReturns a vector whose lowest element is <code>a</code> and all higher \xe2\x80\xa6C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60221100ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60776655221100776655CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa60CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa60CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa60CjPerforms element-by-element bitwise AND between packed \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa60CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa60CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60554433221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CfConvert the exponent of the lower double-precision \xe2\x80\xa60CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa60CfConvert the exponent of the lower single-precision \xe2\x80\xa60CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CeMove packed 16-bit integers from a into dst using \xe2\x80\xa60CmMove packed 32-bit integers from a to dst using writemask \xe2\x80\xa60CmMove packed 64-bit integers from a to dst using writemask \xe2\x80\xa60ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa60CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CnExtract the reduced argument of the lower double-precision \xe2\x80\xa60ClExtract the reduced argument of the lower half-precision \xe2\x80\xa60CnExtract the reduced argument of the lower single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60220000CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa60CiShift packed 16-bit integers in a left by count while \xe2\x80\xa60CiShift packed 32-bit integers in a left by count while \xe2\x80\xa60CiShift packed 64-bit integers in a left by count while \xe2\x80\xa60CjShift packed 16-bit integers in a right by count while \xe2\x80\xa60CjShift packed 32-bit integers in a right by count while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa60221100CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa60CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa60CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa60CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa60CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa60CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa60ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60CgLoads packed 32-bit integers from memory pointed by \xe2\x80\xa60CgLoads packed 64-bit integers from memory pointed by \xe2\x80\xa60CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa60CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa60CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa6000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6000ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60554433221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa60CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa601100CmMove packed 8-bit integers from a into dst using zeromask \xe2\x80\xa60CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa60CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa60000000C`Compute the approximate reciprocal of packed \xe2\x80\xa6000CcCompute the approximate reciprocal of the lower \xe2\x80\xa6000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiCompute the approximate reciprocal square root of the \xe2\x80\xa60CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa60CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa606666ChReduce the packed 8-bit integers in a by bitwise OR. \xe2\x80\xa60CjPerforms an intermediate calculation for the next four \xe2\x80\xa60CiPerforms the final calculation for the next four SHA1 \xe2\x80\xa60ClThe intrinsic performs two rounds of SM3 operation using \xe2\x80\xa60CnThis intrinsic performs four rounds of SM4 encryption. The \xe2\x80\xa60CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa60CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa60CmUnpacks and interleave 16-bit integers from the high half \xe2\x80\xa60CmUnpacks and interleave 32-bit integers from the high half \xe2\x80\xa60CmUnpacks and interleave 64-bit integers from the high half \xe2\x80\xa60ClUnpacks and interleave 16-bit integers from the low half \xe2\x80\xa60ClUnpacks and interleave 32-bit integers from the low half \xe2\x80\xa60ClUnpacks and interleave 64-bit integers from the low half \xe2\x80\xa60CgMoves a row from a tile register to a zmm register, \xe2\x80\xa60CmLoad tile rows from memory specifieid by base address and \xe2\x80\xa6CgConverts this char into an ASCII character, without \xe2\x80\xa6CgConverts this array of bytes into an array of ASCII \xe2\x80\xa6CfConverts this slice of bytes into a slice of ASCII \xe2\x80\xa6CnConverts this string slice into a slice of ASCII characters\xe2\x80\xa6CnConverts this byte to an ASCII character, without checking \xe2\x80\xa643210DjInvoked when unit tests terminate. Returns <code>Result::Err</code> if \xe2\x80\xa6CjReturns the value that would be obtained by taking the \xe2\x80\xa60000DgFinds the closest <code>x</code> not below <code>index</code> where \xe2\x80\xa60DkChecked addition with a signed integer. Computes <code>self + rhs</code>\xe2\x80\xa600000000000DkChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, \xe2\x80\xa600000000000000000000000DjChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>\xe2\x80\xa60000DiChecked Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>, \xe2\x80\xa6000010111110000010CgChecked subtraction with a signed integer. Computes \xe2\x80\xa600000000000ClReturns the value of the discriminant for the variant in \xe2\x80\xa60FbDivides <code>Duration</code> by <code>Duration</code> and returns <code>u128</code>, rounding \xe2\x80\xa60DmDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete \xe2\x80\xa6BeDowncasts the box to a concrete type.00D`Downcasts the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.21110DfGiven a range <code>src</code>, clones a slice of elements in that \xe2\x80\xa6DiClones the elements at the range <code>src</code> and appends them to \xe2\x80\xa6DeCopies elements from <code>src</code> range to the end of the string.201CjExtracts a lane from a 128-bit vector interpreted as 4 \xe2\x80\xa600DcComputes <code>a * b + c</code> with either one rounding or two \xe2\x80\xa600CjReplaces a lane from a 128-bit vector interpreted as 4 \xe2\x80\xa600CjExtracts a lane from a 128-bit vector interpreted as 2 \xe2\x80\xa600222CjReplaces a lane from a 128-bit vector interpreted as 2 \xe2\x80\xa600ChCreates a Unix socket address in the abstract namespace.CdConverts a vector of integers to a mask, where 0 \xe2\x80\xa60BkForms a mutable slice from a pointer range.00CfConverts a mutable reference to a non-zero mutable \xe2\x80\xa60DjPerforms the same functionality as <code>from_raw_parts</code>, except \xe2\x80\xa6D`Creates a <code>&amp;mut str</code> from a pointer and a length.110110DfConverts a <code>u32</code> to a <code>char</code>, ignoring validity.DnConverts a <code>u32</code> to a <code>char</code>, ignoring validity. Use \xe2\x80\xa610E`Decode a UTF-16BE\xe2\x80\x93encoded slice <code>v</code> into a <code>String</code>, \xe2\x80\xa60E`Decode a UTF-16LE\xe2\x80\x93encoded slice <code>v</code> into a <code>String</code>, \xe2\x80\xa60CmCreates a C-compatible string by consuming a byte vector, \xe2\x80\xa60DjInserts a value computed from <code>f</code> into the set if the given \xe2\x80\xa6DiInserts a value computed from <code>f</code> into the option if it is \xe2\x80\xa6011BbSignals a memory allocation error.0CjExtracts a lane from a 128-bit vector interpreted as 8 \xe2\x80\xa600ClConverts two input vectors into a smaller lane vector by \xe2\x80\xa600CjReplaces a lane from a 128-bit vector interpreted as 8 \xe2\x80\xa600CjExtracts a lane from a 128-bit vector interpreted as 4 \xe2\x80\xa600CjReplaces a lane from a 128-bit vector interpreted as 4 \xe2\x80\xa600CjExtracts a lane from a 128-bit vector interpreted as 2 \xe2\x80\xa600CjReplaces a lane from a 128-bit vector interpreted as 2 \xe2\x80\xa600CkExtracts a lane from a 128-bit vector interpreted as 16 \xe2\x80\xa600666CkReplaces a lane from a 128-bit vector interpreted as 16 \xe2\x80\xa600DjConverts the <code>OsString</code> into a byte vector.  To convert the \xe2\x80\xa6ChChecks if the value is an ASCII lowercase character: \xe2\x80\xa6000ChChecks if the value is an ASCII uppercase character: \xe2\x80\xa6000CjChecks if the value is a Unicode surrogate code point, \xe2\x80\xa60EhReturns <code>self</code> with only the least significant bit set, or <code>0</code> \xe2\x80\xa600000000000DbReturns <code>self</code> with only the least significant bit set.00000000000111111111111000000000000DbExecutes an operation of the <code>IP_DROP_MEMBERSHIP</code> type.DdExecutes an operation of the <code>IPV6_DROP_MEMBERSHIP</code> type.CgExtracts the main thread raw handle, without taking \xe2\x80\xa6CmMedian absolute deviation as a percent of the median. See \xe2\x80\xa6CkEnsures a value is in the entry by inserting, if empty, \xe2\x80\xa600DkReturns the amount of padding we must insert after <code>self</code> to \xe2\x80\xa600CjLike <code>panic_fmt</code>, but for non-unwinding panics.CnMoves all but the first of consecutive elements to the end \xe2\x80\xa60DfReorders the elements of this iterator <em>in-place</em> according \xe2\x80\xa600DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa60CmProvides a value or other type with only static lifetimes \xe2\x80\xa60DnSee documentation of <code>&lt;*const T&gt;::guaranteed_eq</code> for details.0ChConditionally write pointers elementwise into a SIMD \xe2\x80\xa60DdSets the <code>dwSecurityQosFlags</code> argument to the call to \xe2\x80\xa6ChChanges the timestamps of the file or symlink at the \xe2\x80\xa6ClSorts the slice in ascending order with a key extraction \xe2\x80\xa6CkReturns the remaining spare capacity of the vector as a \xe2\x80\xa60DgReturns vector content as a slice of <code>T</code>, along with the \xe2\x80\xa60CiDivides one slice into two at an index, without doing \xe2\x80\xa60CkRemoves the last element of the slice and returns a mutable0CeMakes a copy of the value in its ASCII lower case \xe2\x80\xa600CjReturns a vector containing a copy of this slice where \xe2\x80\xa6CiReturns a copy of this string where each character is \xe2\x80\xa6202CeMakes a copy of the value in its ASCII upper case \xe2\x80\xa60021010DfConverts this address to an IPv4-compatible <code>IPv6</code> address.0CiReturns a string slice with all suffixes that match a \xe2\x80\xa60CiReturns a string slice with all prefixes that match a \xe2\x80\xa60ElConstructs a new <code>Arc&lt;T&gt;</code> with a clone of <code>value</code>, returning \xe2\x80\xa6DfAllocates memory on the heap then clones <code>src</code> into it, \xe2\x80\xa6EnConstructs a new <code>Rc&lt;T&gt;</code> with a clone of <code>value</code>, returning an \xe2\x80\xa6210DhCreates a new <code>OwnedHandle</code> instance that shares the same \xe2\x80\xa6DhCreates a new <code>OwnedSocket</code> instance that shares the same \xe2\x80\xa6DdCreates a new <code>OwnedFd</code> instance that shares the same \xe2\x80\xa6CjExtracts a lane from a 128-bit vector interpreted as 8 \xe2\x80\xa600ClConverts two input vectors into a smaller lane vector by \xe2\x80\xa600CjReplaces a lane from a 128-bit vector interpreted as 8 \xe2\x80\xa600CjExtracts a lane from a 128-bit vector interpreted as 4 \xe2\x80\xa600CjReplaces a lane from a 128-bit vector interpreted as 4 \xe2\x80\xa600CjExtracts a lane from a 128-bit vector interpreted as 2 \xe2\x80\xa600CjReplaces a lane from a 128-bit vector interpreted as 2 \xe2\x80\xa600CkExtracts a lane from a 128-bit vector interpreted as 16 \xe2\x80\xa600666CkReplaces a lane from a 128-bit vector interpreted as 16 \xe2\x80\xa600CgReturns the unpaired surrogate which caused this error.0CnFloating-point convert to lower precision narrow, rounding \xe2\x80\xa6BbVector Compare Equal or Zero IndexBfVector Compare Not Equal or Zero IndexBcVector Compare Ranges or Zero IndexCaVector Find Any Element Equal with Condition CodeCeVector Find Any Element Not Equal with Condition CodeAeVector Gather ElementDfPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>0Dds390x-specific 128-bit wide vector of sixteen packed <code>i8</code>DcPowerPC-specific 128-bit wide vector of two packed <code>i64</code>0ChSigned saturating doubling multiply-add long Arm\xe2\x80\x99s \xe2\x80\xa6000CmSigned saturating doubling multiply-subtract long Arm\xe2\x80\x99s \xe2\x80\xa6000CnSigned saturating doubling multiply returning high half Arm\xe2\x80\xa6CnVector saturating doubling multiply high by scalar Arm\xe2\x80\x99s \xe2\x80\xa60001CdSigned saturating doubling multiply long Arm\xe2\x80\x99s \xe2\x80\xa6000CkSigned saturating rounding doubling multiply accumulate \xe2\x80\xa600000CiSigned saturating rounding doubling multiply subtract \xe2\x80\xa600000CkVector rounding saturating doubling multiply high by scalar000CjSigned saturating rounding doubling multiply returning \xe2\x80\xa611110ChSigned saturating rounded shift right narrow Arm\xe2\x80\x99s \xe2\x80\xa600CjUnsigned saturating rounded shift right narrow Arm\xe2\x80\x99s \xe2\x80\xa600CiSigned saturating shift right unsigned narrow Arm\xe2\x80\x99s \xe2\x80\xa600CgVector reinterpret cast operation Arm\xe2\x80\x99s documentation00000000000ChWaits on this condition variable for a notification, \xe2\x80\xa60CkCreates a pointer with the given address and no provenance.0CjConverts an address to a pointer without giving it any \xe2\x80\xa60110000CdAttempts to write multiple buffers into this writer.AoProgram argument list too long.fU+00090CeErrors returned when trying to retrieve a literal \xe2\x80\xa6AjThe default random source.CbAn iterator able to yield elements from both ends.0DhA marker trait to express that a <code>ReverseSearcher</code> can be \xe2\x80\xa600CfAn error indicating that a nul byte was not in the \xe2\x80\xa6000CiThe error type returned by <code>get_disjoint_mut</code>.00D`A helper trait for <code>&lt;[T]&gt;::get_disjoint_mut()</code>.fU+00150CnCharacter code in numeric escape is non-ascii (e.g. \xe2\x80\x98\\xFF\xe2\x80\xa6CeRequired trait for constants used in pattern matches.0CgA lazy iterator producing elements in the symmetric \xe2\x80\xa600DdDetails of the allocation that caused a <code>TryReserveError</code>0BdUnicode escape code in byte literal.AkSee <code>_mm_setcsr</code>000BhSee <code>_MM_GET_FLUSH_ZERO_MODE</code>0AjSee <code>prefetch</code>.000EhFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>0CjCompute the bitwise OR of 16-bit masks a and b. If the \xe2\x80\xa60CjCompute the bitwise OR of 32-bit masks a and b. If the \xe2\x80\xa60CjCompute the bitwise OR of 64-bit masks a and b. If the \xe2\x80\xa60221100CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa6000CnComputes the bitwise NOT of 256 bits (representing integer \xe2\x80\xa60CiBroadcasts 128 bits from memory (composed of 2 packed \xe2\x80\xa60CiBroadcasts 128 bits from memory (composed of 4 packed \xe2\x80\xa60CiBroadcasts a double-precision (64-bit) floating-point \xe2\x80\xa60CiBroadcasts a single-precision (32-bit) floating-point \xe2\x80\xa60E`Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while \xe2\x80\xa60EaShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while \xe2\x80\xa60BmCasts vector of type __m256d to type __m256i.0DoCast vector of type <code>__m256h</code> to type <code>__m256i</code>. This \xe2\x80\xa60BlCasts vector of type __m256 to type __m256i.0BmCasts vector of type __m256i to type __m256d.0DoCast vector of type <code>__m256i</code> to type <code>__m256h</code>. This \xe2\x80\xa60BlCasts vector of type __m256i to type __m256.0CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClConverts packed double-precision (64-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa60444444CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa6000CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6000ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6000CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa6000EdExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000EgCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into \xe2\x80\xa60EgCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into \xe2\x80\xa60EfCopies <code>a</code> to result, and insert the 64-bit integer <code>i</code> into \xe2\x80\xa6CbLoads two 128-bit values (composed of 2 packed \xe2\x80\xa60ClLoads two 128-bit values (composed of integer data) from \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CjStores packed double-precision (64-bit) floating-point \xe2\x80\xa60CjStores packed single-precision (32-bit) floating-point \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise AND of packed double-precision \xe2\x80\xa60CfCompute the bitwise AND of packed single-precision \xe2\x80\xa60CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa60ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa60CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa60CeSet each bit of mask register k based on the most \xe2\x80\xa60CfComputes the sum of absolute differences (SADs) of \xe2\x80\xa60EeMultiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60EdConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa60EdConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60DnShuffles bytes from <code>a</code> according to the content of <code>b</code>.0CnStores the high and low 128-bit halves (each composed of 4 \xe2\x80\xa60CjStore 256-bits (composed of 16 packed 16-bit integers) \xe2\x80\xa60CnStore 256-bits (composed of 8 packed 32-bit integers) from \xe2\x80\xa60CnStore 256-bits (composed of 4 packed 64-bit integers) from \xe2\x80\xa60DdStores 256-bits of integer data from <code>a</code> into memory. \xe2\x80\xa60CiMoves integer data from a 256-bit integer vector to a \xe2\x80\xa60DhReturns vector of type <code>__m256d</code> with indeterminate elements.0DcReturn vector of type <code>__m256h</code> with indetermination \xe2\x80\xa60DkReturns vector of type <code>__m256</code> with indeterminate elements. \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa6000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa60CkCompute the bitwise NOT of 512 bits (composed of packed \xe2\x80\xa60CmCompute the bitwise NOT of 512 bits (representing integer \xe2\x80\xa60CnShift 128-bit lanes in a left by imm8 bytes while shifting \xe2\x80\xa60CfShift 128-bit lanes in a right by imm8 bytes while \xe2\x80\xa60CeCast vector of type __m512d to type __m512i. This \xe2\x80\xa60DoCast vector of type <code>__m512h</code> to type <code>__m512i</code>. This \xe2\x80\xa60CnCast vector of type __m512 to type __m512i. This intrinsic \xe2\x80\xa60CeCast vector of type __m512i to type __m512d. This \xe2\x80\xa60DoCast vector of type <code>__m512i</code> to type <code>__m512h</code>. This \xe2\x80\xa60CnCast vector of type __m512i to type __m512. This intrinsic \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000000000022222222CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60ClGather double-precision (64-bit) floating-point elements \xe2\x80\xa60ClGather single-precision (32-bit) floating-point elements \xe2\x80\xa601100ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise AND of packed double-precision \xe2\x80\xa60CfCompute the bitwise AND of packed single-precision \xe2\x80\xa60CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChMove packed double-precision (64-bit) floating-point \xe2\x80\xa60ChMove packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CgCompute the approximate reciprocal of packed 16-bit \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60CfCompute the bitwise XOR of packed double-precision \xe2\x80\xa60CfCompute the bitwise XOR of packed single-precision \xe2\x80\xa60==<<;;==<<;;CeSet each bit of mask register k based on the most \xe2\x80\xa60998877CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CnMultiplies elements in packed 64-bit integer vectors a and \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa60CjStore 512-bits (composed of 32 packed 16-bit integers) \xe2\x80\xa60CjStore 512-bits (composed of 16 packed 32-bit integers) \xe2\x80\xa60CnStore 512-bits (composed of 8 packed 64-bit integers) from \xe2\x80\xa60CfStore 512-bits of integer data from a into memory. \xe2\x80\xa60CmStore 512-bits of integer data from a into memory using a \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60DhReturns vector of type <code>__m512d</code> with indeterminate elements.0DcReturn vector of type <code>__m512h</code> with indetermination \xe2\x80\xa60DkReturns vector of type <code>__m512</code> with indeterminate elements. \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60DfBroadcasts the low packed 8-bit integer from <code>a</code> to all \xe2\x80\xa60CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa601100110011001100CkConvert the signed 32-bit integer b to a half-precision \xe2\x80\xa60CmConvert the signed 32-bit integer b to a single-precision \xe2\x80\xa60CmConvert the signed 64-bit integer b to a double-precision \xe2\x80\xa6CkConvert the signed 64-bit integer b to a half-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a single-precision \xe2\x80\xa6CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa600000222222CmConvert the unsigned 32-bit integer b to a half-precision \xe2\x80\xa60BnConvert the unsigned 32-bit integer b to a \xe2\x80\xa60BnConvert the unsigned 64-bit integer b to a \xe2\x80\xa6CmConvert the unsigned 64-bit integer b to a half-precision \xe2\x80\xa61CkConvert packed single precision (32-bit) floating-point \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60221100ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa60CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa60ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa60CkTest the lower double-precision (64-bit) floating-point \xe2\x80\xa60CiTest the lower half-precision (16-bit) floating-point \xe2\x80\xa60CkTest the lower single-precision (32-bit) floating-point \xe2\x80\xa60CfConvert the exponent of the lower double-precision \xe2\x80\xa60CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa60CfConvert the exponent of the lower single-precision \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60>>ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60554433221100CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa60ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa60CjBlend packed 8-bit integers from a and b using control \xe2\x80\xa60CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CiMultiply the lower complex number in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CiNormalize the mantissas of the lower double-precision \xe2\x80\xa60CgNormalize the mantissas of the lower half-precision \xe2\x80\xa60CiNormalize the mantissas of the lower single-precision \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000CiCompute the approximate reciprocal square root of the \xe2\x80\xa6000CkBroadcast 16-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa608877ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa60CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa60554433221100CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa60CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa60DgConditionally store 8-bit integer elements from <code>a</code> into \xe2\x80\xa60DiStores packed 32-bit integers from <code>a</code> into memory pointed \xe2\x80\xa60DiStores packed 64-bit integers from <code>a</code> into memory pointed \xe2\x80\xa60CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa60CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa60CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa60CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa60CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60554433221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CfConvert the exponent of the lower double-precision \xe2\x80\xa60CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa60CfConvert the exponent of the lower single-precision \xe2\x80\xa60CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CnMove packed 16-bit integers from a into dst using zeromask \xe2\x80\xa60CnMove packed 32-bit integers from a into dst using zeromask \xe2\x80\xa60CnMove packed 64-bit integers from a into dst using zeromask \xe2\x80\xa60ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa60CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CnExtract the reduced argument of the lower double-precision \xe2\x80\xa60ClExtract the reduced argument of the lower half-precision \xe2\x80\xa60CnExtract the reduced argument of the lower single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60220000CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa60CiShift packed 16-bit integers in a left by count while \xe2\x80\xa60CiShift packed 32-bit integers in a left by count while \xe2\x80\xa60CiShift packed 64-bit integers in a left by count while \xe2\x80\xa60CjShift packed 16-bit integers in a right by count while \xe2\x80\xa60CjShift packed 32-bit integers in a right by count while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa60221100CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa60CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa60CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa60CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa60ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CnReduce the packed 8-bit integers in a by addition. Returns \xe2\x80\xa60CiReduce the packed 8-bit integers in a by bitwise AND. \xe2\x80\xa60CmReduce the packed 8-bit integers in a by maximum. Returns \xe2\x80\xa60CnReduce the packed unsigned 8-bit integers in a by maximum. \xe2\x80\xa60CmReduce the packed 8-bit integers in a by minimum. Returns \xe2\x80\xa60CnReduce the packed unsigned 8-bit integers in a by minimum. \xe2\x80\xa60ClReduce the packed 8-bit integers in a by multiplication. \xe2\x80\xa60CiReduce the packed 16-bit integers in a by bitwise OR. \xe2\x80\xa60CnExtract the reduced argument of the lower double-precision \xe2\x80\xa60ClExtract the reduced argument of the lower half-precision \xe2\x80\xa60CnExtract the reduced argument of the lower single-precision \xe2\x80\xa60CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6000ChCalculate SHA1 state variable E after four rounds of \xe2\x80\xa60CkPerforms four rounds of SHA1 operation using an initial \xe2\x80\xa60DhShuffles 16-bit integers in the high 64 bits of <code>a</code> using \xe2\x80\xa60DkShuffles 16-bit integers in the low 64 bits of <code>a</code> using the \xe2\x80\xa60CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa60CeReturns vector of type __m128i with indeterminate \xe2\x80\xa60CjCreates a layout describing the record that can hold a \xe2\x80\xa600CkTransmutes the mutable uninitialized slice to a mutable \xe2\x80\xa60CmAttribute macro applied to a function to register it as a \xe2\x80\xa60DcSplits the slice into a slice of <code>N</code>-element arrays, \xe2\x80\xa60DgReturns <code>None</code> if the pointer is null, or else returns a \xe2\x80\xa6CeReturns a unique reference to a slice of possibly \xe2\x80\xa610kAsync drop.0CdThis is an identity function used as part of the \xe2\x80\xa6DeChecked integer subtraction. Computes <code>self - rhs</code> and \xe2\x80\xa600000000000EcCreates a new mask from the elements of <code>first</code> and <code>second</code>.00BkThis is an accidentally-stable alias to \xe2\x80\xa6FiCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The \xe2\x80\xa610ChConverts a 128-bit vector interpreted as four 32-bit \xe2\x80\xa600000DdComputes <code>-a * b + c</code> with either one rounding or two \xe2\x80\xa600000DkFinds the closest <code>x</code> not exceeding <code>index</code> where \xe2\x80\xa60CmCreates a C string wrapper from a byte slice with exactly \xe2\x80\xa60FbConstructs a <code>Layout</code> from a given <code>size</code> and <code>alignment</code>, or \xe2\x80\xa600CgConverts a slice of bytes to a string slice without \xe2\x80\xa6DhConverts a vector of bytes to a <code>String</code> without checking \xe2\x80\xa611110CkChecks whether the standard library\xe2\x80\x99s panic hook will \xe2\x80\xa6CkGets the mutable reference of the contents of the cell, \xe2\x80\xa600DdEquivalent to <code>CString::into_bytes()</code> except that the \xe2\x80\xa60CeChecks if the value is an ASCII alphabetic character:000CiChecks if the value is an ASCII whitespace character: \xe2\x80\xa6000EgReturns <code>self</code> with only the most significant bit set, or <code>0</code> \xe2\x80\xa600000000000DaReturns <code>self</code> with only the most significant bit set.00000000000111111111111000000000000ClConstructs a new atomically reference-counted slice with \xe2\x80\xa6ClConstructs a new boxed slice with uninitialized contents \xe2\x80\xa6CaConstructs a new reference-counted slice with \xe2\x80\xa6210210210DfNormalize a path, including <code>..</code> without traversing the \xe2\x80\xa6DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa60DjClones the elements at the range <code>src</code> and prepends them to \xe2\x80\xa60DgReturns the nearest integer to an <code>f16</code>. Rounds half-way \xe2\x80\xa60DgReturns the nearest integer to an <code>f32</code>. Rounds half-way \xe2\x80\xa60DgReturns the nearest integer to an <code>f64</code>. Rounds half-way \xe2\x80\xa60BiGet the state of a specific barrier type.CnCreates schedule groups with specific properties to create \xe2\x80\xa6DjReorders the slice such that the element at <code>index</code> is at a \xe2\x80\xa60CnConfigures whether the default panic hook will capture and \xe2\x80\xa6DkShifts the mask elements to the left by <code>OFFSET</code>, filling in \xe2\x80\xa6DjShifts the vector elements to the left by <code>OFFSET</code>, filling \xe2\x80\xa610CdDetermines if the <code>0</code> flag was specified.BgSets or unsets the <code>0</code> flag.1010CcAdds two simd vectors elementwise, with saturation.0ChSubtracts two simd vectors elementwise, with saturation.0B`Selects elements from a bitmask.0CnTakes a substring based on a range that corresponds to the \xe2\x80\xa6EhProjects to the <code>index</code>-th element of <code>slice_ptr</code>, as the same \xe2\x80\xa60CeCreates a string slice from another string slice, \xe2\x80\xa60CkReturns an iterator over mutable subslices separated by \xe2\x80\xa60ChRemoves the first element of the slice and returns a \xe2\x80\xa60CfStrict addition with an unsigned integer. Computes \xe2\x80\xa600000000000CiStrict subtraction with an unsigned integer. Computes \xe2\x80\xa600000000000EaSwaps <code>count * size_of::&lt;T&gt;()</code> bytes between the two regions \xe2\x80\xa60DgLike <code>transmute</code>, but even less checked at compile-time: \xe2\x80\xa60CjUnchecked integer division without remainder. Computes \xe2\x80\xa600000000000000000000000EaUnchecked exact shift left. Computes <code>self &lt;&lt; rhs</code>, assuming \xe2\x80\xa600000000000000000000000DiUnchecked exact shift right. Computes <code>self &gt;&gt; rhs</code>, \xe2\x80\xa600000000000000000000000BjVector Compare Not in Ranges or Zero IndexDeConverts the elements of vector <code>a</code> to the 16-bit IEEE \xe2\x80\xa6CgVector Find Any Element Equal Index with Condition CodeCkVector Find Any Element Not Equal Index with Condition CodeAfVector Insert and ZeroEgConverts the elements of single-precision vectors <code>a</code> and <code>b</code> \xe2\x80\xa6DePowerPC-specific 128-bit wide vector of eight packed <code>i16</code>0Dcs390x-specific 128-bit wide vector of eight packed <code>i16</code>DdPowerPC-specific 128-bit wide vector of four packed <code>u32</code>0Dbs390x-specific 128-bit wide vector of four packed <code>u32</code>CmFloating-point fused Multiply-Add Long to accumulator (by \xe2\x80\xa6CdFloating-point fused Multiply-Subtract Long from \xe2\x80\xa6CjLookup table read with 4-bit indices Arm\xe2\x80\x99s documentation000BgMultiply-add long Arm\xe2\x80\x99s documentation000BlMultiply-subtract long Arm\xe2\x80\x99s documentation000BcMultiply long Arm\xe2\x80\x99s documentation000DaEquivalent to the appropriate <code>llvm.memset.p0i8.*</code> \xe2\x80\xa60CkSigned saturating rounding doubling multiply accumulate \xe2\x80\xa6000CiSigned saturating rounding doubling multiply subtract \xe2\x80\xa6000CjSigned saturating rounding doubling multiply returning \xe2\x80\xa6CkVector rounding saturating doubling multiply high by scalar0001ClSigned saturating rounded shift right unsigned narrow Arm\xe2\x80\xa600CgVector reinterpret cast operation Arm\xe2\x80\x99s documentation00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CkWrapping (modular) addition with a signed integer. Computes00000000000DhWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,0000DhWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>.000010111110000010DkWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>\xe2\x80\xa60000DfWrapping Euclidean modulo. Computes <code>self.rem_euclid(rhs)</code>.000010111110000010CiWrapping (modular) subtraction with a signed integer. \xe2\x80\xa600000000000EgCopies the elements from <code>src</code> to <code>self</code>, returning a mutable \xe2\x80\xa60CmWrites a length prefix into this hasher, as part of being \xe2\x80\xa60EkAssociated type for <code>&lt;&amp;[char; N] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.00CdZero-sized type used to mark a type parameter as \xe2\x80\xa60CmAn iterator over the non-ASCII-whitespace substrings of a \xe2\x80\xa600AkSee <code>_mm_setcsr</code>0Bmuse MXCSR.RC and suppress exceptions; see \xe2\x80\xa60Ajdo not suppress exceptions0DbThe strings defined by <code>a</code> and <code>b</code> are equal0ChPerforms one round of an AES decryption flow on each \xe2\x80\xa60ChPerforms one round of an AES encryption flow on each \xe2\x80\xa60CnConvert scalar BF16 (16-bit) floating point element stored \xe2\x80\xa60ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa60CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60BnSign-extend 8-bit integers to 16-bit integers.0BnSign-extend 8-bit integers to 32-bit integers.0BnSign-extend 8-bit integers to 64-bit integers.0DcZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit \xe2\x80\xa60DiZero-extend the lower eight unsigned 8-bit integers in <code>a</code> \xe2\x80\xa60DkZero-extend the lower four unsigned 8-bit integers in <code>a</code> to \xe2\x80\xa60ClConvert packed BF16 (16-bit) floating-point even-indexed \xe2\x80\xa60CkConvert packed BF16 (16-bit) floating-point odd-indexed \xe2\x80\xa60DhReturns the first element of the input vector of <code>[8 x i32]</code>.0CgMultiply groups of 4 adjacent pairs of signed 8-bit \xe2\x80\xa6000CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa6000ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa6000CjMultiply groups of 2 adjacent pairs of unsigned 16-bit \xe2\x80\xa6000EdExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. \xe2\x80\xa60E`Extracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.0E`Extracts a 64-bit integer from <code>a</code>, selected with <code>INDEX</code>.CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CnStores 4 double-precision (64-bit) floating-point elements \xe2\x80\xa60CnStores 8 single-precision (32-bit) floating-point elements \xe2\x80\xa6011CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa60DiCopies <code>a</code> to result, then inserts 128 bits (composed of 2 \xe2\x80\xa60DiCopies <code>a</code> to result, then inserts 128 bits (composed of 4 \xe2\x80\xa60DiVertically multiplies each unsigned 8-bit integer from <code>a</code> \xe2\x80\xa60CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa60CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa60CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa60CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa60CgBlend packed half-precision (16-bit) floating-point \xe2\x80\xa60CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa60CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa601100CnMove packed 8-bit integers from a into dst using writemask \xe2\x80\xa60CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa60CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000C`Compute the approximate reciprocal of packed \xe2\x80\xa6000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa60CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa60CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa60<<;;==CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60ClCreates mask from the most significant bit of each 8-bit \xe2\x80\xa60CeSet each bit of mask register k based on the most \xe2\x80\xa600000CnShuffles double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffles single-precision (32-bit) floating-point elements \xe2\x80\xa60ClReduce the packed half-precision (16-bit) floating-point \xe2\x80\xa60000000CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60CkReturns vector of type __m256i with all elements set to \xe2\x80\xa60DiShuffles 32-bit integers in 128-bit lanes of <code>a</code> using the \xe2\x80\xa60CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa60CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa60CmThis intrinsic performs four rounds of SM4 key expansion. \xe2\x80\xa60CnStores the high and low 128-bit halves (each composed of 2 \xe2\x80\xa60ClStores the high and low 128-bit halves (each composed of \xe2\x80\xa60CnComputes the bitwise AND of 256 bits (representing integer \xe2\x80\xa60ClUnpacks and interleave 8-bit integers from the high half \xe2\x80\xa60CnUnpacks and interleave 8-bit integers from the low half of \xe2\x80\xa60ChPerforms one round of an AES decryption flow on each \xe2\x80\xa60ChPerforms one round of an AES encryption flow on each \xe2\x80\xa60ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa60CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6011001100CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60ClPerforms element-by-element conversion of the lower half \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa60CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa6044CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa6000CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa60BjCopy the lower 32-bit integer in a to dst.0CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CmScatter double-precision (64-bit) floating-point elements \xe2\x80\xa60CmScatter single-precision (32-bit) floating-point elements \xe2\x80\xa601100CjVertically multiply each unsigned 8-bit integer from a \xe2\x80\xa60CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa60CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa60CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa60CiBlend packed double-precision (64-bit) floating-point \xe2\x80\xa60CgBlend packed half-precision (16-bit) floating-point \xe2\x80\xa60CiBlend packed single-precision (32-bit) floating-point \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa60CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa601100CnMove packed 8-bit integers from a into dst using writemask \xe2\x80\xa60CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa60CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000C`Compute the approximate reciprocal of packed \xe2\x80\xa6000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa60CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa60CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa60<<;;==CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CeSet each bit of mask register k based on the most \xe2\x80\xa600000CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CnReduce the packed double-precision (64-bit) floating-point \xe2\x80\xa60ClReduce the packed half-precision (16-bit) floating-point \xe2\x80\xa60CnReduce the packed single-precision (32-bit) floating-point \xe2\x80\xa60221100221100221100CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60DgReturn vector of type <code>__m512i</code> with all elements set to \xe2\x80\xa60DhReturns vector of type <code>__m512i</code> with all elements set to \xe2\x80\xa6088CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa60CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa60CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa60CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa60CmPerforms the last round of an AES decryption flow on data \xe2\x80\xa60CmPerforms the last round of an AES encryption flow on data \xe2\x80\xa60DgBroadcasts the low packed 32-bit integer from <code>a</code> to all \xe2\x80\xa60DgBroadcasts the low packed 64-bit integer from <code>a</code> to all \xe2\x80\xa60CjBroadcasts the low packed 16-bit integer from a to all \xe2\x80\xa60CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa60CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6055ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60443322771100443322771100443322771100443322CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa600CmConvert the signed 32-bit integer b to a single-precision \xe2\x80\xa60CmConvert the signed 64-bit integer b to a double-precision \xe2\x80\xa6CmConvert the signed 64-bit integer b to a single-precision \xe2\x80\xa6CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa600444444ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa600000111111CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60ChWrap a 128-bit AES key into a 384-bit key handle and \xe2\x80\xa60ChWrap a 256-bit AES key into a 512-bit key handle and \xe2\x80\xa60CiMultiply the lower complex number in a by the complex \xe2\x80\xa60CiNormalize the mantissas of the lower double-precision \xe2\x80\xa60CgNormalize the mantissas of the lower half-precision \xe2\x80\xa60CiNormalize the mantissas of the lower single-precision \xe2\x80\xa60CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa60CnStores 2 64-bit integer elements from a to memory starting \xe2\x80\xa60CnStores 2 32-bit integer elements from a to memory starting \xe2\x80\xa6011CgMultiply packed complex numbers in a by the complex \xe2\x80\xa6077CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa60CkBlend packed 16-bit integers from a and b using control \xe2\x80\xa60CkBlend packed 32-bit integers from a and b using control \xe2\x80\xa60CkBlend packed 64-bit integers from a and b using control \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60000000ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa60CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa60ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa60CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa60CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa60EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CiStore packed 32-bit integers from a into memory using \xe2\x80\xa60CiStore packed 64-bit integers from a into memory using \xe2\x80\xa60ChStore packed 8-bit integers from a into memory using \xe2\x80\xa60CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa60CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa601100CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa60ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa60CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CiMultiply the lower complex number in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CiNormalize the mantissas of the lower double-precision \xe2\x80\xa60CgNormalize the mantissas of the lower half-precision \xe2\x80\xa60CiNormalize the mantissas of the lower single-precision \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000CiCompute the approximate reciprocal square root of the \xe2\x80\xa6000CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa608877ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa60CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa60554433221100CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa60CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa60CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60CgReduce the packed 16-bit integers in a by addition. \xe2\x80\xa60CjReduce the packed 16-bit integers in a by bitwise AND. \xe2\x80\xa60CnReduce the packed 16-bit integers in a by maximum. Returns \xe2\x80\xa60CfReduce the packed unsigned 16-bit integers in a by \xe2\x80\xa60CnReduce the packed 16-bit integers in a by minimum. Returns \xe2\x80\xa6011CmReduce the packed 16-bit integers in a by multiplication. \xe2\x80\xa60CjPerforms an intermediate calculation for the next four \xe2\x80\xa60CkPerforms the final calculation for the next four SHA256 \xe2\x80\xa60CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa60ClLoad tile rows from memory specified by base address and \xe2\x80\xa6DdBinary searches this <code>VecDeque</code> with a key extraction \xe2\x80\xa6CjBinary searches this slice with a key extraction function.01CgChecked addition with an unsigned integer. Computes \xe2\x80\xa600000000000CjChecked subtraction with an unsigned integer. Computes \xe2\x80\xa600000000000ChAsserts that an expression matches the provided pattern.0CkChecks that two values are an ASCII case-insensitive match.CkChecks that two slices are an ASCII case-insensitive match.CiChecks that two strings are an ASCII case-insensitive \xe2\x80\xa62210202CiCreates a C string wrapper from a byte slice with any \xe2\x80\xa60EdUnwraps this <code>Pin&lt;Ptr&gt;</code>, returning the underlying <code>Ptr</code>.0CfChecks if the value is an ASCII punctuation character:000CiConverts this type to its ASCII lower case equivalent \xe2\x80\xa6CjConverts this slice to its ASCII lower case equivalent \xe2\x80\xa6CkConverts this string to its ASCII lower case equivalent \xe2\x80\xa6CjConverts this value to its ASCII lower case equivalent \xe2\x80\xa6321013CiConverts this type to its ASCII upper case equivalent \xe2\x80\xa6CjConverts this slice to its ASCII upper case equivalent \xe2\x80\xa6CkConverts this string to its ASCII upper case equivalent \xe2\x80\xa6CjConverts this value to its ASCII upper case equivalent \xe2\x80\xa6321013DiCorresponding intrinsic to wasm\xe2\x80\x99s <code>memory.atomic.notify</code> \xe2\x80\xa600DiCorresponding intrinsic to wasm\xe2\x80\x99s <code>memory.atomic.wait32</code> \xe2\x80\xa600DiCorresponding intrinsic to wasm\xe2\x80\x99s <code>memory.atomic.wait64</code> \xe2\x80\xa600CkCalculates the distance between two pointers within the \xe2\x80\xa600000CmAppends an element and returns a reference to it if there \xe2\x80\xa60DhRotates the mask such that the first <code>OFFSET</code> elements of \xe2\x80\xa6DjRotates the vector such that the first <code>OFFSET</code> elements of \xe2\x80\xa610DhReturns the nearest integer to an <code>f128</code>. Rounds half-way \xe2\x80\xa60EcReturns either <code>true_val</code> or <code>false_val</code> depending on the \xe2\x80\xa6DoReturns either <code>true_val</code> or <code>false_val</code> depending on \xe2\x80\xa610CkRegisters a custom allocation error hook, replacing any \xe2\x80\xa6DgSets the value of the <code>IP_MULTICAST_TTL</code> option for this \xe2\x80\xa6DiShifts the mask elements to the right by <code>OFFSET</code>, filling \xe2\x80\xa6DkShifts the vector elements to the right by <code>OFFSET</code>, filling \xe2\x80\xa610ClRounds each element to the closest integer-valued float. \xe2\x80\xa60BnForms a raw slice from a pointer and a length.CjCreates a non-null raw slice from a thin pointer and a \xe2\x80\xa610ClSorts the slice in ascending order with a key extraction \xe2\x80\xa60CmDivides one mutable slice into two at an index, returning \xe2\x80\xa6CfDivides one mutable string slice into two at an index.10DiReturns a mutable array reference to the last <code>N</code> items in \xe2\x80\xa60CnVisits the elements representing the symmetric difference, \xe2\x80\xa6ClVisits the values representing the symmetric difference, \xe2\x80\xa61CnImmutably borrows the wrapped value, returning an error if \xe2\x80\xa60CmConstructs a new boxed slice with uninitialized contents. \xe2\x80\xa60CmConstructs a new boxed slice with uninitialized contents, \xe2\x80\xa60DjConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the \xe2\x80\xa60AbFunnel Shift left.DhSee <code>super::unchecked_funnel_shl</code>; we just need the trait \xe2\x80\xa610AcFunnel Shift right.DhSee <code>super::unchecked_funnel_shr</code>; we just need the trait \xe2\x80\xa610EhReturns the contained <code>Err</code> value, consuming the <code>self</code> value, \xe2\x80\xa60CfFloating-point complex multiply accumulate Arm\xe2\x80\x99s \xe2\x80\xa60AfVector Copy Until ZeroChVector Galois Field Multiply Sum and Accumulate 128-bitsAdVector Search StringDfPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>0Dds390x-specific 128-bit wide vector of sixteen packed <code>u8</code>DcPowerPC-specific 128-bit wide vector of two packed <code>u64</code>0CmFloating-point fused Multiply-Add Long to accumulator (by \xe2\x80\xa600CdFloating-point fused Multiply-Subtract Long from \xe2\x80\xa600CjLookup table read with 4-bit indices Arm\xe2\x80\x99s documentation000BgMultiply-add long Arm\xe2\x80\x99s documentation000BlMultiply-subtract long Arm\xe2\x80\x99s documentation000BcMultiply long Arm\xe2\x80\x99s documentation000DfEquivalent to the appropriate <code>llvm.memmove.p0i8.0i8.*</code> \xe2\x80\xa60DhReturns the value of the <code>dwVolumeSerialNumber</code> field of thisCgVector reinterpret cast operation Arm\xe2\x80\x99s documentation0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000EgCreates an owned <code>PathBuf</code> like <code>self</code> but with the extension \xe2\x80\xa6CmAdds a signed offset in bytes to a pointer using wrapping \xe2\x80\xa6000EgClones the elements from <code>src</code> to <code>self</code>, returning a mutable \xe2\x80\xa60DnAssociated type for <code>&lt;F as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.00CfAn error indicating that a nul byte was not in the \xe2\x80\xa6000CnRAII structure used to release the shared read access of a \xe2\x80\xa600CcMore than 6 characters in \xe2\x80\x98\\u{..}\xe2\x80\x99, e.g. \xe2\x80\x98\xe2\x80\xa6Di<code>U+FFFD REPLACEMENT CHARACTER</code> (\xef\xbf\xbd) is used in Unicode to \xe2\x80\xa6000CdAn error which can be returned when converting a \xe2\x80\xa60CcNo closing brace in \xe2\x80\x98\\u{..}\xe2\x80\x99, e.g. \xe2\x80\x98\\u{12\xe2\x80\x99.CkThe reason we are terminating the process during unwinding.0jround down0hround up0AkSee <code>_mm_setcsr</code>0Adinterval [0.75, 1.5)01111CfAdd a logical tag to the set of excluded logical tags.EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa60C`Broadcasts the low double-precision (64-bit) \xe2\x80\xa60C`Broadcasts the low single-precision (32-bit) \xe2\x80\xa60CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa60ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60BoSign-extend 16-bit integers to 32-bit integers.0BoSign-extend 16-bit integers to 64-bit integers.0ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60BoSign-extend 32-bit integers to 64-bit integers.0ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60DfZeroes extend packed unsigned 16-bit integers in <code>a</code> to \xe2\x80\xa60DiZero-extend the lower four unsigned 16-bit integers in <code>a</code> \xe2\x80\xa60DdZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa60ClExtracts 128 bits (composed of 4 packed single-precision \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa60CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa60CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa60CjPerforms element-by-element bitwise AND between packed \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa60CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa60CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CeMove packed 16-bit integers from a into dst using \xe2\x80\xa60CmMove packed 32-bit integers from a to dst using writemask \xe2\x80\xa60CmMove packed 64-bit integers from a to dst using writemask \xe2\x80\xa60ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa60CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa60CiShift packed 16-bit integers in a left by count while \xe2\x80\xa60CiShift packed 32-bit integers in a left by count while \xe2\x80\xa60CiShift packed 64-bit integers in a left by count while \xe2\x80\xa60CjShift packed 16-bit integers in a right by count while \xe2\x80\xa60CjShift packed 32-bit integers in a right by count while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa60221100CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa60CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa60CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa60CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa60CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa60CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa60ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60CgLoads packed 32-bit integers from memory pointed by \xe2\x80\xa60CgLoads packed 64-bit integers from memory pointed by \xe2\x80\xa60CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa60CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa60CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa60CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa601100CmMove packed 8-bit integers from a into dst using zeromask \xe2\x80\xa60CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa60CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000C`Compute the approximate reciprocal of packed \xe2\x80\xa6000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa60DjShuffles 64-bit floating-point elements in <code>a</code> across lanes \xe2\x80\xa60CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60ChReduce the packed 8-bit integers in a by bitwise OR. \xe2\x80\xa60CnThis intrinsic performs four rounds of SM4 encryption. The \xe2\x80\xa60CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa60CmUnpacks and interleave 16-bit integers from the high half \xe2\x80\xa60CmUnpacks and interleave 32-bit integers from the high half \xe2\x80\xa60CmUnpacks and interleave 64-bit integers from the high half \xe2\x80\xa60ClUnpacks and interleave 16-bit integers from the low half \xe2\x80\xa60ClUnpacks and interleave 32-bit integers from the low half \xe2\x80\xa60ClUnpacks and interleave 64-bit integers from the low half \xe2\x80\xa60CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa60CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa60CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa60ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60110011001100CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa6000CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60CmLoads 8 double-precision (64-bit) floating-point elements \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000554433554433CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa60DjComputes the absolute value of packed 32-bit integers in <code>a</code>\xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa60CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa60CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa60CjPerforms element-by-element bitwise AND between packed \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa60CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa60CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CeMove packed 16-bit integers from a into dst using \xe2\x80\xa60CmMove packed 32-bit integers from a to dst using writemask \xe2\x80\xa60CmMove packed 64-bit integers from a to dst using writemask \xe2\x80\xa60ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa60CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa60CiShift packed 16-bit integers in a left by count while \xe2\x80\xa60CiShift packed 32-bit integers in a left by count while \xe2\x80\xa60CiShift packed 64-bit integers in a left by count while \xe2\x80\xa60CjShift packed 16-bit integers in a right by count while \xe2\x80\xa60CjShift packed 32-bit integers in a right by count while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa60221100CiStore packed double-precision (64-bit) floating-point \xe2\x80\xa60CiStore packed single-precision (32-bit) floating-point \xe2\x80\xa60CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa60CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa60CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa60CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa60ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60CnCompute the absolute value of packed signed 8-bit integers \xe2\x80\xa60CgAdd packed 8-bit integers in a and b, and store the \xe2\x80\xa60CjAverage packed unsigned 8-bit integers in a and b, and \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CkCompute the complex conjugates of complex numbers in a, \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa6000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa6000ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa60ChLoad packed double-precision (64-bit) floating-point \xe2\x80\xa60ChLoad packed single-precision (32-bit) floating-point \xe2\x80\xa60CnCompare packed signed 8-bit integers in a and b, and store \xe2\x80\xa60CjCompare packed unsigned 8-bit integers in a and b, and \xe2\x80\xa601100CmMove packed 8-bit integers from a into dst using zeromask \xe2\x80\xa60CmCompute the bitwise OR of packed 32-bit integers in a and \xe2\x80\xa60CmCompute the bitwise OR of packed 64-bit integers in a and \xe2\x80\xa60CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000C`Compute the approximate reciprocal of packed \xe2\x80\xa6000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa60CiSubtract packed 8-bit integers in b from packed 8-bit \xe2\x80\xa60CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa607777CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa60ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa60CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa60ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa60CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa60CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa600CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa60CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6011ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa601122CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa60ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa60CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa60CnConcatenate a and b into a 32-byte immediate result, shift \xe2\x80\xa6000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000000000002222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa6033CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa60CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa60CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60221100C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa60CiStore packed 16-bit integers from a into memory using \xe2\x80\xa60CiStore packed 32-bit integers from a into memory using \xe2\x80\xa60CiStore packed 64-bit integers from a into memory using \xe2\x80\xa60C`Subtract the lower double-precision (64-bit) \xe2\x80\xa60CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Subtract the lower single-precision (32-bit) \xe2\x80\xa60CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ClConverts packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60000000ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa60CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa60ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa60CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa60CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa60EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa60CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa601100ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CjPerforms 2 rounds of SHA256 operation using an initial \xe2\x80\xa60CgLoad 128-bits of integer data from memory into dst. \xe2\x80\xa60CnReturns an estimate of the default amount of parallelism a \xe2\x80\xa6DiStores a value into the <code>bool</code> if the current value is the \xe2\x80\xa6CkStores a value into the pointer if the current value is \xe2\x80\xa6CiStores a value into the atomic integer if the current \xe2\x80\xa60000000000021000000000000CiMarks the struct as non-exhaustive, indicating to the \xe2\x80\xa6CkMarks the tuple struct as non-exhaustive, indicating to \xe2\x80\xa6CmMarks the set as non-exhaustive, indicating to the reader \xe2\x80\xa6CnMarks the list as non-exhaustive, indicating to the reader \xe2\x80\xa6CmMarks the map as non-exhaustive, indicating to the reader \xe2\x80\xa64321043210EnConverts a <code>Vec&lt;u8&gt;</code> to a <code>String</code>, substituting invalid UTF-8 \xe2\x80\xa60DiInserts the default value into the option if it is <code>None</code>, \xe2\x80\xa60DiA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both \xe2\x80\xa600ChConverts a 128-bit vector interpreted as four 32-bit \xe2\x80\xa600DgA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects \xe2\x80\xa600DcDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: \xe2\x80\xa60CgChecks if the value is an ASCII alphanumeric character:000DfReturns <code>true</code> if the address is a unicast address with \xe2\x80\xa60DkReads contiguous elements from <code>slice</code>. Each element is read \xe2\x80\xa60DiPartially sorts the slice in ascending order <strong>without</strong> \xe2\x80\xa60DiRotates the mask such that the first <code>self.len() - OFFSET</code> \xe2\x80\xa6DkRotates the vector such that the first <code>self.len() - OFFSET</code> \xe2\x80\xa610CgSaturating addition with a signed integer. Computes \xe2\x80\xa600000000000EbSaturating integer subtraction. Computes <code>self</code> - <code>rhs</code>, \xe2\x80\xa600000000000DhSets the value of the <code>IP_MULTICAST_LOOP</code> option for this \xe2\x80\xa6DjSets the value of the <code>IPV6_MULTICAST_LOOP</code> option for this \xe2\x80\xa6CjExecutes the command as a child process with the given \xe2\x80\xa6DjReturns a mutable array reference to the first <code>N</code> items in \xe2\x80\xa60ClUnregisters the current allocation error hook, returning \xe2\x80\xa6EhConstructs a new <code>Arc&lt;T&gt;</code> with a clone of <code>value</code> in the \xe2\x80\xa6DhAllocates memory in the given allocator then clones <code>src</code> \xe2\x80\xa6EgConstructs a new <code>Rc&lt;T&gt;</code> with a clone of <code>value</code> in the \xe2\x80\xa6210DiA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both \xe2\x80\xa600ChConverts a 128-bit vector interpreted as four 32-bit \xe2\x80\xa600DgA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects \xe2\x80\xa600ClInforms the compiler that the site which is calling this \xe2\x80\xa60CfFloating-point complex multiply accumulate Arm\xe2\x80\x99s \xe2\x80\xa60000000CfVector Compare Equal or Zero Index with Condition CodeCjVector Compare Not Equal or Zero Index with Condition CodeCgVector Compare Ranges or Zero Index with Condition CodeDjConverts the elements of vector <code>a</code> to an internal floating \xe2\x80\xa6D`Converts the left-most half of <code>a</code> to a vector of \xe2\x80\xa6DaConverts the right-most half of <code>a</code> to a vector of \xe2\x80\xa6Cis390x-specific 128-bit wide vector mask of two packed \xe2\x80\xa6DePowerPC-specific 128-bit wide vector of eight packed <code>u16</code>0Dcs390x-specific 128-bit wide vector of eight packed <code>u16</code>CmFloating-point fused Multiply-Add Long to accumulator (by \xe2\x80\xa600CdFloating-point fused Multiply-Subtract Long from \xe2\x80\xa600ChSigned saturating doubling multiply-add long Arm\xe2\x80\x99s \xe2\x80\xa60CmSigned saturating doubling multiply-subtract long Arm\xe2\x80\x99s \xe2\x80\xa60CdSigned saturating doubling multiply long Arm\xe2\x80\x99s \xe2\x80\xa60CgVector reinterpret cast operation Arm\xe2\x80\x99s documentation0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CiWrapping (modular) addition with an unsigned integer. \xe2\x80\xa600000000000ClWrapping (modular) subtraction with an unsigned integer. \xe2\x80\xa600000000000fU+00170CaAn error indicating that no nul byte was present.000CdInvalid character in numeric escape (e.g. \xe2\x80\x98\\xz\xe2\x80\x99)CmRAII structure used to release the exclusive write access \xe2\x80\xa600Ba\xe2\x80\x98\\u\xe2\x80\x99 not followed by \xe2\x80\x98{\xe2\x80\x99.AjStale network file handle.AkSee <code>_mm_setcsr</code>0DhThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa \xe2\x80\xa60DhThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa \xe2\x80\xa6022Cl<strong>Index only</strong>: return the most significant bit0CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa60CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa60DfBroadcasts the low packed 8-bit integer from <code>a</code> to all \xe2\x80\xa60CkCasts vector of type __m128d to type __m256d; the upper \xe2\x80\xa60BmCasts vector of type __m256d to type __m128d.0EfCast vector of type <code>__m128h</code> to type <code>__m256h</code>. The upper 8 \xe2\x80\xa60DoCast vector of type <code>__m256h</code> to type <code>__m128h</code>. This \xe2\x80\xa60CmCasts vector of type __m128 to type __m256; the upper 128 \xe2\x80\xa60BkCasts vector of type __m256 to type __m128.0CkCasts vector of type __m128i to type __m256i; the upper \xe2\x80\xa60BmCasts vector of type __m256i to type __m128i.0CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa601100110011001100CkConvert packed single precision (32-bit) floating-point \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa60ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa60CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa60ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa60ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa60CjBlend packed 8-bit integers from a and b using control \xe2\x80\xa60CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000CkBroadcast 16-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa607766ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa60CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa60554433221100CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa60CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa60DiStores packed 32-bit integers from <code>a</code> into memory pointed \xe2\x80\xa60DiStores packed 64-bit integers from <code>a</code> into memory pointed \xe2\x80\xa60CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 32-bit \xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa60CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa60CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa60CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa60CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CnMove packed 16-bit integers from a into dst using zeromask \xe2\x80\xa60CnMove packed 32-bit integers from a into dst using zeromask \xe2\x80\xa60CnMove packed 64-bit integers from a into dst using zeromask \xe2\x80\xa60ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa60CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa60CiShift packed 16-bit integers in a left by count while \xe2\x80\xa60CiShift packed 32-bit integers in a left by count while \xe2\x80\xa60CiShift packed 64-bit integers in a left by count while \xe2\x80\xa60CjShift packed 16-bit integers in a right by count while \xe2\x80\xa60CjShift packed 32-bit integers in a right by count while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa60221100CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa60CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa60CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa60CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa60ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60ClShuffles 256 bits (composed of 4 packed double-precision \xe2\x80\xa60ClShuffles 256 bits (composed of 8 packed single-precision \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CnReduce the packed 8-bit integers in a by addition. Returns \xe2\x80\xa60CiReduce the packed 8-bit integers in a by bitwise AND. \xe2\x80\xa60CmReduce the packed 8-bit integers in a by maximum. Returns \xe2\x80\xa60CnReduce the packed unsigned 8-bit integers in a by maximum. \xe2\x80\xa60CmReduce the packed 8-bit integers in a by minimum. Returns \xe2\x80\xa60CnReduce the packed unsigned 8-bit integers in a by minimum. \xe2\x80\xa60ClReduce the packed 8-bit integers in a by multiplication. \xe2\x80\xa60CiReduce the packed 16-bit integers in a by bitwise OR. \xe2\x80\xa60CkShuffles 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CjShuffles 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa60CjReturns vector of type __m256i with with indeterminate \xe2\x80\xa60DkConstructs a 256-bit floating-point vector of <code>[4 x double]</code> \xe2\x80\xa60EfCast vector of type <code>__m256h</code> to type <code>__m128h</code>. The upper 8 \xe2\x80\xa60DjConstructs a 256-bit floating-point vector of <code>[8 x float]</code> \xe2\x80\xa60CnConstructs a 256-bit integer vector from a 128-bit integer \xe2\x80\xa60CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa60CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa60CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa60CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa60CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa60ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa60CnCast vector of type __m128d to type __m512d; the upper 384 \xe2\x80\xa60CnCast vector of type __m256d to type __m512d; the upper 256 \xe2\x80\xa60CeCast vector of type __m512d to type __m128d. This \xe2\x80\xa60CeCast vector of type __m512d to type __m256d. This \xe2\x80\xa60EgCast vector of type <code>__m128h</code> to type <code>__m512h</code>. The upper 24 \xe2\x80\xa60EgCast vector of type <code>__m256h</code> to type <code>__m512h</code>. The upper 16 \xe2\x80\xa60DoCast vector of type <code>__m512h</code> to type <code>__m128h</code>. This \xe2\x80\xa60DoCast vector of type <code>__m512h</code> to type <code>__m256h</code>. This \xe2\x80\xa60ClCast vector of type __m128 to type __m512; the upper 384 \xe2\x80\xa60ClCast vector of type __m256 to type __m512; the upper 256 \xe2\x80\xa60CmCast vector of type __m512 to type __m128. This intrinsic \xe2\x80\xa60CmCast vector of type __m512 to type __m256. This intrinsic \xe2\x80\xa60CnCast vector of type __m128i to type __m512i; the upper 384 \xe2\x80\xa60CnCast vector of type __m256i to type __m512i; the upper 256 \xe2\x80\xa60CeCast vector of type __m512i to type __m128i. This \xe2\x80\xa60CeCast vector of type __m512i to type __m256i. This \xe2\x80\xa60CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa601100110011001100ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa60ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa60CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa60CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa60ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa60ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60ClGather 32-bit integers from memory using 32-bit indices. \xe2\x80\xa60ClGather 64-bit integers from memory using 32-bit indices. \xe2\x80\xa60CnStores 8 double-precision (64-bit) floating-point elements \xe2\x80\xa60ClGather 32-bit integers from memory using 64-bit indices. \xe2\x80\xa60ClGather 64-bit integers from memory using 64-bit indices. \xe2\x80\xa60>>==<<;;==<<;;CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa60ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa60CjBlend packed 8-bit integers from a and b using control \xe2\x80\xa60CgPerforms an element-by-element conversion of packed \xe2\x80\xa60ClPerforms element-by-element conversion of the lower half \xe2\x80\xa60CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000CkBroadcast 16-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa607766ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa60CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa60554433221100CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa60CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa60CfCompute the absolute value of packed signed 16-bit \xe2\x80\xa60DjComputes the absolute value of packed 32-bit integers in <code>a</code>\xe2\x80\xa60CfCompute the absolute value of packed signed 64-bit \xe2\x80\xa60ChAdd packed 16-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 32-bit integers in a and b, and store the \xe2\x80\xa60ChAdd packed 64-bit integers in a and b, and store the \xe2\x80\xa60CeAdd packed signed 8-bit integers in a and b using \xe2\x80\xa60CgAdd packed unsigned 8-bit integers in a and b using \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CfCompute the bitwise NOT of packed double-precision \xe2\x80\xa60CfCompute the bitwise NOT of packed single-precision \xe2\x80\xa60CkAverage packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CnConverts packed BF16 (16-bit) floating-point elements in a \xe2\x80\xa60CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CmCompute dot-product of BF16 (16-bit) floating-point pairs \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ChConvert the exponent of each packed double-precision \xe2\x80\xa60CfConvert the exponent of each packed half-precision \xe2\x80\xa60ChConvert the exponent of each packed single-precision \xe2\x80\xa60CiCompare packed signed 16-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 32-bit integers in a and b, and \xe2\x80\xa60CiCompare packed signed 64-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 16-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 32-bit integers in a and b, and \xe2\x80\xa60CkCompare packed unsigned 64-bit integers in a and b, and \xe2\x80\xa60554433221100CnMove packed 16-bit integers from a into dst using zeromask \xe2\x80\xa60CnMove packed 32-bit integers from a into dst using zeromask \xe2\x80\xa60CnMove packed 64-bit integers from a into dst using zeromask \xe2\x80\xa60ClMultiply the low signed 32-bit integers from each packed \xe2\x80\xa60CnMultiply the low unsigned 32-bit integers from each packed \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjBroadcast 8-bit integer a to all elements of dst using \xe2\x80\xa60CiShift packed 16-bit integers in a left by count while \xe2\x80\xa60CiShift packed 32-bit integers in a left by count while \xe2\x80\xa60CiShift packed 64-bit integers in a left by count while \xe2\x80\xa60CjShift packed 16-bit integers in a right by count while \xe2\x80\xa60CjShift packed 32-bit integers in a right by count while \xe2\x80\xa60CjShift packed 64-bit integers in a right by count while \xe2\x80\xa60221100CkSubtract packed 16-bit integers in b from packed 16-bit \xe2\x80\xa60CkSubtract packed 32-bit integers in b from packed 32-bit \xe2\x80\xa60CkSubtract packed 64-bit integers in b from packed 64-bit \xe2\x80\xa60CjSubtract packed signed 8-bit integers in b from packed \xe2\x80\xa60ClSubtract packed unsigned 8-bit integers in b from packed \xe2\x80\xa60CnCompute the bitwise XOR of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise XOR of packed 64-bit integers in a and \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnShuffle half-precision (16-bit) floating-point elements in \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiReduce the packed 32-bit integers in a by bitwise OR. \xe2\x80\xa60CiReduce the packed 64-bit integers in a by bitwise OR. \xe2\x80\xa60CkExtract the reduced argument of packed double-precision \xe2\x80\xa60CiExtract the reduced argument of packed half-precision \xe2\x80\xa60CkExtract the reduced argument of packed single-precision \xe2\x80\xa60CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa60CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa60CnReturn vector of type __m512i with indeterminate elements. \xe2\x80\xa60CnCast vector of type __m128d to type __m512d; the upper 384 \xe2\x80\xa60CnCast vector of type __m256d to type __m512d; the upper 256 \xe2\x80\xa60EgCast vector of type <code>__m128h</code> to type <code>__m512h</code>. The upper 24 \xe2\x80\xa60EgCast vector of type <code>__m256h</code> to type <code>__m512h</code>. The upper 16 \xe2\x80\xa60ClCast vector of type __m128 to type __m512; the upper 384 \xe2\x80\xa60ClCast vector of type __m256 to type __m512; the upper 256 \xe2\x80\xa60CnCast vector of type __m128i to type __m512i; the upper 384 \xe2\x80\xa60CnCast vector of type __m256i to type __m512i; the upper 256 \xe2\x80\xa60ClDecrypt 10 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa60ClDecrypt 14 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa60ClEncrypt 10 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa60ClEncrypt 14 rounds of 8 groups of unsigned 8-bit integers \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa60CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa60ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa60CmSign extend packed 8-bit integers in the low 2 bytes of a \xe2\x80\xa60CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 2 \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CnStores 2 double-precision (64-bit) floating-point elements \xe2\x80\xa60CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa6011CnStores 2 single-precision (32-bit) floating-point elements \xe2\x80\xa60CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa60ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa60CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa60ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa60CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa60CiCompute the square root of the lower double-precision \xe2\x80\xa60CgCompute the square root of the lower half-precision \xe2\x80\xa60CiCompute the square root of the lower single-precision \xe2\x80\xa60CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa60CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa60CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa60ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa60CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa60CnConcatenate a and b into a 32-byte immediate result, shift \xe2\x80\xa6000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000000000002222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa6033CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa60CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa60CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa60CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa60ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa60CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa60221100C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa60C`Subtract the lower double-precision (64-bit) \xe2\x80\xa60CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Subtract the lower single-precision (32-bit) \xe2\x80\xa60CmLoads 2 double-precision (64-bit) floating-point elements \xe2\x80\xa60CmLoads 4 single-precision (32-bit) floating-point elements \xe2\x80\xa6011CmLoads 2 single-precision (32-bit) floating-point elements \xe2\x80\xa60CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60CiBitwise ternary logic that provides the capability to \xe2\x80\xa6000CnReturns the amount of time elapsed from another instant to \xe2\x80\xa6CkCheck if the post-condition <code>cond</code> has been met.0FkCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>self</code> to <code>dest</code>. The \xe2\x80\xa600000DjDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa610CjReturns a mutable reference to the inner value as type \xe2\x80\xa6D`Forwards to the method defined on the type <code>dyn Any</code>.ClForwards to the method defined on the type <code>Any</code>.12010DbReturns a reference to the inner value as type <code>dyn T</code>.120CjConverts with LLVM\xe2\x80\x99s fptoui/fptosi, which may return \xe2\x80\xa60DiIf set to <code>true</code>, prevent the \xe2\x80\x9clast write time\xe2\x80\x9d of the \xe2\x80\xa6ClConverts low half of the smaller lane vector to a larger \xe2\x80\xa600000CmLane-wise integer extended multiplication producing twice \xe2\x80\xa600000CkLoad eight 8-bit integers and sign extend each one to a \xe2\x80\xa600CkLoad eight 8-bit integers and zero extend each one to a \xe2\x80\xa600333333222222333333222222DjIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa610CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa60CjInserts a new element into the set in the gap that the \xe2\x80\xa601100DkReads contiguous elements from <code>slice</code>. Each element is read \xe2\x80\xa60DoCalculates <code>self</code> + <code>rhs</code> with a signed <code>rhs</code>.00000000000CaCalculates the quotient of Euclidean division \xe2\x80\xa600000000000000000000000BoOverflowing Euclidean remainder. Calculates \xe2\x80\xa60000DgCalculates the remainder <code>self.rem_euclid(rhs)</code> as if by \xe2\x80\xa6000010111110000010DnCalculates <code>self</code> - <code>rhs</code> with a signed <code>rhs</code>00000000000CnMoves all but the first of consecutive elements to the end \xe2\x80\xa60DhRemoves the current element from the <code>LinkedList</code> without \xe2\x80\xa60CkReorders the slice with a comparator function such that \xe2\x80\xa60CfExposes a vector of pointers as a vector of addresses.0BjSplits a string slice by ASCII whitespace.0CgDivides one mutable raw slice into two at an index, \xe2\x80\xa6CkDivides one mutable slice into two at an index, without \xe2\x80\xa610DeWhen true, sets the <code>STARTF_RUNFULLSCREEN</code> flag on the \xe2\x80\xa6DfConditionally write contiguous elements to <code>slice</code>. The \xe2\x80\xa60CiA variant optimized for invocation with a static test \xe2\x80\xa6ClConverts low half of the smaller lane vector to a larger \xe2\x80\xa600CmLane-wise integer extended multiplication producing twice \xe2\x80\xa600CkLoad eight 8-bit integers and zero extend each one to a \xe2\x80\xa600222111222111CfFloating-point complex multiply accumulate Arm\xe2\x80\x99s \xe2\x80\xa6000000000CmVector Compare Not in Ranges or Zero Index with Condition \xe2\x80\xa6CgVector Find Any Element Equal Index with Condition CodeCkVector Find Any Element Not Equal Index with Condition CodeBeVector Floating-Point Test Data ClassCmFloating-point fused Multiply-Add Long to accumulator (by \xe2\x80\xa6CdFloating-point fused Multiply-Subtract Long from \xe2\x80\xa6ChSigned saturating doubling multiply-add long Arm\xe2\x80\x99s \xe2\x80\xa60CmSigned saturating doubling multiply-subtract long Arm\xe2\x80\x99s \xe2\x80\xa60CdSigned saturating doubling multiply long Arm\xe2\x80\x99s \xe2\x80\xa60CgVector reinterpret cast operation Arm\xe2\x80\x99s documentation00000000000000000000000000000000000000000CkCreates a pointer with the given address and no provenance.0fU+001F0fU+001E0CnOut of bounds unicode character code, e.g. \xe2\x80\x98\\u{FFFFFF}\xe2\x80\x99\xe2\x80\xa6CnA wrapper around windows <code>ProcThreadAttributeList</code>.AkSee <code>_mm_setcsr</code>0000000BnSearch for the defined substring in the target0E`<strong>Index only</strong>: return the least significant bit <em>(Default)</em>0oNegates results0BhDo not negate results <em>(Default)</em>0CmReturn a pointer with the logical address tag offset by a \xe2\x80\xa6EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa6DgBroadcasts the low packed 32-bit integer from <code>a</code> to all \xe2\x80\xa60DgBroadcasts the low packed 64-bit integer from <code>a</code> to all \xe2\x80\xa60CjBroadcasts the low packed 16-bit integer from a to all \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa60CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6055ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60443322771100443322771100443322771100443322CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CnStores 8 32-bit integer elements from a to memory starting \xe2\x80\xa60CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa60CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa60CnStores 4 64-bit integer elements from a to memory starting \xe2\x80\xa60EcCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into \xe2\x80\xa60EeCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa60CkBlend packed 16-bit integers from a and b using control \xe2\x80\xa60CkBlend packed 32-bit integers from a and b using control \xe2\x80\xa60CkBlend packed 64-bit integers from a and b using control \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000000000022222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa60CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa601100CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa60ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa60CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa60CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa60EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CiStore packed 32-bit integers from a into memory using \xe2\x80\xa60CiStore packed 64-bit integers from a into memory using \xe2\x80\xa60ChStore packed 8-bit integers from a into memory using \xe2\x80\xa60CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa60CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa601100CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa60ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa60CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa607766ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa60CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa60554433221100CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa60CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa60CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60CgReduce the packed 16-bit integers in a by addition. \xe2\x80\xa60CjReduce the packed 16-bit integers in a by bitwise AND. \xe2\x80\xa60CnReduce the packed 16-bit integers in a by maximum. Returns \xe2\x80\xa60CfReduce the packed unsigned 16-bit integers in a by \xe2\x80\xa60CnReduce the packed 16-bit integers in a by minimum. Returns \xe2\x80\xa6011CmReduce the packed 16-bit integers in a by multiplication. \xe2\x80\xa60CnThis intrinsic is one of the two SHA512 message scheduling \xe2\x80\xa6000CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa60CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa60CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6055ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60443322771100443322771100443322771100443322CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CkScatter 32-bit integers from a into memory using 32-bit \xe2\x80\xa60CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa60CkScatter 32-bit integers from a into memory using 64-bit \xe2\x80\xa60CkScatter 64-bit integers from a into memory using 64-bit \xe2\x80\xa6077CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa60CkBlend packed 16-bit integers from a and b using control \xe2\x80\xa60CkBlend packed 32-bit integers from a and b using control \xe2\x80\xa60CkBlend packed 64-bit integers from a and b using control \xe2\x80\xa60??CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60??CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000000000022222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa60CmCopy a to tmp, then insert 256 bits (composed of 8 packed \xe2\x80\xa60CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa60CmCopy a to tmp, then insert 256 bits (composed of 4 packed \xe2\x80\xa6033221100CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa60ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa60CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa60CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa60EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CiStore packed 32-bit integers from a into memory using \xe2\x80\xa60CiStore packed 64-bit integers from a into memory using \xe2\x80\xa60ChStore packed 8-bit integers from a into memory using \xe2\x80\xa60CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa60CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa601100CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa60ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa60CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa60CgMultiply packed complex numbers in a by the complex \xe2\x80\xa60CfNormalize the mantissas of packed double-precision \xe2\x80\xa60CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa60CfNormalize the mantissas of packed single-precision \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa60CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa601100ClCompute the approximate reciprocal square root of packed \xe2\x80\xa6000CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa60CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa607766ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa60ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa60ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa60CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa60CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa60CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa60554433221100CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa60CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60CgReduce the packed 32-bit integers in a by addition. \xe2\x80\xa60CgReduce the packed 64-bit integers in a by addition. \xe2\x80\xa60CjReduce the packed 32-bit integers in a by bitwise AND. \xe2\x80\xa60CjReduce the packed 64-bit integers in a by bitwise AND. \xe2\x80\xa60CmReduce the packed signed 32-bit integers in a by maximum. \xe2\x80\xa60CmReduce the packed signed 64-bit integers in a by maximum. \xe2\x80\xa60CfReduce the packed unsigned 32-bit integers in a by \xe2\x80\xa60CfReduce the packed unsigned 64-bit integers in a by \xe2\x80\xa60CmReduce the packed signed 32-bit integers in a by minimum. \xe2\x80\xa60CmReduce the packed signed 64-bit integers in a by minimum. \xe2\x80\xa603322CmReduce the packed 32-bit integers in a by multiplication. \xe2\x80\xa60CmReduce the packed 64-bit integers in a by multiplication. \xe2\x80\xa60CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa60CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa60CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa60ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa6000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa60ClZero extend packed unsigned 16-bit integers in the low 4 \xe2\x80\xa60CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60221100ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000CmReduce the packed 8-bit integers in a by bitwise OR using \xe2\x80\xa60CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa60ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa60CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa60ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa60CmSign extend packed 8-bit integers in the low 2 bytes of a \xe2\x80\xa60CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in th elow 4 \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 2 \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa60ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa60CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa60ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa60CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa60CiCompute the square root of the lower double-precision \xe2\x80\xa60CgCompute the square root of the lower half-precision \xe2\x80\xa60CiCompute the square root of the lower single-precision \xe2\x80\xa60CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa60CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa60887766CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa60DcSplits the slice into a slice of <code>N</code>-element arrays, \xe2\x80\xa60CjCheck if the pre-condition <code>cond</code> has been met.0CiConversion of the two double-precision floating point \xe2\x80\xa600CdLane-wise conversion from integer to floating point.00000CiConversion of the two lower single-precision floating \xe2\x80\xa600DjIf set to <code>true</code>, prevent the \xe2\x80\x9clast access time\xe2\x80\x9d of the \xe2\x80\xa6CgConverts a slice of bytes to a string slice without \xe2\x80\xa60000DhReads from indices in <code>slice</code> to construct a SIMD vector. \xe2\x80\xa60BhReturns the current <code>0</code> flag.00CmConverts high half of the smaller lane vector to a larger \xe2\x80\xa600000CmLane-wise integer extended multiplication producing twice \xe2\x80\xa600000111111000000CkLoad four 16-bit integers and sign extend each one to a \xe2\x80\xa600CkLoad four 16-bit integers and zero extend each one to a \xe2\x80\xa600333333222222CjLoad two 32-bit integers and sign extend each one to a \xe2\x80\xa600CjLoad two 32-bit integers and zero extend each one to a \xe2\x80\xa600CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa60CjInserts a new element into the set in the gap that the \xe2\x80\xa601100DdConsumes the <code>Arc</code>, returning the wrapped pointer and \xe2\x80\xa6DnConsumes the <code>Weak&lt;T&gt;</code>, returning the wrapped pointer and \xe2\x80\xa6DjConsumes the <code>Box</code>, returning a wrapped raw pointer and the \xe2\x80\xa6DcConsumes the <code>Rc</code>, returning the wrapped pointer and \xe2\x80\xa6232102CcCheck for the presence of a CPU feature at runtime.0CnReturns whether the argument\xe2\x80\x99s value is statically known \xe2\x80\xa60111CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa600CjSaturating addition with an unsigned integer. Computes \xe2\x80\xa600000000000CmSaturating subtraction with an unsigned integer. Computes \xe2\x80\xa600000000000CaAdds elements within a vector from left to right.0CgMultiplies elements within a vector from left to right.0ClConstructs a new boxed slice with uninitialized contents \xe2\x80\xa6000CmConverts high half of the smaller lane vector to a larger \xe2\x80\xa600CmLane-wise integer extended multiplication producing twice \xe2\x80\xa600111000CkLoad four 16-bit integers and zero extend each one to a \xe2\x80\xa600222111CjLoad two 32-bit integers and zero extend each one to a \xe2\x80\xa600DjPerforms a volatile load from the <code>src</code> pointer The pointer \xe2\x80\xa60CfFloating-point complex multiply accumulate Arm\xe2\x80\x99s \xe2\x80\xa6000Das390x-specific 128-bit wide vector of two packed <code>i64</code>CjConverts an address back to a pointer, picking up some \xe2\x80\xa6CmConverts an address back to a mutable pointer, picking up \xe2\x80\xa6CgConverts an address back to a pointer, picking up a \xe2\x80\xa60210000fU+001C0CeZero-sized type used to mark a lifetime as covariant.0CeZero-sized type used to mark a lifetime as invariant.0Cluse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>0CmPerforms the last round of an AES decryption flow on each \xe2\x80\xa60CmPerforms the last round of an AES encryption flow on each \xe2\x80\xa60ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa60CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa60CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60DeExtracts 128 bits (composed of integer data) from <code>a</code>, \xe2\x80\xa60DiExtracts 128 bits (of integer data) from <code>a</code> selected with \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6011ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa601122CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa6000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000000000002222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa6033==<<CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa60CiStore packed 16-bit integers from a into memory using \xe2\x80\xa60CiStore packed 32-bit integers from a into memory using \xe2\x80\xa60CiStore packed 64-bit integers from a into memory using \xe2\x80\xa60CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000000000022222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa60CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa601100CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa60ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa60CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa60CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa60EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa60CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa601100EbPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.0DjShuffles eight 32-bit floating-point elements in <code>a</code> across \xe2\x80\xa60ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa60CjThis intrinsic performs two rounds of SHA512 operation \xe2\x80\xa60CnLoad 256-bits of integer data from memory into dst using a \xe2\x80\xa60CmPerforms the last round of an AES decryption flow on each \xe2\x80\xa60CmPerforms the last round of an AES encryption flow on each \xe2\x80\xa60ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa60CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa60CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa6000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60000000CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CkLoads 8 64-bit integer elements from memory starting at \xe2\x80\xa60112211332211CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa6000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa60<<>>>>>>>>============<<<<CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa60==CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa60ClGather double-precision (64-bit) floating-point elements \xe2\x80\xa60ClGather single-precision (32-bit) floating-point elements \xe2\x80\xa601100CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CnMultiplies elements in packed 64-bit integer vectors a and \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa60CiStore packed 16-bit integers from a into memory using \xe2\x80\xa60CiStore packed 32-bit integers from a into memory using \xe2\x80\xa60CiStore packed 64-bit integers from a into memory using \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa60CkContiguously store the active double-precision (64-bit) \xe2\x80\xa60CkContiguously store the active single-precision (32-bit) \xe2\x80\xa60ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa60000000000022222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa60CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa60CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa60ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa60ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60221100CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa60CmCopy a to tmp, then insert 256 bits (composed of 8 packed \xe2\x80\xa60CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa60CmCopy a to tmp, then insert 256 bits (composed of 4 packed \xe2\x80\xa6033221100CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa60CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa60CiCounts the number of leading zero bits in each packed \xe2\x80\xa6000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa60CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa60CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa60ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa60CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa60CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa60EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa60CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa60221100CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa60CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa60221100CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa60CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa601100ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa60CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa60CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa60CnLoad 512-bits of integer data from memory into dst using a \xe2\x80\xa60CmBroadcasts 128 bits of integer data from a to all 128-bit \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60221100CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa60CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa601100110011001100ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa60==<<;;==<<;;ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa60CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa60ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa60CkTest the lower double-precision (64-bit) floating-point \xe2\x80\xa60CiTest the lower half-precision (16-bit) floating-point \xe2\x80\xa60CkTest the lower single-precision (32-bit) floating-point \xe2\x80\xa60CfConvert the exponent of the lower double-precision \xe2\x80\xa60CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa60CfConvert the exponent of the lower single-precision \xe2\x80\xa60DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa60000000CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CkReduce the packed 8-bit integers in a by addition using \xe2\x80\xa60CnReduce the packed 8-bit integers in a by bitwise AND using \xe2\x80\xa60CjReduce the packed 8-bit integers in a by maximum using \xe2\x80\xa60CmReduce the packed unsigned 8-bit integers in a by maximum \xe2\x80\xa60CjReduce the packed 8-bit integers in a by minimum using \xe2\x80\xa60CmReduce the packed unsigned 8-bit integers in a by minimum \xe2\x80\xa60CkReduce the packed 8-bit integers in a by multiplication \xe2\x80\xa60CnReduce the packed 16-bit integers in a by bitwise OR using \xe2\x80\xa60CnExtract the reduced argument of the lower double-precision \xe2\x80\xa60ClExtract the reduced argument of the lower half-precision \xe2\x80\xa60CnExtract the reduced argument of the lower single-precision \xe2\x80\xa60CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6000CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa60CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa6000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa6000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa6000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa60ClZero extend packed unsigned 16-bit integers in the low 4 \xe2\x80\xa60CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60221100ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa6000ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa60CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa60CkAn atomic fence for synchronization within a single thread.0DjIf <code>rhs</code> is positive, calculates the smallest value greater \xe2\x80\xa60000DkCalculates the smallest value greater than or equal to <code>self</code>\xe2\x80\xa6000010111110000010FjCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>self</code>. The \xe2\x80\xa6000DfA relaxed version of <code>v128_bitselect</code> where this either \xe2\x80\xa600000000000CcCheck for the presence of a CPU feature at runtime.0EbCalculates <code>self</code> + <code>rhs</code> with an unsigned <code>rhs</code>.00000000000EbCalculates <code>self</code> - <code>rhs</code> with an unsigned <code>rhs</code>.00000000000CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa60000000CgPartially sorts the slice in ascending order with a \xe2\x80\xa60E`See documentation of <code>&lt;*const T&gt;::offset_from_unsigned</code> for \xe2\x80\xa60AoSignal a specific barrier type.ClWrites values from a SIMD vector to multiple potentially \xe2\x80\xa60CfSet the permissions of a file, unless it is a symlink.CfForms a raw mutable slice from a pointer and a length.0::::::::::::DjPerforms a volatile store to the <code>dst</code> pointer. The pointer \xe2\x80\xa60DjSame value as <code>self | other</code>, but UB if any bit position is \xe2\x80\xa600000000000CnVector Find Any Element Equal or Zero Index with Condition \xe2\x80\xa6ChVector Find Any Element Not Equal or Zero Index with \xe2\x80\xa6DeCreates an empty <code>HashMap</code> with at least the specified \xe2\x80\xa6DeCreates an empty <code>HashSet</code> with at least the specified \xe2\x80\xa6fU+001D0A`round to nearest0CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa60CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa60ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa60CmSign extend packed 8-bit integers in the low 4 bytes of a \xe2\x80\xa60CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CnStores 4 double-precision (64-bit) floating-point elements \xe2\x80\xa60CnStores 8 single-precision (32-bit) floating-point elements \xe2\x80\xa6011CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa60CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa60CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa60CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa60CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa60CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa60CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa6000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000000000002222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa6033CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa60CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa60CmLoads 4 double-precision (64-bit) floating-point elements \xe2\x80\xa60CmLoads 8 single-precision (32-bit) floating-point elements \xe2\x80\xa6011CmLoads 4 single-precision (32-bit) floating-point elements \xe2\x80\xa60ClShuffles 128-bits (composed of integer data) selected by \xe2\x80\xa60EgShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> \xe2\x80\xa60CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60CiBitwise ternary logic that provides the capability to \xe2\x80\xa6000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60000000CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa60ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa60ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa60CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa60CnStores 8 64-bit integer elements from a to memory starting \xe2\x80\xa60ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa60CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa6011001100ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60ClPerforms element-by-element conversion of the lower half \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa60CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa6044CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa6000CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CmScatter double-precision (64-bit) floating-point elements \xe2\x80\xa60CmScatter single-precision (32-bit) floating-point elements \xe2\x80\xa601100CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa60CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CnReduce the packed double-precision (64-bit) floating-point \xe2\x80\xa60CnReduce the packed single-precision (32-bit) floating-point \xe2\x80\xa60110011001100CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa60CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa60CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa60CfCompute the square root of packed double-precision \xe2\x80\xa60CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa60CfCompute the square root of packed single-precision \xe2\x80\xa60CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa60CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa60CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa60CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa60CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa60CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa6000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa60CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa60000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa6000000000002222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa6033CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa60ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa60CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa60CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa60CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa60CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa60CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa60221100ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa60CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa6011CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa60CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa60CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa60ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa60ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa60CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa60ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa60CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa60ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa60CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa60CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa60CiBitwise ternary logic that provides the capability to \xe2\x80\xa6000BgAssist in expanding the AES cipher key.0EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60221100CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa60CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa60ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa60CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa60CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa60CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa60CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa6055ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa60ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa60443322771100443322771100443322771100443322CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa60CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa6000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa60CiMultiply the lower complex number in a by the complex \xe2\x80\xa60CiNormalize the mantissas of the lower double-precision \xe2\x80\xa60CgNormalize the mantissas of the lower half-precision \xe2\x80\xa60CiNormalize the mantissas of the lower single-precision \xe2\x80\xa60CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa60CnStores 2 64-bit integer elements from a to memory starting \xe2\x80\xa60CnStores 2 32-bit integer elements from a to memory starting \xe2\x80\xa6011CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa60ClReduce the packed 16-bit integers in a by addition using \xe2\x80\xa60CiReduce the packed 16-bit integers in a by bitwise AND \xe2\x80\xa60CkReduce the packed 16-bit integers in a by maximum using \xe2\x80\xa60CnReduce the packed unsigned 16-bit integers in a by maximum \xe2\x80\xa60CkReduce the packed 16-bit integers in a by minimum using \xe2\x80\xa60CnReduce the packed unsigned 16-bit integers in a by minimum \xe2\x80\xa60ClReduce the packed 16-bit integers in a by multiplication \xe2\x80\xa60CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa60CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa60CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa60ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa60ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa60ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa6000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa60CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa60CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa60C`Multiply the lower double-precision (64-bit) \xe2\x80\xa60CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa60C`Multiply the lower single-precision (32-bit) \xe2\x80\xa60221100CfConvert the exponent of the lower double-precision \xe2\x80\xa60CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa60CfConvert the exponent of the lower single-precision \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CnExtract the reduced argument of the lower double-precision \xe2\x80\xa60ClExtract the reduced argument of the lower half-precision \xe2\x80\xa60CnExtract the reduced argument of the lower single-precision \xe2\x80\xa60CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa60CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa6000CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa60CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa60CkLoads 4 32-bit integer elements from memory starting at \xe2\x80\xa60CkLoads 2 64-bit integer elements from memory starting at \xe2\x80\xa60CkLoads 2 32-bit integer elements from memory starting at \xe2\x80\xa6011CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa60CkCalculates the distance between two pointers within the \xe2\x80\xa600000CnReturns the smallest power of two greater than or equal to \xe2\x80\xa600000000000000000000000DjDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa610CkConverts a boxed slice of bytes to a boxed string slice \xe2\x80\xa60BgCreates a layout, bypassing all checks.00DkA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the \xe2\x80\xa600DjIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa610DcDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: \xe2\x80\xa60CcCheck for the presence of a CPU feature at runtime.000D`Prefetch the cache line containing <code>ptr</code> into the \xe2\x80\xa6DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa610ChGet the index of the current wavefront in the workgroup.CnReturns the amount of time elapsed from another instant to \xe2\x80\xa6CjSaturating computation of time elapsed from an earlier \xe2\x80\xa6CnAdds elements within a vector in arbitrary order. May also \xe2\x80\xa60CkMultiplies elements within a vector in arbitrary order. \xe2\x80\xa60CfNon-overlapping <em>typed</em> swap of a single value.0DkA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the \xe2\x80\xa600Das390x-specific 128-bit wide vector of two packed <code>u64</code>BfNon-hexadecimal value in \xe2\x80\x98\\u{..}\xe2\x80\x99.ClInvalid in-bound unicode character code, e.g. \xe2\x80\x98\\u{DFFF}\xe2\x80\xa6CmAfter a line ending with \xe2\x80\x99&#39;, the next line contains \xe2\x80\xa6Cg<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>0CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa60CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa60CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa60ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa60ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa60CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa60CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa60CmTest each 32-bit element of a for equality with all other \xe2\x80\xa60CmTest each 64-bit element of a for equality with all other \xe2\x80\xa60CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa60ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa60ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa60ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa60CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa60ClZero extend packed unsigned 16-bit integers in the low 8 \xe2\x80\xa60CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa60CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa60CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa60CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa6000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CmReduce the packed 8-bit integers in a by bitwise OR using \xe2\x80\xa60CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa60ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa60ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa60CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa60CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa60ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa60CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa60CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa60CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa60CmSign extend packed 8-bit integers in the low 4 bytes of a \xe2\x80\xa60CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa60CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa60CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa60ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa60CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa60CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa60CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa60CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa60CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa60CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa60CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa60CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa60CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa60CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa60CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa60CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa60CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa60CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa60CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa60CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa60CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa6")