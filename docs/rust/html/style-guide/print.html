<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Style Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-7ef70756.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-86a258df.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Style Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/style-guide/" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="rust-style-guide"><a class="header" href="#rust-style-guide">Rust Style Guide</a></h1>
<h2 id="motivation---why-use-a-formatting-tool"><a class="header" href="#motivation---why-use-a-formatting-tool">Motivation - why use a formatting tool?</a></h2>
<p>Formatting code is a mostly mechanical task which takes both time and mental
effort. By using an automatic formatting tool, a programmer is relieved of
this task and can concentrate on more important things.</p>
<p>Furthermore, by sticking to an established style guide (such as this one),
programmers don’t need to formulate ad hoc style rules, nor do they need to
debate with other programmers what style rules should be used, saving time,
communication overhead, and mental energy.</p>
<p>Humans comprehend information through pattern matching. By ensuring that all
Rust code has similar formatting, less mental effort is required to comprehend a
new project, lowering the barrier to entry for new developers.</p>
<p>Thus, there are productivity benefits to using a formatting tool (such as
<code>rustfmt</code>), and even larger benefits by using a community-consistent
formatting, typically by using a formatting tool’s default settings.</p>
<h2 id="the-default-rust-style"><a class="header" href="#the-default-rust-style">The default Rust style</a></h2>
<p>The Rust Style Guide defines the default Rust style, and <em>recommends</em> that
developers and tools follow the default Rust style. Tools such as <code>rustfmt</code> use
the style guide as a reference for the default style. Everything in this style
guide, whether or not it uses language such as “must” or the imperative mood
such as “insert a space …” or “break the line after …”, refers to the
default style.</p>
<p>This should not be interpreted as forbidding developers from following a
non-default style, or forbidding tools from adding any particular configuration
options.</p>
<h2 id="bugs"><a class="header" href="#bugs">Bugs</a></h2>
<p>If the style guide differs from rustfmt, that may represent a bug in rustfmt,
or a bug in the style guide; either way, please report it to the style team or
the rustfmt team or both, for investigation and fix.</p>
<p>If implementing a new formatting tool based on the style guide and default Rust
style, please test it on the corpus of existing Rust code, and avoid causing
widespread breakage. The implementation and testing of such a tool may surface
bugs in either the style guide or rustfmt, as well as bugs in the tool itself.</p>
<p>We typically resolve bugs in a fashion that avoids widespread breakage.</p>
<h2 id="formatting-conventions"><a class="header" href="#formatting-conventions">Formatting conventions</a></h2>
<h3 id="indentation-and-line-width"><a class="header" href="#indentation-and-line-width">Indentation and line width</a></h3>
<ul>
<li>Use spaces, not tabs.</li>
<li>Each level of indentation must be 4 spaces (that is, all indentation
outside of string literals and comments must be a multiple of 4).</li>
<li>The maximum width for a line is 100 characters.</li>
</ul>
<h4 id="block-indent"><a class="header" href="#block-indent">Block indent</a></h4>
<p>Prefer block indent over visual indent:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Block indent
a_function_call(
    foo,
    bar,
);

// Visual indent
a_function_call(foo,
                bar);
<span class="boring">}</span></code></pre>
<p>This makes for smaller diffs (e.g., if <code>a_function_call</code> is renamed in the above
example) and less rightward drift.</p>
<h3 id="trailing-commas"><a class="header" href="#trailing-commas">Trailing commas</a></h3>
<p>In comma-separated lists of any kind, use a trailing comma when followed by a
newline:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>function_call(
    argument,
    another_argument,
);

let array = [
    element,
    another_element,
    yet_another_element,
];
<span class="boring">}</span></code></pre>
<p>This makes moving code (e.g., by copy and paste) easier, and makes diffs
smaller, as appending or removing items does not require modifying another line
to add or remove a comma.</p>
<h3 id="blank-lines"><a class="header" href="#blank-lines">Blank lines</a></h3>
<p>Separate items and statements by either zero or one blank lines (i.e., one or
two newlines). E.g,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = ...;

    let y = ...;
    let z = ...;
}

fn bar() {}
fn baz() {}
<span class="boring">}</span></code></pre>
<h3 id="trailing-whitespace"><a class="header" href="#trailing-whitespace">Trailing whitespace</a></h3>
<p>Do not include trailing whitespace on the end of any line. This includes blank
lines, comment lines, code lines, and string literals.</p>
<p>Note that avoiding trailing whitespace in string literals requires care to
preserve the value of the literal.</p>
<h3 id="sorting"><a class="header" href="#sorting">Sorting</a></h3>
<p>In various cases, the default Rust style specifies to sort things. If not
otherwise specified, such sorting should be “version sorting”, which ensures
that (for instance) <code>x8</code> comes before <code>x16</code> even though the character <code>1</code> comes
before the character <code>8</code>.</p>
<p>For the purposes of the Rust style, to compare two strings for version-sorting:</p>
<ul>
<li>Process both strings from beginning to end as two sequences of maximal-length
chunks, where each chunk consists either of a sequence of characters other
than ASCII digits, or a sequence of ASCII digits (a numeric chunk), and
compare corresponding chunks from the strings.</li>
<li>To compare two numeric chunks, compare them by numeric value, ignoring
leading zeroes. If the two chunks have equal numeric value, but different
numbers of leading digits, and this is the first time this has happened for
these strings, treat the chunks as equal (moving on to the next chunk) but
remember which string had more leading zeroes.</li>
<li>To compare two chunks if both are not numeric, compare them by Unicode
character lexicographically, with two exceptions:
<ul>
<li><code>_</code> (underscore) sorts immediately after <code> </code> (space) but before any other
character. (This treats underscore as a word separator, as commonly used in
identifiers.)</li>
<li>Unless otherwise specified, version-sorting should sort non-lowercase
characters (characters that can start an <code>UpperCamelCase</code> identifier)
before lowercase characters.</li>
</ul>
</li>
<li>If the comparison reaches the end of the string and considers each pair of
chunks equal:
<ul>
<li>If one of the numeric comparisons noted the earliest point at which one
string had more leading zeroes than the other, sort the string with more
leading zeroes first.</li>
<li>Otherwise, the strings are equal.</li>
</ul>
</li>
</ul>
<p>Note that there exist various algorithms called “version sorting”, which
generally try to solve the same problem, but which differ in various ways (such
as in their handling of numbers with leading zeroes). This algorithm
does not purport to precisely match the behavior of any particular other
algorithm, only to produce a simple and satisfying result for Rust formatting.
In particular, this algorithm aims to produce a satisfying result for a set of
symbols that have the same number of leading zeroes, and an acceptable and
easily understandable result for a set of symbols that has varying numbers of
leading zeroes.</p>
<p>As an example, version-sorting will sort the following strings in the order
given:</p>
<ul>
<li><code>_ZYXW</code></li>
<li><code>_abcd</code></li>
<li><code>A2</code></li>
<li><code>ABCD</code></li>
<li><code>Z_YXW</code></li>
<li><code>ZY_XW</code></li>
<li><code>ZY_XW</code></li>
<li><code>ZYXW</code></li>
<li><code>ZYXW_</code></li>
<li><code>a1</code></li>
<li><code>abcd</code></li>
<li><code>u_zzz</code></li>
<li><code>u8</code></li>
<li><code>u16</code></li>
<li><code>u32</code></li>
<li><code>u64</code></li>
<li><code>u128</code></li>
<li><code>u256</code></li>
<li><code>ua</code></li>
<li><code>usize</code></li>
<li><code>uz</code></li>
<li><code>v000</code></li>
<li><code>v00</code></li>
<li><code>v0</code></li>
<li><code>v0s</code></li>
<li><code>v00t</code></li>
<li><code>v0u</code></li>
<li><code>v001</code></li>
<li><code>v01</code></li>
<li><code>v1</code></li>
<li><code>v009</code></li>
<li><code>v09</code></li>
<li><code>v9</code></li>
<li><code>v010</code></li>
<li><code>v10</code></li>
<li><code>w005s09t</code></li>
<li><code>w5s009t</code></li>
<li><code>x64</code></li>
<li><code>x86</code></li>
<li><code>x86_32</code></li>
<li><code>x86_64</code></li>
<li><code>x86_128</code></li>
<li><code>x87</code></li>
<li><code>zyxw</code></li>
</ul>
<h3 id="module-level-items"><a class="header" href="#module-level-items"><a href="#items">Module-level items</a></a></h3>
<h3 id="statements"><a class="header" href="#statements"><a href="#statements-1">Statements</a></a></h3>
<h3 id="expressions"><a class="header" href="#expressions"><a href="#expressions-1">Expressions</a></a></h3>
<h3 id="types"><a class="header" href="#types"><a href="#types-and-bounds">Types</a></a></h3>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>The following guidelines for comments are recommendations only, a mechanical
formatter might skip formatting of comments.</p>
<p>Prefer line comments (<code>//</code>) to block comments (<code>/* ... */</code>).</p>
<p>When using line comments, put a single space after the opening sigil.</p>
<p>When using single-line block comments, put a single space after the opening
sigil and before the closing sigil. For multi-line block comments, put a
newline after the opening sigil, and a newline before the closing sigil.</p>
<p>Prefer to put a comment on its own line. Where a comment follows code, put a
single space before it. Where a block comment appears inline, use surrounding
whitespace as if it were an identifier or keyword.</p>
<p>Examples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A comment on an item.
struct Foo { ... }

fn foo() {} // A comment after an item.

pub fn foo(/* a comment before an argument */ x: T) {...}
<span class="boring">}</span></code></pre>
<p>Comments should usually be complete sentences. Start with a capital letter, end
with a period (<code>.</code>). An inline block comment may be treated as a note without
punctuation.</p>
<p>Source lines which are entirely a comment should be limited to 80 characters
in length (including comment sigils, but excluding indentation) or the maximum
width of the line (including comment sigils and indentation), whichever is
smaller:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This comment goes up to the ................................. 80 char margin.

{
    // This comment is .............................................. 80 chars wide.
}

{
    {
        {
            {
                {
                    {
                        // This comment is limited by the ......................... 100 char margin.
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h4 id="doc-comments"><a class="header" href="#doc-comments">Doc comments</a></h4>
<p>Prefer line comments (<code>///</code>) to block comments (<code>/** ... */</code>).</p>
<p>Prefer outer doc comments (<code>///</code> or <code>/** ... */</code>), only use inner doc comments
(<code>//!</code> and <code>/*! ... */</code>) to write module-level or crate-level documentation.</p>
<p>Put doc comments before attributes.</p>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Put each attribute on its own line, indented to the level of the item.
In the case of inner attributes (<code>#!</code>), indent it to the level of the inside of
the item. Prefer outer attributes, where possible.</p>
<p>For attributes with argument lists, format like functions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
#[foo(foo, bar)]
#[long_multi_line_attribute(
    split,
    across,
    lines,
)]
struct CRepr {
    #![repr(C)]
    x: f32,
    y: f32,
}
<span class="boring">}</span></code></pre>
<p>For attributes with an equal sign, put a single space before and after the <code>=</code>,
e.g., <code>#[foo = 42]</code>.</p>
<p>There must only be a single <code>derive</code> attribute. Note for tool authors: if
combining multiple <code>derive</code> attributes into a single attribute, the ordering of
the derived names must generally be preserved for correctness:
<code>#[derive(Foo)] #[derive(Bar)] struct Baz;</code> must be formatted to
<code>#[derive(Foo, Bar)] struct Baz;</code>.</p>
<h3 id="small-items"><a class="header" href="#small-items"><em>small</em> items</a></h3>
<p>In many places in this guide we specify formatting that depends on a code
construct being <em>small</em>. For example, single-line vs multi-line struct
literals:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Normal formatting
Foo {
    f1: an_expression,
    f2: another_expression(),
}

// "small" formatting
Foo { f1, f2 }
<span class="boring">}</span></code></pre>
<p>We leave it to individual tools to decide on exactly what <em>small</em> means. In
particular, tools are free to use different definitions in different
circumstances.</p>
<p>Some suitable heuristics are the size of the item (in characters) or the
complexity of an item (for example, that all components must be simple names,
not more complex sub-expressions). For more discussion on suitable heuristics,
see <a href="https://github.com/rust-lang-nursery/fmt-rfcs/issues/47">this issue</a>.</p>
<h2 id="non-formatting-conventions"><a class="header" href="#non-formatting-conventions"><a href="#other-style-advice">Non-formatting conventions</a></a></h2>
<h2 id="cargotoml-conventions"><a class="header" href="#cargotoml-conventions"><a href="#cargotoml-conventions-1">Cargo.toml conventions</a></a></h2>
<h2 id="principles-used-for-deciding-these-guidelines"><a class="header" href="#principles-used-for-deciding-these-guidelines"><a href="#guiding-principles-and-rationale">Principles used for deciding these guidelines</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="items"><a class="header" href="#items">Items</a></h1>
<p>Items consist of the set of things permitted at the top level of a module.
However, Rust also allows some items to appear within some other types of
items, such as within a function. The same formatting conventions apply whether
an item appears at module level or within another item.</p>
<p><code>extern crate</code> statements must be first in a file. They must be ordered
alphabetically.</p>
<p><code>use</code> statements, and module <em>declarations</em> (<code>mod foo;</code>, not <code>mod { ... }</code>)
must come before other items. Put imports before module declarations.
Version-sort each, except that <code>self</code> and <code>super</code> must come before any other
names.</p>
<p>Don’t automatically move module declarations annotated with <code>#[macro_use]</code>,
since that might change semantics.</p>
<h2 id="function-definitions"><a class="header" href="#function-definitions">Function definitions</a></h2>
<p>In Rust, people often find functions by searching for <code>fn [function-name]</code>, so
the formatting of function definitions must enable this.</p>
<p>The proper ordering and spacing is:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[pub] [unsafe] [extern ["ABI"]] fn foo(arg1: i32, arg2: i32) -&gt; i32 {
    ...
}
<span class="boring">}</span></code></pre>
<p>Avoid comments within the signature itself.</p>
<p>If the function signature does not fit on one line, then break after the opening
parenthesis and before the closing parenthesis and put each argument on its own
block-indented line. For example,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(
    arg1: i32,
    arg2: i32,
) -&gt; i32 {
    ...
}
<span class="boring">}</span></code></pre>
<p>Note the trailing comma on the last argument.</p>
<h2 id="tuples-and-tuple-structs"><a class="header" href="#tuples-and-tuple-structs">Tuples and tuple structs</a></h2>
<p>Write the type list as you would a parameter list to a function.</p>
<p>Build a tuple or tuple struct as you would call a function.</p>
<h3 id="single-line"><a class="header" href="#single-line">Single-line</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar(Type1, Type2);

let x = Bar(11, 22);
let y = (11, 22, 33);
<span class="boring">}</span></code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>In the declaration, put each variant on its own line, block indented.</p>
<p>Format each variant accordingly as either a struct (but without the <code>struct</code>
keyword), a tuple struct, or an identifier (which doesn’t require special
formatting):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FooBar {
    First(u32),
    Second,
    Error {
        err: Box&lt;Error&gt;,
        line: u32,
    },
}
<span class="boring">}</span></code></pre>
<p>If a struct variant is <a href="#small-items"><em>small</em></a>, format it on one
line. In this case, do not use a trailing comma for the field list, but do put
spaces around each brace:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FooBar {
    Error { err: Box&lt;Error&gt;, line: u32 },
}
<span class="boring">}</span></code></pre>
<p>In an enum with multiple struct variants, if any struct variant is written on
multiple lines, use the multi-line formatting for all struct variants. However,
such a situation might be an indication that you should factor out the fields
of the variant into their own struct.</p>
<h2 id="structs-and-unions"><a class="header" href="#structs-and-unions">Structs and Unions</a></h2>
<p>Struct names follow on the same line as the <code>struct</code> keyword, with the opening
brace on the same line when it fits within the right margin. All struct fields
are indented once and end with a trailing comma. The closing brace is not
indented and appears on its own line.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: A,
    b: B,
}
<span class="boring">}</span></code></pre>
<p>If and only if the type of a field does not fit within the right margin, it is
pulled down to its own line and indented again.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: A,
    long_name:
        LongType,
}
<span class="boring">}</span></code></pre>
<p>Prefer using a unit struct (e.g., <code>struct Foo;</code>) to an empty struct (e.g.,
<code>struct Foo();</code> or <code>struct Foo {}</code>, these only exist to simplify code
generation), but if you must use an empty struct, keep it on one line with no
space between the braces: <code>struct Foo();</code> or <code>struct Foo {}</code>.</p>
<p>The same guidelines are used for untagged union declarations.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union Foo {
    a: A,
    b: B,
    long_name:
        LongType,
}
<span class="boring">}</span></code></pre>
<h2 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple structs</a></h2>
<p>Put the whole struct on one line if possible. Separate types within the
parentheses using a comma and space. Don’t use a trailing comma for a
single-line tuple struct. Don’t put spaces around the parentheses or semicolon:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo(String, u8);
<span class="boring">}</span></code></pre>
<p>Prefer unit structs to empty tuple structs (these only exist to simplify code
generation), e.g., <code>struct Foo;</code> rather than <code>struct Foo();</code>.</p>
<p>For more than a few fields (in particular if the tuple struct does not fit on
one line), prefer a proper struct with named fields.</p>
<p>For a multi-line tuple struct, block-format the fields with a field on each
line and a trailing comma:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo(
    String,
    u8,
);
<span class="boring">}</span></code></pre>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Use block-indent for trait items. If there are no items, format the trait (including its <code>{}</code>)
on a single line. Otherwise, break after the opening brace and before
the closing brace:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

pub trait Bar {
    ...
}
<span class="boring">}</span></code></pre>
<p>If the trait has bounds, put a space after the colon but not before,
and put spaces around each <code>+</code>, e.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo: Debug + Bar {}
<span class="boring">}</span></code></pre>
<p>Prefer not to line-break in the bounds if possible (consider using a <code>where</code>
clause). Prefer to break between bounds than to break any individual bound. If
you must break the bounds, put each bound (including the first) on its own
block-indented line, break before the <code>+</code> and put the opening brace on its own
line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IndexRanges:
    Index&lt;Range&lt;usize&gt;, Output=Self&gt;
    + Index&lt;RangeTo&lt;usize&gt;, Output=Self&gt;
    + Index&lt;RangeFrom&lt;usize&gt;, Output=Self&gt;
    + Index&lt;RangeFull, Output=Self&gt;
{
    ...
}
<span class="boring">}</span></code></pre>
<h2 id="impls"><a class="header" href="#impls">Impls</a></h2>
<p>Use block-indent for impl items. If there are no items, format the impl
(including its <code>{}</code>) on a single line. Otherwise, break after the opening brace
and before the closing brace:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {}

impl Bar for Foo {
    ...
}
<span class="boring">}</span></code></pre>
<p>Avoid line-breaking in the signature if possible. If a line break is required in
a non-inherent impl, break immediately before <code>for</code>, block indent the concrete type
and put the opening brace on its own line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Bar
    for Foo
{
    ...
}
<span class="boring">}</span></code></pre>
<h2 id="extern-crate"><a class="header" href="#extern-crate">Extern crate</a></h2>
<p><code>extern crate foo;</code></p>
<p>Use spaces around keywords, no spaces around the semicolon.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
}
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo;
<span class="boring">}</span></code></pre>
<p>Use spaces around keywords and before the opening brace, no spaces around the
semicolon.</p>
<h2 id="macro_rules"><a class="header" href="#macro_rules"><code>macro_rules!</code></a></h2>
<p>Use <code>{}</code> for the full definition of the macro.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
}
<span class="boring">}</span></code></pre>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Prefer to put a generics clause on one line. Break other parts of an item
declaration rather than line-breaking a generics clause. If a generics clause is
large enough to require line-breaking, prefer a <code>where</code> clause instead.</p>
<p>Do not put spaces before or after <code>&lt;</code> nor before <code>&gt;</code>. Only put a space after
<code>&gt;</code> if it is followed by a word or opening brace, not an opening parenthesis.
Put a space after each comma. Do not use a trailing comma for a single-line
generics clause.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Display, U: Debug&gt;(x: Vec&lt;T&gt;, y: Vec&lt;U&gt;) ...

impl&lt;T: Display, U: Debug&gt; SomeType&lt;T, U&gt; { ...
<span class="boring">}</span></code></pre>
<p>If the generics clause must be formatted across multiple lines, put each
parameter on its own block-indented line, break after the opening <code>&lt;</code> and
before the closing <code>&gt;</code>, and use a trailing comma.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;
    T: Display,
    U: Debug,
&gt;(x: Vec&lt;T&gt;, y: Vec&lt;U&gt;) ...
<span class="boring">}</span></code></pre>
<p>If an associated type is bound in a generic type, put spaces around the <code>=</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;T: Example&lt;Item = u32&gt;&gt;
<span class="boring">}</span></code></pre>
<p>Prefer to use single-letter names for generic parameters.</p>
<h2 id="where-clauses"><a class="header" href="#where-clauses"><code>where</code> clauses</a></h2>
<p>These rules apply for <code>where</code> clauses on any item.</p>
<p>If immediately following a closing bracket of any kind, write the keyword
<code>where</code> on the same line, with a space before it.</p>
<p>Otherwise, put <code>where</code> on a new line at the same indentation level. Put each
component of a <code>where</code> clause on its own line, block-indented. Use a trailing
comma, unless the clause is terminated with a semicolon. If the <code>where</code> clause
is followed by a block (or assignment), start that block on a new line.
Examples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T, U&gt;(args)
where
    T: Bound,
    U: AnotherBound,
{
    body
}

fn foo&lt;T&gt;(
    args
) -&gt; ReturnType
where
    T: Bound,
{
    body
}

fn foo&lt;T, U&gt;(
    args,
) where
    T: Bound,
    U: AnotherBound,
{
    body
}

fn foo&lt;T, U&gt;(
    args
) -&gt; ReturnType
where
    T: Bound,
    U: AnotherBound;  // Note, no trailing comma.

// Note that where clauses on `type` aliases are not enforced and should not
// be used.
type Foo&lt;T&gt;
where
    T: Bound
= Bar&lt;T&gt;;
<span class="boring">}</span></code></pre>
<p>If a <code>where</code> clause is very short, prefer using an inline bound on the type
parameter.</p>
<p>If a component of a <code>where</code> clause does not fit and contains <code>+</code>, break it
before each <code>+</code> and block-indent the continuation lines. Put each bound on its
own line. E.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized, Idx&gt; IndexRanges&lt;Idx&gt; for T
where
    T: Index&lt;Range&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeTo&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeFrom&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeInclusive&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeToInclusive&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeFull&gt;,
<span class="boring">}</span></code></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h2>
<p>Keep type aliases on one line when they fit. If necessary to break the line, do
so before the <code>=</code>, and block-indent the right-hand side:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Foo = Bar&lt;T&gt;;

// If multi-line is required
type VeryLongType&lt;T, U: SomeBound&gt;
    = AnEvenLongerType&lt;T, U, Foo&lt;T&gt;&gt;;
<span class="boring">}</span></code></pre>
<p>When there is a trailing <code>where</code> clause after the type, and no <code>where</code> clause
present before the type, break before the <code>=</code> and indent. Then break before the
<code>where</code> keyword and format the clauses normally, e.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// With only a trailing where clause
type VeryLongType&lt;T, U&gt;
    = AnEvenLongerType&lt;T, U, Foo&lt;T&gt;&gt;
where
    T: U::AnAssociatedType,
    U: SomeBound;
<span class="boring">}</span></code></pre>
<p>When there is a <code>where</code> clause before the type, format it normally, and break
after the last clause. Do not indent before the <code>=</code> to leave it visually
distinct from the indented clauses that precede it. If there is additionally a
<code>where</code> clause after the type, break before the <code>where</code> keyword and format the
clauses normally.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// With only a preceding where clause.
type WithPrecedingWC&lt;T, U&gt;
where
    T: U::AnAssociatedType,
    U: SomeBound,
= AnEvenLongerType&lt;T, U, Foo&lt;T&gt;&gt;;

// Or with both a preceding and trailing where clause.
type WithPrecedingWC&lt;T, U&gt;
where
    T: U::AnAssociatedType,
    U: SomeBound,
= AnEvenLongerType&lt;T, U, Foo&lt;T&gt;&gt;
where
    T: U::AnAssociatedType2,
    U: SomeBound2;
<span class="boring">}</span></code></pre>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h2>
<p>Format associated types like type aliases. Where an associated type has a
bound, put a space after the colon but not before:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Foo: Bar;
<span class="boring">}</span></code></pre>
<h2 id="extern-items"><a class="header" href="#extern-items">extern items</a></h2>
<p>When writing extern items (such as <code>extern "C" fn</code>), always specify the ABI.
For example, write <code>extern "C" fn foo ...</code> or <code>unsafe extern "C" { ...}</code>
and avoid <code>extern fn foo ...</code> and <code>unsafe extern { ... }</code>.</p>
<h2 id="imports-use-statements"><a class="header" href="#imports-use-statements">Imports (<code>use</code> statements)</a></h2>
<p>Format imports on one line where possible. Don’t put spaces around braces.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use a::b::c;
use a::b::d::*;
use a::b::{foo, bar, baz};
<span class="boring">}</span></code></pre>
<h3 id="large-list-imports"><a class="header" href="#large-list-imports">Large list imports</a></h3>
<p>Prefer to use multiple imports rather than a multi-line import. However, tools
should not split imports by default.</p>
<p>If an import does require multiple lines (either because a list of single names
does not fit within the max width, or because of the rules for nested imports
below), then break after the opening brace and before the closing brace, use a
trailing comma, and block indent the names.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefer
foo::{long, list, of, imports};
foo::{more, imports};

// If necessary
foo::{
    long, list, of, imports, more,
    imports,  // Note trailing comma
};
<span class="boring">}</span></code></pre>
<h3 id="ordering-of-imports"><a class="header" href="#ordering-of-imports">Ordering of imports</a></h3>
<p>A <em>group</em> of imports is a set of imports on the same or sequential lines. One or
more blank lines or other items (e.g., a function) separate groups of imports.</p>
<p>Within a group of imports, imports must be version-sorted. Groups of imports
must not be merged or re-ordered.</p>
<p>E.g., input:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use d;
use c;

use b;
use a;
<span class="boring">}</span></code></pre>
<p>output:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use c;
use d;

use a;
use b;
<span class="boring">}</span></code></pre>
<p>Because of <code>macro_use</code>, attributes must also start a new group and prevent
re-ordering.</p>
<h3 id="ordering-list-import"><a class="header" href="#ordering-list-import">Ordering list import</a></h3>
<p>Names in a list import must be version-sorted, except that:</p>
<ul>
<li><code>self</code> and <code>super</code> always come first if present, and</li>
<li>groups and glob imports always come last if present.</li>
</ul>
<p>This applies recursively. For example, <code>a::*</code> comes before <code>b::a</code> but <code>a::b</code>
comes before <code>a::*</code>. E.g., <code>use foo::bar::{a, b::c, b::d, b::d::{x, y, z}, b::{self, r, s}};</code>.</p>
<h3 id="normalisation"><a class="header" href="#normalisation">Normalisation</a></h3>
<p>Tools must make the following normalisations, recursively:</p>
<ul>
<li><code>use a::self;</code> -&gt; <code>use a;</code></li>
<li><code>use a::{};</code> -&gt; (nothing)</li>
<li><code>use a::{b};</code> -&gt; <code>use a::b;</code></li>
</ul>
<p>Tools must not otherwise merge or un-merge import lists or adjust glob imports
(without an explicit option).</p>
<h3 id="nested-imports"><a class="header" href="#nested-imports">Nested imports</a></h3>
<p>If there are any nested imports in a list import, then use the multi-line form,
even if the import fits on one line. Each nested import must be on its own line,
but non-nested imports must be grouped on as few lines as possible.</p>
<p>For example,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use a::b::{
    x, y, z,
    u::{...},
    w::{...},
};
<span class="boring">}</span></code></pre>
<h3 id="mergingun-merging-imports"><a class="header" href="#mergingun-merging-imports">Merging/un-merging imports</a></h3>
<p>An example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Un-merged
use a::b;
use a::c::d;

// Merged
use a::{b, c::d};
<span class="boring">}</span></code></pre>
<p>Tools must not merge or un-merge imports by default. They may offer merging or
un-merging as an option.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="statements-1"><a class="header" href="#statements-1">Statements</a></h1>
<h2 id="let-statements"><a class="header" href="#let-statements">Let statements</a></h2>
<p>Put a space after the <code>:</code> and on both sides of the <code>=</code> (if they are present).
Don’t put a space before the semicolon.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A comment.
let pattern: Type = expr;

let pattern;
let pattern: Type;
let pattern = expr;
<span class="boring">}</span></code></pre>
<p>If possible, format the declaration on a single line. If not possible, then try
splitting after the <code>=</code>, if the declaration fits on two lines. Block-indent the
expression.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pattern: Type =
    expr;
<span class="boring">}</span></code></pre>
<p>If the first line still does not fit on a single line, split after the <code>:</code>, and
use block indentation. If the type requires multiple lines, even after
line-breaking after the <code>:</code>, then place the first line on the same line as the
<code>:</code>, subject to the <a href="#combinable-expressions">combining rules</a>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pattern:
    Type =
    expr;
<span class="boring">}</span></code></pre>
<p>e.g,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Foo {
    f: abcd,
    g: qwer,
}: Foo&lt;Bar&gt; =
    Foo { f, g };

let (abcd,
    defg):
    Baz =
{ ... }
<span class="boring">}</span></code></pre>
<p>If the expression covers multiple lines, if the first line of the expression
fits in the remaining space, it stays on the same line as the <code>=</code>, and the rest
of the expression is not further indented. If the first line does not fit, then
put the expression on subsequent lines, block indented. If the expression is a
block and the type or pattern cover multiple lines, put the opening brace on a
new line and not indented (this provides separation for the interior of the
block from the type); otherwise, the opening brace follows the <code>=</code>.</p>
<p>Examples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Foo {
    f: abcd,
    g: qwer,
};

let foo =
    ALongName {
        f: abcd,
        g: qwer,
    };

let foo: Type = {
    an_expression();
    ...
};

let foo:
    ALongType =
{
    an_expression();
    ...
};

let Foo {
    f: abcd,
    g: qwer,
}: Foo&lt;Bar&gt; = Foo {
    f: blimblimblim,
    g: blamblamblam,
};

let Foo {
    f: abcd,
    g: qwer,
}: Foo&lt;Bar&gt; = foo(
    blimblimblim,
    blamblamblam,
);
<span class="boring">}</span></code></pre>
<h3 id="else-blocks-let-else-statements"><a class="header" href="#else-blocks-let-else-statements">else blocks (let-else statements)</a></h3>
<p>A let statement can contain an <code>else</code> component, making it a let-else statement.
In this case, always apply the same formatting rules to the components preceding
the <code>else</code> block (i.e. the <code>let pattern: Type = initializer_expr</code> portion)
as described <a href="#let-statements">for other let statements</a>.</p>
<p>Format the entire let-else statement on a single line if all the following are
true:</p>
<ul>
<li>the entire statement is <em>short</em></li>
<li>the <code>else</code> block contains only a single-line expression and no statements</li>
<li>the <code>else</code> block contains no comments</li>
<li>the let statement components preceding the <code>else</code> block can be formatted on a single line</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Some(1) = opt else { return };
<span class="boring">}</span></code></pre>
<p>Otherwise, the let-else statement requires some line breaks.</p>
<p>If breaking a let-else statement across multiple lines, never break between the
<code>else</code> and the <code>{</code>, and always break before the <code>}</code>.</p>
<p>If the let statement components preceding the <code>else</code> can be formatted on a
single line, but the let-else does not qualify to be placed entirely on a
single line, put the <code>else {</code> on the same line as the initializer expression,
with a space between them, then break the line after the <code>{</code>. Indent the
closing <code>}</code> to match the <code>let</code>, and indent the contained block one step
further.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Some(1) = opt else {
    return;
};

let Some(1) = opt else {
    // nope
    return
};
<span class="boring">}</span></code></pre>
<p>If the let statement components preceding the <code>else</code> can be formatted on a
single line, but the <code>else {</code> does not fit on the same line, break the line
before the <code>else</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let Some(x) = some_really_really_really_really_really_really_really_really_really_long_name
    else {
        return;
    };
<span class="boring">}</span></code></pre>
<p>If the initializer expression is multi-line, put the <code>else</code> keyword and opening
brace of the block (i.e. <code>else {</code>) on the same line as the end of the
initializer expression, with a space between them, if and only if all the
following are true:</p>
<ul>
<li>The initializer expression ends with one or more closing
parentheses, square brackets, and/or braces</li>
<li>There is nothing else on that line</li>
<li>That line has the same indentation level as the initial <code>let</code> keyword.</li>
</ul>
<p>For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Some(x) = y.foo(
    "abc",
    fairly_long_identifier,
    "def",
    "123456",
    "string",
    "cheese",
) else {
    bar()
}
<span class="boring">}</span></code></pre>
<p>Otherwise, put the <code>else</code> keyword and opening brace on the next line after the
end of the initializer expression, with the <code>else</code> keyword at the same
indentation level as the <code>let</code> keyword.</p>
<p>For example:</p>
<pre class="playground"><code class="language-rust">fn main() {
    let Some(x) = abcdef()
        .foo(
            "abc",
            some_really_really_really_long_ident,
            "ident",
            "123456",
        )
        .bar()
        .baz()
        .qux("fffffffffffffffff")
    else {
        return
    };

    let Some(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) =
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    else {
        return;
    };

    let LongStructName(AnotherStruct {
        multi,
        line,
        pattern,
    }) = slice.as_ref()
    else {
        return;
    };

    let LongStructName(AnotherStruct {
        multi,
        line,
        pattern,
    }) = multi_line_function_call(
        arg1,
        arg2,
        arg3,
        arg4,
    ) else {
        return;
    };
}</code></pre>
<h2 id="macros-in-statement-position"><a class="header" href="#macros-in-statement-position">Macros in statement position</a></h2>
<p>For a macro use in statement position, use parentheses or square brackets as
delimiters, and terminate it with a semicolon. Do not put spaces around the
name, <code>!</code>, the delimiters, or the <code>;</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A comment.
a_macro!(...);
<span class="boring">}</span></code></pre>
<h2 id="expressions-in-statement-position"><a class="header" href="#expressions-in-statement-position">Expressions in statement position</a></h2>
<p>Do not put space between the expression and the semicolon.</p>
<pre><code>&lt;expr&gt;;
</code></pre>
<p>Terminate all expressions in statement position with a semicolon, unless they
end with a block or are used as the value for a block.</p>
<p>E.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    an_expression();
    expr_as_value()
}

return foo();

loop {
    break;
}
<span class="boring">}</span></code></pre>
<p>Use a semicolon where an expression has void type, even if it could be
propagated. E.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() { ... }

fn bar() {
    foo();
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h1>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>A block expression must have a newline after the initial <code>{</code> and before the
terminal <code>}</code>, unless it qualifies to be written as a single line based on
another style rule.</p>
<p>A keyword before the block (such as <code>unsafe</code> or <code>async</code>) must be on the same
line as the opening brace, with a single space between the keyword and the
opening brace. Indent the contents of the block.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn block_as_stmt() {
    a_call();

    {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}

fn block_as_expr() {
    let foo = {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    };
}

fn unsafe_block_as_stmt() {
    a_call();

    unsafe {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}
<span class="boring">}</span></code></pre>
<p>If a block has an attribute, put it on its own line before the block:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn block_as_stmt() {
    #[an_attribute]
    {
        #![an_inner_attribute]

        // a comment in a block
        the_value
    }
}
<span class="boring">}</span></code></pre>
<p>Avoid writing comments on the same lines as either of the braces.</p>
<p>Write an empty block as <code>{}</code>.</p>
<p>Write a block on a single line if:</p>
<ul>
<li>it is either used in expression position (not statement position) or is an
unsafe block in statement position,</li>
<li>it contains a single-line expression and no statements, and</li>
<li>it contains no comments</li>
</ul>
<p>For a single-line block, put spaces after the opening brace and before the
closing brace.</p>
<p>Examples:</p>
<pre class="playground"><code class="language-rust">fn main() {
    // Single line
    let _ = { a_call() };
    let _ = unsafe { a_call() };

    // Not allowed on one line
    // Statement position.
    {
        a_call()
    }

    // Contains a statement
    let _ = {
        a_call();
    };
    unsafe {
        a_call();
    }

    // Contains a comment
    let _ = {
        // A comment
    };
    let _ = {
        // A comment
        a_call()
    };

    // Multiple lines
    let _ = {
        a_call();
        another_call()
    };
    let _ = {
        a_call(
            an_argument,
            another_arg,
        )
    };
}</code></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>Don’t put any extra spaces before the first <code>|</code> (unless the closure is prefixed
by a keyword such as <code>move</code>); put a space between the second <code>|</code> and the
expression of the closure. Between the <code>|</code>s, use function definition syntax,
but elide types where possible.</p>
<p>Use closures without the enclosing <code>{}</code>, if possible. Add the <code>{}</code> when you have
a return type, when there are statements, when there are comments inside the
closure, or when the body expression is a control-flow expression that spans
multiple lines. If using braces, follow the rules above for blocks. Examples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|arg1, arg2| expr

move |arg1: i32, arg2: i32| -&gt; i32 {
    expr1;
    expr2
}

|| Foo {
    field1,
    field2: 0,
}

|| {
    if true {
        blah
    } else {
        boo
    }
}

|x| unsafe {
    expr
}
<span class="boring">}</span></code></pre>
<h2 id="struct-literals"><a class="header" href="#struct-literals">Struct literals</a></h2>
<p>If a struct literal is <em>small</em>, format it on a single line, and do not use a
trailing comma. If not, split it across multiple lines, with each field on its
own block-indented line, and use a trailing comma.</p>
<p>For each <code>field: value</code> entry, put a space after the colon only.</p>
<p>Put a space before the opening brace. In the single-line form, put spaces after
the opening brace and before the closing brace.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo { field1, field2: 0 }
let f = Foo {
    field1,
    field2: an_expr,
};
<span class="boring">}</span></code></pre>
<p>Functional record update syntax is treated like a field, but it must never have
a trailing comma. Do not put a space after <code>..</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = Foo {
    field1,
    ..an_expr
};
<span class="boring">}</span></code></pre>
<h2 id="unit-literals"><a class="header" href="#unit-literals">Unit literals</a></h2>
<p>Never break between the opening and closing parentheses of the <code>()</code> unit literal.</p>
<h2 id="tuple-literals"><a class="header" href="#tuple-literals">Tuple literals</a></h2>
<p>Use a single-line form where possible. Do not put spaces between the opening
parenthesis and the first element, or between the last element and the closing
parenthesis. Separate elements with a comma followed by a space.</p>
<p>Where a single-line form is not possible, write the tuple across
multiple lines, with each element of the tuple on its own block-indented line,
and use a trailing comma.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(a, b, c)

let x = (
    a_long_expr,
    another_very_long_expr,
);
<span class="boring">}</span></code></pre>
<h2 id="tuple-struct-literals"><a class="header" href="#tuple-struct-literals">Tuple struct literals</a></h2>
<p>Do not put space between the identifier and the opening parenthesis. Otherwise,
follow the rules for tuple literals:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo(a, b, c)

let x = Foo(
    a_long_expr,
    another_very_long_expr,
);
<span class="boring">}</span></code></pre>
<h2 id="enum-literals"><a class="header" href="#enum-literals">Enum literals</a></h2>
<p>Follow the formatting rules for the various struct literals. Prefer using the
name of the enum as a qualifying name, unless the enum is in the prelude:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo::Bar(a, b)
Foo::Baz {
    field1,
    field2: 1001,
}
Ok(an_expr)
<span class="boring">}</span></code></pre>
<h2 id="array-literals"><a class="header" href="#array-literals">Array literals</a></h2>
<p>Write small array literals on a single line. Do not put spaces between the opening
square bracket and the first element, or between the last element and the closing
square bracket. Separate elements with a comma followed by a space.</p>
<p>If using the repeating initializer, put a space after the semicolon
only.</p>
<p>Apply the same rules if using <code>vec!</code> or similar array-like macros; always use
square brackets with such macros. Examples:</p>
<pre class="playground"><code class="language-rust">fn main() {
    let x = [1, 2, 3];
    let y = vec![a, b, c, d];
    let a = [42; 10];
}</code></pre>
<p>For arrays that have to be broken across lines, if using the repeating
initializer, break after the <code>;</code>, not before. Otherwise, follow the rules below
for function calls. In any case, block-indent the contents of the initializer,
and put line breaks after the opening square bracket and before the closing
square bracket:</p>
<pre class="playground"><code class="language-rust">fn main() {
    [
        a_long_expression();
        1234567890
    ]
    let x = [
        an_expression,
        another_expression,
        a_third_expression,
    ];
}</code></pre>
<h2 id="array-accesses-indexing-and-slicing"><a class="header" href="#array-accesses-indexing-and-slicing">Array accesses, indexing, and slicing</a></h2>
<p>Don’t put spaces around the square brackets. Avoid breaking lines if possible.
Never break a line between the target expression and the opening square
bracket. If the indexing expression must be broken onto a subsequent line, or
spans multiple lines itself, then block-indent the indexing expression, and put
newlines after the opening square bracket and before the closing square
bracket:</p>
<p>Examples:</p>
<pre class="playground"><code class="language-rust">fn main() {
    foo[42];
    &amp;foo[..10];
    bar[0..100];
    foo[4 + 5 / bar];
    a_long_target[
        a_long_indexing_expression
    ];
}</code></pre>
<h2 id="unary-operations"><a class="header" href="#unary-operations">Unary operations</a></h2>
<p>Do not include a space between a unary op and its operand (i.e., <code>!x</code>, not
<code>! x</code>). However, there must be a space after <code>&amp;mut</code>. Avoid line-breaking
between a unary operator and its operand.</p>
<h2 id="binary-operations"><a class="header" href="#binary-operations">Binary operations</a></h2>
<p>Do include spaces around binary ops (i.e., <code>x + 1</code>, not <code>x+1</code>) (including <code>=</code>
and other assignment operators such as <code>+=</code> or <code>*=</code>).</p>
<p>For comparison operators, because for <code>T op U</code>, <code>&amp;T op &amp;U</code> is also implemented:
if you have <code>t: &amp;T</code>, and <code>u: U</code>, prefer <code>*t op u</code> to <code>t op &amp;u</code>. In general,
within expressions, prefer dereferencing to taking references, unless necessary
(e.g. to avoid an unnecessarily expensive operation).</p>
<p>Use parentheses liberally; do not necessarily elide them due to precedence.
Tools should not automatically insert or remove parentheses. Do not use spaces
to indicate precedence.</p>
<p>If line-breaking, block-indent each subsequent line. For assignment operators,
break after the operator; for all other operators, put the operator on the
subsequent line. Put each sub-expression on its own line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo_bar
    + bar
    + baz
    + qux
    + whatever
<span class="boring">}</span></code></pre>
<p>Prefer line-breaking at an assignment operator (either <code>=</code> or <code>+=</code>, etc.) rather
than at other binary operators.</p>
<h3 id="casts-as"><a class="header" href="#casts-as">Casts (<code>as</code>)</a></h3>
<p>Format <code>as</code> casts like a binary operator. In particular, always include spaces
around <code>as</code>, and if line-breaking, break before the <code>as</code> (never after) and
block-indent the subsequent line. Format the type on the right-hand side using
the rules for types.</p>
<p>However, unlike with other binary operators, if chaining a series of <code>as</code> casts
that require line-breaking, and line-breaking before the first <code>as</code> suffices to
make the remainder fit on the next line, don’t break before any subsequent
<code>as</code>; instead, leave the series of types all on the same line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cstr = very_long_expression()
    as *const str as *const [u8] as *const std::os::raw::c_char;
<span class="boring">}</span></code></pre>
<p>If the subsequent line still requires line-breaking, break and block-indent
before each <code>as</code> as with other binary operators.</p>
<h2 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h2>
<p>Do not include extraneous parentheses for <code>if</code> and <code>while</code> expressions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if true {
}
<span class="boring">}</span></code></pre>
<p>is better than</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (true) {
}
<span class="boring">}</span></code></pre>
<p>Do include extraneous parentheses if it makes an arithmetic or logic expression
easier to understand (<code>(x * 15) + (y * 20)</code> is fine)</p>
<h2 id="function-calls"><a class="header" href="#function-calls">Function calls</a></h2>
<p>Do not put a space between the function name, and the opening parenthesis.</p>
<p>Do not put a space between an argument, and the comma which follows.</p>
<p>Do put a space between an argument, and the comma which precedes it.</p>
<p>Prefer not to break a line in the callee expression.</p>
<p>For a function call with no arguments (a nullary function call like <code>func()</code>),
never break within the parentheses, and never put a space between the
parentheses. Always write a nullary function call as a single-line call, never
a multi-line call.</p>
<h3 id="single-line-calls"><a class="header" href="#single-line-calls">Single-line calls</a></h3>
<p>Do not put a space between the function name and open paren, between the open
paren and the first argument, or between the last argument and the close paren.</p>
<p>Do not put a comma after the last argument.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo(x, y, z)
<span class="boring">}</span></code></pre>
<h3 id="multi-line-calls"><a class="header" href="#multi-line-calls">Multi-line calls</a></h3>
<p>If the function call is not <em>small</em>, it would otherwise over-run the max width,
or any argument or the callee is multi-line, then format the call across
multiple lines. In this case, put each argument on its own block-indented line,
break after the opening parenthesis and before the closing parenthesis,
and use a trailing comma:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a_function_call(
    arg1,
    a_nested_call(a, b),
)
<span class="boring">}</span></code></pre>
<h2 id="method-calls"><a class="header" href="#method-calls">Method calls</a></h2>
<p>Follow the function rules for calling.</p>
<p>Do not put any spaces around the <code>.</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.foo().bar().baz(x, y, z);
<span class="boring">}</span></code></pre>
<h2 id="macro-uses"><a class="header" href="#macro-uses">Macro uses</a></h2>
<p>If a macro can be parsed like other constructs, format it like those
constructs. For example, a macro use <code>foo!(a, b, c)</code> can be parsed like a
function call (ignoring the <code>!</code>), so format it using the rules for function
calls.</p>
<p>The style guide defines specific formatting for particular macros in the
language or standard library. The style guide does not define formatting for
any third-party macros, even if similar to those in the language or standard
library.</p>
<h3 id="format-string-macros"><a class="header" href="#format-string-macros">Format string macros</a></h3>
<p>For macros which take a format string, if all other arguments are <em>small</em>,
format the arguments before the format string on a single line if they fit, and
format the arguments after the format string on a single line if they fit, with
the format string on its own line. If the arguments are not small or do not
fit, put each on its own line as with a function. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(
    "Hello {} and {}",
    name1, name2,
);

assert_eq!(
    x, y,
    "x and y were not equal, see {}",
    reason,
);
<span class="boring">}</span></code></pre>
<h2 id="chains-of-fields-and-method-calls"><a class="header" href="#chains-of-fields-and-method-calls">Chains of fields and method calls</a></h2>
<p>A chain is a sequence of field accesses, method calls, and/or uses of the try
operator <code>?</code>. E.g., <code>a.b.c().d</code> or <code>foo?.bar().baz?</code>.</p>
<p>Format the chain on one line if it is “small” and otherwise possible to do so.
If formatting on multiple lines, put each field access or method call in the
chain on its own line, with the line-break before the <code>.</code> and after any <code>?</code>.
Block-indent each subsequent line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = bar
    .baz?
    .qux();
<span class="boring">}</span></code></pre>
<p>If the length of the last line of the first element plus its indentation is
less than or equal to the indentation of the second line, then combine the
first and second lines if they fit. Apply this rule recursively.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.baz?
    .qux()

x.y.z
    .qux()

let foo = x
    .baz?
    .qux();

foo(
    expr1,
    expr2,
).baz?
    .qux();
<span class="boring">}</span></code></pre>
<h3 id="multi-line-elements"><a class="header" href="#multi-line-elements">Multi-line elements</a></h3>
<p>If any element in a chain is formatted across multiple lines, put that element
and any later elements on their own lines.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a.b.c()?
    .foo(
        an_expr,
        another_expr,
    )
    .bar
    .baz
<span class="boring">}</span></code></pre>
<p>Note there is block indent due to the chain and the function call in the above
example.</p>
<p>Prefer formatting the whole chain in multi-line style and each element on one
line, rather than putting some elements on multiple lines and some on a single
line, e.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Better
self.pre_comment
    .as_ref()
    .map_or(false, |comment| comment.starts_with("//"))

// Worse
self.pre_comment.as_ref().map_or(
    false,
    |comment| comment.starts_with("//"),
)
<span class="boring">}</span></code></pre>
<h2 id="control-flow-expressions"><a class="header" href="#control-flow-expressions">Control flow expressions</a></h2>
<p>This section covers <code>for</code> and <code>loop</code> expressions, as well as <code>if</code> and <code>while</code>
expressions with their sub-expression variants. This includes those with a
single <code>let</code> sub-expression (i.e. <code>if let</code> and <code>while let</code>)
as well as “let-chains”: those with one or more <code>let</code> sub-expressions and
one or more bool-type conditions (i.e.  <code>if a &amp;&amp; let Some(b) = c</code>).</p>
<p>Put the keyword, any initial clauses, and the opening brace of the block all on
a single line, if they fit. Apply the usual rules for <a href="#blocks">block
formatting</a> to the block.</p>
<p>If there is an <code>else</code> component, then put the closing brace, <code>else</code>, any
following clause, and the opening brace all on the same line, with a single
space before and after the <code>else</code> keyword:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ... {
    ...
} else {
    ...
}

if let ... {
    ...
} else if ... {
    ...
} else {
    ...
}
<span class="boring">}</span></code></pre>
<p>If the control line needs to be broken, then prefer breaking after the <code>=</code> for any
<code>let</code> sub-expression in an <code>if</code> or <code>while</code> expression that does not fit,
and before <code>in</code> in a <code>for</code> expression; the following line should be block indented.
If the control line is broken for any reason, then the opening brace should be on its
own line and not indented. Examples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(foo)
    = a_long_expression
{
    ...
}

for foo
    in a_long_expression
{
    ...
}

if a_long_expression
    &amp;&amp; another_long_expression
    || a_third_long_expression
{
    ...
}

if let Some(a) = b
    &amp;&amp; another_long_expression
    &amp;&amp; a_third_long_expression
{
    // ...
}

if let Some(relatively_long_thing)
    = a_long_expression
    &amp;&amp; another_long_expression
    &amp;&amp; a_third_long_expression
{
    // ...
}

if some_expr
    &amp;&amp; another_long_expression
    &amp;&amp; let Some(relatively_long_thing) =
        a_long_long_long_long_long_long_really_reallllllllllyyyyyyy_long_expression
    &amp;&amp; a_third_long_expression
{
    // ...
}
<span class="boring">}</span></code></pre>
<p>A let-chain control line is allowed to be formatted on a single line provided
it only consists of two clauses, with the first, left-hand side operand being a literal or an
<code>ident</code> (which can optionally be preceded by any number of unary prefix operators),
and the second, right-hand side operand being a single-line <code>let</code> clause. Otherwise,
the control line must be broken and formatted according to the above rules. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if a &amp;&amp; let Some(b) = foo() {
    // ...
}

if true &amp;&amp; let Some(b) = foo() {
    // ...
}

let operator = if !from_hir_call &amp;&amp; let Some(p) = parent {
    // ...
};

if let Some(b) = foo()
    &amp;&amp; a
{
    // ..
}

if foo()
    &amp;&amp; let Some(b) = bar
{
    // ...
}

if gen_pos != GenericArgPosition::Type
    &amp;&amp; let Some(b) = gen_args.bindings.first()
{
    // ..
}
<span class="boring">}</span></code></pre>
<p>Where the initial clause spans multiple lines and ends with one or more closing
parentheses, square brackets, or braces, and there is nothing else on that
line, and that line is not indented beyond the indent on the first line of the
control flow expression, then put the opening brace of the block on the same
line with a preceding space. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !self.config.file_lines().intersects(
    &amp;self.codemap.lookup_line_range(
        stmt.span,
    ),
) {  // Opening brace on same line as initial clause.
    ...
}
<span class="boring">}</span></code></pre>
<h3 id="single-line-if-else"><a class="header" href="#single-line-if-else">Single line <code>if else</code></a></h3>
<p>Put an <code>if else</code> or <code>if let else</code> on a single line if it occurs in expression
context (i.e., is not a standalone statement), it contains a single <code>else</code>
clause, and is <em>small</em>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = if x { 0 } else { 1 };

// Examples that must be multi-line.
let y = if something_very_long {
    not_small
} else {
    also_not_small
};

if x {
    0
} else {
    1
}
<span class="boring">}</span></code></pre>
<h2 id="match"><a class="header" href="#match">Match</a></h2>
<p>Prefer not to line-break inside the discriminant expression. Always break after
the opening brace and before the closing brace. Block-indent the match arms
once:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    // arms
}

let x = match foo.bar.baz() {
    // arms
};
<span class="boring">}</span></code></pre>
<p>Use a trailing comma for a match arm if and only if not using a block.</p>
<p>Never start a match arm pattern with <code>|</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    // Don't do this.
    | foo =&gt; bar,
    // Or this.
    | a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_fourth_pattern =&gt; {
        ...
    }
}
<span class="boring">}</span></code></pre>
<p>Prefer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    foo =&gt; bar,
    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_fourth_pattern =&gt; {
        ...
    }
}
<span class="boring">}</span></code></pre>
<p>Avoid splitting the left-hand side (before the <code>=&gt;</code>) of a match arm where
possible. If the right-hand side of the match arm is kept on the same line,
never use a block (unless the block is empty).</p>
<p>If the right-hand side consists of multiple statements, or has line comments,
or the start of the line does not fit on the same line as the left-hand side,
use a block. Do not flatten a right-hand side block containing a single macro call
because its expanded form could contain a trailing semicolon.</p>
<p>Block-indent the body of a block arm.</p>
<p>Examples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    foo =&gt; bar,
    a_very_long_pattern | another_pattern if an_expression() =&gt; {
        no_room_for_this_expression()
    }
    foo =&gt; {
        // A comment.
        an_expression()
    }
    foo =&gt; {
        let a = statement();
        an_expression()
    }
    bar =&gt; {}
    // Trailing comma on last item.
    foo =&gt; bar,
    baz =&gt; qux!(),
    lorem =&gt; {
        ipsum!()
    }
}
<span class="boring">}</span></code></pre>
<p>If the body is a single expression with no line comments and not a control flow
expression, start it on the same line as the left-hand side. If not, then it
must be in a block. Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    // A combinable expression.
    foo =&gt; a_function_call(another_call(
        argument1,
        argument2,
    )),
    // A non-combinable expression
    bar =&gt; {
        a_function_call(
            another_call(
                argument1,
                argument2,
            ),
            another_argument,
        )
    }
}
<span class="boring">}</span></code></pre>
<h3 id="line-breaking"><a class="header" href="#line-breaking">Line-breaking</a></h3>
<p>If using a block form on the right-hand side of a match arm makes it possible
to avoid breaking on the left-hand side, do that:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Assuming the following line does not fit in the max width
    a_very_long_pattern | another_pattern =&gt; ALongStructName {
        ...
    },
    // Prefer this
    a_very_long_pattern | another_pattern =&gt; {
        ALongStructName {
            ...
        }
    }
    // To splitting the pattern.
<span class="boring">}</span></code></pre>
<p>Never break after <code>=&gt;</code> without using the block form of the body.</p>
<p>If the left-hand side must be split and there is an <code>if</code> clause, break before
the <code>if</code> and block indent. In this case, always use a block body and start the
body on a new line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    a_very_long_pattern | another_pattern
        if expr =&gt;
    {
        ...
    }
<span class="boring">}</span></code></pre>
<p>If required to break the pattern, put each clause of the pattern on its own
line with no additional indent, breaking before the <code>|</code>. If there is an <code>if</code>
clause, use the above form:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern =&gt; {
        ...
    }
    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern
        if expr =&gt;
    {
        ...
    }
<span class="boring">}</span></code></pre>
<p>If the pattern is multi-line, and the last line is less wide than the indent, do
not put the <code>if</code> clause on a new line. E.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Token::Dimension {
         value,
         ref unit,
         ..
    } if num_context.is_ok(context.parsing_mode, value) =&gt; {
        ...
    }
<span class="boring">}</span></code></pre>
<p>If every clause in a pattern is <em>small</em>, but the whole pattern does not fit on
one line, then format the pattern across multiple lines with as many clauses
per line as possible. Again, break before a <code>|</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    foo | bar | baz
    | qux =&gt; {
        ...
    }
<span class="boring">}</span></code></pre>
<p>We define a pattern clause to be <em>small</em> if it fits on a single line and
matches “small” in the following grammar:</p>
<pre><code>small:
    - small_no_tuple
    - unary tuple constructor: `(` small_no_tuple `,` `)`
    - `&amp;` small

small_no_tuple:
    - single token
    - `&amp;` small_no_tuple
</code></pre>
<p>E.g., <code>&amp;&amp;Some(foo)</code> matches, <code>Foo(4, Bar)</code> does not.</p>
<h2 id="combinable-expressions"><a class="header" href="#combinable-expressions">Combinable expressions</a></h2>
<p>Where a function call has a single argument, and that argument is formatted
across multiple-lines, format the outer call as if it were a single-line call,
if the result fits. Apply the same combining behaviour to any similar
expressions which have multi-line, block-indented lists of sub-expressions
delimited by parentheses (e.g., macros or tuple struct literals). E.g.,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo(bar(
    an_expr,
    another_expr,
))

let x = foo(Bar {
    field: whatever,
});

foo(|param| {
    action();
    foo(param)
})

let x = combinable([
    an_expr,
    another_expr,
]);

let arr = [combinable(
    an_expr,
    another_expr,
)];
<span class="boring">}</span></code></pre>
<p>Apply this behavior recursively.</p>
<p>For a function with multiple arguments, if the last argument is a multi-line
closure with an explicit block, there are no other closure arguments, and all
the arguments and the first line of the closure fit on the first line, use the
same combining behavior:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo(first_arg, x, |param| {
    action();
    foo(param)
})
<span class="boring">}</span></code></pre>
<h2 id="ranges"><a class="header" href="#ranges">Ranges</a></h2>
<p>Do not put spaces in ranges, e.g., <code>0..10</code>, <code>x..=y</code>, <code>..x.len()</code>, <code>foo..</code>.</p>
<p>When writing a range with both upper and lower bounds, if the line must be
broken within the range, break before the range operator and block indent the
second line:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a_long_expression
    ..another_long_expression
<span class="boring">}</span></code></pre>
<p>For the sake of indicating precedence, if either bound is a compound
expression, use parentheses around it, e.g., <code>..(x + 1)</code>, <code>(x.f)..(x.f.len())</code>,
or <code>0..(x - 10)</code>.</p>
<h2 id="hexadecimal-literals"><a class="header" href="#hexadecimal-literals">Hexadecimal literals</a></h2>
<p>Hexadecimal literals may use upper- or lower-case letters, but they must not be
mixed within the same literal. Projects should use the same case for all
literals, but we do not make a recommendation for either lower- or upper-case.</p>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<p>Format patterns like their corresponding expressions. See the section on
<code>match</code> for additional formatting for patterns in match arms.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="types-and-bounds"><a class="header" href="#types-and-bounds">Types and Bounds</a></h1>
<h2 id="single-line-formatting"><a class="header" href="#single-line-formatting">Single line formatting</a></h2>
<ul>
<li><code>[T]</code> no spaces</li>
<li><code>[T; expr]</code>, e.g., <code>[u32; 42]</code>, <code>[Vec&lt;Foo&gt;; 10 * 2 + foo()]</code> (space after colon, no spaces around square brackets)</li>
<li><code>*const T</code>, <code>*mut T</code> (no space after <code>*</code>, space before type)</li>
<li><code>&amp;'a T</code>, <code>&amp;T</code>, <code>&amp;'a mut T</code>, <code>&amp;mut T</code> (no space after <code>&amp;</code>, single spaces separating other words)</li>
<li><code>unsafe extern "C" fn&lt;'a, 'b, 'c&gt;(T, U, V) -&gt; W</code> or <code>fn()</code> (single spaces around keywords and sigils, and after commas, no trailing commas, no spaces around brackets)</li>
<li><code>!</code> gets treated like any other type name, <code>Name</code></li>
<li><code>(A, B, C, D)</code> (spaces after commas, no spaces around parens, no trailing comma unless it is a one-tuple)</li>
<li><code>&lt;Baz&lt;T&gt; as SomeTrait&gt;::Foo::Bar</code> or <code>Foo::Bar</code> or <code>::Foo::Bar</code> (no spaces around <code>::</code> or angle brackets, single spaces around <code>as</code>)</li>
<li><code>Foo::Bar&lt;T, U, V&gt;</code> (spaces after commas, no trailing comma, no spaces around angle brackets)</li>
<li><code>T + T + T</code> (single spaces between types, and <code>+</code>).</li>
<li><code>impl T + T + T</code> (single spaces between keyword, types, and <code>+</code>).</li>
</ul>
<p>Do not put space around parentheses used in types, e.g., <code>(Foo)</code></p>
<h2 id="line-breaks"><a class="header" href="#line-breaks">Line breaks</a></h2>
<p>Avoid breaking lines in types where possible. Prefer breaking at outermost scope, e.g., prefer</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo&lt;
    Bar,
    Baz&lt;Type1, Type2&gt;,
&gt;
<span class="boring">}</span></code></pre>
<p>to</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo&lt;Bar, Baz&lt;
    Type1,
    Type2,
&gt;&gt;
<span class="boring">}</span></code></pre>
<p>If a type requires line-breaks in order to fit, this section outlines where to
break such types if necessary.</p>
<p>Break <code>[T; expr]</code> after the <code>;</code> if necessary.</p>
<p>Break function types following the rules for function declarations.</p>
<p>Break generic types following the rules for generics.</p>
<p>Break types with <code>+</code> by breaking before the <code>+</code> and block-indenting the
subsequent lines. When breaking such a type, break before <em>every</em> <code>+</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Clone
    + Copy
    + Debug

Box&lt;
    Clone
    + Copy
    + Debug
&gt;
<span class="boring">}</span></code></pre>
<h2 id="precise-capturing-bounds"><a class="header" href="#precise-capturing-bounds">Precise capturing bounds</a></h2>
<p>A <code>use&lt;'a, T&gt;</code> precise capturing bound is formatted as if it were a single path segment with non-turbofished angle-bracketed args, like a trait bound whose identifier is <code>use</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; impl Sized + use&lt;'a&gt; {}

// is formatted analogously to:

fn foo() -&gt; impl Sized + Use&lt;'a&gt; {}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="other-style-advice"><a class="header" href="#other-style-advice">Other style advice</a></h1>
<h2 id="expressions-2"><a class="header" href="#expressions-2">Expressions</a></h2>
<p>Prefer to use Rust’s expression oriented nature where possible;</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// use
let x = if y { 1 } else { 0 };
// not
let x;
if y {
    x = 1;
} else {
    x = 0;
}
<span class="boring">}</span></code></pre>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<ul>
<li>Types shall be <code>UpperCamelCase</code>,</li>
<li>Enum variants shall be <code>UpperCamelCase</code>,</li>
<li>Struct fields shall be <code>snake_case</code>,</li>
<li>Function and method names shall be <code>snake_case</code>,</li>
<li>Local variables shall be <code>snake_case</code>,</li>
<li>Macro names shall be <code>snake_case</code>,</li>
<li>Constants (<code>const</code>s and immutable <code>static</code>s) shall be <code>SCREAMING_SNAKE_CASE</code>.</li>
<li>When a name is forbidden because it is a reserved word (such as <code>crate</code>),
either use a raw identifier (<code>r#crate</code>) or use a trailing underscore
(<code>crate_</code>). Don’t misspell the word (<code>krate</code>).</li>
</ul>
<h3 id="modules-1"><a class="header" href="#modules-1">Modules</a></h3>
<p>Avoid <code>#[path]</code> annotations where possible.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargotoml-conventions-1"><a class="header" href="#cargotoml-conventions-1"><code>Cargo.toml</code> conventions</a></h1>
<h2 id="formatting-conventions-1"><a class="header" href="#formatting-conventions-1">Formatting conventions</a></h2>
<p>Use the same line width and indentation as Rust code.</p>
<p>Put a blank line between the last key-value pair in a section and the header of
the next section. Do not place a blank line between section headers and the
key-value pairs in that section, or between key-value pairs in a section.</p>
<p>Version-sort key names within each section, with the exception of the
<code>[package]</code> section. Put the <code>[package]</code> section at the top of the file; put
the <code>name</code> and <code>version</code> keys in that order at the top of that section,
followed by the remaining keys other than <code>description</code> in order, followed by
the <code>description</code> at the end of that section.</p>
<p>Don’t use quotes around any standard key names; use bare keys. Only use quoted
keys for non-standard keys whose names require them, and avoid introducing such
key names when possible.  See the <a href="https://toml.io/en/v1.0.0#keys">TOML
specification</a> for details.</p>
<p>Put a single space both before and after the <code>=</code> between a key and value. Do
not indent any key names; start all key names at the start of a line.</p>
<p>Use multi-line strings (rather than newline escape sequences) for any string
values that include multiple lines, such as the crate description.</p>
<p>For array values, such as a list of features, put the entire list on the same
line as the key, if it fits. Otherwise, use block indentation: put a newline
after the opening square bracket, indent each item by one indentation level,
put a comma after each item (including the last), and put the closing square
bracket at the start of a line by itself after the last item.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>some_feature = [
    "another_feature",
    "yet_another_feature",
    "some_dependency?/some_feature",
]
<span class="boring">}</span></code></pre>
<p>For table values, such as a crate dependency with a path, write the entire
table using curly braces and commas on the same line as the key if it fits. If
the entire table does not fit on the same line as the key, separate it out into
a separate section with key-value pairs:</p>
<pre><code class="language-toml">[dependencies]
crate1 = { path = "crate1", version = "1.2.3" }

[dependencies.extremely_long_crate_name_goes_here]
path = "extremely_long_path_name_goes_right_here"
version = "4.5.6"
</code></pre>
<h2 id="metadata-conventions"><a class="header" href="#metadata-conventions">Metadata conventions</a></h2>
<p>The authors list, if present, should consist of strings that each contain an
author name followed by an email address in angle brackets: <code>Full Name &lt;email@address&gt;</code>. It should not contain bare email addresses, or names without
email addresses. (The authors list may also include a mailing list address
without an associated name.)</p>
<p>The license field must contain a valid <a href="https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60">SPDX
expression</a>,
using valid <a href="https://spdx.org/licenses/">SPDX license names</a>. (As an exception,
by widespread convention, the license field may use <code>/</code> in place of <code>OR</code>; for
example, <code>MIT/Apache-2.0</code>.)</p>
<p>The homepage field, if present, must consist of a single URL, including the
scheme (e.g. <code>https://example.org/</code>, not just <code>example.org</code>.)</p>
<p>Within the description field, wrap text at 80 columns. Don’t start the
description field with the name of the crate (e.g. “cratename is a …”); just
describe the crate itself. If providing a multi-sentence description, the first
sentence should go on a line by itself and summarize the crate, like the
subject of an email or commit message; subsequent sentences can then describe
the crate in more detail.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="guiding-principles-and-rationale"><a class="header" href="#guiding-principles-and-rationale">Guiding principles and rationale</a></h1>
<p>When deciding on style guidelines, the style team follows these guiding
principles (in rough priority order):</p>
<ul>
<li>
<p>readability</p>
<ul>
<li>scan-ability</li>
<li>avoiding misleading formatting</li>
<li>accessibility - readable and editable by users using the widest
variety of hardware, including non-visual accessibility interfaces</li>
<li>readability of code in contexts without syntax highlighting or IDE
assistance, such as rustc error messages, diffs, grep, and other
plain-text contexts</li>
</ul>
</li>
<li>
<p>aesthetics</p>
<ul>
<li>sense of ‘beauty’</li>
<li>consistent with other languages/tools</li>
</ul>
</li>
<li>
<p>specifics</p>
<ul>
<li>compatibility with version control practices - preserving diffs,
merge-friendliness, etc.</li>
<li>preventing rightward drift</li>
<li>minimising vertical space</li>
</ul>
</li>
<li>
<p>application</p>
<ul>
<li>ease of manual application</li>
<li>ease of implementation (in <code>rustfmt</code>, and in other tools/editors/code generators)</li>
<li>internal consistency</li>
<li>simplicity of formatting rules</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-style-editions"><a class="header" href="#rust-style-editions">Rust style editions</a></h1>
<p>The default Rust style evolves over time, as Rust does. However, to avoid
breaking established code style, and CI jobs checking code style, changes to
the default Rust style only appear in <em>style editions</em>.</p>
<p>Code written in a given
<a href="https://doc.rust-lang.org/edition-guide/">Rust edition</a>
uses the corresponding Rust style edition by default. To make it easier to
migrate code style separately from the semantic changes between Rust editions,
formatting tools such as <code>rustfmt</code> allow updating the style edition separately
from the Rust edition.</p>
<p>The current version of the style guide describes the latest Rust style edition.
Each distinct past style will have a corresponding archived version of the
style guide.</p>
<p>Note that archived versions of the style guide do not document formatting for
newer Rust constructs that did not exist at the time that version of the style
guide was archived. However, each style edition will still format all
constructs valid in that Rust edition, with the style of newer constructs
coming from the first subsequent style edition providing formatting rules for
that construct (without any of the systematic/global changes from that style
edition).</p>
<p>Not all Rust editions have corresponding changes to the Rust style. For
instance, Rust 2015, Rust 2018, and Rust 2021 all use the same style edition.</p>
<h2 id="rust-next-style-edition"><a class="header" href="#rust-next-style-edition">Rust next style edition</a></h2>
<ul>
<li>Never break within a nullary function call <code>func()</code> or a unit literal <code>()</code>.</li>
</ul>
<h2 id="rust-2024-style-edition"><a class="header" href="#rust-2024-style-edition">Rust 2024 style edition</a></h2>
<p>This style guide describes the Rust 2024 style edition. The Rust 2024 style
edition is currently nightly-only and may change before the release of Rust
2024.</p>
<p>For a full history of changes in the Rust 2024 style edition, see the git
history of the style guide. Notable changes in the Rust 2024 style edition
include:</p>
<ul>
<li>Miscellaneous <code>rustfmt</code> bugfixes.</li>
<li>Use version-sort (sort <code>x8</code>, <code>x16</code>, <code>x32</code>, <code>x64</code>, <code>x128</code> in that order).</li>
<li>Change “ASCIIbetical” sort to Unicode-aware “non-lowercase before lowercase”.</li>
</ul>
<h2 id="rust-201520182021-style-edition"><a class="header" href="#rust-201520182021-style-edition">Rust 2015/2018/2021 style edition</a></h2>
<p>The archived version of the style guide at
<a href="https://github.com/rust-lang/rust/tree/37343f4a4d4ed7ad0891cb79e8eb25acf43fb821/src/doc/style-guide/src">https://github.com/rust-lang/rust/tree/37343f4a4d4ed7ad0891cb79e8eb25acf43fb821/src/doc/style-guide/src</a>
describes the style edition corresponding to Rust 2015, Rust 2018, and Rust
2021.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nightly"><a class="header" href="#nightly">Nightly</a></h1>
<p>This chapter documents style and formatting for nightly-only syntax. The rest of the style guide documents style for stable Rust syntax; nightly syntax only appears in this chapter. Each section here includes the name of the feature gate, so that searches (e.g. <code>git grep</code>) for a nightly feature in the Rust repository also turn up the style guide section.</p>
<p>Style and formatting for nightly-only syntax should be removed from this chapter and integrated into the appropriate sections of the style guide at the time of stabilization.</p>
<p>There is no guarantee of the stability of this chapter in contrast to the rest of the style guide. Refer to the style team policy for nightly formatting procedure regarding breaking changes to this chapter.</p>
<h3 id="frontmatter"><a class="header" href="#frontmatter">Frontmatter</a></h3>
<p><em>Location: Placed before comments and attributes in the <a href="#rust-style-guide">root</a>.</em></p>
<p><em>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/136889">#136889</a></em></p>
<p><em>Feature gate: <code>frontmatter</code></em></p>
<p>There should be no blank lines between the frontmatter and either the start of the file or a shebang.
There can be zero or one line between the frontmatter and any following content.</p>
<p>The frontmatter fences should use the minimum number of dashes necessary for the contained content (one more than the longest series of initial dashes in the
content, with a minimum of 3 to be recognized as frontmatter delimiters).
If an infostring is present after the opening fence, there should be one space separating them.
The frontmatter fence lines should not have trailing whitespace.</p>
<pre class="playground"><code class="language-rust">#!/usr/bin/env cargo
--- cargo
[dependencies]
regex = "1"
---

fn main() {}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
