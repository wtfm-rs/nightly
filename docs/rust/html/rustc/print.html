<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The rustc book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-12e09b8e.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-46ab57f5.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The rustc book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/rustc" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="what-is-rustc"><a class="header" href="#what-is-rustc">What is rustc?</a></h1>
<p>Welcome to “The rustc book”! <code>rustc</code> is the compiler for the Rust programming
language, provided by the project itself. Compilers take your source code and
produce binary code, either as a library or executable.</p>
<p>Most Rust programmers don’t invoke <code>rustc</code> directly, but instead do it through
<a href="../cargo/index.html">Cargo</a>. It’s all in service of <code>rustc</code> though! If you
want to see how Cargo calls <code>rustc</code>, you can</p>
<pre><code class="language-bash">$ cargo build --verbose
</code></pre>
<p>And it will print out each <code>rustc</code> invocation. This book can help you
understand what each of these options does. Additionally, while most
Rustaceans use Cargo, not all do: sometimes they integrate <code>rustc</code> into other
build systems. This book should provide a guide to all of the options you’d
need to do so.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p>Let’s say you’ve got a little hello world program in a file <code>hello.rs</code>:</p>
<pre><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre>
<p>To turn this source code into an executable, you can use <code>rustc</code>:</p>
<pre><code class="language-bash">$ rustc hello.rs
$ ./hello # on a *NIX
$ .\hello.exe # on Windows
</code></pre>
<p>Note that we only ever pass <code>rustc</code> the <em>crate root</em>, not every file we wish
to compile. For example, if we had a <code>main.rs</code> that looked like this:</p>
<pre><code class="language-rust ignore (needs-multiple-files)">mod foo;

fn main() {
    foo::hello();
}</code></pre>
<p>And a <code>foo.rs</code> that had this:</p>
<pre><code class="language-rust no_run">pub fn hello() {
    println!("Hello, world!");
}</code></pre>
<p>To compile this, we’d run this command:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>No need to tell <code>rustc</code> about <code>foo.rs</code>; the <code>mod</code> statements give it
everything that it needs. This is different than how you would use a C
compiler, where you invoke the compiler on each file, and then link
everything together. In other words, the <em>crate</em> is a translation unit, not a
particular module.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command-line Arguments</a></h1>
<p>Here’s a list of command-line arguments to <code>rustc</code> and what they do.</p>
<p><a id="option-help"></a></p>
<h2 id="-h--help-get-help"><a class="header" href="#-h--help-get-help"><code>-h</code>/<code>--help</code>: get help</a></h2>
<p>This flag will print out help information for <code>rustc</code>.</p>
<p><a id="option-cfg"></a></p>
<h2 id="--cfg-configure-the-compilation-environment"><a class="header" href="#--cfg-configure-the-compilation-environment"><code>--cfg</code>: configure the compilation environment</a></h2>
<p>This flag can turn on or off various <code>#[cfg]</code> settings for <a href="../reference/conditional-compilation.html">conditional
compilation</a>.</p>
<p>The value can either be a single identifier or two identifiers separated by <code>=</code>.</p>
<p>For examples, <code>--cfg 'verbose'</code> or <code>--cfg 'feature="serde"'</code>. These correspond
to <code>#[cfg(verbose)]</code> and <code>#[cfg(feature = "serde")]</code> respectively.</p>
<p><a id="option-check-cfg"></a></p>
<h2 id="--check-cfg-configure-compile-time-checking-of-conditional-compilation"><a class="header" href="#--check-cfg-configure-compile-time-checking-of-conditional-compilation"><code>--check-cfg</code>: configure compile-time checking of conditional compilation</a></h2>
<p>This flag enables checking conditional configurations of the crate at compile-time,
specifically it helps configure the set of expected cfg names and values, in order
to check that every <em>reachable</em> <code>#[cfg]</code> matches the expected config names and values.</p>
<p>This is different from the <code>--cfg</code> flag above which activates some config but do
not expect them. This is useful to prevent stalled conditions, typos, …</p>
<p>Refer to the <a href="#checking-conditional-configurations">Checking conditional configurations</a> of this book
for further details and explanation.</p>
<p>For examples, <code>--check-cfg 'cfg(verbose)'</code> or <code>--check-cfg 'cfg(feature, values("serde"))'</code>.
These correspond to <code>#[cfg(verbose)]</code> and <code>#[cfg(feature = "serde")]</code> respectively.</p>
<p><a id="option-l-search-path"></a></p>
<h2 id="-l-add-a-directory-to-the-library-search-path"><a class="header" href="#-l-add-a-directory-to-the-library-search-path"><code>-L</code>: add a directory to the library search path</a></h2>
<p>The <code>-L</code> flag adds a path to search for external crates and libraries.</p>
<p>The kind of search path can optionally be specified with the form <code>-L KIND=PATH</code> where <code>KIND</code> may be one of:</p>
<ul>
<li><code>dependency</code> — Only search for transitive dependencies in this directory.</li>
<li><code>crate</code> — Only search for this crate’s direct dependencies in this
directory.</li>
<li><code>native</code> — Only search for native libraries in this directory.</li>
<li><code>framework</code> — Only search for macOS frameworks in this directory.</li>
<li><code>all</code> — Search for all library kinds in this directory, except frameworks. This is the default
if <code>KIND</code> is not specified.</li>
</ul>
<p><a id="option-l-link-lib"></a></p>
<h2 id="-l-link-the-generated-crate-to-a-native-library"><a class="header" href="#-l-link-the-generated-crate-to-a-native-library"><code>-l</code>: link the generated crate to a native library</a></h2>
<p>Syntax: <code>-l [KIND[:MODIFIERS]=]NAME[:RENAME]</code>.</p>
<p>This flag allows you to specify linking to a specific native library when building
a crate.</p>
<p>The kind of library can optionally be specified with the form <code>-l KIND=lib</code>
where <code>KIND</code> may be one of:</p>
<ul>
<li><code>dylib</code> — A native dynamic library.</li>
<li><code>static</code> — A native static library (such as a <code>.a</code> archive).</li>
<li><code>framework</code> — A macOS framework.</li>
</ul>
<p>If the kind is specified, then linking modifiers can be attached to it.
Modifiers are specified as a comma-delimited string with each modifier prefixed with
either a <code>+</code> or <code>-</code> to indicate that the modifier is enabled or disabled, respectively.
Specifying multiple <code>modifiers</code> arguments in a single <code>link</code> attribute,
or multiple identical modifiers in the same <code>modifiers</code> argument is not currently supported. <br>Example: <code>-l static:+whole-archive=mylib</code>.</p>
<p>The kind of library and the modifiers can also be specified in a <a href="../reference/items/external-blocks.html#the-link-attribute"><code>#[link]</code>
attribute</a>. If the kind is not specified in the <code>link</code>
attribute or on the command-line, it will link a dynamic library by default,
except when building a static executable. If the kind is specified on the
command-line, it will override the kind specified in a <code>link</code> attribute.</p>
<p>The name used in a <code>link</code> attribute may be overridden using the form <code>-l ATTR_NAME:LINK_NAME</code> where <code>ATTR_NAME</code> is the name in the <code>link</code> attribute,
and <code>LINK_NAME</code> is the name of the actual library that will be linked.</p>
<h3 id="linking-modifiers-whole-archive"><a class="header" href="#linking-modifiers-whole-archive">Linking modifiers: <code>whole-archive</code></a></h3>
<p>This modifier is only compatible with the <code>static</code> linking kind.
Using any other kind will result in a compiler error.</p>
<p><code>+whole-archive</code> means that the static library is linked as a whole archive
without throwing any object files away.</p>
<p>This modifier translates to <code>--whole-archive</code> for <code>ld</code>-like linkers,
to <code>/WHOLEARCHIVE</code> for <code>link.exe</code>, and to <code>-force_load</code> for <code>ld64</code>.
The modifier does nothing for linkers that don’t support it.</p>
<p>The default for this modifier is <code>-whole-archive</code>.</p>
<h3 id="linking-modifiers-bundle"><a class="header" href="#linking-modifiers-bundle">Linking modifiers: <code>bundle</code></a></h3>
<p>This modifier is only compatible with the <code>static</code> linking kind.
Using any other kind will result in a compiler error.</p>
<p>When building a rlib or staticlib <code>+bundle</code> means that the native static library
will be packed into the rlib or staticlib archive, and then retrieved from there
during linking of the final binary.</p>
<p>When building a rlib <code>-bundle</code> means that the native static library is registered as a dependency
of that rlib “by name”, and object files from it are included only during linking of the final
binary, the file search by that name is also performed during final linking. <br>When building a staticlib <code>-bundle</code> means that the native static library is simply not included
into the archive and some higher level build system will need to add it later during linking of
the final binary.</p>
<p>This modifier has no effect when building other targets like executables or dynamic libraries.</p>
<p>The default for this modifier is <code>+bundle</code>.</p>
<h3 id="linking-modifiers-verbatim"><a class="header" href="#linking-modifiers-verbatim">Linking modifiers: <code>verbatim</code></a></h3>
<p>This modifier is compatible with all linking kinds.</p>
<p><code>+verbatim</code> means that rustc itself won’t add any target-specified library prefixes or suffixes
(like <code>lib</code> or <code>.a</code>) to the library name, and will try its best to ask for the same thing from the
linker.</p>
<p>For <code>ld</code>-like linkers supporting GNU extensions rustc will use the <code>-l:filename</code> syntax (note the
colon) when passing the library, so the linker won’t add any prefixes or suffixes to it.
See <a href="https://sourceware.org/binutils/docs/ld/Options.html"><code>-l namespec</code></a> in ld documentation for
more details. <br>For linkers not supporting any verbatim modifiers (e.g. <code>link.exe</code> or <code>ld64</code>) the library name will
be passed as is. So the most reliable cross-platform use scenarios for this option are when no
linker is involved, for example bundling native libraries into rlibs.</p>
<p><code>-verbatim</code> means that rustc will either add a target-specific prefix and suffix to the library
name before passing it to linker, or won’t prevent linker from implicitly adding it. <br>In case of <code>raw-dylib</code> kind in particular <code>.dll</code> will be added to the library name on Windows.</p>
<p>The default for this modifier is <code>-verbatim</code>.</p>
<p>NOTE: Even with <code>+verbatim</code> and <code>-l:filename</code> syntax <code>ld</code>-like linkers do not typically support
passing absolute paths to libraries. Usually such paths need to be passed as input files without
using any options like <code>-l</code>, e.g. <code>ld /my/absolute/path</code>. <br><code>-Clink-arg=/my/absolute/path</code> can be used for doing this from stable <code>rustc</code>.</p>
<p><a id="option-crate-type"></a></p>
<h2 id="--crate-type-a-list-of-types-of-crates-for-the-compiler-to-emit"><a class="header" href="#--crate-type-a-list-of-types-of-crates-for-the-compiler-to-emit"><code>--crate-type</code>: a list of types of crates for the compiler to emit</a></h2>
<p>This instructs <code>rustc</code> on which crate type to build. This flag accepts a
comma-separated list of values, and may be specified multiple times. The valid
crate types are:</p>
<ul>
<li><code>lib</code> — Generates a library kind preferred by the compiler, currently
defaults to <code>rlib</code>.</li>
<li><code>rlib</code> — A Rust static library.</li>
<li><code>staticlib</code> — A native static library.</li>
<li><code>dylib</code> — A Rust dynamic library.</li>
<li><code>cdylib</code> — A native dynamic library.</li>
<li><code>bin</code> — A runnable executable program.</li>
<li><code>proc-macro</code> — Generates a format suitable for a procedural macro library
that may be loaded by the compiler.</li>
</ul>
<p>The crate type may be specified with the <a href="../reference/linkage.html"><code>crate_type</code> attribute</a>.
The <code>--crate-type</code> command-line value will override the <code>crate_type</code>
attribute.</p>
<p>More details may be found in the <a href="../reference/linkage.html">linkage chapter</a> of the reference.</p>
<p><a id="option-crate-name"></a></p>
<h2 id="--crate-name-specify-the-name-of-the-crate-being-built"><a class="header" href="#--crate-name-specify-the-name-of-the-crate-being-built"><code>--crate-name</code>: specify the name of the crate being built</a></h2>
<p>This informs <code>rustc</code> of the name of your crate.</p>
<p><a id="option-edition"></a></p>
<h2 id="--edition-specify-the-edition-to-use"><a class="header" href="#--edition-specify-the-edition-to-use"><code>--edition</code>: specify the edition to use</a></h2>
<p>This flag takes a value of <code>2015</code>, <code>2018</code>,<code>2021</code>, or <code>2024</code>. The default is <code>2015</code>. More
information about editions may be found in the <a href="../edition-guide/introduction.html">edition guide</a>.</p>
<p><a id="option-emit"></a></p>
<h2 id="--emit-specifies-the-types-of-output-files-to-generate"><a class="header" href="#--emit-specifies-the-types-of-output-files-to-generate"><code>--emit</code>: specifies the types of output files to generate</a></h2>
<p>This flag controls the types of output files generated by the compiler. It
accepts a comma-separated list of values, and may be specified multiple times.
The valid emit kinds are:</p>
<ul>
<li><code>asm</code> — Generates a file with the crate’s assembly code. The default output
filename is <code>CRATE_NAME.s</code>.</li>
<li><code>dep-info</code> — Generates a file with Makefile syntax that indicates all the
source files that were loaded to generate the crate. The default output
filename is <code>CRATE_NAME.d</code>.</li>
<li><code>link</code> — Generates the crates specified by <code>--crate-type</code>. The default
output filenames depend on the crate type and platform. This is the default
if <code>--emit</code> is not specified.</li>
<li><code>llvm-bc</code> — Generates a binary file containing the <a href="https://llvm.org/docs/BitCodeFormat.html">LLVM bitcode</a>. The
default output filename is <code>CRATE_NAME.bc</code>.</li>
<li><code>llvm-ir</code> — Generates a file containing <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a>. The default output
filename is <code>CRATE_NAME.ll</code>.</li>
<li><code>metadata</code> — Generates a file containing metadata about the crate. The
default output filename is <code>libCRATE_NAME.rmeta</code>.</li>
<li><code>mir</code> — Generates a file containing rustc’s mid-level intermediate
representation. The default output filename is <code>CRATE_NAME.mir</code>.</li>
<li><code>obj</code> — Generates a native object file. The default output filename is
<code>CRATE_NAME.o</code>.</li>
</ul>
<p>The output filename can be set with the <a href="#option-o-output"><code>-o</code> flag</a>. A
suffix may be added to the filename with the
<a href="#extra-filename"><code>-C extra-filename</code> flag</a>.</p>
<p>Output files are written to the current directory unless the
<a href="#option-out-dir"><code>--out-dir</code> flag</a> is used.</p>
<h3 id="custom-paths-for-individual-emit-kinds"><a class="header" href="#custom-paths-for-individual-emit-kinds">Custom paths for individual emit kinds</a></h3>
<p>Each emit type can optionally be followed by <code>=</code> to specify an explicit output
path that only applies to the output of that type. For example:</p>
<ul>
<li><code>--emit=link,dep-info=/path/to/dep-info.d</code>
<ul>
<li>Emit the crate itself as normal,
and also emit dependency info to the specified path.</li>
</ul>
</li>
<li><code>--emit=llvm-ir=-,mir</code>
<ul>
<li>Emit MIR to the default filename (based on crate name),
and emit LLVM IR to stdout.</li>
</ul>
</li>
</ul>
<h3 id="emitting-to-stdout"><a class="header" href="#emitting-to-stdout">Emitting to stdout</a></h3>
<p>When using <code>--emit</code> or <a href="#option-o-output"><code>-o</code></a>, output can be sent to stdout
by specifying <code>-</code> as the path (e.g. <code>-o -</code>).</p>
<p>Binary output types can only be written to stdout if it is not a tty.
Text output types (<code>asm</code>, <code>dep-info</code>, <code>llvm-ir</code> and <code>mir</code>) can be written to
stdout regardless of whether it is a tty or not.</p>
<p>Only one type of output can be written to stdout. Attempting to write multiple
types to stdout at the same time will result in an error.</p>
<p><a id="option-print"></a></p>
<h2 id="--print-print-compiler-information"><a class="header" href="#--print-print-compiler-information"><code>--print</code>: print compiler information</a></h2>
<p>This flag will allow you to set <a href="#print-options">print options</a>.</p>
<p><a id="option-g-debug"></a></p>
<h2 id="-g-include-debug-information"><a class="header" href="#-g-include-debug-information"><code>-g</code>: include debug information</a></h2>
<p>A synonym for <a href="#debuginfo"><code>-C debuginfo=2</code></a>.</p>
<p><a id="option-o-optimize"></a></p>
<h2 id="-o-optimize-your-code"><a class="header" href="#-o-optimize-your-code"><code>-O</code>: optimize your code</a></h2>
<p>A synonym for <a href="#opt-level"><code>-C opt-level=3</code></a>.</p>
<p><a id="option-o-output"></a></p>
<h2 id="-o-filename-of-the-output"><a class="header" href="#-o-filename-of-the-output"><code>-o</code>: filename of the output</a></h2>
<p>This flag controls the output filename.</p>
<p><a id="option-out-dir"></a></p>
<h2 id="--out-dir-directory-to-write-the-output-in"><a class="header" href="#--out-dir-directory-to-write-the-output-in"><code>--out-dir</code>: directory to write the output in</a></h2>
<p>The outputted crate will be written to this directory. This flag is ignored if
the <a href="#option-o-output"><code>-o</code> flag</a> is used.</p>
<p><a id="option-explain"></a></p>
<h2 id="--explain-provide-a-detailed-explanation-of-an-error-message"><a class="header" href="#--explain-provide-a-detailed-explanation-of-an-error-message"><code>--explain</code>: provide a detailed explanation of an error message</a></h2>
<p>Each error of <code>rustc</code>’s comes with an error code; this will print
out a longer explanation of a given error.</p>
<p><a id="option-test"></a></p>
<h2 id="--test-build-a-test-harness"><a class="header" href="#--test-build-a-test-harness"><code>--test</code>: build a test harness</a></h2>
<p>When compiling this crate, <code>rustc</code> will ignore your <code>main</code> function
and instead produce a test harness. See the <a href="#tests">Tests chapter</a>
for more information about tests.</p>
<p><a id="option-target"></a></p>
<h2 id="--target-select-a-target-tuple-to-build"><a class="header" href="#--target-select-a-target-tuple-to-build"><code>--target</code>: select a target tuple to build</a></h2>
<p>This controls which <a href="#targets">target</a> to produce.</p>
<p><a id="option-w-warn"></a></p>
<h2 id="-w-set-lint-warnings"><a class="header" href="#-w-set-lint-warnings"><code>-W</code>: set lint warnings</a></h2>
<p>This flag will set which lints should be set to the <a href="#warn">warn level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-force-warn"></a></p>
<h2 id="--force-warn-force-a-lint-to-warn"><a class="header" href="#--force-warn-force-a-lint-to-warn"><code>--force-warn</code>: force a lint to warn</a></h2>
<p>This flag sets the given lint to the <a href="#force-warn">forced warn level</a> and the level cannot be overridden, even ignoring the <a href="#capping-lints">lint caps</a>.</p>
<p><a id="option-a-allow"></a></p>
<h2 id="-a-set-lint-allowed"><a class="header" href="#-a-set-lint-allowed"><code>-A</code>: set lint allowed</a></h2>
<p>This flag will set which lints should be set to the <a href="#allow">allow level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-d-deny"></a></p>
<h2 id="-d-set-lint-denied"><a class="header" href="#-d-set-lint-denied"><code>-D</code>: set lint denied</a></h2>
<p>This flag will set which lints should be set to the <a href="#deny">deny level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-f-forbid"></a></p>
<h2 id="-f-set-lint-forbidden"><a class="header" href="#-f-set-lint-forbidden"><code>-F</code>: set lint forbidden</a></h2>
<p>This flag will set which lints should be set to the <a href="#forbid">forbid level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-z-unstable"></a></p>
<h2 id="-z-set-unstable-options"><a class="header" href="#-z-set-unstable-options"><code>-Z</code>: set unstable options</a></h2>
<p>This flag will allow you to set unstable options of rustc. In order to set multiple options,
the -Z flag can be used multiple times. For example: <code>rustc -Z verbose-internals -Z time-passes</code>.
Specifying options with -Z is only available on nightly. To view all available options
run: <code>rustc -Z help</code>, or see <a href="../unstable-book/index.html">The Unstable Book</a>.</p>
<p><a id="option-cap-lints"></a></p>
<h2 id="--cap-lints-set-the-most-restrictive-lint-level"><a class="header" href="#--cap-lints-set-the-most-restrictive-lint-level"><code>--cap-lints</code>: set the most restrictive lint level</a></h2>
<p>This flag lets you ‘cap’ lints, for more, <a href="#capping-lints">see here</a>.</p>
<p><a id="option-codegen"></a></p>
<h2 id="-c--codegen-code-generation-options"><a class="header" href="#-c--codegen-code-generation-options"><code>-C</code>/<code>--codegen</code>: code generation options</a></h2>
<p>This flag will allow you to set <a href="#codegen-options">codegen options</a>.</p>
<p><a id="option-version"></a></p>
<h2 id="-v--version-print-a-version"><a class="header" href="#-v--version-print-a-version"><code>-V</code>/<code>--version</code>: print a version</a></h2>
<p>This flag will print out <code>rustc</code>’s version.</p>
<p><a id="option-verbose"></a></p>
<h2 id="-v--verbose-use-verbose-output"><a class="header" href="#-v--verbose-use-verbose-output"><code>-v</code>/<code>--verbose</code>: use verbose output</a></h2>
<p>This flag, when combined with other flags, makes them produce extra output.</p>
<p><a id="option-extern"></a></p>
<h2 id="--extern-specify-where-an-external-library-is-located"><a class="header" href="#--extern-specify-where-an-external-library-is-located"><code>--extern</code>: specify where an external library is located</a></h2>
<p>This flag allows you to pass the name and location for an external crate of a
direct dependency. Indirect dependencies (dependencies of dependencies) are
located using the <a href="#option-l-search-path"><code>-L</code> flag</a>. The given crate name is
added to the <a href="../reference/names/preludes.html#extern-prelude">extern prelude</a>, similar to specifying <code>extern crate</code> within the
root module. The given crate name does not need to match the name
the library was built with.</p>
<p>Specifying <code>--extern</code> has one behavior difference from <code>extern crate</code>:
<code>--extern</code> merely makes the crate a <em>candidate</em> for being linked; it does not
actually link it unless it’s actively used. In rare occasions you may wish
to ensure a crate is linked even if you don’t actively use it from your
code: for example, if it changes the global allocator or if it contains
<code>#[no_mangle]</code> symbols for use by other programming languages. In such
cases you’ll need to use <code>extern crate</code>.</p>
<p>This flag may be specified multiple times. This flag takes an argument with
either of the following formats:</p>
<ul>
<li><code>CRATENAME=PATH</code> — Indicates the given crate is found at the given path.</li>
<li><code>CRATENAME</code> — Indicates the given crate may be found in the search path,
such as within the sysroot or via the <code>-L</code> flag.</li>
</ul>
<p>The same crate name may be specified multiple times for different crate types.
If both an <code>rlib</code> and <code>dylib</code> are found, an internal algorithm is used to
decide which to use for linking. The <a href="#prefer-dynamic"><code>-C prefer-dynamic</code>
flag</a> may be used to influence which is used.</p>
<p>If the same crate name is specified with and without a path, the one with the
path is used and the pathless flag has no effect.</p>
<p><a id="option-sysroot"></a></p>
<h2 id="--sysroot-override-the-system-root"><a class="header" href="#--sysroot-override-the-system-root"><code>--sysroot</code>: Override the system root</a></h2>
<p>The “sysroot” is where <code>rustc</code> looks for the crates that come with the Rust
distribution; this flag allows that to be overridden.</p>
<p><a id="option-error-format"></a></p>
<h2 id="--error-format-control-how-errors-are-produced"><a class="header" href="#--error-format-control-how-errors-are-produced"><code>--error-format</code>: control how errors are produced</a></h2>
<p>This flag lets you control the format of messages. Messages are printed to
stderr. The valid options are:</p>
<ul>
<li><code>human</code> — Human-readable output. This is the default.</li>
<li><code>json</code> — Structured JSON output. See <a href="#json-output">the JSON chapter</a> for more detail.</li>
<li><code>short</code> — Short, one-line messages.</li>
</ul>
<p><a id="option-color"></a></p>
<h2 id="--color-configure-coloring-of-output"><a class="header" href="#--color-configure-coloring-of-output"><code>--color</code>: configure coloring of output</a></h2>
<p>This flag lets you control color settings of the output. The valid options
are:</p>
<ul>
<li><code>auto</code> — Use colors if output goes to a tty. This is the default.</li>
<li><code>always</code> — Always use colors.</li>
<li><code>never</code> — Never colorize output.</li>
</ul>
<p><a id="option-diagnostic-width"></a></p>
<h2 id="--diagnostic-width-specify-the-terminal-width-for-diagnostics"><a class="header" href="#--diagnostic-width-specify-the-terminal-width-for-diagnostics"><code>--diagnostic-width</code>: specify the terminal width for diagnostics</a></h2>
<p>This flag takes a number that specifies the width of the terminal in characters.
Formatting of diagnostics will take the width into consideration to make them better fit on the screen.</p>
<p><a id="option-remap-path-prefix"></a></p>
<h2 id="--remap-path-prefix-remap-source-paths-in-output"><a class="header" href="#--remap-path-prefix-remap-source-paths-in-output"><code>--remap-path-prefix</code>: remap source paths in output</a></h2>
<p>Remap source path prefixes in all output, including compiler diagnostics,
debug information, macro expansions, etc. It takes a value of the form <code>FROM=TO</code>
where a path prefix equal to <code>FROM</code> is rewritten to the value <code>TO</code>. This flag may be
specified multiple times.</p>
<p>Refer to the <a href="#remap-source-paths">Remap source paths</a> section of this book for
further details and explanation.</p>
<p><a id="option-remap-path-scope"></a></p>
<h2 id="--remap-path-scope-remap-source-paths-in-output"><a class="header" href="#--remap-path-scope-remap-source-paths-in-output"><code>--remap-path-scope</code>: remap source paths in output</a></h2>
<p>Defines which scopes of paths should be remapped by <code>--remap-path-prefix</code>.</p>
<p>Refer to the <a href="#remap-source-paths">Remap source paths</a> section of this book for
further details and explanation.</p>
<p><a id="option-json"></a></p>
<h2 id="--json-configure-json-messages-printed-by-the-compiler"><a class="header" href="#--json-configure-json-messages-printed-by-the-compiler"><code>--json</code>: configure json messages printed by the compiler</a></h2>
<p>When the <a href="#option-error-format"><code>--error-format=json</code> option</a> is passed to
rustc then all of the compiler’s diagnostic output will be emitted in the form
of JSON blobs. The <code>--json</code> argument can be used in conjunction with
<code>--error-format=json</code> to configure what the JSON blobs contain as well as
which ones are emitted.</p>
<p>With <code>--error-format=json</code> the compiler will always emit any compiler errors as
a JSON blob, but the following options are also available to the <code>--json</code> flag
to customize the output:</p>
<ul>
<li>
<p><code>diagnostic-short</code> - json blobs for diagnostic messages should use the “short”
rendering instead of the normal “human” default. This means that the output of
<code>--error-format=short</code> will be embedded into the JSON diagnostics instead of
the default <code>--error-format=human</code>.</p>
</li>
<li>
<p><code>diagnostic-rendered-ansi</code> - by default JSON blobs in their <code>rendered</code> field
will contain a plain text rendering of the diagnostic. This option instead
indicates that the diagnostic should have embedded ANSI color codes intended
to be used to colorize the message in the manner rustc typically already does
for terminal outputs. Note that this is usefully combined with crates like
<a href="https://crates.io/crates/fwdansi"><code>fwdansi</code></a> to translate these ANSI codes
on Windows to console commands or
<a href="https://crates.io/crates/strip-ansi-escapes"><code>strip-ansi-escapes</code></a> if you’d
like to optionally remove the ansi colors afterwards.</p>
</li>
<li>
<p><code>artifacts</code> - this instructs rustc to emit a JSON blob for each artifact that
is emitted. An artifact corresponds to a request from the <a href="#option-emit"><code>--emit</code> CLI
argument</a>, and as soon as the artifact is available on the
filesystem a notification will be emitted.</p>
</li>
<li>
<p><code>future-incompat</code> - includes a JSON message that contains a report if the
crate contains any code that may fail to compile in the future.</p>
</li>
<li>
<p><code>timings</code> - output a JSON message when a certain compilation “section”
(such as frontend analysis, code generation, linking) begins or ends.</p>
</li>
</ul>
<p>Note that it is invalid to combine the <code>--json</code> argument with the
<a href="#option-color"><code>--color</code></a> argument, and it is required to combine <code>--json</code>
with <code>--error-format=json</code>.</p>
<p>See <a href="#json-output">the JSON chapter</a> for more detail.</p>
<p><a id="at-path"></a></p>
<h2 id="path-load-command-line-flags-from-a-path"><a class="header" href="#path-load-command-line-flags-from-a-path"><code>@path</code>: load command-line flags from a path</a></h2>
<p>If you specify <code>@path</code> on the command-line, then it will open <code>path</code> and read
command line options from it. These options are one per line; a blank line indicates
an empty option. The file can use Unix or Windows style line endings, and must be
encoded as UTF-8.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="print-options"><a class="header" href="#print-options">Print Options</a></h1>
<p>All of these options are passed to <code>rustc</code> via the <code>--print</code> flag.</p>
<p>Those options prints out various information about the compiler. Multiple options can be
specified, and the information is printed in the order the options are specified.</p>
<p>Specifying an option will usually disable the <a href="#option-emit"><code>--emit</code></a>
step and will only print the requested information.</p>
<p>A filepath may optionally be specified for each requested information kind, in the format
<code>--print KIND=PATH</code>, just like for <code>--emit</code>. When a path is specified, information will be
written there instead of to stdout.</p>
<h2 id="crate-name"><a class="header" href="#crate-name"><code>crate-name</code></a></h2>
<p>The name of the crate.</p>
<p>Generally coming from either from the <code>#![crate_name = "..."]</code> attribute,
<a href="#option-crate-name"><code>--crate-name</code> flag</a> or the filename.</p>
<p>Example:</p>
<pre><code class="language-bash">$ rustc --print crate-name --crate-name my_crate a.rs
my_crate
</code></pre>
<h2 id="file-names"><a class="header" href="#file-names"><code>file-names</code></a></h2>
<p>The names of the files created by the <code>link</code> emit kind.</p>
<h2 id="sysroot"><a class="header" href="#sysroot"><code>sysroot</code></a></h2>
<p>Absolute path to the sysroot.</p>
<p>Example (with rustup and the stable toolchain):</p>
<pre><code class="language-bash">$ rustc --print sysroot a.rs
/home/[REDACTED]/.rustup/toolchains/stable-x86_64-unknown-linux-gnu
</code></pre>
<h2 id="target-libdir"><a class="header" href="#target-libdir"><code>target-libdir</code></a></h2>
<p>Path to the target libdir.</p>
<p>Example (with rustup and the stable toolchain):</p>
<pre><code class="language-bash">$ rustc --print target-libdir a.rs
/home/[REDACTED]/.rustup/toolchains/beta-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib
</code></pre>
<h2 id="host-tuple"><a class="header" href="#host-tuple"><code>host-tuple</code></a></h2>
<p>The target-tuple string of the host compiler.</p>
<p>Example:</p>
<pre><code class="language-bash">$ rustc --print host-tuple a.rs
x86_64-unknown-linux-gnu
</code></pre>
<p>Example with the <code>--target</code> flag:</p>
<pre><code class="language-bash">$ rustc --print host-tuple --target "armv7-unknown-linux-gnueabihf" a.rs
x86_64-unknown-linux-gnu
</code></pre>
<h2 id="cfg"><a class="header" href="#cfg"><code>cfg</code></a></h2>
<p>List of cfg values. See <a href="../reference/conditional-compilation.html">conditional compilation</a> for more information about cfg values.</p>
<p>Example (for <code>x86_64-unknown-linux-gnu</code>):</p>
<pre><code class="language-bash">$ rustc --print cfg a.rs
debug_assertions
panic="unwind"
target_abi=""
target_arch="x86_64"
target_endian="little"
target_env="gnu"
target_family="unix"
target_feature="fxsr"
target_feature="sse"
target_feature="sse2"
target_has_atomic="16"
target_has_atomic="32"
target_has_atomic="64"
target_has_atomic="8"
target_has_atomic="ptr"
target_os="linux"
target_pointer_width="64"
target_vendor="unknown"
unix
</code></pre>
<h2 id="target-list"><a class="header" href="#target-list"><code>target-list</code></a></h2>
<p>List of known targets. The target may be selected with the <code>--target</code> flag.</p>
<h2 id="target-cpus"><a class="header" href="#target-cpus"><code>target-cpus</code></a></h2>
<p>List of available CPU values for the current target. The target CPU may be selected with
the <a href="#target-cpu"><code>-C target-cpu=val</code> flag</a>.</p>
<h2 id="target-features"><a class="header" href="#target-features"><code>target-features</code></a></h2>
<p>List of available target features for the <em>current target</em>.</p>
<p>Target features may be enabled with the <strong>unsafe</strong>
<a href="#target-feature"><code>-C target-feature=val</code> flag</a>.</p>
<p>See <a href="#known-issues">known issues</a> for more details.</p>
<h2 id="relocation-models"><a class="header" href="#relocation-models"><code>relocation-models</code></a></h2>
<p>List of relocation models. Relocation models may be selected with the
<a href="#relocation-model"><code>-C relocation-model=val</code> flag</a>.</p>
<p>Example:</p>
<pre><code class="language-bash">$ rustc --print relocation-models a.rs
Available relocation models:
    static
    pic
    pie
    dynamic-no-pic
    ropi
    rwpi
    ropi-rwpi
    default
</code></pre>
<h2 id="code-models"><a class="header" href="#code-models"><code>code-models</code></a></h2>
<p>List of code models. Code models may be selected with the
<a href="#code-model"><code>-C code-model=val</code> flag</a>.</p>
<p>Example:</p>
<pre><code class="language-bash">$ rustc --print code-models a.rs
Available code models:
    tiny
    small
    kernel
    medium
    large
</code></pre>
<h2 id="tls-models"><a class="header" href="#tls-models"><code>tls-models</code></a></h2>
<p>List of Thread Local Storage models supported. The model may be selected with the
<code>-Z tls-model=val</code> flag.</p>
<p>Example:</p>
<pre><code class="language-bash">$ rustc --print tls-models a.rs
Available TLS models:
    global-dynamic
    local-dynamic
    initial-exec
    local-exec
    emulated
</code></pre>
<h2 id="native-static-libs"><a class="header" href="#native-static-libs"><code>native-static-libs</code></a></h2>
<p>This may be used when creating a <code>staticlib</code> crate type.</p>
<p>If this is the only flag, it will perform a full compilation and include a diagnostic note
that indicates the linker flags to use when linking the resulting static library.</p>
<p>The note starts with the text <code>native-static-libs:</code> to make it easier to fetch the output.</p>
<p>Example:</p>
<pre><code class="language-bash">$ rustc --print native-static-libs --crate-type staticlib a.rs
note: link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.

note: native-static-libs: -lgcc_s -lutil [REDACTED] -lpthread -lm -ldl -lc
</code></pre>
<h2 id="link-args"><a class="header" href="#link-args"><code>link-args</code></a></h2>
<p>This flag does not disable the <code>--emit</code> step. This can be useful when debugging linker options.</p>
<p>When linking, this flag causes <code>rustc</code> to print the full linker invocation in a human-readable
form. The exact format of this debugging output is not a stable guarantee, other than that it
will include the linker executable and the text of each command-line argument passed to the
linker.</p>
<h2 id="deployment-target"><a class="header" href="#deployment-target"><code>deployment-target</code></a></h2>
<p>The currently selected <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/cross_development/Configuring/configuring.html">deployment target</a> (or minimum OS version) for the selected Apple
platform target.</p>
<p>This value can be used or passed along to other components alongside a Rust build that need
this information, such as C compilers. This returns rustc’s minimum supported deployment target
if no <code>*_DEPLOYMENT_TARGET</code> variable is present in the environment, or otherwise returns the
variable’s parsed value.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="codegen-options"><a class="header" href="#codegen-options">Codegen Options</a></h1>
<p>All of these options are passed to <code>rustc</code> via the <code>-C</code> flag, short for “codegen.” You can see
a version of this list for your exact compiler by running <code>rustc -C help</code>.</p>
<h2 id="ar"><a class="header" href="#ar">ar</a></h2>
<p>This option is deprecated and does nothing.</p>
<h2 id="code-model"><a class="header" href="#code-model">code-model</a></h2>
<p>This option lets you choose which code model to use. <br>Code models put constraints on address ranges that the program and its symbols may use. <br>With smaller address ranges machine instructions
may be able to use more compact addressing modes.</p>
<p>The specific ranges depend on target architectures and addressing modes available to them. <br>For x86 more detailed description of its code models can be found in
<a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf">System V Application Binary Interface</a>
specification.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>tiny</code> - Tiny code model.</li>
<li><code>small</code> - Small code model. This is the default model for majority of supported targets.</li>
<li><code>kernel</code> - Kernel code model.</li>
<li><code>medium</code> - Medium code model.</li>
<li><code>large</code> - Large code model.</li>
</ul>
<p>Supported values can also be discovered by running <code>rustc --print code-models</code>.</p>
<h2 id="codegen-units"><a class="header" href="#codegen-units">codegen-units</a></h2>
<p>This flag controls the maximum number of code generation units the crate is
split into. It takes an integer greater than 0.</p>
<p>When a crate is split into multiple codegen units, LLVM is able to process
them in parallel. Increasing parallelism may speed up compile times, but may
also produce slower code. Setting this to 1 may improve the performance of
generated code, but may be slower to compile.</p>
<p>The default value, if not specified, is 16 for non-incremental builds. For
incremental builds the default is 256 which allows caching to be more granular.</p>
<h2 id="collapse-macro-debuginfo"><a class="header" href="#collapse-macro-debuginfo">collapse-macro-debuginfo</a></h2>
<p>This flag controls whether code locations from a macro definition are collapsed into a single
location associated with that macro’s call site, when generating debuginfo for this crate.</p>
<p>This option, if passed, overrides both default collapsing behavior and <code>#[collapse_debuginfo]</code>
attributes in code.</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>: collapse code locations in debuginfo.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: do not collapse code locations in debuginfo.</li>
<li><code>external</code>: collapse code locations in debuginfo only if the macro comes from a different crate.</li>
</ul>
<h2 id="control-flow-guard"><a class="header" href="#control-flow-guard">control-flow-guard</a></h2>
<p>This flag controls whether LLVM enables the Windows <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">Control Flow
Guard</a>
platform security feature. This flag is currently ignored for non-Windows targets.
It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>, <code>checks</code>, or no value: enable Control Flow Guard.</li>
<li><code>nochecks</code>: emit Control Flow Guard metadata without runtime enforcement checks (this
should only be used for testing purposes as it does not provide security enforcement).</li>
<li><code>n</code>, <code>no</code>, <code>off</code>, <code>false</code>: do not enable Control Flow Guard (the default).</li>
</ul>
<h2 id="debug-assertions"><a class="header" href="#debug-assertions">debug-assertions</a></h2>
<p>This flag lets you turn <code>cfg(debug_assertions)</code> <a href="../reference/conditional-compilation.html#debug_assertions">conditional
compilation</a> on
or off. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>, or no value: enable debug-assertions.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: disable debug-assertions.</li>
</ul>
<p>If not specified, debug assertions are automatically enabled only if the
<a href="#opt-level">opt-level</a> is 0.</p>
<h2 id="debuginfo"><a class="header" href="#debuginfo">debuginfo</a></h2>
<p>This flag controls the generation of debug information. It takes one of the
following values:</p>
<ul>
<li><code>0</code> or <code>none</code>: no debug info at all (the default).</li>
<li><code>line-directives-only</code>: line info directives only. For the nvptx* targets this enables <a href="https://reviews.llvm.org/D46061">profiling</a>. For other use cases, <code>line-tables-only</code> is the better, more compatible choice.</li>
<li><code>line-tables-only</code>: line tables only. Generates the minimal amount of debug info for backtraces with filename/line number info, but not anything else, i.e. no variable or function parameter info.</li>
<li><code>1</code> or <code>limited</code>: debug info without type or variable-level information.</li>
<li><code>2</code> or <code>full</code>: full debug info.</li>
</ul>
<p>Note: The <a href="#option-g-debug"><code>-g</code> flag</a> is an alias for <code>-C debuginfo=2</code>.</p>
<h2 id="default-linker-libraries"><a class="header" href="#default-linker-libraries">default-linker-libraries</a></h2>
<p>This flag controls whether or not the linker includes its default libraries.
It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>: include default libraries.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code> or no value: exclude default libraries (the default).</li>
</ul>
<p>For example, for gcc flavor linkers, this issues the <code>-nodefaultlibs</code> flag to
the linker.</p>
<h2 id="dlltool"><a class="header" href="#dlltool">dlltool</a></h2>
<p>On <code>windows-gnu</code> targets, this flag controls which dlltool <code>rustc</code> invokes to
generate import libraries when using the <a href="../reference/items/external-blocks.html#the-link-attribute"><code>raw-dylib</code> link kind</a>.
It takes a path to <a href="https://sourceware.org/binutils/docs/binutils/dlltool.html">the dlltool executable</a>.
If this flag is not specified, a dlltool executable will be inferred based on
the host environment and target.</p>
<h2 id="dwarf-version"><a class="header" href="#dwarf-version">dwarf-version</a></h2>
<p>This option controls the version of DWARF that the compiler emits, on platforms
that use DWARF to encode debug information. It takes one of the following
values:</p>
<ul>
<li><code>2</code>: DWARF version 2 (the default on certain platforms, like Android).</li>
<li><code>3</code>: DWARF version 3 (the default on certain platforms, like AIX).</li>
<li><code>4</code>: DWARF version 4 (the default on most platforms, like Linux &amp; macOS).</li>
<li><code>5</code>: DWARF version 5.</li>
</ul>
<p>DWARF version 1 is not supported.</p>
<h2 id="embed-bitcode"><a class="header" href="#embed-bitcode">embed-bitcode</a></h2>
<p>This flag controls whether or not the compiler embeds LLVM bitcode into object
files. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: put bitcode in rlibs (the default).</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: omit bitcode from rlibs.</li>
</ul>
<p>LLVM bitcode is required when rustc is performing link-time optimization (LTO).
Embedded bitcode will appear in rustc-generated object files inside of a section
whose name is defined by the target platform. Most of the time this is <code>.llvmbc</code>.</p>
<p>The use of <code>-C embed-bitcode=no</code> can significantly improve compile times and
reduce generated file sizes if your compilation does not actually need bitcode
(e.g. if you’re not performing LTO). For these reasons, Cargo uses <code>-C embed-bitcode=no</code>
whenever possible. Likewise, if you are building directly with <code>rustc</code> we recommend
using <code>-C embed-bitcode=no</code> whenever you are not using LTO.</p>
<p>If combined with <code>-C lto</code>, <code>-C embed-bitcode=no</code> will cause <code>rustc</code> to abort
at start-up, because the combination is invalid.</p>
<blockquote>
<p><strong>Note</strong>: if you’re building Rust code with LTO then you probably don’t even
need the <code>embed-bitcode</code> option turned on. You’ll likely want to use
<code>-Clinker-plugin-lto</code> instead which skips generating object files entirely and
simply replaces object files with LLVM bitcode. The only purpose for
<code>-Cembed-bitcode</code> is when you’re generating an rlib that is both being used
with and without LTO. For example Rust’s standard library ships with embedded
bitcode since users link to it both with and without LTO.</p>
<p>This also may make you wonder why the default is <code>yes</code> for this option. The
reason for that is that it’s how it was for rustc 1.44 and prior. In 1.45 this
option was added to turn off what had always been the default.</p>
</blockquote>
<h2 id="extra-filename"><a class="header" href="#extra-filename">extra-filename</a></h2>
<p>This option allows you to put extra data in each output filename. It takes a
string to add as a suffix to the filename. See the <a href="#option-emit"><code>--emit</code>
flag</a> for more information.</p>
<h2 id="force-frame-pointers"><a class="header" href="#force-frame-pointers">force-frame-pointers</a></h2>
<p>This flag forces the use of frame pointers. It takes one of the following
values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: force-enable frame pointers.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: do not force-enable frame pointers. This does
not necessarily mean frame pointers will be removed.</li>
</ul>
<p>The default behaviour, if frame pointers are not force-enabled, depends on the
target.</p>
<h2 id="force-unwind-tables"><a class="header" href="#force-unwind-tables">force-unwind-tables</a></h2>
<p>This flag forces the generation of unwind tables. It takes one of the following
values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: Unwind tables are forced to be generated.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: Unwind tables are not forced to be generated. If unwind
tables are required by the target an error will be emitted.</li>
</ul>
<p>The default if not specified depends on the target.</p>
<h2 id="incremental"><a class="header" href="#incremental">incremental</a></h2>
<p>This flag allows you to enable incremental compilation, which allows <code>rustc</code>
to save information after compiling a crate to be reused when recompiling the
crate, improving re-compile times. This takes a path to a directory where
incremental files will be stored.</p>
<p>Using incremental compilation inhibits certain optimizations (for example by increasing the amount of codegen units) and is therefore not recommended for release builds.</p>
<h2 id="inline-threshold"><a class="header" href="#inline-threshold">inline-threshold</a></h2>
<p>This option is deprecated and does nothing.</p>
<p>Consider using <code>-Cllvm-args=--inline-threshold=...</code>.</p>
<h2 id="instrument-coverage"><a class="header" href="#instrument-coverage">instrument-coverage</a></h2>
<p>This option enables instrumentation-based code coverage support. See the
chapter on <a href="#instrumentation-based-code-coverage">instrumentation-based code coverage</a> for more information.</p>
<p>Note that while the <code>-C instrument-coverage</code> option is stable, the profile data
format produced by the resulting instrumentation may change, and may not work
with coverage tools other than those built and shipped with the compiler.</p>
<h2 id="jump-tables"><a class="header" href="#jump-tables">jump-tables</a></h2>
<p>This option is used to allow or prevent the LLVM codegen backend from creating
jump tables when lowering switches from Rust code.</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: allow jump tables (the default).</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: disable jump tables.</li>
</ul>
<p>To prevent jump tables being created from Rust code, a target must ensure
all crates are compiled with jump tables disabled.</p>
<p>Note, in many cases the Rust toolchain is distributed with precompiled
crates, such as the core and std crates, which could possibly include
jump tables. Furthermore, this option does not guarantee a target will
be free of jump tables. They could arise from external dependencies,
inline asm, or other complicated interactions when using crates which
are compiled with jump table support.</p>
<p>Disabling jump tables can be used to help provide protection against
jump-oriented-programming (JOP) attacks.</p>
<h2 id="link-arg"><a class="header" href="#link-arg">link-arg</a></h2>
<p>This flag lets you append a single extra argument to the linker invocation.</p>
<p>“Append” is significant; you can pass this flag multiple times to add multiple arguments.</p>
<p>On Unix-like targets that use <code>cc</code> as the linker driver, use <code>-Clink-arg=-Wl,$ARG</code> to pass an argument to the actual linker.</p>
<h2 id="link-args-1"><a class="header" href="#link-args-1">link-args</a></h2>
<p>This flag lets you append multiple extra arguments to the linker invocation. The
options should be separated by spaces.</p>
<h2 id="link-dead-code"><a class="header" href="#link-dead-code">link-dead-code</a></h2>
<p>Tries to generate and link dead code that would otherwise not be generated or
linked. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: try to keep dead code.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: remove dead code (the default).</li>
</ul>
<p>This flag was historically used to help improve some older forms of code
coverage measurement. Its use is not recommended.</p>
<h2 id="link-self-contained"><a class="header" href="#link-self-contained">link-self-contained</a></h2>
<p>This flag controls whether the linker will use libraries and objects shipped with Rust instead of
those in the system.  It also controls which binary is used for the linker itself. This allows
overriding cases when detection fails or the user wants to use shipped libraries.</p>
<p>You can enable or disable the usage of any self-contained components using one of the following values:</p>
<ul>
<li>no value: rustc will use heuristic to disable self-contained mode if system has necessary tools.</li>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>: use only libraries/objects shipped with Rust.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: rely on the user or the linker to provide non-Rust libraries/objects.</li>
</ul>
<p>It is also possible to enable or disable specific self-contained components in a more granular way.
You can pass a comma-separated list of self-contained components, individually enabled
(<code>+component</code>) or disabled (<code>-component</code>).</p>
<p>Currently, only the <code>linker</code> granular option is stabilized, and only on the <code>x86_64-unknown-linux-gnu</code> target:</p>
<ul>
<li><code>linker</code>: toggle the usage of self-contained linker binaries (linker, dlltool, and their necessary libraries)</li>
</ul>
<p>Note that only the <code>-linker</code> opt-out is stable on the <code>x86_64-unknown-linux-gnu</code> target: <code>+linker</code> is
already the default on this target.</p>
<h4 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation notes</a></h4>
<p>On the <code>x86_64-unknown-linux-gnu</code> target, when using the default linker flavor (using <code>cc</code> as the
linker driver) and linker features (to try using <code>lld</code>), <code>rustc</code> will try to use the self-contained
linker by passing a <code>-B /path/to/sysroot/</code> link argument to the driver to find <code>rust-lld</code> in the
sysroot. For backwards-compatibility, and to limit name and <code>PATH</code> collisions, this is done using a
shim executable (the <code>lld-wrapper</code> tool) that forwards execution to the <code>rust-lld</code> executable itself.</p>
<h2 id="linker"><a class="header" href="#linker">linker</a></h2>
<p>This flag controls which linker <code>rustc</code> invokes to link your code. It takes a
path to the linker executable. If this flag is not specified, the linker will
be inferred based on the target. See also the <a href="#linker-flavor">linker-flavor</a>
flag for another way to specify the linker.</p>
<p>Note that on Unix-like targets (for example, <code>*-unknown-linux-gnu</code> or <code>*-unknown-freebsd</code>)
the C compiler (for example <code>cc</code> or <code>clang</code>) is used as the “linker” here, serving as a linker driver.
It will invoke the actual linker with all the necessary flags to be able to link against the system libraries like libc.</p>
<h2 id="linker-features"><a class="header" href="#linker-features">linker-features</a></h2>
<p>The <code>-Clinker-features</code> flag allows enabling or disabling specific features used during linking.</p>
<p>These feature flags are a flexible extension mechanism that is complementary to linker flavors,
designed to avoid the combinatorial explosion of having to create a new set of flavors for each
linker feature we’d want to use.</p>
<p>The flag accepts a comma-separated list of features, individually enabled (<code>+feature</code>) or disabled
(<code>-feature</code>).</p>
<p>Currently only one is stable, and only on the <code>x86_64-unknown-linux-gnu</code> target:</p>
<ul>
<li><code>lld</code>: to toggle trying to use the lld linker, either the system-installed binary, or the self-contained
<code>rust-lld</code> linker (via the <a href="#link-self-contained"><code>-Clink-self-contained=+linker</code></a> flag).</li>
</ul>
<p>For example, use:</p>
<ul>
<li><code>-Clinker-features=+lld</code> to opt into using the <code>lld</code> linker, when possible (see the Implementation notes below)</li>
<li><code>-Clinker-features=-lld</code> to opt out instead, for targets where it is configured as the default linker</li>
</ul>
<p>Note that only the <code>-lld</code> opt-out is stable on the <code>x86_64-unknown-linux-gnu</code> target: <code>+lld</code> is
already the default on this target.</p>
<h4 id="implementation-notes-1"><a class="header" href="#implementation-notes-1">Implementation notes</a></h4>
<p>On the <code>x86_64-unknown-linux-gnu</code> target, when using the default linker flavor (using <code>cc</code> as the
linker driver), <code>rustc</code> will try to use lld by passing a <code>-fuse-ld=lld</code> link argument to the driver.
<code>rustc</code> will also try to detect if that <em>causes</em> an error during linking (for example, if GCC is too
old to understand the flag, and returns an error) and will then retry linking without this argument,
as a fallback.</p>
<p>If the user <em>also</em> passes a <code>-Clink-arg=-fuse-ld=$value</code>, both will be given to the linker
driver but the user’s will be passed last, and would generally have priority over <code>rustc</code>’s.</p>
<h2 id="linker-flavor"><a class="header" href="#linker-flavor">linker-flavor</a></h2>
<p>This flag controls the linker flavor used by <code>rustc</code>. If a linker is given with
the <a href="#linker"><code>-C linker</code> flag</a>, then the linker flavor is inferred from the
value provided. If no linker is given then the linker flavor is used to
determine the linker to use. Every <code>rustc</code> target defaults to some linker
flavor. Valid options are:</p>
<ul>
<li><code>em</code>: use <a href="https://emscripten.org/docs/tools_reference/emcc.html">Emscripten <code>emcc</code></a>.</li>
<li><code>gcc</code>: use the <code>cc</code> executable, which is typically gcc or clang on many systems.</li>
<li><code>ld</code>: use the <code>ld</code> executable.</li>
<li><code>msvc</code>: use the <code>link.exe</code> executable from Microsoft Visual Studio MSVC.</li>
<li><code>wasm-ld</code>: use the <a href="https://lld.llvm.org/WebAssembly.html"><code>wasm-ld</code></a>
executable, a port of LLVM <code>lld</code> for WebAssembly.</li>
<li><code>ld64.lld</code>: use the LLVM <code>lld</code> executable with the <a href="https://releases.llvm.org/12.0.0/tools/lld/docs/Driver.html"><code>-flavor darwin</code>
flag</a> for Apple’s <code>ld</code>.</li>
<li><code>ld.lld</code>: use the LLVM <code>lld</code> executable with the <a href="https://releases.llvm.org/12.0.0/tools/lld/docs/Driver.html"><code>-flavor gnu</code>
flag</a> for GNU binutils’ <code>ld</code>.</li>
<li><code>lld-link</code>: use the LLVM <code>lld</code> executable with the <a href="https://releases.llvm.org/12.0.0/tools/lld/docs/Driver.html"><code>-flavor link</code>
flag</a> for Microsoft’s <code>link.exe</code>.</li>
</ul>
<h2 id="linker-plugin-lto"><a class="header" href="#linker-plugin-lto">linker-plugin-lto</a></h2>
<p>This flag defers LTO optimizations to the linker. See
<a href="#linker-plugin-based-lto">linker-plugin-LTO</a> for more details. It takes one of
the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: enable linker plugin LTO.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: disable linker plugin LTO (the default).</li>
<li>A path to the linker plugin.</li>
</ul>
<p>More specifically this flag will cause the compiler to replace its typical
object file output with LLVM bitcode files. For example an rlib produced with
<code>-Clinker-plugin-lto</code> will still have <code>*.o</code> files in it, but they’ll all be LLVM
bitcode instead of actual machine code. It is expected that the native platform
linker is capable of loading these LLVM bitcode files and generating code at
link time (typically after performing optimizations).</p>
<p>Note that rustc can also read its own object files produced with
<code>-Clinker-plugin-lto</code>. If an rlib is only ever going to get used later with a
<code>-Clto</code> compilation then you can pass <code>-Clinker-plugin-lto</code> to speed up
compilation and avoid generating object files that aren’t used.</p>
<h2 id="llvm-args"><a class="header" href="#llvm-args">llvm-args</a></h2>
<p>This flag can be used to pass a list of arguments directly to LLVM.</p>
<p>The list must be separated by spaces.</p>
<p>Pass <code>--help</code> to see a list of options.</p>
<div class="warning">
<p>Because this flag directly talks to LLVM, it is not subject to the usual stability guarantees of rustc’s CLI interface.</p>
</div>

<h2 id="lto"><a class="header" href="#lto">lto</a></h2>
<p>This flag controls whether LLVM uses <a href="https://llvm.org/docs/LinkTimeOptimization.html">link time
optimizations</a> to produce
better optimized code, using whole-program analysis, at the cost of longer
linking time. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code>, <code>fat</code>, or no value: perform “fat” LTO which attempts to
perform optimizations across all crates within the dependency graph.</li>
<li><code>thin</code>: perform <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">“thin”
LTO</a>.
This is similar to “fat”, but takes substantially less time to run while
still achieving performance gains similar to “fat”.
For larger projects like the Rust compiler, ThinLTO can even result in better performance than fat LTO.</li>
<li><code>n</code>, <code>no</code>, <code>off</code>, <code>false</code>: disables LTO.</li>
</ul>
<p>If <code>-C lto</code> is not specified, then the compiler will attempt to perform “thin
local LTO” which performs “thin” LTO on the local crate only across its
<a href="#codegen-units">codegen units</a>. When <code>-C lto</code> is not specified, LTO is
disabled if codegen units is 1 or optimizations are disabled (<a href="#opt-level"><code>-C opt-level=0</code></a>). That is:</p>
<ul>
<li>When <code>-C lto</code> is not specified:
<ul>
<li><code>codegen-units=1</code>: disable LTO.</li>
<li><code>opt-level=0</code>: disable LTO.</li>
</ul>
</li>
<li>When <code>-C lto</code> is specified:
<ul>
<li><code>lto</code>: 16 codegen units, perform fat LTO across crates.</li>
<li><code>codegen-units=1</code> + <code>lto</code>: 1 codegen unit, fat LTO across crates.</li>
</ul>
</li>
</ul>
<p>See also <a href="#linker-plugin-lto">linker-plugin-lto</a> for cross-language LTO.</p>
<h2 id="metadata"><a class="header" href="#metadata">metadata</a></h2>
<p>This option allows you to control the metadata used for symbol mangling. This
takes a space-separated list of strings. Mangled symbols will incorporate a
hash of the metadata. This may be used, for example, to differentiate symbols
between two different versions of the same crate being linked.</p>
<h2 id="no-prepopulate-passes"><a class="header" href="#no-prepopulate-passes">no-prepopulate-passes</a></h2>
<p>This flag tells the pass manager to use an empty list of passes, instead of the
usual pre-populated list of passes.</p>
<p>When combined with <code>-O --emit llvm-ir</code>, it can be used to see the optimized LLVM IR emitted by rustc before any optimizations are applied by LLVM.</p>
<h2 id="no-redzone"><a class="header" href="#no-redzone">no-redzone</a></h2>
<p>This flag allows you to disable <a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">the
red zone</a>. It takes one
of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: disable the red zone.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: enable the red zone.</li>
</ul>
<p>The default behaviour, if the flag is not specified, depends on the target.</p>
<h2 id="no-stack-check"><a class="header" href="#no-stack-check">no-stack-check</a></h2>
<p>This option is deprecated and does nothing.</p>
<h2 id="no-vectorize-loops"><a class="header" href="#no-vectorize-loops">no-vectorize-loops</a></h2>
<p>This flag disables <a href="https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer">loop
vectorization</a>.</p>
<h2 id="no-vectorize-slp"><a class="header" href="#no-vectorize-slp">no-vectorize-slp</a></h2>
<p>This flag disables vectorization using
<a href="https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer">superword-level
parallelism</a>.</p>
<h2 id="opt-level"><a class="header" href="#opt-level">opt-level</a></h2>
<p>This flag controls the optimization level.</p>
<ul>
<li><code>0</code>: no optimizations, also turns on
<a href="#debug-assertions"><code>cfg(debug_assertions)</code></a> (the default).</li>
<li><code>1</code>: basic optimizations.</li>
<li><code>2</code>: some optimizations.</li>
<li><code>3</code>: all optimizations.</li>
<li><code>s</code>: optimize for binary size.</li>
<li><code>z</code>: optimize for binary size, but more aggressively. Often results in larger binaries than <code>s</code></li>
</ul>
<p>Note: The <a href="#option-o-optimize"><code>-O</code> flag</a> is an alias for <code>-C opt-level=3</code>.</p>
<p>The default is <code>0</code>.</p>
<h2 id="overflow-checks"><a class="header" href="#overflow-checks">overflow-checks</a></h2>
<p>This flag allows you to control the behavior of <a href="../reference/expressions/operator-expr.html#overflow">runtime integer
overflow</a>. When
overflow-checks are enabled, a panic will occur on overflow. This flag takes
one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: enable overflow checks.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: disable overflow checks.</li>
</ul>
<p>If not specified, overflow checks are enabled if
<a href="#debug-assertions">debug-assertions</a> are enabled, disabled otherwise.</p>
<h2 id="panic"><a class="header" href="#panic">panic</a></h2>
<p>This option lets you control what happens when the code panics.</p>
<ul>
<li><code>abort</code>: terminate the process upon panic</li>
<li><code>immediate-abort</code>: terminate the process upon panic, and do not call any panic hooks</li>
<li><code>unwind</code>: unwind the stack upon panic</li>
</ul>
<p>If not specified, the default depends on the target.</p>
<p>If any crate in the crate graph uses <code>abort</code>, the final binary (<code>bin</code>, <code>dylib</code>, <code>cdylib</code>, <code>staticlib</code>) must also use <code>abort</code>.
If any crate in the crate graph uses <code>immediate-abort</code>, every crate in the graph must use <code>immediate-abort</code>.
If <code>std</code> is used as a <code>dylib</code> with <code>unwind</code>, the final binary must also use <code>unwind</code>.</p>
<h2 id="passes"><a class="header" href="#passes">passes</a></h2>
<p>This flag can be used to add extra <a href="http://llvm.org/docs/Passes.html">LLVM
passes</a> to the compilation.</p>
<p>The list must be separated by spaces.</p>
<p>See also the <a href="#no-prepopulate-passes"><code>no-prepopulate-passes</code></a> flag.</p>
<div class="warning">
<p>Because this flag directly talks to LLVM, it not subject to the usual stability guarantees of rustc’s CLI interface.</p>
</div>

<h2 id="prefer-dynamic"><a class="header" href="#prefer-dynamic">prefer-dynamic</a></h2>
<p>By default, <code>rustc</code> prefers to statically link dependencies. This option will
indicate that dynamic linking should be used if possible if both a static and
dynamic versions of a library are available.</p>
<p>There is <a href="https://github.com/rust-lang/rust/blob/HEAD/compiler/rustc_metadata/src/dependency_format.rs">an internal algorithm</a>
for determining whether or not it is possible to statically or dynamically link
with a dependency.</p>
<p>This flag takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: prefer dynamic linking.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: prefer static linking (the default).</li>
</ul>
<h2 id="profile-generate"><a class="header" href="#profile-generate">profile-generate</a></h2>
<p>This flag allows for creating instrumented binaries that will collect
profiling data for use with profile-guided optimization (PGO). The flag takes
an optional argument which is the path to a directory into which the
instrumented binary will emit the collected data. See the chapter on
<a href="#profile-guided-optimization">profile-guided optimization</a> for more information.</p>
<h2 id="profile-use"><a class="header" href="#profile-use">profile-use</a></h2>
<p>This flag specifies the profiling data file to be used for profile-guided
optimization (PGO). The flag takes a mandatory argument which is the path
to a valid <code>.profdata</code> file. See the chapter on
<a href="#profile-guided-optimization">profile-guided optimization</a> for more information.</p>
<h2 id="relocation-model"><a class="header" href="#relocation-model">relocation-model</a></h2>
<p>This option controls generation of
<a href="https://en.wikipedia.org/wiki/Position-independent_code">position-independent code (PIC)</a>.</p>
<p>Supported values for this option are:</p>
<h4 id="primary-relocation-models"><a class="header" href="#primary-relocation-models">Primary relocation models</a></h4>
<ul>
<li>
<p><code>static</code> - non-relocatable code, machine instructions may use absolute addressing modes.</p>
</li>
<li>
<p><code>pic</code> - fully relocatable position independent code,
machine instructions need to use relative addressing modes.  <br>Equivalent to the “uppercase” <code>-fPIC</code> or <code>-fPIE</code> options in other compilers,
depending on the produced crate types.  <br>This is the default model for majority of supported targets.</p>
</li>
<li>
<p><code>pie</code> - position independent executable, relocatable code but without support for symbol
interpositioning (replacing symbols by name using <code>LD_PRELOAD</code> and similar). Equivalent to the “uppercase” <code>-fPIE</code> option in other compilers. <code>pie</code>
code cannot be linked into shared libraries (you’ll get a linking error on attempt to do this).</p>
</li>
</ul>
<h4 id="special-relocation-models"><a class="header" href="#special-relocation-models">Special relocation models</a></h4>
<ul>
<li><code>dynamic-no-pic</code> - relocatable external references, non-relocatable code.  <br>Only makes sense on Darwin and is rarely used.  <br>If StackOverflow tells you to use this as an opt-out of PIC or PIE, don’t believe it,
use <code>-C relocation-model=static</code> instead.</li>
<li><code>ropi</code>, <code>rwpi</code> and <code>ropi-rwpi</code> - relocatable code and read-only data, relocatable read-write data,
and combination of both, respectively.  <br>Only makes sense for certain embedded ARM targets.</li>
<li><code>default</code> - relocation model default to the current target.  <br>Only makes sense as an override for some other explicitly specified relocation model
previously set on the command line.</li>
</ul>
<p>Supported values can also be discovered by running <code>rustc --print relocation-models</code>.</p>
<h4 id="linking-effects"><a class="header" href="#linking-effects">Linking effects</a></h4>
<p>In addition to codegen effects, <code>relocation-model</code> has effects during linking.</p>
<p>If the relocation model is <code>pic</code> and the current target supports position-independent executables
(PIE), the linker will be instructed (<code>-pie</code>) to produce one.  <br>If the target doesn’t support both position-independent and statically linked executables,
then <code>-C target-feature=+crt-static</code> “wins” over <code>-C relocation-model=pic</code>,
and the linker is instructed (<code>-static</code>) to produce a statically linked
but not position-independent executable.</p>
<h2 id="relro-level"><a class="header" href="#relro-level">relro-level</a></h2>
<p>This flag controls what level of RELRO (Relocation Read-Only) is enabled. RELRO is an exploit
mitigation which makes the Global Offset Table (GOT) read-only.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>off</code>: Dynamically linked functions are resolved lazily and the GOT is writable.</li>
<li><code>partial</code>: Dynamically linked functions are resolved lazily and written into the Procedure
Linking Table (PLT) part of the GOT (<code>.got.plt</code>). The non-PLT part of the GOT (<code>.got</code>) is made
read-only and both are moved to prevent writing from buffer overflows.</li>
<li><code>full</code>: Dynamically linked functions are resolved at the start of program execution and the
Global Offset Table (<code>.got</code>/<code>.got.plt</code>) is populated eagerly and then made read-only. The GOT is
also moved to prevent writing from buffer overflows. Full RELRO uses more memory and increases
process startup time.</li>
</ul>
<p>This flag is ignored on platforms where RELRO is not supported (targets which do not use the ELF
binary format), such as Windows or macOS. Each rustc target has its own default for RELRO. rustc
enables Full RELRO by default on platforms where it is supported.</p>
<h2 id="remark"><a class="header" href="#remark">remark</a></h2>
<p>This flag lets you print remarks for optimization passes.</p>
<p>The list of passes should be separated by spaces.</p>
<p><code>all</code> will remark on every pass.</p>
<h2 id="rpath"><a class="header" href="#rpath">rpath</a></h2>
<p>This flag controls whether rustc sets an <a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a> for the binary.
It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: enable rpath.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: disable rpath (the default).</li>
</ul>
<p>This flag only does something on Unix-like platforms (Mach-O and ELF), it is ignored on other platforms.</p>
<p>If enabled, rustc will add output-relative (using <code>@load_path</code> on Mach-O and <code>$ORIGIN</code> on ELF respectively) rpaths to all <code>dylib</code> dependencies.</p>
<p>For example, for the following directory structure, with <code>libdep.so</code> being a <code>dylib</code> crate compiled with <code>-Cprefer-dynamic</code>:</p>
<pre><code class="language-text">dep
 |- libdep.so
a.rs
</code></pre>
<p><code>rustc a.rs --extern dep=dep/libdep.so -Crpath</code> will, on x86-64 Linux, result in approximately the following <code>DT_RUNPATH</code>: <code>$ORIGIN/dep:$ORIGIN/$RELATIVE_PATH_TO_SYSROOT/lib/rustlib/x86_64-unknown-linux-gnu/lib</code> (where <code>RELATIVE_PATH_TO_SYSROOT</code> depends on the build directory location).</p>
<p>This is primarily useful for local development, to ensure that all the <code>dylib</code> dependencies can be found appropriately.</p>
<p>To set the rpath to a different value (which can be useful for distribution), <code>-Clink-arg</code> with a platform-specific linker argument can be used to set the rpath directly.</p>
<h2 id="save-temps"><a class="header" href="#save-temps">save-temps</a></h2>
<p>This flag controls whether temporary files generated during compilation are
deleted once compilation finishes. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: save temporary files.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: delete temporary files (the default).</li>
</ul>
<h2 id="soft-float"><a class="header" href="#soft-float">soft-float</a></h2>
<p>This option controls whether <code>rustc</code> generates code that emulates floating
point instructions in software. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>true</code> or no value: use soft floats.</li>
<li><code>n</code>, <code>no</code>, <code>off</code> or <code>false</code>: use hardware floats (the default).</li>
</ul>
<p>This flag only works on <code>*eabihf</code> targets and <strong>is unsound and deprecated</strong>.</p>
<h2 id="split-debuginfo"><a class="header" href="#split-debuginfo">split-debuginfo</a></h2>
<p>This option controls the emission of “split debuginfo” for debug information
that <code>rustc</code> generates. The default behavior of this option is
platform-specific, and not all possible values for this option work on all
platforms. Possible values are:</p>
<ul>
<li>
<p><code>off</code> - This is the default for platforms with ELF binaries and windows-gnu
(not Windows MSVC and not macOS). This typically means that DWARF debug
information can be found in the final artifact in sections of the executable.
This option is not supported on Windows MSVC. On macOS this options prevents
the final execution of <code>dsymutil</code> to generate debuginfo.</p>
</li>
<li>
<p><code>packed</code> - This is the default for Windows MSVC and macOS. The term
“packed” here means that all the debug information is packed into a separate
file from the main executable. On Windows MSVC this is a <code>*.pdb</code> file, on
macOS this is a <code>*.dSYM</code> folder, and on other platforms this is a <code>*.dwp</code>
file.</p>
</li>
<li>
<p><code>unpacked</code> - This means that debug information will be found in separate
files for each compilation unit (object file). This is not supported on
Windows MSVC. On macOS this means the original object files will contain
debug information. On other Unix platforms this means that <code>*.dwo</code> files will
contain debug information.</p>
</li>
</ul>
<p>Note that all three options are supported on Linux and Apple platforms,
<code>packed</code> is supported on Windows-MSVC, and all other platforms support <code>off</code>.
Attempting to use an unsupported option requires using the nightly channel
with the <code>-Z unstable-options</code> flag.</p>
<h2 id="strip"><a class="header" href="#strip">strip</a></h2>
<p>The option <code>-C strip=val</code> controls stripping of debuginfo and similar auxiliary
data from binaries during linking.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>none</code> - debuginfo and symbols are not modified.</li>
<li><code>debuginfo</code> - debuginfo sections and debuginfo symbols from the symbol table
section are stripped at link time and are not copied to the produced binary.
This should leave backtraces mostly-intact but may make using a debugger like
gdb or lldb ineffectual. Prior to 1.79, this unintentionally disabled the
generation of <code>*.pdb</code> files on MSVC, resulting in the absence of symbols.</li>
<li><code>symbols</code> - same as <code>debuginfo</code>, but the rest of the symbol table section is
stripped as well, depending on platform support. On platforms which depend on
this symbol table for backtraces, profiling, and similar, this can affect
them so negatively as to make the trace incomprehensible. Programs which may
be combined with others, such as CLI pipelines and developer tooling, or even
anything which wants crash-reporting, should usually avoid <code>-Cstrip=symbols</code>.</li>
</ul>
<p>Note that, at any level, removing debuginfo only necessarily impacts “friendly”
introspection. <code>-Cstrip</code> cannot be relied on as a meaningful security or
obfuscation measure, as disassemblers and decompilers can extract considerable
information even in the absence of symbols.</p>
<h2 id="symbol-mangling-version"><a class="header" href="#symbol-mangling-version">symbol-mangling-version</a></h2>
<p>This option controls the <a href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a> format for encoding Rust item names
for the purpose of generating object code and linking.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>v0</code> — The “v0” mangling scheme.</li>
</ul>
<p>The default, if not specified, will use a compiler-chosen default which may
change in the future.</p>
<p>See the <a href="#symbol-mangling">Symbol Mangling</a> chapter for details on symbol mangling and the mangling format.</p>
<h2 id="target-cpu"><a class="header" href="#target-cpu">target-cpu</a></h2>
<p>This instructs <code>rustc</code> to generate code specifically for a particular processor.</p>
<p>You can run <code>rustc --print target-cpus</code> to see the valid options to pass
and the default target CPU for the current build target.
Each target has a default base CPU. Special values include:</p>
<ul>
<li><code>native</code> can be passed to use the processor of the host machine.</li>
<li><code>generic</code> refers to an LLVM target with minimal features but modern tuning.</li>
</ul>
<h2 id="target-feature"><a class="header" href="#target-feature">target-feature</a></h2>
<p>Individual targets will support different features; this flag lets you control
enabling or disabling a feature. Each feature should be prefixed with a <code>+</code> to
enable it or <code>-</code> to disable it.</p>
<p>Features from multiple <code>-C target-feature</code> options are combined. <br>Multiple features can be specified in a single option by separating them
with commas - <code>-C target-feature=+x,-y</code>. <br>If some feature is specified more than once with both <code>+</code> and <code>-</code>,
then values passed later override values passed earlier. <br>For example, <code>-C target-feature=+x,-y,+z -Ctarget-feature=-x,+y</code>
is equivalent to <code>-C target-feature=-x,+y,+z</code>.</p>
<p>To see the valid options and an example of use, run <code>rustc --print target-features</code>.</p>
<p>Using this flag is unsafe and might result in <a href="#known-issues">undefined runtime
behavior</a>.</p>
<p>See also the <a href="../reference/attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code>
attribute</a>
for controlling features per-function.</p>
<p>This also supports the feature <code>+crt-static</code> and <code>-crt-static</code> to control
<a href="../reference/linkage.html#static-and-dynamic-c-runtimes">static C runtime linkage</a>.</p>
<p>Each target and <a href="#target-cpu"><code>target-cpu</code></a> has a default set of enabled
features.</p>
<h2 id="tune-cpu"><a class="header" href="#tune-cpu">tune-cpu</a></h2>
<p>This instructs <code>rustc</code> to schedule code specifically for a particular
processor. This does not affect the compatibility (instruction sets or ABI),
but should make your code slightly more efficient on the selected CPU.</p>
<p>The valid options are the same as those for <a href="#target-cpu"><code>target-cpu</code></a>.
The default is <code>None</code>, which LLVM translates as the <code>target-cpu</code>.</p>
<p>This is an unstable option. Use <code>-Z tune-cpu=machine</code> to specify a value.</p>
<p>Due to limitations in LLVM (12.0.0-git9218f92), this option is currently
effective only for x86 targets.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="jobserver"><a class="header" href="#jobserver">Jobserver</a></h1>
<p>Internally, <code>rustc</code> may take advantage of parallelism. <code>rustc</code> will coordinate
with the build system calling it if a <a href="https://www.gnu.org/software/make/manual/html_node/POSIX-Jobserver.html">GNU Make jobserver</a> is passed in the
<code>MAKEFLAGS</code> environment variable. Other flags may have an effect as well, such
as <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html"><code>CARGO_MAKEFLAGS</code></a>. If a jobserver is not passed, then <code>rustc</code> will choose
the number of jobs to use.</p>
<p>Starting with Rust 1.76.0, <code>rustc</code> will warn if a jobserver appears to be
available but is not accessible, e.g.:</p>
<pre><code class="language-console">$ echo 'fn main() {}' | MAKEFLAGS=--jobserver-auth=3,4 rustc -
warning: failed to connect to jobserver from environment variable `MAKEFLAGS="--jobserver-auth=3,4"`: cannot open file descriptor 3 from the jobserver environment variable value: Bad file descriptor (os error 9)
  |
  = note: the build environment is likely misconfigured
</code></pre>
<h2 id="integration-with-build-systems"><a class="header" href="#integration-with-build-systems">Integration with build systems</a></h2>
<p>The following subsections contain recommendations on how to integrate <code>rustc</code>
with build systems so that the jobserver is handled appropriately.</p>
<h3 id="gnu-make"><a class="header" href="#gnu-make">GNU Make</a></h3>
<p>When calling <code>rustc</code> from GNU Make, it is recommended that all <code>rustc</code>
invocations are marked as recursive in the <code>Makefile</code> (by prefixing the command
line with the <code>+</code> indicator), so that GNU Make enables the jobserver for them.
For instance:</p>
<!-- ignore-tidy-tab -->
<pre><code class="language-make">x:
	+@echo 'fn main() {}' | rustc -
</code></pre>
<p>In particular, GNU Make 4.3 (a widely used version as of 2024) passes a simple
pipe jobserver in <code>MAKEFLAGS</code> even when it was not made available for the child
process, which in turn means <code>rustc</code> will warn about it. For instance, if the
<code>+</code> indicator is removed from the example above and GNU Make is called with e.g.
<code>make -j2</code>, then the aforementioned warning will trigger.</p>
<p>For calls to <code>rustc</code> inside <code>$(shell ...)</code> inside a recursive Make, one can
disable the jobserver manually by clearing the <code>MAKEFLAGS</code> variable, e.g.:</p>
<pre><code class="language-make">S := $(shell MAKEFLAGS= rustc --print sysroot)

x:
	@$(MAKE) y

y:
	@echo $(S)
</code></pre>
<h3 id="cmake"><a class="header" href="#cmake">CMake</a></h3>
<p>CMake 3.28 supports the <code>JOB_SERVER_AWARE</code> option in its <a href="https://cmake.org/cmake/help/latest/command/add_custom_target.html"><code>add_custom_target</code></a>
command, e.g.:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.28)
project(x)
add_custom_target(x
    JOB_SERVER_AWARE TRUE
    COMMAND echo 'fn main() {}' | rustc -
)
</code></pre>
<p>For earlier versions, when using CMake with the Makefile generator, one
workaround is to have <a href="https://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html"><code>$(MAKE)</code></a> somewhere in the command so that GNU Make
treats it as a recursive Make call, e.g.:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.22)
project(x)
add_custom_target(x
    COMMAND DUMMY_VARIABLE=$(MAKE) echo 'fn main() {}' | rustc -
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lints"><a class="header" href="#lints">Lints</a></h1>
<p>In software, a “lint” is a tool used to help improve your source code. The
Rust compiler contains a number of lints, and when it compiles your code, it will
also run the lints. These lints may produce a warning, an error, or nothing at all,
depending on how you’ve configured things.</p>
<p>Here’s a small example:</p>
<pre><code class="language-bash">$ cat main.rs
fn main() {
    let x = 5;
}
$ rustc main.rs
warning: unused variable: `x`
 --&gt; main.rs:2:9
  |
2 |     let x = 5;
  |         ^
  |
  = note: `#[warn(unused_variables)]` on by default
  = note: to avoid this warning, consider using `_x` instead
</code></pre>
<p>This is the <code>unused_variables</code> lint, and it tells you that you’ve introduced
a variable that you don’t use in your code. That’s not <em>wrong</em>, so it’s not
an error, but it might be a bug, so you get a warning.</p>
<h2 id="future-incompatible-lints"><a class="header" href="#future-incompatible-lints">Future-incompatible lints</a></h2>
<p>Sometimes the compiler needs to be changed to fix an issue that can cause
existing code to stop compiling. “Future-incompatible” lints are issued in
these cases to give users of Rust a smooth transition to the new behavior.
Initially, the compiler will continue to accept the problematic code and issue
a warning. The warning has a description of the problem, a notice that this
will become an error in the future, and a link to a tracking issue that
provides detailed information and an opportunity for feedback. This gives
users some time to fix the code to accommodate the change. After some time,
the warning may become an error.</p>
<p>The following is an example of what a future-incompatible looks like:</p>
<pre><code class="language-text">warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)
  --&gt; lint_example.rs:11:13
   |
11 |     let y = &amp;x.data.0;
   |             ^^^^^^^^^
   |
   = note: `#[warn(safe_packed_borrows)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #46043 &lt;https://github.com/rust-lang/rust/issues/46043&gt;
   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior
</code></pre>
<p>For more information about the process and policy of future-incompatible
changes, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1589-rustc-bug-fix-procedure.md">RFC 1589</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lint-levels"><a class="header" href="#lint-levels">Lint Levels</a></h1>
<p>In <code>rustc</code>, lints are divided into six <em>levels</em>:</p>
<ol>
<li>allow</li>
<li>expect</li>
<li>warn</li>
<li>force-warn</li>
<li>deny</li>
<li>forbid</li>
</ol>
<p>Each lint has a default level (explained in the lint listing later in this
chapter), and the compiler has a default warning level. First, let’s explain
what these levels mean, and then we’ll talk about configuration.</p>
<h2 id="allow"><a class="header" href="#allow">allow</a></h2>
<p>These lints exist, but by default, do nothing. For example, consider this
source:</p>
<pre><code class="language-rust">pub fn foo() {}</code></pre>
<p>Compiling this file produces no warnings:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib
$
</code></pre>
<p>But this code violates the <code>missing_docs</code> lint.</p>
<p>These lints exist mostly to be manually turned on via configuration, as we’ll
talk about later in this section.</p>
<h2 id="expect"><a class="header" href="#expect">expect</a></h2>
<p>Sometimes, it can be helpful to suppress lints, but at the same time ensure that
the code in question still emits them. The ‘expect’ level does exactly this. If
the lint in question is not emitted, the <code>unfulfilled_lint_expectations</code> lint
triggers on the <code>expect</code> attribute, notifying you that the expectation is no
longer fulfilled.</p>
<pre><code class="language-rust">fn main() {
    #[expect(unused_variables)]
    let unused = "Everyone ignores me";

    #[expect(unused_variables)] // `unused_variables` lint is not emitted
    let used = "I'm useful";    // the expectation is therefore unfulfilled
    println!("The `used` value is equal to: {:?}", used);
}</code></pre>
<p>This will produce the following warning:</p>
<pre><code class="language-txt">warning: this lint expectation is unfulfilled
 --&gt; src/main.rs:7:14
  |
7 |     #[expect(unused_variables)]
  |              ^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unfulfilled_lint_expectations)]` on by default
</code></pre>
<p>This level can only be defined via the <code>#[expect]</code> attribute, there is no equivalent
flag. Lints with the special ‘force-warn’ level will still be emitted as usual.</p>
<h2 id="warn"><a class="header" href="#warn">warn</a></h2>
<p>The ‘warn’ lint level will produce a warning if you violate the lint. For example,
this code runs afoul of the <code>unused_variables</code> lint:</p>
<pre><code class="language-rust">pub fn foo() {
    let x = 5;
}</code></pre>
<p>This will produce this warning:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib
warning: unused variable: `x`
 --&gt; lib.rs:2:9
  |
2 |     let x = 5;
  |         ^
  |
  = note: `#[warn(unused_variables)]` on by default
  = note: to avoid this warning, consider using `_x` instead
</code></pre>
<h2 id="force-warn"><a class="header" href="#force-warn">force-warn</a></h2>
<p>‘force-warn’ is a special lint level. It’s the same as ‘warn’ in that a lint
at this level will produce a warning, but unlike the ‘warn’ level, the
‘force-warn’ level cannot be overridden. If a lint is set to ‘force-warn’, it
is guaranteed to warn: no more, no less. This is true even if the overall lint
level is capped via cap-lints.</p>
<h2 id="deny"><a class="header" href="#deny">deny</a></h2>
<p>A ‘deny’ lint produces an error if you violate it. For example, this code
runs into the <code>exceeding_bitshifts</code> lint.</p>
<pre><code class="language-rust no_run">fn main() {
    100u8 &lt;&lt; 10;
}</code></pre>
<pre><code class="language-bash">$ rustc main.rs
error: bitshift exceeds the type's number of bits
 --&gt; main.rs:2:13
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^
  |
  = note: `#[deny(exceeding_bitshifts)]` on by default
</code></pre>
<p>What’s the difference between an error from a lint and a regular old error?
Lints are configurable via levels, so in a similar way to ‘allow’ lints,
warnings that are ‘deny’ by default let you allow them. Similarly, you may
wish to set up a lint that is <code>warn</code> by default to produce an error instead.
This lint level gives you that.</p>
<h2 id="forbid"><a class="header" href="#forbid">forbid</a></h2>
<p>‘forbid’ is a special lint level that fills the same role for ‘deny’ that
‘force-warn’ does for ‘warn’. It’s the same as ‘deny’ in that a lint at this
level will produce an error, but unlike the ‘deny’ level, the ‘forbid’ level
can not be overridden to be anything lower than an error.  However, lint
levels may still be capped with <code>--cap-lints</code> (see below) so <code>rustc --cap-lints warn</code>
will make lints set to ‘forbid’ just warn.</p>
<h2 id="configuring-warning-levels"><a class="header" href="#configuring-warning-levels">Configuring warning levels</a></h2>
<p>Remember our <code>missing_docs</code> example from the ‘allow’ lint level?</p>
<pre><code class="language-bash">$ cat lib.rs
pub fn foo() {}
$ rustc lib.rs --crate-type=lib
$
</code></pre>
<p>We can configure this lint to operate at a higher level, both with
compiler flags, as well as with an attribute in the source code.</p>
<p>You can also “cap” lints so that the compiler can choose to ignore
certain lint levels. We’ll talk about that last.</p>
<h3 id="via-compiler-flag"><a class="header" href="#via-compiler-flag">Via compiler flag</a></h3>
<p>The <code>-A</code>, <code>-W</code>, <code>--force-warn</code> <code>-D</code>, and <code>-F</code> flags let you turn one or more lints
into allowed, warning, force-warn, deny, or forbid levels, like this:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -W missing-docs
warning: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
  |
  = note: requested on the command line with `-W missing-docs`

warning: missing documentation for a function
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
</code></pre>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs
error: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
  |
  = note: requested on the command line with `-D missing-docs`

error: missing documentation for a function
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^

error: aborting due to 2 previous errors
</code></pre>
<p>You can also pass each flag more than once for changing multiple lints:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables
</code></pre>
<p>And of course, you can mix these five flags together:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables
</code></pre>
<p>The order of these command line arguments is taken into account. The following allows the <code>unused-variables</code> lint, because it is the last argument for that lint:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D unused-variables -A unused-variables
</code></pre>
<p>You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the <code>unused</code> group, but explicitly allows the <code>unused-variables</code> lint in that group (forbid still trumps everything regardless of ordering):</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D unused -A unused-variables
</code></pre>
<p>Since <code>force-warn</code> and <code>forbid</code> cannot be overridden, setting
one of them will prevent any later level for the same lint from
taking effect.</p>
<h3 id="via-an-attribute"><a class="header" href="#via-an-attribute">Via an attribute</a></h3>
<p>You can also modify the lint level with a crate-wide attribute:</p>
<pre><code class="language-bash">$ cat lib.rs
#![warn(missing_docs)]

pub fn foo() {}
$ rustc lib.rs --crate-type=lib
warning: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | / #![warn(missing_docs)]
2 | |
3 | | pub fn foo() {}
  | |_______________^
  |
note: lint level defined here
 --&gt; lib.rs:1:9
  |
1 | #![warn(missing_docs)]
  |         ^^^^^^^^^^^^

warning: missing documentation for a function
 --&gt; lib.rs:3:1
  |
3 | pub fn foo() {}
  | ^^^^^^^^^^^^
</code></pre>
<p><code>warn</code>, <code>allow</code>, <code>deny</code>, and <code>forbid</code> all work this way. There is
no way to set a lint to <code>force-warn</code> using an attribute.</p>
<p>You can also pass in multiple lints per attribute:</p>
<pre><code class="language-rust">#![warn(missing_docs, unused_variables)]

pub fn foo() {}</code></pre>
<p>And use multiple attributes together:</p>
<pre><code class="language-rust">#![warn(missing_docs)]
#![deny(unused_variables)]

pub fn foo() {}</code></pre>
<p>All lint attributes support an additional <code>reason</code> parameter, to give context why
a certain attribute was added. This reason will be displayed as part of the lint
message, if the lint is emitted at the defined level.</p>
<pre><code class="language-rust">use std::path::PathBuf;
pub fn get_path() -&gt; PathBuf {
    #[allow(unused_mut, reason = "this is only modified on some platforms")]
    let mut file_name = PathBuf::from("git");
    #[cfg(target_os = "windows")]
    file_name.set_extension("exe");
    file_name
}</code></pre>
<h3 id="capping-lints"><a class="header" href="#capping-lints">Capping lints</a></h3>
<p><code>rustc</code> supports a flag, <code>--cap-lints LEVEL</code> that sets the “lint cap level.”
This is the maximum level for all lints. So for example, if we take our
code sample from the “deny” lint level above:</p>
<pre><code class="language-rust no_run">fn main() {
    100u8 &lt;&lt; 10;
}</code></pre>
<p>And we compile it, capping lints to warn:</p>
<pre><code class="language-bash">$ rustc lib.rs --cap-lints warn
warning: bitshift exceeds the type's number of bits
 --&gt; lib.rs:2:5
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^
  |
  = note: `#[warn(exceeding_bitshifts)]` on by default

warning: this expression will panic at run-time
 --&gt; lib.rs:2:5
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^ attempt to shift left with overflow
</code></pre>
<p>It now only warns, rather than errors. We can go further and allow all lints:</p>
<pre><code class="language-bash">$ rustc lib.rs --cap-lints allow
$
</code></pre>
<p>This feature is used heavily by Cargo; it will pass <code>--cap-lints allow</code> when
compiling your dependencies, so that if they have any warnings, they do not
pollute the output of your build. However, note that <code>--cap-lints allow</code> does <strong>not</strong> override lints marked as <code>force-warn</code>.</p>
<h2 id="priority-of-lint-level-sources"><a class="header" href="#priority-of-lint-level-sources">Priority of lint level sources</a></h2>
<p>Rust allows setting lint levels (<code>allow</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code>, <code>force-warn</code>) through various sources:</p>
<ul>
<li><strong>Attributes</strong>: <code>#[allow(...)]</code>, <code>#![deny(...)]</code>, etc.</li>
<li><strong>Command-line options</strong>: <code>--cap-lints</code>, <code>--force-warn</code>, <code>-A</code>, <code>-W</code>, <code>-D</code>, <code>-F</code></li>
</ul>
<p>Here’s how these different lint controls interact:</p>
<ol>
<li>
<p><a href="#force-warn"><code>--force-warn</code></a> forces a lint to warning level, and takes precedence over attributes and all other CLI flags.</p>
<pre><code class="language-rust compile_fail">#[forbid(unused_variables)]
fn main() {
    let x = 42;
}</code></pre>
<p>Compiled with:</p>
<pre><code class="language-bash"> $ rustc --force-warn unused_variables lib.rs
 warning: unused variable: `x`
   --&gt; lib.rs:3:9
   |
 3 |     let x = 42;
   |         ^ help: if this is intentional, prefix it with an underscore: `_x`
   |
   = note: requested on the command line with `--force-warn unused-variables`

 warning: 1 warning emitted
</code></pre>
</li>
<li>
<p><a href="#capping-lints"><code>--cap-lints</code></a> sets the maximum level of a lint, and takes precedence over attributes as well as the <code>-D</code>, <code>-W</code>, and <code>-F</code> CLI flags.</p>
<pre><code class="language-rust compile_fail">#[deny(unused_variables)]
fn main() {
    let x = 42;
}</code></pre>
<p>Compiled with:</p>
<pre><code class="language-bash"> $ rustc --cap-lints=warn lib.rs
 warning: unused variable: `x`
 --&gt; test1.rs:3:9
   |
 3 |     let x = 42;
   |         ^ help: if this is intentional, prefix it with an underscore: `_x`
   |
 note: the lint level is defined here
 --&gt; test1.rs:1:8
   |
 1 | #[deny(unused_variables)]
   |        ^^^^^^^^^^^^^^^^

 warning: 1 warning emitted
</code></pre>
</li>
<li>
<p><a href="#via-compiler-flag">CLI level flags</a> take precedence over attributes.</p>
<p>The order of the flags matter; flags on the right take precedence over earlier flags.</p>
<pre><code class="language-rust">fn main() {
    let x = 42;
}</code></pre>
<p>Compiled with:</p>
<pre><code class="language-bash"> $ rustc -A unused_variables -D unused_variables lib.rs
 error: unused variable: `x`
 --&gt; test1.rs:2:9
   |
 2 |     let x = 42;
   |         ^ help: if this is intentional, prefix it with an underscore: `_x`
   |
   = note: requested on the command line with `-D unused-variables`

 error: aborting due to 1 previous error
</code></pre>
</li>
<li>
<p>Within the source, <a href="#via-an-attribute">attributes</a> at a lower-level in the syntax tree take precedence over attributes at a higher level, or from a previous attribute on the same entity as listed in left-to-right source order.</p>
<pre><code class="language-rust">#![deny(unused_variables)]

#[allow(unused_variables)]
fn main() {
    let x = 42; // Allow wins
}</code></pre>
<ul>
<li>The exception is once a lint is set to “forbid”, it is an error to try to change its level except for <code>deny</code>, which is allowed inside a forbid context, but is ignored.</li>
</ul>
</li>
</ol>
<p>In terms of priority, <a href="#lint-groups">lint groups</a> are treated as-if they are expanded to a list of all of the lints they contain. The exception is the <code>warnings</code> group which ignores attribute and CLI order and applies to all lints that would otherwise warn within the entity.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lint-groups"><a class="header" href="#lint-groups">Lint Groups</a></h1>
<p><code>rustc</code> has the concept of a “lint group”, where you can toggle several warnings
through one name.</p>
<p>For example, the <code>nonstandard-style</code> lint sets <code>non-camel-case-types</code>,
<code>non-snake-case</code>, and <code>non-upper-case-globals</code> all at once. So these are
equivalent:</p>
<pre><code class="language-bash">$ rustc -D nonstandard-style
$ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals
</code></pre>
<p>Here’s a list of each lint group, and the lints that they are made up of:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Group</th><th>Description</th><th>Lints</th></tr>
</thead>
<tbody>
<tr><td>warnings</td><td>All lints that are set to issue warnings</td><td>See <a href="#warn-by-default-lints">warn-by-default</a> for the default set of warnings</td></tr>
<tr><td>deprecated-safe</td><td>Lints for functions which were erroneously marked as safe in the past</td><td><a href="#deprecated-safe-2024">deprecated-safe-2024</a></td></tr>
<tr><td>future-incompatible</td><td>Lints that detect code that has future-compatibility problems</td><td><a href="#aarch64-softfloat-neon">aarch64-softfloat-neon</a>, <a href="#ambiguous-associated-items">ambiguous-associated-items</a>, <a href="#ambiguous-glob-imported-traits">ambiguous-glob-imported-traits</a>, <a href="#ambiguous-glob-imports">ambiguous-glob-imports</a>, <a href="#ambiguous-panic-imports">ambiguous-panic-imports</a>, <a href="#coherence-leak-check">coherence-leak-check</a>, <a href="#conflicting-repr-hints">conflicting-repr-hints</a>, <a href="#const-evaluatable-unchecked">const-evaluatable-unchecked</a>, <a href="#elided-lifetimes-in-associated-constant">elided-lifetimes-in-associated-constant</a>, <a href="#forbidden-lint-groups">forbidden-lint-groups</a>, <a href="#ill-formed-attribute-input">ill-formed-attribute-input</a>, <a href="#invalid-macro-export-arguments">invalid-macro-export-arguments</a>, <a href="#invalid-type-param-default">invalid-type-param-default</a>, <a href="#late-bound-lifetime-arguments">late-bound-lifetime-arguments</a>, <a href="#legacy-derive-helpers">legacy-derive-helpers</a>, <a href="#macro-expanded-macro-exports-accessed-by-absolute-paths">macro-expanded-macro-exports-accessed-by-absolute-paths</a>, <a href="#out-of-scope-macro-calls">out-of-scope-macro-calls</a>, <a href="#patterns-in-fns-without-body">patterns-in-fns-without-body</a>, <a href="#proc-macro-derive-resolution-fallback">proc-macro-derive-resolution-fallback</a>, <a href="#pub-use-of-private-extern-crate">pub-use-of-private-extern-crate</a>, <a href="#repr-c-enums-larger-than-int">repr-c-enums-larger-than-int</a>, <a href="#repr-transparent-non-zst-fields">repr-transparent-non-zst-fields</a>, <a href="#self-constructor-from-outer-item">self-constructor-from-outer-item</a>, <a href="#semicolon-in-expressions-from-macros">semicolon-in-expressions-from-macros</a>, <a href="#soft-unstable">soft-unstable</a>, <a href="#uncovered-param-in-projection">uncovered-param-in-projection</a>, <a href="#uninhabited-static">uninhabited-static</a>, <a href="#unstable-name-collisions">unstable-name-collisions</a>, <a href="#unstable-syntax-pre-expansion">unstable-syntax-pre-expansion</a>, <a href="#unsupported-calling-conventions">unsupported-calling-conventions</a>, <a href="#varargs-without-pattern">varargs-without-pattern</a></td></tr>
<tr><td>keyword-idents</td><td>Lints that detect identifiers which will be come keywords in later editions</td><td><a href="#keyword-idents-2018">keyword-idents-2018</a>, <a href="#keyword-idents-2024">keyword-idents-2024</a></td></tr>
<tr><td>let-underscore</td><td>Lints that detect wildcard let bindings that are likely to be invalid</td><td><a href="#let-underscore-drop">let-underscore-drop</a>, <a href="#let-underscore-lock">let-underscore-lock</a></td></tr>
<tr><td>nonstandard-style</td><td>Violation of standard naming conventions</td><td><a href="#non-camel-case-types">non-camel-case-types</a>, <a href="#non-snake-case">non-snake-case</a>, <a href="#non-upper-case-globals">non-upper-case-globals</a></td></tr>
<tr><td>refining-impl-trait</td><td>Detects refinement of <code>impl Trait</code> return types by trait implementations</td><td><a href="#refining-impl-trait-internal">refining-impl-trait-internal</a>, <a href="#refining-impl-trait-reachable">refining-impl-trait-reachable</a></td></tr>
<tr><td>rust-2018-compatibility</td><td>Lints used to transition code from the 2015 edition to 2018</td><td><a href="#absolute-paths-not-starting-with-crate">absolute-paths-not-starting-with-crate</a>, <a href="#anonymous-parameters">anonymous-parameters</a>, <a href="#keyword-idents-2018">keyword-idents-2018</a>, <a href="#tyvar-behind-raw-pointer">tyvar-behind-raw-pointer</a></td></tr>
<tr><td>rust-2018-idioms</td><td>Lints to nudge you toward idiomatic features of Rust 2018</td><td><a href="#bare-trait-objects">bare-trait-objects</a>, <a href="#elided-lifetimes-in-paths">elided-lifetimes-in-paths</a>, <a href="#ellipsis-inclusive-range-patterns">ellipsis-inclusive-range-patterns</a>, <a href="#explicit-outlives-requirements">explicit-outlives-requirements</a>, <a href="#unused-extern-crates">unused-extern-crates</a></td></tr>
<tr><td>rust-2021-compatibility</td><td>Lints used to transition code from the 2018 edition to 2021</td><td><a href="#array-into-iter">array-into-iter</a>, <a href="#bare-trait-objects">bare-trait-objects</a>, <a href="#ellipsis-inclusive-range-patterns">ellipsis-inclusive-range-patterns</a>, <a href="#non-fmt-panics">non-fmt-panics</a>, <a href="#rust-2021-incompatible-closure-captures">rust-2021-incompatible-closure-captures</a>, <a href="#rust-2021-incompatible-or-patterns">rust-2021-incompatible-or-patterns</a>, <a href="#rust-2021-prefixes-incompatible-syntax">rust-2021-prefixes-incompatible-syntax</a>, <a href="#rust-2021-prelude-collisions">rust-2021-prelude-collisions</a></td></tr>
<tr><td>rust-2024-compatibility</td><td>Lints used to transition code from the 2021 edition to 2024</td><td><a href="#boxed-slice-into-iter">boxed-slice-into-iter</a>, <a href="#dependency-on-unit-never-type-fallback">dependency-on-unit-never-type-fallback</a>, <a href="#deprecated-safe-2024">deprecated-safe-2024</a>, <a href="#edition-2024-expr-fragment-specifier">edition-2024-expr-fragment-specifier</a>, <a href="#if-let-rescope">if-let-rescope</a>, <a href="#impl-trait-overcaptures">impl-trait-overcaptures</a>, <a href="#keyword-idents-2024">keyword-idents-2024</a>, <a href="#missing-unsafe-on-extern">missing-unsafe-on-extern</a>, <a href="#never-type-fallback-flowing-into-unsafe">never-type-fallback-flowing-into-unsafe</a>, <a href="#rust-2024-guarded-string-incompatible-syntax">rust-2024-guarded-string-incompatible-syntax</a>, <a href="#rust-2024-incompatible-pat">rust-2024-incompatible-pat</a>, <a href="#rust-2024-prelude-collisions">rust-2024-prelude-collisions</a>, <a href="#static-mut-refs">static-mut-refs</a>, <a href="#tail-expr-drop-order">tail-expr-drop-order</a>, <a href="#unsafe-attr-outside-unsafe">unsafe-attr-outside-unsafe</a>, <a href="#unsafe-op-in-unsafe-fn">unsafe-op-in-unsafe-fn</a></td></tr>
<tr><td>unknown-or-malformed-diagnostic-attributes</td><td>detects unknown or malformed diagnostic attributes</td><td><a href="#malformed-diagnostic-attributes">malformed-diagnostic-attributes</a>, <a href="#malformed-diagnostic-format-literals">malformed-diagnostic-format-literals</a>, <a href="#misplaced-diagnostic-attributes">misplaced-diagnostic-attributes</a>, <a href="#unknown-diagnostic-attributes">unknown-diagnostic-attributes</a></td></tr>
<tr><td>unused</td><td>Lints that detect things being declared but not used, or excess syntax</td><td><a href="#dead-code">dead-code</a>, <a href="#map-unit-fn">map-unit-fn</a>, <a href="#path-statements">path-statements</a>, <a href="#redundant-semicolons">redundant-semicolons</a>, <a href="#unreachable-code">unreachable-code</a>, <a href="#unreachable-patterns">unreachable-patterns</a>, <a href="#unused-allocation">unused-allocation</a>, <a href="#unused-assignments">unused-assignments</a>, <a href="#unused-attributes">unused-attributes</a>, <a href="#unused-braces">unused-braces</a>, <a href="#unused-doc-comments">unused-doc-comments</a>, <a href="#unused-extern-crates">unused-extern-crates</a>, <a href="#unused-features">unused-features</a>, <a href="#unused-imports">unused-imports</a>, <a href="#unused-labels">unused-labels</a>, <a href="#unused-macro-rules">unused-macro-rules</a>, <a href="#unused-macros">unused-macros</a>, <a href="#unused-must-use">unused-must-use</a>, <a href="#unused-mut">unused-mut</a>, <a href="#unused-parens">unused-parens</a>, <a href="#unused-unsafe">unused-unsafe</a>, <a href="#unused-variables">unused-variables</a>, <a href="#unused-visibilities">unused-visibilities</a></td></tr>
</tbody>
</table>
</div>
<p>Additionally, there’s a <code>bad-style</code> lint group that’s a deprecated alias for <code>nonstandard-style</code>.</p>
<p>Finally, you can also see the table above by invoking <code>rustc -W help</code>. This will give you the exact values for the specific
compiler you have installed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lint-listing"><a class="header" href="#lint-listing">Lint Listing</a></h1>
<p>This section lists out all of the lints, grouped by their default lint levels.</p>
<p>You can also see this list by running <code>rustc -W help</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="allowed-by-default-lints"><a class="header" href="#allowed-by-default-lints">Allowed-by-default Lints</a></h1>
<p>These lints are all set to the ‘allow’ level by default. As such, they won’t show up
unless you set them to a higher lint level with a flag or attribute.</p>
<ul>
<li><a href="#absolute-paths-not-starting-with-crate"><code>absolute_paths_not_starting_with_crate</code></a></li>
<li><a href="#ambiguous-negative-literals"><code>ambiguous_negative_literals</code></a></li>
<li><a href="#async-idents"><code>async-idents</code></a></li>
<li><a href="#closure-returning-async-block"><code>closure_returning_async_block</code></a></li>
<li><a href="#deprecated-safe-2024"><code>deprecated_safe_2024</code></a></li>
<li><a href="#deref-into-dyn-supertrait"><code>deref_into_dyn_supertrait</code></a></li>
<li><a href="#disjoint-capture-migration"><code>disjoint-capture-migration</code></a></li>
<li><a href="#edition-2024-expr-fragment-specifier"><code>edition_2024_expr_fragment_specifier</code></a></li>
<li><a href="#elided-lifetime-in-path"><code>elided-lifetime-in-path</code></a></li>
<li><a href="#elided-lifetimes-in-paths"><code>elided_lifetimes_in_paths</code></a></li>
<li><a href="#explicit-outlives-requirements"><code>explicit_outlives_requirements</code></a></li>
<li><a href="#ffi-unwind-calls"><code>ffi_unwind_calls</code></a></li>
<li><a href="#fuzzy-provenance-casts"><code>fuzzy_provenance_casts</code></a></li>
<li><a href="#if-let-rescope"><code>if_let_rescope</code></a></li>
<li><a href="#impl-trait-overcaptures"><code>impl_trait_overcaptures</code></a></li>
<li><a href="#impl-trait-redundant-captures"><code>impl_trait_redundant_captures</code></a></li>
<li><a href="#keyword-idents"><code>keyword-idents</code></a></li>
<li><a href="#keyword-idents-2018"><code>keyword_idents_2018</code></a></li>
<li><a href="#keyword-idents-2024"><code>keyword_idents_2024</code></a></li>
<li><a href="#let-underscore-drop"><code>let_underscore_drop</code></a></li>
<li><a href="#linker-messages"><code>linker_messages</code></a></li>
<li><a href="#lossy-provenance-casts"><code>lossy_provenance_casts</code></a></li>
<li><a href="#macro-use-extern-crate"><code>macro_use_extern_crate</code></a></li>
<li><a href="#meta-variable-misuse"><code>meta_variable_misuse</code></a></li>
<li><a href="#missing-copy-implementations"><code>missing_copy_implementations</code></a></li>
<li><a href="#missing-debug-implementations"><code>missing_debug_implementations</code></a></li>
<li><a href="#missing-docs"><code>missing_docs</code></a></li>
<li><a href="#missing-unsafe-on-extern"><code>missing_unsafe_on_extern</code></a></li>
<li><a href="#multiple-supertrait-upcastable"><code>multiple_supertrait_upcastable</code></a></li>
<li><a href="#must-not-suspend"><code>must_not_suspend</code></a></li>
<li><a href="#non-ascii-idents"><code>non_ascii_idents</code></a></li>
<li><a href="#non-exhaustive-omitted-patterns"><code>non_exhaustive_omitted_patterns</code></a></li>
<li><a href="#or-patterns-back-compat"><code>or-patterns-back-compat</code></a></li>
<li><a href="#redundant-imports"><code>redundant_imports</code></a></li>
<li><a href="#redundant-lifetimes"><code>redundant_lifetimes</code></a></li>
<li><a href="#resolving-to-items-shadowing-supertrait-items"><code>resolving_to_items_shadowing_supertrait_items</code></a></li>
<li><a href="#rust-2021-incompatible-closure-captures"><code>rust_2021_incompatible_closure_captures</code></a></li>
<li><a href="#rust-2021-incompatible-or-patterns"><code>rust_2021_incompatible_or_patterns</code></a></li>
<li><a href="#rust-2021-prefixes-incompatible-syntax"><code>rust_2021_prefixes_incompatible_syntax</code></a></li>
<li><a href="#rust-2021-prelude-collisions"><code>rust_2021_prelude_collisions</code></a></li>
<li><a href="#rust-2024-guarded-string-incompatible-syntax"><code>rust_2024_guarded_string_incompatible_syntax</code></a></li>
<li><a href="#rust-2024-incompatible-pat"><code>rust_2024_incompatible_pat</code></a></li>
<li><a href="#rust-2024-prelude-collisions"><code>rust_2024_prelude_collisions</code></a></li>
<li><a href="#shadowing-supertrait-items"><code>shadowing_supertrait_items</code></a></li>
<li><a href="#single-use-lifetime"><code>single-use-lifetime</code></a></li>
<li><a href="#single-use-lifetimes"><code>single_use_lifetimes</code></a></li>
<li><a href="#tail-expr-drop-order"><code>tail_expr_drop_order</code></a></li>
<li><a href="#trivial-casts"><code>trivial_casts</code></a></li>
<li><a href="#trivial-numeric-casts"><code>trivial_numeric_casts</code></a></li>
<li><a href="#unit-bindings"><code>unit_bindings</code></a></li>
<li><a href="#unnameable-types"><code>unnameable_types</code></a></li>
<li><a href="#unqualified-local-imports"><code>unqualified_local_imports</code></a></li>
<li><a href="#unreachable-pub"><code>unreachable_pub</code></a></li>
<li><a href="#unsafe-attr-outside-unsafe"><code>unsafe_attr_outside_unsafe</code></a></li>
<li><a href="#unsafe-code"><code>unsafe_code</code></a></li>
<li><a href="#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a></li>
<li><a href="#unstable-features"><code>unstable_features</code></a></li>
<li><a href="#unused-crate-dependencies"><code>unused_crate_dependencies</code></a></li>
<li><a href="#unused-extern-crates"><code>unused_extern_crates</code></a></li>
<li><a href="#unused-import-braces"><code>unused_import_braces</code></a></li>
<li><a href="#unused-lifetimes"><code>unused_lifetimes</code></a></li>
<li><a href="#unused-macro-rules"><code>unused_macro_rules</code></a></li>
<li><a href="#unused-qualifications"><code>unused_qualifications</code></a></li>
<li><a href="#unused-results"><code>unused_results</code></a></li>
<li><a href="#variant-size-differences"><code>variant_size_differences</code></a></li>
</ul>
<h2 id="absolute-paths-not-starting-with-crate"><a class="header" href="#absolute-paths-not-starting-with-crate">absolute-paths-not-starting-with-crate</a></h2>
<p>The <code>absolute_paths_not_starting_with_crate</code> lint detects fully
qualified paths that start with a module name instead of <code>crate</code>,
<code>self</code>, or an extern crate name</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(absolute_paths_not_starting_with_crate)]

mod foo {
    pub fn bar() {}
}

fn main() {
    ::foo::bar();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition
 --&gt; lint_example.rs:8:5
  |
8 |     ::foo::bar();
  |     ^^^^^^^^^^ help: use `crate`: `crate::foo::bar`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(absolute_paths_not_starting_with_crate)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses absolute
paths in the style of the 2015 edition. In the 2015 edition, absolute
paths (those starting with <code>::</code>) refer to either the crate root or an
external crate. In the 2018 edition it was changed so that they only
refer to external crates. The path prefix <code>crate::</code> should be used
instead to reference items from the crate root.</p>
<p>If you switch the compiler from the 2015 to 2018 edition without
updating the code, then it will fail to compile if the old style paths
are used. You can manually change the paths to use the <code>crate::</code>
prefix to transition to the 2018 edition.</p>
<p>This lint solves the problem automatically. It is “allow” by default
because the code is perfectly valid in the 2015 edition. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to “warn”
and automatically apply the suggested fix from the compiler. This
provides a completely automated way to update old code to the 2018
edition.</p>
<h2 id="ambiguous-negative-literals"><a class="header" href="#ambiguous-negative-literals">ambiguous-negative-literals</a></h2>
<p>The <code>ambiguous_negative_literals</code> lint checks for cases that are
confusing between a negative literal and a negation that’s not part
of the literal.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![deny(ambiguous_negative_literals)]
</span><span class="boring">#![allow(unused)]
</span>-1i32.abs(); // equals -1, while `(-1i32).abs()` equals 1</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `-` has lower precedence than method calls, which might be unexpected
 --&gt; lint_example.rs:4:1
  |
4 | -1i32.abs(); // equals -1, while `(-1i32).abs()` equals 1
  | ^^^^^^^^^^^
  |
  = note: e.g. `-4.abs()` equals `-4`; while `(-4).abs()` equals `4`
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(ambiguous_negative_literals)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: add parentheses around the `-` and the literal to call the method on a negative literal
  |
4 | (-1i32).abs(); // equals -1, while `(-1i32).abs()` equals 1
  | +     +
help: add parentheses around the literal and the method call to keep the current behavior
  |
4 | -(1i32.abs()); // equals -1, while `(-1i32).abs()` equals 1
  |  +          +

</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h3>
<p>Method calls take precedence over unary precedence. Setting the
precedence explicitly makes the code clearer and avoid potential bugs.</p>
<h2 id="async-idents"><a class="header" href="#async-idents">async-idents</a></h2>
<p>The lint <code>async-idents</code> has been renamed to <a href="#keyword-idents"><code>keyword-idents</code></a>.</p>
<h2 id="closure-returning-async-block"><a class="header" href="#closure-returning-async-block">closure-returning-async-block</a></h2>
<p>The <code>closure_returning_async_block</code> lint detects cases where users
write a closure that returns an async block.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-rust">#![warn(closure_returning_async_block)]
let c = |x: &amp;str| async {};</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: closure returning async block can be made into an async closure
 --&gt; lint_example.rs:3:9
  |
3 | let c = |x: &amp;str| async {};
  |         ^^^^^^^^^ ----- this async block can be removed, and the closure can be turned into an async closure
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(closure_returning_async_block)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: turn this into an async closure
  |
3 - let c = |x: &amp;str| async {};
3 + let c = async |x: &amp;str| {};
  |

</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<p>Using an async closure is preferable over a closure that returns an
async block, since async closures are less restrictive in how its
captures are allowed to be used.</p>
<p>For example, this code does not work with a closure returning an async
block:</p>
<pre><code class="language-rust compile_fail">async fn callback(x: &amp;str) {}

let captured_str = String::new();
let c = move || async {
    callback(&amp;captured_str).await;
};</code></pre>
<p>But it does work with async closures:</p>
<pre><code class="language-rust">async fn callback(x: &amp;str) {}

let captured_str = String::new();
let c = async move || {
    callback(&amp;captured_str).await;
};</code></pre>
<h2 id="deprecated-safe-2024"><a class="header" href="#deprecated-safe-2024">deprecated-safe-2024</a></h2>
<p>The <code>deprecated_safe_2024</code> lint detects unsafe functions being used as
safe functions.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(deprecated_safe)]
// edition 2021
use std::env;
fn enable_backtrace() {
    env::set_var("RUST_BACKTRACE", "1");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: call to deprecated safe function `std::env::set_var` is unsafe and requires unsafe block
 --&gt; lint_example.rs:6:5
  |
6 |     env::set_var("RUST_BACKTRACE", "1");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/newly-unsafe-functions.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(deprecated_safe)]
  |         ^^^^^^^^^^^^^^^
  = note: `#[deny(deprecated_safe_2024)]` implied by `#[deny(deprecated_safe)]`
help: you can wrap the call in an `unsafe` block if you can guarantee that the environment access only happens in single-threaded code
  |
6 +     // TODO: Audit that the environment access only happens in single-threaded code.
7 ~     unsafe { env::set_var("RUST_BACKTRACE", "1") };
  |

</code></pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking backward
compatibility. This lint catches code that uses <code>unsafe</code> functions that
were declared as safe (non-<code>unsafe</code>) in editions prior to Rust 2024. If
you switch the compiler to Rust 2024 without updating the code, then it
will fail to compile if you are using a function previously marked as
safe.</p>
<p>You can audit the code to see if it suffices the preconditions of the
<code>unsafe</code> code, and if it does, you can wrap it in an <code>unsafe</code> block. If
you can’t fulfill the preconditions, you probably need to switch to a
different way of doing what you want to achieve.</p>
<p>This lint can automatically wrap the calls in <code>unsafe</code> blocks, but this
obviously cannot verify that the preconditions of the <code>unsafe</code>
functions are fulfilled, so that is still up to the user.</p>
<p>The lint is currently “allow” by default, but that might change in the
future.</p>
<h2 id="deref-into-dyn-supertrait"><a class="header" href="#deref-into-dyn-supertrait">deref-into-dyn-supertrait</a></h2>
<p>The <code>deref_into_dyn_supertrait</code> lint is emitted whenever there is a <code>Deref</code> implementation
for <code>dyn SubTrait</code> with a <code>dyn SuperTrait</code> type as the <code>Output</code> type.</p>
<p>These implementations are “shadowed” by trait upcasting (stabilized since
1.86.0). The <code>deref</code> functions is no longer called implicitly, which might
change behavior compared to previous rustc versions.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(deref_into_dyn_supertrait)]
#![allow(dead_code)]

use core::ops::Deref;

trait A {}
trait B: A {}
impl&lt;'a&gt; Deref for dyn 'a + B {
    type Target = dyn A;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        todo!()
    }
}

fn take_a(_: &amp;dyn A) { }

fn take_b(b: &amp;dyn B) {
    take_a(b);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this `Deref` implementation is covered by an implicit supertrait coercion
  --&gt; lint_example.rs:9:1
   |
 9 | impl&lt;'a&gt; Deref for dyn 'a + B {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `dyn B` implements `Deref&lt;Target = dyn A&gt;` which conflicts with supertrait `A`
10 |     type Target = dyn A;
   |     ----------- target type is a supertrait of `dyn B`
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(deref_into_dyn_supertrait)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h3>
<p>The trait upcasting coercion added a new coercion rule, taking priority over certain other
coercion rules, which causes some behavior change compared to older <code>rustc</code> versions.</p>
<p><code>deref</code> can be still called explicitly, it just isn’t called as part of a deref coercion
(since trait upcasting coercion takes priority).</p>
<h2 id="disjoint-capture-migration"><a class="header" href="#disjoint-capture-migration">disjoint-capture-migration</a></h2>
<p>The lint <code>disjoint-capture-migration</code> has been renamed to <a href="#rust-2021-incompatible-closure-captures"><code>rust-2021-incompatible-closure-captures</code></a>.</p>
<h2 id="edition-2024-expr-fragment-specifier"><a class="header" href="#edition-2024-expr-fragment-specifier">edition-2024-expr-fragment-specifier</a></h2>
<p>The <code>edition_2024_expr_fragment_specifier</code> lint detects the use of
<code>expr</code> fragments in macros during migration to the 2024 edition.</p>
<p>The <code>expr</code> fragment specifier will accept more expressions in the 2024
edition. To maintain the behavior from the 2021 edition and earlier, use
the <code>expr_2021</code> fragment specifier.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(edition_2024_expr_fragment_specifier)]
macro_rules! m {
  ($e:expr) =&gt; {
      $e
  }
}

fn main() {
   m!(1);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the `expr` fragment specifier will accept more expressions in the 2024 edition
 --&gt; lint_example.rs:3:7
  |
3 |   ($e:expr) =&gt; {
  |       ^^^^
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/macro-fragment-specifiers.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(edition_2024_expr_fragment_specifier)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to keep the existing behavior, use the `expr_2021` fragment specifier
  |
3 |   ($e:expr_2021) =&gt; {
  |           +++++

</code></pre>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking backwards
compatibility. This lint catches code that uses <a href="https://doc.rust-lang.org/edition-guide/rust-2024/macro-fragment-specifiers.html">macro matcher fragment
specifiers</a> that have changed meaning in the 2024 edition. If you switch
to the new edition without updating the code, your macros may behave
differently.</p>
<p>In the 2024 edition, the <code>expr</code> fragment specifier <code>expr</code> will also
match <code>const { ... }</code> blocks. This means if a macro had a pattern that
matched <code>$e:expr</code> and another that matches <code>const { $e: expr }</code>, for
example, that under the 2024 edition the first pattern would match while
in the 2021 and earlier editions the second pattern would match. To keep
the old behavior, use the <code>expr_2021</code> fragment specifier.</p>
<p>This lint detects macros whose behavior might change due to the changing
meaning of the <code>expr</code> fragment specifier. It is “allow” by default
because the code is perfectly valid in older editions. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a>
tool with the <code>--edition</code> flag will switch this lint to “warn” and
automatically apply the suggested fix from the compiler. This provides a
completely automated way to update old code for a new edition.</p>
<p>Using <code>cargo fix --edition</code> with this lint will ensure that your code
retains the same behavior. This may not be the desired, as macro authors
often will want their macros to use the latest grammar for matching
expressions. Be sure to carefully review changes introduced by this lint
to ensure the macros implement the desired behavior.</p>
<h2 id="elided-lifetime-in-path"><a class="header" href="#elided-lifetime-in-path">elided-lifetime-in-path</a></h2>
<p>The lint <code>elided-lifetime-in-path</code> has been renamed to <a href="#elided-lifetimes-in-paths"><code>elided-lifetimes-in-paths</code></a>.</p>
<h2 id="elided-lifetimes-in-paths"><a class="header" href="#elided-lifetimes-in-paths">elided-lifetimes-in-paths</a></h2>
<p>The <code>elided_lifetimes_in_paths</code> lint detects the use of hidden
lifetime parameters.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(elided_lifetimes_in_paths)]
#![deny(warnings)]
struct Foo&lt;'a&gt; {
    x: &amp;'a u32
}

fn foo(x: &amp;Foo) {
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: hidden lifetime parameters in types are deprecated
 --&gt; lint_example.rs:8:12
  |
8 | fn foo(x: &amp;Foo) {
  |            ^^^ expected lifetime parameter
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(elided_lifetimes_in_paths)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
help: indicate the anonymous lifetime
  |
8 | fn foo(x: &amp;Foo&lt;'_&gt;) {
  |               ++++

</code></pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation</a></h3>
<p>Elided lifetime parameters can make it difficult to see at a glance
that borrowing is occurring. This lint ensures that lifetime
parameters are always explicitly stated, even if it is the <code>'_</code>
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html#lifetime-elision-in-functions">placeholder lifetime</a>.</p>
<p>This lint is “allow” by default because it has some known issues, and
may require a significant transition for old code.</p>
<h2 id="explicit-outlives-requirements"><a class="header" href="#explicit-outlives-requirements">explicit-outlives-requirements</a></h2>
<p>The <code>explicit_outlives_requirements</code> lint detects unnecessary
lifetime bounds that can be inferred.</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(explicit_outlives_requirements)]
#![deny(warnings)]

struct SharedRef&lt;'a, T&gt;
where
    T: 'a,
{
    data: &amp;'a T,
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: outlives requirements can be inferred
 --&gt; lint_example.rs:6:24
  |
6 |   struct SharedRef&lt;'a, T&gt;
  |  ________________________^
7 | | where
8 | |     T: 'a,
  | |__________^ help: remove this bound
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(explicit_outlives_requirements)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation</a></h3>
<p>If a <code>struct</code> contains a reference, such as <code>&amp;'a T</code>, the compiler
requires that <code>T</code> outlives the lifetime <code>'a</code>. This historically
required writing an explicit lifetime bound to indicate this
requirement. However, this can be overly explicit, causing clutter and
unnecessary complexity. The language was changed to automatically
infer the bound if it is not specified. Specifically, if the struct
contains a reference, directly or indirectly, to <code>T</code> with lifetime
<code>'x</code>, then it will infer that <code>T: 'x</code> is a requirement.</p>
<p>This lint is “allow” by default because it can be noisy for existing
code that already had these requirements. This is a stylistic choice,
as it is still valid to explicitly state the bound. It also has some
false positives that can cause confusion.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md">RFC 2093</a> for more details.</p>
<h2 id="ffi-unwind-calls"><a class="header" href="#ffi-unwind-calls">ffi-unwind-calls</a></h2>
<p>The <code>ffi_unwind_calls</code> lint detects calls to foreign functions or function pointers with
<code>C-unwind</code> or other FFI-unwind ABIs.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-rust">#![warn(ffi_unwind_calls)]

unsafe extern "C-unwind" {
    fn foo();
}

fn bar() {
    unsafe { foo(); }
    let ptr: unsafe extern "C-unwind" fn() = foo;
    unsafe { ptr(); }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: call to foreign function with FFI-unwind ABI
 --&gt; lint_example.rs:9:14
  |
9 |     unsafe { foo(); }
  |              ^^^^^ call to foreign function with FFI-unwind ABI
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(ffi_unwind_calls)]
  |         ^^^^^^^^^^^^^^^^


warning: call to function pointer with FFI-unwind ABI
  --&gt; lint_example.rs:11:14
   |
11 |     unsafe { ptr(); }
   |              ^^^^^ call to function pointer with FFI-unwind ABI

</code></pre>
<h3 id="explanation-8"><a class="header" href="#explanation-8">Explanation</a></h3>
<p>For crates containing such calls, if they are compiled with <code>-C panic=unwind</code> then the
produced library cannot be linked with crates compiled with <code>-C panic=abort</code>. For crates
that desire this ability it is therefore necessary to avoid such calls.</p>
<h2 id="fuzzy-provenance-casts"><a class="header" href="#fuzzy-provenance-casts">fuzzy-provenance-casts</a></h2>
<p>The <code>fuzzy_provenance_casts</code> lint detects an <code>as</code> cast between an integer
and a pointer.</p>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><code class="language-rust">#![feature(strict_provenance_lints)]
#![warn(fuzzy_provenance_casts)]

fn main() {
    let _dangling = 16_usize as *const u8;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: strict provenance disallows casting integer `usize` to pointer `*const u8`
 --&gt; lint_example.rs:5:21
  |
5 |     let _dangling = 16_usize as *const u8;
  |                     ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: if you can't comply with strict provenance and don't have a pointer with the correct provenance you can use `std::ptr::with_exposed_provenance()` instead
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![warn(fuzzy_provenance_casts)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
help: use `.with_addr()` to adjust a valid pointer in the same allocation, to this address
  |
5 -     let _dangling = 16_usize as *const u8;
5 +     let _dangling = (...).with_addr(16_usize);
  |

</code></pre>
<h3 id="explanation-9"><a class="header" href="#explanation-9">Explanation</a></h3>
<p>This lint is part of the strict provenance effort, see <a href="https://github.com/rust-lang/rust/issues/95228">issue #95228</a>.
Casting an integer to a pointer is considered bad style, as a pointer
contains, besides the <em>address</em> also a <em>provenance</em>, indicating what
memory the pointer is allowed to read/write. Casting an integer, which
doesn’t have provenance, to a pointer requires the compiler to assign
(guess) provenance. The compiler assigns “all exposed valid” (see the
docs of <a href="https://doc.rust-lang.org/core/ptr/fn.with_exposed_provenance.html"><code>ptr::with_exposed_provenance</code></a> for more information about this
“exposing”). This penalizes the optimiser and is not well suited for
dynamic analysis/dynamic program verification (e.g. Miri or CHERI
platforms).</p>
<p>It is much better to use <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.with_addr"><code>ptr::with_addr</code></a> instead to specify the
provenance you want. If using this function is not possible because the
code relies on exposed provenance then there is as an escape hatch
<a href="https://doc.rust-lang.org/core/ptr/fn.with_exposed_provenance.html"><code>ptr::with_exposed_provenance</code></a>.</p>
<h2 id="if-let-rescope"><a class="header" href="#if-let-rescope">if-let-rescope</a></h2>
<p>The <code>if_let_rescope</code> lint detects cases where a temporary value with
significant drop is generated on the right hand side of <code>if let</code>
and suggests a rewrite into <code>match</code> when possible.</p>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(if_let_rescope)]
#![allow(unused_variables)]

struct Droppy;
impl Drop for Droppy {
    fn drop(&amp;mut self) {
        // Custom destructor, including this `drop` implementation, is considered
        // significant.
        // Rust does not check whether this destructor emits side-effects that can
        // lead to observable change in program semantics, when the drop order changes.
        // Rust biases to be on the safe side, so that you can apply discretion whether
        // this change indeed breaches any contract or specification that your code needs
        // to honour.
        println!("dropped");
    }
}
impl Droppy {
    fn get(&amp;self) -&gt; Option&lt;u8&gt; {
        None
    }
}

fn main() {
    if let Some(value) = Droppy.get() {
        // do something
    } else {
        // do something else
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `if let` assigns a shorter lifetime since Edition 2024
  --&gt; lint_example.rs:24:8
   |
24 |     if let Some(value) = Droppy.get() {
   |        ^^^^^^^^^^^^^^^^^^------^^^^^^
   |                          |
   |                          this value has a significant drop implementation which may observe a major change in drop order and requires your discretion
   |
   = warning: this changes meaning in Rust 2024
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html&gt;
note: value invokes this custom destructor
  --&gt; lint_example.rs:5:1
   |
 5 | impl Drop for Droppy {
   | ^^^^^^^^^^^^^^^^^^^^
help: the value is now dropped here in Edition 2024
  --&gt; lint_example.rs:26:5
   |
26 |     } else {
   |     ^
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![warn(if_let_rescope)]
   |         ^^^^^^^^^^^^^^
help: a `match` with a single arm can preserve the drop order up to Edition 2021
   |
24 ~     match Droppy.get() { Some(value) =&gt; {
25 |         // do something
26 ~     } _ =&gt; {
27 |         // do something else
28 ~     }}
   |

</code></pre>
<h3 id="explanation-10"><a class="header" href="#explanation-10">Explanation</a></h3>
<p>With Edition 2024, temporaries generated while evaluating <code>if let</code>s
will be dropped before the <code>else</code> block.
This lint captures a possible change in runtime behaviour due to
a change in sequence of calls to significant <code>Drop::drop</code> destructors.</p>
<p>A significant <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop::drop</code></a>
destructor here refers to an explicit, arbitrary implementation of the <code>Drop</code> trait on the type
with exceptions including <code>Vec</code>, <code>Box</code>, <code>Rc</code>, <code>BTreeMap</code> and <code>HashMap</code>
that are marked by the compiler otherwise so long that the generic types have
no significant destructor recursively.
In other words, a type has a significant drop destructor when it has a <code>Drop</code> implementation
or its destructor invokes a significant destructor on a type.
Since we cannot completely reason about the change by just inspecting the existence of
a significant destructor, this lint remains only a suggestion and is set to <code>allow</code> by default.</p>
<p>Whenever possible, a rewrite into an equivalent <code>match</code> expression that
observe the same order of calls to such destructors is proposed by this lint.
Authors may take their own discretion whether the rewrite suggestion shall be
accepted, or rejected to continue the use of the <code>if let</code> expression.</p>
<h2 id="impl-trait-overcaptures"><a class="header" href="#impl-trait-overcaptures">impl-trait-overcaptures</a></h2>
<p>The <code>impl_trait_overcaptures</code> lint warns against cases where lifetime
capture behavior will differ in edition 2024.</p>
<p>In the 2024 edition, <code>impl Trait</code>s will capture all lifetimes in scope,
rather than just the lifetimes that are mentioned in the bounds of the type.
Often these sets are equal, but if not, it means that the <code>impl Trait</code> may
cause erroneous borrow-checker errors.</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><code class="language-rust compile_fail edition2021"><span class="boring">#![deny(impl_trait_overcaptures)]
</span><span class="boring">use std::fmt::Display;
</span>let mut x = vec![];
x.push(1);

fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display {
    x[0]
}

let element = test(&amp;x);
x.push(2);
println!("{element}");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `impl std::fmt::Display` will capture more lifetimes than possibly intended in edition 2024
 --&gt; lint_example.rs:7:26
  |
7 | fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display {
  |                          ^^^^^^^^^^^^
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/rpit-lifetime-capture.html&gt;
note: specifically, this lifetime is in scope but not mentioned in the type's bounds
 --&gt; lint_example.rs:7:12
  |
7 | fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display {
  |            ^
  = note: all lifetimes in scope will be captured by `impl Trait`s in edition 2024
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(impl_trait_overcaptures)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^
help: use the precise capturing `use&lt;...&gt;` syntax to make the captures explicit
  |
7 | fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display + use&lt;&gt; {
  |                                       +++++++

</code></pre>
<h3 id="explanation-11"><a class="header" href="#explanation-11">Explanation</a></h3>
<p>In edition &lt; 2024, the returned <code>impl Display</code> doesn’t capture the
lifetime from the <code>&amp;Vec&lt;i32&gt;</code>, so the vector can be mutably borrowed
while the <code>impl Display</code> is live.</p>
<p>To fix this, we can explicitly state that the <code>impl Display</code> doesn’t
capture any lifetimes, using <code>impl Display + use&lt;&gt;</code>.</p>
<h2 id="impl-trait-redundant-captures"><a class="header" href="#impl-trait-redundant-captures">impl-trait-redundant-captures</a></h2>
<p>The <code>impl_trait_redundant_captures</code> lint warns against cases where use of the
precise capturing <code>use&lt;...&gt;</code> syntax is not needed.</p>
<p>In the 2024 edition, <code>impl Trait</code>s will capture all lifetimes in scope.
If precise-capturing <code>use&lt;...&gt;</code> syntax is used, and the set of parameters
that are captures are <em>equal</em> to the set of parameters in scope, then
the syntax is redundant, and can be removed.</p>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<pre><code class="language-rust edition2024 compile_fail"><span class="boring">#![deny(impl_trait_redundant_captures)]
</span>fn test&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Sized + use&lt;'a&gt; { x }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: all possible in-scope parameters are already captured, so `use&lt;...&gt;` syntax is redundant
 --&gt; lint_example.rs:3:28
  |
3 | fn test&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Sized + use&lt;'a&gt; { x }
  |                            ^^^^^^^^^^^^^-------
  |                                         |
  |                                         help: remove the `use&lt;...&gt;` syntax
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(impl_trait_redundant_captures)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-12"><a class="header" href="#explanation-12">Explanation</a></h3>
<p>To fix this, remove the <code>use&lt;'a&gt;</code>, since the lifetime is already captured
since it is in scope.</p>
<h2 id="keyword-idents"><a class="header" href="#keyword-idents">keyword-idents</a></h2>
<p>The lint <code>keyword-idents</code> has been renamed to <a href="#keyword-idents-2018"><code>keyword-idents-2018</code></a>.</p>
<h2 id="keyword-idents-2018"><a class="header" href="#keyword-idents-2018">keyword-idents-2018</a></h2>
<p>The <code>keyword_idents_2018</code> lint detects edition keywords being used as an
identifier.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(keyword_idents_2018)]
// edition 2015
fn dyn() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `dyn` is a keyword in the 2018 edition
 --&gt; lint_example.rs:4:4
  |
4 | fn dyn() {}
  |    ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(keyword_idents_2018)]
  |         ^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-13"><a class="header" href="#explanation-13">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses new keywords
that are added to the language that are used as identifiers (such as a
variable name, function name, etc.). If you switch the compiler to a
new edition without updating the code, then it will fail to compile if
you are using a new keyword as an identifier.</p>
<p>You can manually change the identifiers to a non-keyword, or use a
<a href="https://doc.rust-lang.org/reference/identifiers.html">raw identifier</a>, for example <code>r#dyn</code>, to transition to a new edition.</p>
<p>This lint solves the problem automatically. It is “allow” by default
because the code is perfectly valid in older editions. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to “warn”
and automatically apply the suggested fix from the compiler (which is
to use a raw identifier). This provides a completely automated way to
update old code for a new edition.</p>
<h2 id="keyword-idents-2024"><a class="header" href="#keyword-idents-2024">keyword-idents-2024</a></h2>
<p>The <code>keyword_idents_2024</code> lint detects edition keywords being used as an
identifier.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(keyword_idents_2024)]
// edition 2015
fn gen() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `gen` is a keyword in the 2024 edition
 --&gt; lint_example.rs:4:4
  |
4 | fn gen() {}
  |    ^^^ help: you can use a raw identifier to stay compatible: `r#gen`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/gen-keyword.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(keyword_idents_2024)]
  |         ^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-14"><a class="header" href="#explanation-14">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses new keywords
that are added to the language that are used as identifiers (such as a
variable name, function name, etc.). If you switch the compiler to a
new edition without updating the code, then it will fail to compile if
you are using a new keyword as an identifier.</p>
<p>You can manually change the identifiers to a non-keyword, or use a
<a href="https://doc.rust-lang.org/reference/identifiers.html">raw identifier</a>, for example <code>r#gen</code>, to transition to a new edition.</p>
<p>This lint solves the problem automatically. It is “allow” by default
because the code is perfectly valid in older editions. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to “warn”
and automatically apply the suggested fix from the compiler (which is
to use a raw identifier). This provides a completely automated way to
update old code for a new edition.</p>
<h2 id="let-underscore-drop"><a class="header" href="#let-underscore-drop">let-underscore-drop</a></h2>
<p>The <code>let_underscore_drop</code> lint checks for statements which don’t bind
an expression which has a non-trivial Drop implementation to anything,
causing the expression to be dropped immediately instead of at end of
scope.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<pre><code class="language-rust">struct SomeStruct;
impl Drop for SomeStruct {
    fn drop(&amp;mut self) {
        println!("Dropping SomeStruct");
    }
}

fn main() {
   #[warn(let_underscore_drop)]
    // SomeStruct is dropped immediately instead of at end of scope,
    // so "Dropping SomeStruct" is printed before "end of main".
    // The order of prints would be reversed if SomeStruct was bound to
    // a name (such as "_foo").
    let _ = SomeStruct;
    println!("end of main");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: non-binding let on a type that has a destructor
  --&gt; lint_example.rs:14:5
   |
14 |     let _ = SomeStruct;
   |     ^^^^^^^^^^^^^^^^^^^
   |
note: the lint level is defined here
  --&gt; lint_example.rs:9:11
   |
 9 |    #[warn(let_underscore_drop)]
   |           ^^^^^^^^^^^^^^^^^^^
help: consider binding to an unused variable to avoid immediately dropping the value
   |
14 |     let _unused = SomeStruct;
   |          ++++++
help: consider immediately dropping the value
   |
14 -     let _ = SomeStruct;
14 +     drop(SomeStruct);
   |

</code></pre>
<h3 id="explanation-15"><a class="header" href="#explanation-15">Explanation</a></h3>
<p>Statements which assign an expression to an underscore causes the
expression to immediately drop instead of extending the expression’s
lifetime to the end of the scope. This is usually unintended,
especially for types like <code>MutexGuard</code>, which are typically used to
lock a mutex for the duration of an entire scope.</p>
<p>If you want to extend the expression’s lifetime to the end of the scope,
assign an underscore-prefixed name (such as <code>_foo</code>) to the expression.
If you do actually want to drop the expression immediately, then
calling <code>std::mem::drop</code> on the expression is clearer and helps convey
intent.</p>
<h2 id="linker-messages"><a class="header" href="#linker-messages">linker-messages</a></h2>
<p>The <code>linker_messages</code> lint forwards warnings from the linker.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<pre><code class="language-rust ignore (needs CLI args platform-specific)">#[warn(linker_messages)]
extern "C" {
  fn foo();
}
fn main () { unsafe { foo(); } }</code></pre>
<p>On Linux, using <code>gcc -Wl,--warn-unresolved-symbols</code> as a linker, this will produce</p>
<pre><code class="language-text">warning: linker stderr: rust-lld: undefined symbol: foo
         &gt;&gt;&gt; referenced by rust_out.69edbd30df4ae57d-cgu.0
         &gt;&gt;&gt;               rust_out.rust_out.69edbd30df4ae57d-cgu.0.rcgu.o:(rust_out::main::h3a90094b06757803)
  |
note: the lint level is defined here
 --&gt; warn.rs:1:9
  |
1 | #![warn(linker_messages)]
  |         ^^^^^^^^^^^^^^^
warning: 1 warning emitted
</code></pre>
<h3 id="explanation-16"><a class="header" href="#explanation-16">Explanation</a></h3>
<p>Linkers emit platform-specific and program-specific warnings that cannot be predicted in
advance by the Rust compiler. Such messages are ignored by default for now. While linker
warnings could be very useful they have been ignored for many years by essentially all
users, so we need to do a bit more work than just surfacing their text to produce a clear
and actionable warning of similar quality to our other diagnostics. See this tracking
issue for more details: <a href="https://github.com/rust-lang/rust/issues/136096">https://github.com/rust-lang/rust/issues/136096</a>.</p>
<h2 id="lossy-provenance-casts"><a class="header" href="#lossy-provenance-casts">lossy-provenance-casts</a></h2>
<p>The <code>lossy_provenance_casts</code> lint detects an <code>as</code> cast between a pointer
and an integer.</p>
<h3 id="example-17"><a class="header" href="#example-17">Example</a></h3>
<pre><code class="language-rust">#![feature(strict_provenance_lints)]
#![warn(lossy_provenance_casts)]

fn main() {
    let x: u8 = 37;
    let _addr: usize = &amp;x as *const u8 as usize;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: under strict provenance it is considered bad style to cast pointer `*const u8` to integer `usize`
 --&gt; lint_example.rs:6:24
  |
6 |     let _addr: usize = &amp;x as *const u8 as usize;
  |                        ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: if you can't comply with strict provenance and need to expose the pointer provenance you can use `.expose_provenance()` instead
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![warn(lossy_provenance_casts)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
help: use `.addr()` to obtain the address of a pointer
  |
6 -     let _addr: usize = &amp;x as *const u8 as usize;
6 +     let _addr: usize = (&amp;x as *const u8).addr();
  |

</code></pre>
<h3 id="explanation-17"><a class="header" href="#explanation-17">Explanation</a></h3>
<p>This lint is part of the strict provenance effort, see <a href="https://github.com/rust-lang/rust/issues/95228">issue #95228</a>.
Casting a pointer to an integer is a lossy operation, because beyond
just an <em>address</em> a pointer may be associated with a particular
<em>provenance</em>. This information is used by the optimiser and for dynamic
analysis/dynamic program verification (e.g. Miri or CHERI platforms).</p>
<p>Since this cast is lossy, it is considered good style to use the
<a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.addr"><code>ptr::addr</code></a> method instead, which has a similar effect, but doesn’t
“expose” the pointer provenance. This improves optimisation potential.
See the docs of <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.addr"><code>ptr::addr</code></a> and <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.expose_provenance"><code>ptr::expose_provenance</code></a> for more information
about exposing pointer provenance.</p>
<p>If your code can’t comply with strict provenance and needs to expose
the provenance, then there is <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.expose_provenance"><code>ptr::expose_provenance</code></a> as an escape hatch,
which preserves the behaviour of <code>as usize</code> casts while being explicit
about the semantics.</p>
<h2 id="macro-use-extern-crate"><a class="header" href="#macro-use-extern-crate">macro-use-extern-crate</a></h2>
<p>The <code>macro_use_extern_crate</code> lint detects the use of the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a>.</p>
<h3 id="example-18"><a class="header" href="#example-18">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#![deny(macro_use_extern_crate)]

#[macro_use]
extern crate serde_json;

fn main() {
    let _ = json!{{}};
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: applying the `#[macro_use]` attribute to an `extern crate` item is deprecated
 --&gt; src/main.rs:3:1
  |
3 | #[macro_use]
  | ^^^^^^^^^^^^
  |
  = help: remove it and import macros at use sites with a `use` item instead
note: the lint level is defined here
 --&gt; src/main.rs:1:9
  |
1 | #![deny(macro_use_extern_crate)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<h3 id="explanation-18"><a class="header" href="#explanation-18">Explanation</a></h3>
<p>The <a href="https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a> on an <a href="https://doc.rust-lang.org/reference/items/extern-crates.html"><code>extern crate</code></a> item causes
macros in that external crate to be brought into the prelude of the
crate, making the macros in scope everywhere. As part of the efforts
to simplify handling of dependencies in the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate">2018 edition</a>, the use of
<code>extern crate</code> is being phased out. To bring macros from extern crates
into scope, it is recommended to use a <a href="https://doc.rust-lang.org/reference/items/use-declarations.html"><code>use</code> import</a>.</p>
<p>This lint is “allow” by default because this is a stylistic choice
that has not been settled, see <a href="https://github.com/rust-lang/rust/issues/52043">issue #52043</a> for more information.</p>
<h2 id="meta-variable-misuse"><a class="header" href="#meta-variable-misuse">meta-variable-misuse</a></h2>
<p>The <code>meta_variable_misuse</code> lint detects possible meta-variable misuse
in macro definitions.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(meta_variable_misuse)]

macro_rules! foo {
    () =&gt; {};
    ($( $i:ident = $($j:ident),+ );*) =&gt; { $( $( $i = $k; )+ )* };
}

fn main() {
    foo!();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unknown macro variable `k`
 --&gt; lint_example.rs:5:55
  |
5 |     ($( $i:ident = $($j:ident),+ );*) =&gt; { $( $( $i = $k; )+ )* };
  |                                                       ^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(meta_variable_misuse)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-19"><a class="header" href="#explanation-19">Explanation</a></h3>
<p>There are quite a few different ways a <a href="https://doc.rust-lang.org/reference/macros-by-example.html"><code>macro_rules</code></a> macro can be
improperly defined. Many of these errors were previously only detected
when the macro was expanded or not at all. This lint is an attempt to
catch some of these problems when the macro is <em>defined</em>.</p>
<p>This lint is “allow” by default because it may have false positives
and other issues. See <a href="https://github.com/rust-lang/rust/issues/61053">issue #61053</a> for more details.</p>
<h2 id="missing-copy-implementations"><a class="header" href="#missing-copy-implementations">missing-copy-implementations</a></h2>
<p>The <code>missing_copy_implementations</code> lint detects potentially-forgotten
implementations of <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> for public types.</p>
<h3 id="example-20"><a class="header" href="#example-20">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_copy_implementations)]
pub struct Foo {
    pub field: i32
}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type could implement `Copy`; consider adding `impl Copy`
 --&gt; lint_example.rs:2:1
  |
2 | / pub struct Foo {
3 | |     pub field: i32
4 | | }
  | |_^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_copy_implementations)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-20"><a class="header" href="#explanation-20">Explanation</a></h3>
<p>Historically (before 1.0), types were automatically marked as <code>Copy</code>
if possible. This was changed so that it required an explicit opt-in
by implementing the <code>Copy</code> trait. As part of this change, a lint was
added to alert if a copyable type was not marked <code>Copy</code>.</p>
<p>This lint is “allow” by default because this code isn’t bad; it is
common to write newtypes like this specifically so that a <code>Copy</code> type
is no longer <code>Copy</code>. <code>Copy</code> types can result in unintended copies of
large data which can impact performance.</p>
<h2 id="missing-debug-implementations"><a class="header" href="#missing-debug-implementations">missing-debug-implementations</a></h2>
<p>The <code>missing_debug_implementations</code> lint detects missing
implementations of <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>fmt::Debug</code></a> for public types.</p>
<h3 id="example-21"><a class="header" href="#example-21">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_debug_implementations)]
pub struct Foo;
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type does not implement `Debug`; consider adding `#[derive(Debug)]` or a manual implementation
 --&gt; lint_example.rs:2:1
  |
2 | pub struct Foo;
  | ^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_debug_implementations)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-21"><a class="header" href="#explanation-21">Explanation</a></h3>
<p>Having a <code>Debug</code> implementation on all types can assist with
debugging, as it provides a convenient way to format and display a
value. Using the <code>#[derive(Debug)]</code> attribute will automatically
generate a typical implementation, or a custom implementation can be
added by manually implementing the <code>Debug</code> trait.</p>
<p>This lint is “allow” by default because adding <code>Debug</code> to all types can
have a negative impact on compile time and code size. It also requires
boilerplate to be added to every type, which can be an impediment.</p>
<h2 id="missing-docs"><a class="header" href="#missing-docs">missing-docs</a></h2>
<p>The <code>missing_docs</code> lint detects missing documentation for public items.</p>
<h3 id="example-22"><a class="header" href="#example-22">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_docs)]
pub fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: missing documentation for the crate
 --&gt; lint_example.rs:1:1
  |
1 | / #![deny(missing_docs)]
2 | | fn main() {
3 | | pub fn foo() {}
4 | | }
  | |_^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_docs)]
  |         ^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-22"><a class="header" href="#explanation-22">Explanation</a></h3>
<p>This lint is intended to ensure that a library is well-documented.
Items without documentation can be difficult for users to understand
how to use properly.</p>
<p>This lint is “allow” by default because it can be noisy, and not all
projects may want to enforce everything to be documented.</p>
<h2 id="missing-unsafe-on-extern"><a class="header" href="#missing-unsafe-on-extern">missing-unsafe-on-extern</a></h2>
<p>The <code>missing_unsafe_on_extern</code> lint detects missing unsafe keyword on extern declarations.</p>
<h3 id="example-23"><a class="header" href="#example-23">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(missing_unsafe_on_extern)]
#![allow(dead_code)]

extern "C" {
    fn foo(_: i32);
}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: extern blocks should be unsafe
 --&gt; lint_example.rs:4:1
  |
4 |   extern "C" {
  |   ^
  |   |
  |  _help: needs `unsafe` before the extern keyword: `unsafe`
  | |
5 | |     fn foo(_: i32);
6 | | }
  | |_^
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-extern.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(missing_unsafe_on_extern)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-23"><a class="header" href="#explanation-23">Explanation</a></h3>
<p>Declaring extern items, even without ever using them, can cause Undefined Behavior. We
should consider all sources of Undefined Behavior to be unsafe.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="multiple-supertrait-upcastable"><a class="header" href="#multiple-supertrait-upcastable">multiple-supertrait-upcastable</a></h2>
<p>The <code>multiple_supertrait_upcastable</code> lint detects when a dyn-compatible trait has multiple
supertraits.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><code class="language-rust">#![feature(multiple_supertrait_upcastable)]
trait A {}
trait B {}

#[warn(multiple_supertrait_upcastable)]
trait C: A + B {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `C` is dyn-compatible and has multiple supertraits
 --&gt; lint_example.rs:7:1
  |
7 | trait C: A + B {}
  | ^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:6:8
  |
6 | #[warn(multiple_supertrait_upcastable)]
  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-24"><a class="header" href="#explanation-24">Explanation</a></h3>
<p>To support upcasting with multiple supertraits, we need to store multiple vtables and this
can result in extra space overhead, even if no code actually uses upcasting.
This lint allows users to identify when such scenarios occur and to decide whether the
additional overhead is justified.</p>
<h2 id="must-not-suspend"><a class="header" href="#must-not-suspend">must-not-suspend</a></h2>
<p>The <code>must_not_suspend</code> lint guards against values that shouldn’t be held across suspend points
(<code>.await</code>)</p>
<h3 id="example-25"><a class="header" href="#example-25">Example</a></h3>
<pre><code class="language-rust">#![feature(must_not_suspend)]
#![warn(must_not_suspend)]

#[must_not_suspend]
struct SyncThing {}

async fn yield_now() {}

pub async fn uhoh() {
    let guard = SyncThing {};
    yield_now().await;
    let _guard = guard;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `SyncThing` held across a suspend point, but should not be
  --&gt; lint_example.rs:11:9
   |
11 |     let guard = SyncThing {};
   |         ^^^^^
12 |     yield_now().await;
   |                 ----- the value is held across this suspend point
   |
help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point
  --&gt; lint_example.rs:11:9
   |
11 |     let guard = SyncThing {};
   |         ^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:2:9
   |
 2 | #![warn(must_not_suspend)]
   |         ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-25"><a class="header" href="#explanation-25">Explanation</a></h3>
<p>The <code>must_not_suspend</code> lint detects values that are marked with the <code>#[must_not_suspend]</code>
attribute being held across suspend points. A “suspend” point is usually a <code>.await</code> in an async
function.</p>
<p>This attribute can be used to mark values that are semantically incorrect across suspends
(like certain types of timers), values that have async alternatives, and values that
regularly cause problems with the <code>Send</code>-ness of async fn’s returned futures (like
<code>MutexGuard</code>’s)</p>
<h2 id="non-ascii-idents"><a class="header" href="#non-ascii-idents">non-ascii-idents</a></h2>
<p>The <code>non_ascii_idents</code> lint detects non-ASCII identifiers.</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(non_ascii_idents)]
fn main() {
    let föö = 1;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: identifier contains non-ASCII characters
 --&gt; lint_example.rs:4:9
  |
4 |     let föö = 1;
  |         ^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(non_ascii_idents)]
  |         ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-26"><a class="header" href="#explanation-26">Explanation</a></h3>
<p>This lint allows projects that wish to retain the limit of only using
ASCII characters to switch this lint to “forbid” (for example to ease
collaboration or for security reasons).
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md">RFC 2457</a> for more details.</p>
<h2 id="non-exhaustive-omitted-patterns"><a class="header" href="#non-exhaustive-omitted-patterns">non-exhaustive-omitted-patterns</a></h2>
<p>The <code>non_exhaustive_omitted_patterns</code> lint aims to help consumers of a <code>#[non_exhaustive]</code>
struct or enum who want to match all of its fields/variants explicitly.</p>
<p>The <code>#[non_exhaustive]</code> annotation forces matches to use wildcards, so exhaustiveness
checking cannot be used to ensure that all fields/variants are matched explicitly. To remedy
this, this allow-by-default lint warns the user when a match mentions some but not all of
the fields/variants of a <code>#[non_exhaustive]</code> struct or enum.</p>
<h3 id="example-27"><a class="header" href="#example-27">Example</a></h3>
<pre><code class="language-rust ignore (needs separate crate)">// crate A
#[non_exhaustive]
pub enum Bar {
    A,
    B, // added variant in non breaking change
}

// in crate B
#![feature(non_exhaustive_omitted_patterns_lint)]
#[warn(non_exhaustive_omitted_patterns)]
match Bar::A {
    Bar::A =&gt; {},
    _ =&gt; {},
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: some variants are not matched explicitly
   --&gt; $DIR/reachable-patterns.rs:70:9
   |
LL |         match Bar::A {
   |               ^ pattern `Bar::B` not covered
   |
 note: the lint level is defined here
  --&gt; $DIR/reachable-patterns.rs:69:16
   |
LL |         #[warn(non_exhaustive_omitted_patterns)]
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: ensure that all variants are matched explicitly by adding the suggested match arms
   = note: the matched value is of type `Bar` and the `non_exhaustive_omitted_patterns` attribute was found
</code></pre>
<p>Warning: setting this to <code>deny</code> will make upstream non-breaking changes (adding fields or
variants to a <code>#[non_exhaustive]</code> struct or enum) break your crate. This goes against
expected semver behavior.</p>
<h3 id="explanation-27"><a class="header" href="#explanation-27">Explanation</a></h3>
<p>Structs and enums tagged with <code>#[non_exhaustive]</code> force the user to add a (potentially
redundant) wildcard when pattern-matching, to allow for future addition of fields or
variants. The <code>non_exhaustive_omitted_patterns</code> lint detects when such a wildcard happens to
actually catch some fields/variants. In other words, when the match without the wildcard
would not be exhaustive. This lets the user be informed if new fields/variants were added.</p>
<h2 id="or-patterns-back-compat"><a class="header" href="#or-patterns-back-compat">or-patterns-back-compat</a></h2>
<p>The lint <code>or-patterns-back-compat</code> has been renamed to <a href="#rust-2021-incompatible-or-patterns"><code>rust-2021-incompatible-or-patterns</code></a>.</p>
<h2 id="redundant-imports"><a class="header" href="#redundant-imports">redundant-imports</a></h2>
<p>The <code>redundant_imports</code> lint detects imports that are redundant due to being
imported already; either through a previous import, or being present in
the prelude.</p>
<h3 id="example-28"><a class="header" href="#example-28">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(redundant_imports)]
use std::option::Option::None;
fn foo() -&gt; Option&lt;i32&gt; { None }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the item `None` is imported redundantly
   --&gt; lint_example.rs:3:5
    |
  3 | use std::option::Option::None;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: /Users/runner/work/rust/rust/library/std/src/prelude/mod.rs:166:13
    |
166 |     pub use core::prelude::rust_2024::*;
    |             ------------------------ the item `None` is already defined here
    |
note: the lint level is defined here
   --&gt; lint_example.rs:1:9
    |
  1 | #![deny(redundant_imports)]
    |         ^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-28"><a class="header" href="#explanation-28">Explanation</a></h3>
<p>Redundant imports are unnecessary and can be removed to simplify code.
If you intended to re-export the item to make it available outside of the
module, add a visibility modifier like <code>pub</code>.</p>
<h2 id="redundant-lifetimes"><a class="header" href="#redundant-lifetimes">redundant-lifetimes</a></h2>
<p>The <code>redundant_lifetimes</code> lint detects lifetime parameters that are
redundant because they are equal to another named lifetime.</p>
<h3 id="example-29"><a class="header" href="#example-29">Example</a></h3>
<pre><code class="language-rust compile_fail">#[deny(redundant_lifetimes)]

// `'a = 'static`, so all usages of `'a` can be replaced with `'static`
pub fn bar&lt;'a: 'static&gt;() {}

// `'a = 'b`, so all usages of `'b` can be replaced with `'a`
pub fn bar&lt;'a: 'b, 'b: 'a&gt;() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unnecessary lifetime parameter `'a`
 --&gt; lint_example.rs:5:12
  |
5 | pub fn bar&lt;'a: 'static&gt;() {}
  |            ^^
  |
  = note: you can use the `'static` lifetime directly, in place of `'a`
note: the lint level is defined here
 --&gt; lint_example.rs:2:8
  |
2 | #[deny(redundant_lifetimes)]
  |        ^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-29"><a class="header" href="#explanation-29">Explanation</a></h3>
<p>Unused lifetime parameters may signal a mistake or unfinished code.
Consider removing the parameter.</p>
<h2 id="resolving-to-items-shadowing-supertrait-items"><a class="header" href="#resolving-to-items-shadowing-supertrait-items">resolving-to-items-shadowing-supertrait-items</a></h2>
<p>The <code>resolving_to_items_shadowing_supertrait_items</code> lint detects when the
usage of an item that is provided by both a subtrait and supertrait
is shadowed, preferring the subtrait.</p>
<h3 id="example-30"><a class="header" href="#example-30">Example</a></h3>
<pre><code class="language-rust compile_fail">#![feature(supertrait_item_shadowing)]
#![deny(resolving_to_items_shadowing_supertrait_items)]

trait Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Upstream for T {}

trait Downstream: Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Downstream for T {}

struct MyType;
MyType.hello();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait item `hello` from `Downstream` shadows identically named item from supertrait
  --&gt; lint_example.rs:16:8
   |
16 | MyType.hello();
   |        ^^^^^
   |
note: item from `Downstream` shadows a supertrait item
  --&gt; lint_example.rs:11:5
   |
11 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
note: item from `Upstream` is shadowed by a subtrait item
  --&gt; lint_example.rs:6:5
   |
 6 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:2:9
   |
 2 | #![deny(resolving_to_items_shadowing_supertrait_items)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-30"><a class="header" href="#explanation-30">Explanation</a></h3>
<p>RFC 3624 specified a heuristic in which a supertrait item would be
shadowed by a subtrait item when ambiguity occurs during item
selection. In order to mitigate side-effects of this happening
silently, this lint detects these cases when users want to deny them
or fix the call sites.</p>
<h2 id="rust-2021-incompatible-closure-captures"><a class="header" href="#rust-2021-incompatible-closure-captures">rust-2021-incompatible-closure-captures</a></h2>
<p>The <code>rust_2021_incompatible_closure_captures</code> lint detects variables that aren’t completely
captured in Rust 2021, such that the <code>Drop</code> order of their fields may differ between
Rust 2018 and 2021.</p>
<p>It can also detect when a variable implements a trait like <code>Send</code>, but one of its fields does not,
and the field is captured by a closure and used with the assumption that said field implements
the same trait as the root variable.</p>
<h3 id="example-of-drop-reorder"><a class="header" href="#example-of-drop-reorder">Example of drop reorder</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_incompatible_closure_captures)]
<span class="boring">#![allow(unused)]
</span>
struct FancyInteger(i32);

impl Drop for FancyInteger {
    fn drop(&amp;mut self) {
        println!("Just dropped {}", self.0);
    }
}

struct Point { x: FancyInteger, y: FancyInteger }

fn main() {
  let p = Point { x: FancyInteger(10), y: FancyInteger(20) };

  let c = || {
     let x = p.x;
  };

  c();

  // ... More code ...
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: changes to closure capture in Rust 2021 will affect drop order
  --&gt; lint_example.rs:17:11
   |
17 |   let c = || {
   |           ^^
18 |      let x = p.x;
   |              --- in Rust 2018, this closure captures all of `p`, but in Rust 2021, it will only capture `p.x`
...
24 | }
   | - in Rust 2018, `p` is dropped here, but in Rust 2021, only `p.x` will be dropped here as part of the closure
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html&gt;
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(rust_2021_incompatible_closure_captures)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: add a dummy let to cause `p` to be fully captured
   |
17 ~   let c = || {
18 +      let _ = &amp;p;
   |

</code></pre>
<h3 id="explanation-31"><a class="header" href="#explanation-31">Explanation</a></h3>
<p>In the above example, <code>p.y</code> will be dropped at the end of <code>f</code> instead of
with <code>c</code> in Rust 2021.</p>
<h3 id="example-of-auto-trait"><a class="header" href="#example-of-auto-trait">Example of auto-trait</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_incompatible_closure_captures)]
use std::thread;

struct Pointer(*mut i32);
unsafe impl Send for Pointer {}

fn main() {
    let mut f = 10;
    let fptr = Pointer(&amp;mut f as *mut i32);
    thread::spawn(move || unsafe {
        *fptr.0 = 20;
    });
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: changes to closure capture in Rust 2021 will affect which traits the closure implements
  --&gt; lint_example.rs:10:19
   |
10 |     thread::spawn(move || unsafe {
   |                   ^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0` does not implement `Send`
11 |         *fptr.0 = 20;
   |         ------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html&gt;
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(rust_2021_incompatible_closure_captures)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: add a dummy let to cause `fptr` to be fully captured
   |
10 ~     thread::spawn(move || { let _ = &amp;fptr; unsafe {
11 |         *fptr.0 = 20;
12 ~     } });
   |

</code></pre>
<h3 id="explanation-32"><a class="header" href="#explanation-32">Explanation</a></h3>
<p>In the above example, only <code>fptr.0</code> is captured in Rust 2021.
The field is of type <code>*mut i32</code>, which doesn’t implement <code>Send</code>,
making the code invalid as the field cannot be sent between threads safely.</p>
<h2 id="rust-2021-incompatible-or-patterns"><a class="header" href="#rust-2021-incompatible-or-patterns">rust-2021-incompatible-or-patterns</a></h2>
<p>The <code>rust_2021_incompatible_or_patterns</code> lint detects usage of old versions of or-patterns.</p>
<h3 id="example-31"><a class="header" href="#example-31">Example</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_incompatible_or_patterns)]

macro_rules! match_any {
    ( $expr:expr , $( $( $pat:pat )|+ =&gt; $expr_arm:expr ),+ ) =&gt; {
        match $expr {
            $(
                $( $pat =&gt; $expr_arm, )+
            )+
        }
    };
}

fn main() {
    let result: Result&lt;i64, i32&gt; = Err(42);
    let int: i64 = match_any!(result, Ok(i) | Err(i) =&gt; i.into());
    assert_eq!(int, 42);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro
 --&gt; lint_example.rs:4:26
  |
4 |     ( $expr:expr , $( $( $pat:pat )|+ =&gt; $expr_arm:expr ),+ ) =&gt; {
  |                          ^^^^^^^^ help: use pat_param to preserve semantics: `$pat:pat_param`
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2021_incompatible_or_patterns)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-33"><a class="header" href="#explanation-33">Explanation</a></h3>
<p>In Rust 2021, the <code>pat</code> matcher will match additional patterns, which include the <code>|</code> character.</p>
<h2 id="rust-2021-prefixes-incompatible-syntax"><a class="header" href="#rust-2021-prefixes-incompatible-syntax">rust-2021-prefixes-incompatible-syntax</a></h2>
<p>The <code>rust_2021_prefixes_incompatible_syntax</code> lint detects identifiers that will be parsed as a
prefix instead in Rust 2021.</p>
<h3 id="example-32"><a class="header" href="#example-32">Example</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_prefixes_incompatible_syntax)]

macro_rules! m {
    (z $x:expr) =&gt; ();
}

m!(z"hey");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: prefix `z` is unknown
 --&gt; lint_example.rs:8:4
  |
8 | m!(z"hey");
  |    ^ unknown prefix
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/reserving-syntax.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2021_prefixes_incompatible_syntax)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: insert whitespace here to avoid this being parsed as a prefix in Rust 2021
  |
8 | m!(z "hey");
  |     +

</code></pre>
<h3 id="explanation-34"><a class="header" href="#explanation-34">Explanation</a></h3>
<p>In Rust 2015 and 2018, <code>z"hey"</code> is two tokens: the identifier <code>z</code>
followed by the string literal <code>"hey"</code>. In Rust 2021, the <code>z</code> is
considered a prefix for <code>"hey"</code>.</p>
<p>This lint suggests to add whitespace between the <code>z</code> and <code>"hey"</code> tokens
to keep them separated in Rust 2021.</p>
<h2 id="rust-2021-prelude-collisions"><a class="header" href="#rust-2021-prelude-collisions">rust-2021-prelude-collisions</a></h2>
<p>The <code>rust_2021_prelude_collisions</code> lint detects the usage of trait methods which are ambiguous
with traits added to the prelude in future editions.</p>
<h3 id="example-33"><a class="header" href="#example-33">Example</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_prelude_collisions)]

trait Foo {
    fn try_into(self) -&gt; Result&lt;String, !&gt;;
}

impl Foo for &amp;str {
    fn try_into(self) -&gt; Result&lt;String, !&gt; {
        Ok(String::from(self))
    }
}

fn main() {
    let x: String = "3".try_into().unwrap();
    //                  ^^^^^^^^
    // This call to try_into matches both Foo::try_into and TryInto::try_into as
    // `TryInto` has been added to the Rust prelude in 2021 edition.
    println!("{x}");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait method `try_into` will become ambiguous in Rust 2021
  --&gt; lint_example.rs:14:21
   |
14 |     let x: String = "3".try_into().unwrap();
   |                     ^^^^^^^^^^^^^^ help: disambiguate the associated function: `Foo::try_into(&amp;*"3")`
   |
   = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/prelude.html&gt;
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(rust_2021_prelude_collisions)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-35"><a class="header" href="#explanation-35">Explanation</a></h3>
<p>In Rust 2021, one of the important introductions is the <a href="https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html#prelude-changes">prelude changes</a>, which add
<code>TryFrom</code>, <code>TryInto</code>, and <code>FromIterator</code> into the standard library’s prelude. Since this
results in an ambiguity as to which method/function to call when an existing <code>try_into</code>
method is called via dot-call syntax or a <code>try_from</code>/<code>from_iter</code> associated function
is called directly on a type.</p>
<h2 id="rust-2024-guarded-string-incompatible-syntax"><a class="header" href="#rust-2024-guarded-string-incompatible-syntax">rust-2024-guarded-string-incompatible-syntax</a></h2>
<p>The <code>rust_2024_guarded_string_incompatible_syntax</code> lint detects <code>#</code> tokens
that will be parsed as part of a guarded string literal in Rust 2024.</p>
<h3 id="example-34"><a class="header" href="#example-34">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(rust_2024_guarded_string_incompatible_syntax)]

macro_rules! m {
    (# $x:expr #) =&gt; ();
    (# $x:expr) =&gt; ();
}

m!(#"hey"#);
m!(#"hello");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: will be parsed as a guarded string in Rust 2024
 --&gt; lint_example.rs:9:4
  |
9 | m!(#"hey"#);
  |    ^^^^^^^
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2024_guarded_string_incompatible_syntax)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: insert whitespace here to avoid this being parsed as a guarded string in Rust 2024
  |
9 | m!(# "hey"#);
  |     +


error: will be parsed as a guarded string in Rust 2024
  --&gt; lint_example.rs:10:4
   |
10 | m!(#"hello");
   |    ^^^^^^^^
   |
   = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html&gt;
help: insert whitespace here to avoid this being parsed as a guarded string in Rust 2024
   |
10 | m!(# "hello");
   |     +

</code></pre>
<h3 id="explanation-36"><a class="header" href="#explanation-36">Explanation</a></h3>
<p>Prior to Rust 2024, <code>#"hey"#</code> is three tokens: the first <code>#</code>
followed by the string literal <code>"hey"</code> then the final <code>#</code>.
In Rust 2024, the whole sequence is considered a single token.</p>
<p>This lint suggests to add whitespace between the leading <code>#</code>
and the string to keep them separated in Rust 2024.</p>
<h2 id="rust-2024-incompatible-pat"><a class="header" href="#rust-2024-incompatible-pat">rust-2024-incompatible-pat</a></h2>
<p>The <code>rust_2024_incompatible_pat</code> lint
detects patterns whose meaning will change in the Rust 2024 edition.</p>
<h3 id="example-35"><a class="header" href="#example-35">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(rust_2024_incompatible_pat)]

if let Some(&amp;a) = &amp;Some(&amp;0u8) {
    let _: u8 = a;
}
if let Some(mut _a) = &amp;mut Some(0u8) {
    _a = 7u8;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot explicitly dereference within an implicitly-borrowing pattern in Rust 2024
 --&gt; lint_example.rs:4:13
  |
4 | if let Some(&amp;a) = &amp;Some(&amp;0u8) {
  |             ^ reference pattern not allowed when implicitly borrowing
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html&gt;
note: matching on a reference type with a non-reference pattern implicitly borrows the contents
 --&gt; lint_example.rs:4:8
  |
4 | if let Some(&amp;a) = &amp;Some(&amp;0u8) {
  |        ^^^^^^^^ this non-reference pattern matches on a reference type `&amp;_`
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(rust_2024_incompatible_pat)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
help: match on the reference with a reference pattern to avoid implicitly borrowing
  |
4 | if let &amp;Some(&amp;a) = &amp;Some(&amp;0u8) {
  |        +


warning: cannot mutably bind by value within an implicitly-borrowing pattern in Rust 2024
 --&gt; lint_example.rs:7:13
  |
7 | if let Some(mut _a) = &amp;mut Some(0u8) {
  |             ^^^ `mut` binding modifier not allowed when implicitly borrowing
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html&gt;
note: matching on a reference type with a non-reference pattern implicitly borrows the contents
 --&gt; lint_example.rs:7:8
  |
7 | if let Some(mut _a) = &amp;mut Some(0u8) {
  |        ^^^^^^^^^^^^ this non-reference pattern matches on a reference type `&amp;mut _`
help: match on the reference with a reference pattern to avoid implicitly borrowing
  |
7 | if let &amp;mut Some(mut _a) = &amp;mut Some(0u8) {
  |        ++++

</code></pre>
<h3 id="explanation-37"><a class="header" href="#explanation-37">Explanation</a></h3>
<p>In Rust 2024 and above, the <code>mut</code> keyword does not reset the pattern binding mode,
and nor do <code>&amp;</code> or <code>&amp;mut</code> patterns. The lint will suggest code that
has the same meaning in all editions.</p>
<h2 id="rust-2024-prelude-collisions"><a class="header" href="#rust-2024-prelude-collisions">rust-2024-prelude-collisions</a></h2>
<p>The <code>rust_2024_prelude_collisions</code> lint detects the usage of trait methods which are ambiguous
with traits added to the prelude in future editions.</p>
<h3 id="example-36"><a class="header" href="#example-36">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(rust_2024_prelude_collisions)]
trait Meow {
    fn poll(&amp;self) {}
}
impl&lt;T&gt; Meow for T {}

fn main() {
    core::pin::pin!(async {}).poll();
    //                        ^^^^^^
    // This call to try_into matches both Future::poll and Meow::poll as
    // `Future` has been added to the Rust prelude in 2024 edition.
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait method `poll` will become ambiguous in Rust 2024
 --&gt; lint_example.rs:8:5
  |
8 |     core::pin::pin!(async {}).poll();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `Meow::poll(&amp;core::pin::pin!(async {}))`
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/prelude.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2024_prelude_collisions)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-38"><a class="header" href="#explanation-38">Explanation</a></h3>
<p>Rust 2024, introduces two new additions to the standard library’s prelude:
<code>Future</code> and <code>IntoFuture</code>. This results in an ambiguity as to which method/function
to call when an existing <code>poll</code>/<code>into_future</code> method is called via dot-call syntax or
a <code>poll</code>/<code>into_future</code> associated function is called directly on a type.</p>
<h2 id="shadowing-supertrait-items"><a class="header" href="#shadowing-supertrait-items">shadowing-supertrait-items</a></h2>
<p>The <code>shadowing_supertrait_items</code> lint detects when the
definition of an item that is provided by both a subtrait and
supertrait is shadowed, preferring the subtrait.</p>
<h3 id="example-37"><a class="header" href="#example-37">Example</a></h3>
<pre><code class="language-rust compile_fail">#![feature(supertrait_item_shadowing)]
#![deny(shadowing_supertrait_items)]

trait Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Upstream for T {}

trait Downstream: Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Downstream for T {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait item `hello` from `Downstream` shadows identically named item from supertrait
  --&gt; lint_example.rs:11:5
   |
11 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
   |
note: item from `Upstream` is shadowed by a subtrait item
  --&gt; lint_example.rs:6:5
   |
 6 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:2:9
   |
 2 | #![deny(shadowing_supertrait_items)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-39"><a class="header" href="#explanation-39">Explanation</a></h3>
<p>RFC 3624 specified a heuristic in which a supertrait item would be
shadowed by a subtrait item when ambiguity occurs during item
selection. In order to mitigate side-effects of this happening
silently, this lint detects these cases when users want to deny them
or fix their trait definitions.</p>
<h2 id="single-use-lifetime"><a class="header" href="#single-use-lifetime">single-use-lifetime</a></h2>
<p>The lint <code>single-use-lifetime</code> has been renamed to <a href="#single-use-lifetimes"><code>single-use-lifetimes</code></a>.</p>
<h2 id="single-use-lifetimes"><a class="header" href="#single-use-lifetimes">single-use-lifetimes</a></h2>
<p>The <code>single_use_lifetimes</code> lint detects lifetimes that are only used
once.</p>
<h3 id="example-38"><a class="header" href="#example-38">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(single_use_lifetimes)]

fn foo&lt;'a&gt;(x: &amp;'a u32) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: lifetime parameter `'a` only used once
 --&gt; lint_example.rs:4:8
  |
4 | fn foo&lt;'a&gt;(x: &amp;'a u32) {}
  |        ^^      -- ...is used only here
  |        |
  |        this lifetime...
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(single_use_lifetimes)]
  |         ^^^^^^^^^^^^^^^^^^^^
help: elide the single-use lifetime
  |
4 - fn foo&lt;'a&gt;(x: &amp;'a u32) {}
4 + fn foo(x: &amp;u32) {}
  |

</code></pre>
<h3 id="explanation-40"><a class="header" href="#explanation-40">Explanation</a></h3>
<p>Specifying an explicit lifetime like <code>'a</code> in a function or <code>impl</code>
should only be used to link together two things. Otherwise, you should
just use <code>'_</code> to indicate that the lifetime is not linked to anything,
or elide the lifetime altogether if possible.</p>
<p>This lint is “allow” by default because it was introduced at a time
when <code>'_</code> and elided lifetimes were first being introduced, and this
lint would be too noisy. Also, there are some known false positives
that it produces. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2115-argument-lifetimes.md">RFC 2115</a> for historical context, and <a href="https://github.com/rust-lang/rust/issues/44752">issue
#44752</a> for more details.</p>
<h2 id="tail-expr-drop-order"><a class="header" href="#tail-expr-drop-order">tail-expr-drop-order</a></h2>
<p>The <code>tail_expr_drop_order</code> lint looks for those values generated at the tail expression location,
that runs a custom <code>Drop</code> destructor.
Some of them may be dropped earlier in Edition 2024 that they used to in Edition 2021 and prior.
This lint detects those cases and provides you information on those values and their custom destructor implementations.
Your discretion on this information is required.</p>
<h3 id="example-39"><a class="header" href="#example-39">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(tail_expr_drop_order)]
struct Droppy(i32);
impl Droppy {
    fn get(&amp;self) -&gt; i32 {
        self.0
    }
}
impl Drop for Droppy {
    fn drop(&amp;mut self) {
        // This is a custom destructor and it induces side-effects that is observable
        // especially when the drop order at a tail expression changes.
        println!("loud drop {}", self.0);
    }
}
fn edition_2021() -&gt; i32 {
    let another_droppy = Droppy(0);
    Droppy(1).get()
}
fn main() {
    edition_2021();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: relative drop order changing in Rust 2024
  --&gt; lint_example.rs:17:5
   |
16 |     let another_droppy = Droppy(0);
   |         --------------
   |         |
   |         `another_droppy` calls a custom destructor
   |         `another_droppy` will be dropped later as of Edition 2024
17 |     Droppy(1).get()
   |     ^^^^^^^^^
   |     |
   |     this value will be stored in a temporary; let us call it `#1`
   |     up until Edition 2021 `#1` is dropped last but will be dropped earlier in Edition 2024
18 | }
   | - now the temporary value is dropped here, before the local variables in the block or statement
   |
   = warning: this changes meaning in Rust 2024
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/temporary-tail-expr-scope.html&gt;
note: `#1` invokes this custom destructor
  --&gt; lint_example.rs:8:1
   |
 8 | impl Drop for Droppy {
   | ^^^^^^^^^^^^^^^^^^^^
note: `another_droppy` invokes this custom destructor
  --&gt; lint_example.rs:8:1
   |
 8 | impl Drop for Droppy {
   | ^^^^^^^^^^^^^^^^^^^^
   = note: most of the time, changing drop order is harmless; inspect the `impl Drop`s for side effects like releasing locks or sending messages
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![warn(tail_expr_drop_order)]
   |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-41"><a class="header" href="#explanation-41">Explanation</a></h3>
<p>In tail expression of blocks or function bodies,
values of type with significant <code>Drop</code> implementation has an ill-specified drop order
before Edition 2024 so that they are dropped only after dropping local variables.
Edition 2024 introduces a new rule with drop orders for them,
so that they are dropped first before dropping local variables.</p>
<p>A significant <code>Drop::drop</code> destructor here refers to an explicit, arbitrary
implementation of the <code>Drop</code> trait on the type, with exceptions including <code>Vec</code>,
<code>Box</code>, <code>Rc</code>, <code>BTreeMap</code> and <code>HashMap</code> that are marked by the compiler otherwise
so long that the generic types have no significant destructor recursively.
In other words, a type has a significant drop destructor when it has a <code>Drop</code> implementation
or its destructor invokes a significant destructor on a type.
Since we cannot completely reason about the change by just inspecting the existence of
a significant destructor, this lint remains only a suggestion and is set to <code>allow</code> by default.</p>
<p>This lint only points out the issue with <code>Droppy</code>, which will be dropped before <code>another_droppy</code>
does in Edition 2024.
No fix will be proposed by this lint.
However, the most probable fix is to hoist <code>Droppy</code> into its own local variable binding.</p>
<pre><code class="language-rust">struct Droppy(i32);
impl Droppy {
    fn get(&amp;self) -&gt; i32 {
        self.0
    }
}
fn edition_2024() -&gt; i32 {
    let value = Droppy(0);
    let another_droppy = Droppy(1);
    value.get()
}</code></pre>
<h2 id="trivial-casts"><a class="header" href="#trivial-casts">trivial-casts</a></h2>
<p>The <code>trivial_casts</code> lint detects trivial casts which could be replaced
with coercion, which may require a temporary variable.</p>
<h3 id="example-40"><a class="header" href="#example-40">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(trivial_casts)]
let x: &amp;u32 = &amp;42;
let y = x as *const u32;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trivial cast: `&amp;u32` as `*const u32`
 --&gt; lint_example.rs:4:9
  |
4 | let y = x as *const u32;
  |         ^^^^^^^^^^^^^^^
  |
  = help: cast can be replaced by coercion; this might require a temporary variable
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(trivial_casts)]
  |         ^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-42"><a class="header" href="#explanation-42">Explanation</a></h3>
<p>A trivial cast is a cast <code>e as T</code> where <code>e</code> has type <code>U</code> and <code>U</code> is a
subtype of <code>T</code>. This type of cast is usually unnecessary, as it can be
usually be inferred.</p>
<p>This lint is “allow” by default because there are situations, such as
with FFI interfaces or complex type aliases, where it triggers
incorrectly, or in situations where it will be more difficult to
clearly express the intent. It may be possible that this will become a
warning in the future, possibly with an explicit syntax for coercions
providing a convenient way to work around the current issues.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401 (coercions)</a>, <a href="https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md">RFC 803 (type ascription)</a> and
<a href="https://github.com/rust-lang/rfcs/blob/master/text/3307-de-rfc-type-ascription.md">RFC 3307 (remove type ascription)</a> for historical context.</p>
<h2 id="trivial-numeric-casts"><a class="header" href="#trivial-numeric-casts">trivial-numeric-casts</a></h2>
<p>The <code>trivial_numeric_casts</code> lint detects trivial numeric casts of types
which could be removed.</p>
<h3 id="example-41"><a class="header" href="#example-41">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(trivial_numeric_casts)]
let x = 42_i32 as i32;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trivial numeric cast: `i32` as `i32`
 --&gt; lint_example.rs:3:9
  |
3 | let x = 42_i32 as i32;
  |         ^^^^^^^^^^^^^
  |
  = help: cast can be replaced by coercion; this might require a temporary variable
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(trivial_numeric_casts)]
  |         ^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-43"><a class="header" href="#explanation-43">Explanation</a></h3>
<p>A trivial numeric cast is a cast of a numeric type to the same numeric
type. This type of cast is usually unnecessary.</p>
<p>This lint is “allow” by default because there are situations, such as
with FFI interfaces or complex type aliases, where it triggers
incorrectly, or in situations where it will be more difficult to
clearly express the intent. It may be possible that this will become a
warning in the future, possibly with an explicit syntax for coercions
providing a convenient way to work around the current issues.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401 (coercions)</a>, <a href="https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md">RFC 803 (type ascription)</a> and
<a href="https://github.com/rust-lang/rfcs/blob/master/text/3307-de-rfc-type-ascription.md">RFC 3307 (remove type ascription)</a> for historical context.</p>
<h2 id="unit-bindings"><a class="header" href="#unit-bindings">unit-bindings</a></h2>
<p>The <code>unit_bindings</code> lint detects cases where bindings are useless because they have
the unit type <code>()</code> as their inferred type. The lint is suppressed if the user explicitly
annotates the let binding with the unit type <code>()</code>, or if the let binding uses an underscore
wildcard pattern, i.e. <code>let _ = expr</code>, or if the binding is produced from macro expansions.</p>
<h3 id="example-42"><a class="header" href="#example-42">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unit_bindings)]

fn foo() {
    println!("do work");
}

pub fn main() {
    let x = foo(); // useless binding
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: binding has unit type `()`
 --&gt; lint_example.rs:8:5
  |
8 |     let x = foo(); // useless binding
  |     ^^^^-^^^^^^^^^
  |         |
  |         this pattern is inferred to be the unit type `()`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unit_bindings)]
  |         ^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-44"><a class="header" href="#explanation-44">Explanation</a></h3>
<p>Creating a local binding with the unit type <code>()</code> does not do much and can be a sign of a
user error, such as in this example:</p>
<pre><code class="language-rust no_run">fn main() {
    let mut x = [1, 2, 3];
    x[0] = 5;
    let y = x.sort(); // useless binding as `sort` returns `()` and not the sorted array.
    println!("{:?}", y); // prints "()"
}</code></pre>
<h2 id="unnameable-types"><a class="header" href="#unnameable-types">unnameable-types</a></h2>
<p>The <code>unnameable_types</code> lint detects types for which you can get objects of that type,
but cannot name the type itself.</p>
<h3 id="example-43"><a class="header" href="#example-43">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(unnameable_types)]
mod m {
    pub struct S;
}

pub fn get_unnameable() -&gt; m::S { m::S }
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: struct `S` is reachable but cannot be named
 --&gt; lint_example.rs:4:5
  |
4 |     pub struct S;
  |     ^^^^^^^^^^^^ reachable at visibility `pub`, but can only be named at visibility `pub(crate)`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(unnameable_types)]
  |         ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-45"><a class="header" href="#explanation-45">Explanation</a></h3>
<p>It is often expected that if you can obtain an object of type <code>T</code>, then
you can name the type <code>T</code> as well; this lint attempts to enforce this rule.
The recommended action is to either reexport the type properly to make it nameable,
or document that users are not supposed to be able to name it for one reason or another.</p>
<p>Besides types, this lint applies to traits because traits can also leak through signatures,
and you may obtain objects of their <code>dyn Trait</code> or <code>impl Trait</code> types.</p>
<h2 id="unqualified-local-imports"><a class="header" href="#unqualified-local-imports">unqualified-local-imports</a></h2>
<p>The <code>unqualified_local_imports</code> lint checks for <code>use</code> items that import a local item using a
path that does not start with <code>self::</code>, <code>super::</code>, or <code>crate::</code>.</p>
<h3 id="example-44"><a class="header" href="#example-44">Example</a></h3>
<pre><code class="language-rust edition2018">#![feature(unqualified_local_imports)]
#![warn(unqualified_local_imports)]

mod localmod {
    pub struct S;
}

use localmod::S;
<span class="boring">// We have to actually use `S`, or else the `unused` warnings suppress the lint we care about.
</span><span class="boring">pub fn main() {
</span><span class="boring">    let _x = S;
</span><span class="boring">}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `use` of a local item without leading `self::`, `super::`, or `crate::`
 --&gt; lint_example.rs:8:5
  |
8 | use localmod::S;
  |     ^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![warn(unqualified_local_imports)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-46"><a class="header" href="#explanation-46">Explanation</a></h3>
<p>This lint is meant to be used with the (unstable) rustfmt setting <code>group_imports = "StdExternalCrate"</code>.
That setting makes rustfmt group <code>self::</code>, <code>super::</code>, and <code>crate::</code> imports separately from those
referring to other crates. However, rustfmt cannot know whether <code>use c::S;</code> refers to a local module <code>c</code>
or an external crate <code>c</code>, so it always gets categorized as an import from another crate.
To ensure consistent grouping of imports from the local crate, all local imports must
start with <code>self::</code>, <code>super::</code>, or <code>crate::</code>. This lint can be used to enforce that style.</p>
<h2 id="unreachable-pub"><a class="header" href="#unreachable-pub">unreachable-pub</a></h2>
<p>The <code>unreachable_pub</code> lint triggers for <code>pub</code> items not reachable from other crates - that
means neither directly accessible, nor reexported (with <code>pub use</code>), nor leaked through
things like return types (which the <a href="#unnameable-types"><code>unnameable_types</code></a> lint can detect if desired).</p>
<h3 id="example-45"><a class="header" href="#example-45">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unreachable_pub)]
mod foo {
    pub mod bar {

    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unreachable `pub` item
 --&gt; lint_example.rs:4:5
  |
4 |     pub mod bar {
  |     ---^^^^^^^^
  |     |
  |     help: consider restricting its visibility: `pub(crate)`
  |
  = help: or consider exporting it for use by other crates
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unreachable_pub)]
  |         ^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-47"><a class="header" href="#explanation-47">Explanation</a></h3>
<p>The <code>pub</code> keyword both expresses an intent for an item to be publicly available, and also
signals to the compiler to make the item publicly accessible. The intent can only be
satisfied, however, if all items which contain this item are <em>also</em> publicly accessible.
Thus, this lint serves to identify situations where the intent does not match the reality.</p>
<p>If you wish the item to be accessible elsewhere within the crate, but not outside it, the
<code>pub(crate)</code> visibility is recommended to be used instead. This more clearly expresses the
intent that the item is only visible within its own crate.</p>
<p>This lint is “allow” by default because it will trigger for a large amount of existing Rust code.
Eventually it is desired for this to become warn-by-default.</p>
<h2 id="unsafe-attr-outside-unsafe"><a class="header" href="#unsafe-attr-outside-unsafe">unsafe-attr-outside-unsafe</a></h2>
<p>The <code>unsafe_attr_outside_unsafe</code> lint detects a missing unsafe keyword
on attributes considered unsafe.</p>
<h3 id="example-46"><a class="header" href="#example-46">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(unsafe_attr_outside_unsafe)]

#[no_mangle]
extern "C" fn foo() {}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unsafe attribute used without unsafe
 --&gt; lint_example.rs:3:3
  |
3 | #[no_mangle]
  |   ^^^^^^^^^ usage of unsafe attribute
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-attributes.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(unsafe_attr_outside_unsafe)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
help: wrap the attribute in `unsafe(...)`
  |
3 | #[unsafe(no_mangle)]
  |   +++++++         +

</code></pre>
<h3 id="explanation-48"><a class="header" href="#explanation-48">Explanation</a></h3>
<p>Some attributes (e.g. <code>no_mangle</code>, <code>export_name</code>, <code>link_section</code> – see
<a href="https://github.com/rust-lang/rust/issues/82499">issue #82499</a> for a more complete list) are considered “unsafe” attributes.
An unsafe attribute must only be used inside unsafe(…).</p>
<p>This lint can automatically wrap the attributes in <code>unsafe(...)</code> , but this
obviously cannot verify that the preconditions of the <code>unsafe</code>
attributes are fulfilled, so that is still up to the user.</p>
<p>The lint is currently “allow” by default, but that might change in the
future.</p>
<h2 id="unsafe-code"><a class="header" href="#unsafe-code">unsafe-code</a></h2>
<p>The <code>unsafe_code</code> lint catches usage of <code>unsafe</code> code and other
potentially unsound constructs like <code>no_mangle</code>, <code>export_name</code>,
and <code>link_section</code>.</p>
<h3 id="example-47"><a class="header" href="#example-47">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unsafe_code)]
fn main() {
    unsafe {

    }
}

#[no_mangle]
fn func_0() { }

#[export_name = "exported_symbol_name"]
pub fn name_in_rust() { }

#[no_mangle]
#[link_section = ".example_section"]
pub static VAR1: u32 = 1;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: usage of an `unsafe` block
 --&gt; lint_example.rs:3:5
  |
3 | /     unsafe {
4 | |
5 | |     }
  | |_____^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unsafe_code)]
  |         ^^^^^^^^^^^


error: declaration of a `no_mangle` function
 --&gt; lint_example.rs:8:1
  |
8 | #[no_mangle]
  | ^^^^^^^^^^^^
  |
  = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them


error: declaration of a function with `export_name`
  --&gt; lint_example.rs:11:1
   |
11 | #[export_name = "exported_symbol_name"]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them


error: declaration of a `no_mangle` static
  --&gt; lint_example.rs:14:1
   |
14 | #[no_mangle]
   | ^^^^^^^^^^^^
   |
   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them


error: declaration of a static with `link_section`
  --&gt; lint_example.rs:15:1
   |
15 | #[link_section = ".example_section"]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them

</code></pre>
<h3 id="explanation-49"><a class="header" href="#explanation-49">Explanation</a></h3>
<p>This lint is intended to restrict the usage of <code>unsafe</code> blocks and other
constructs (including, but not limited to <code>no_mangle</code>, <code>link_section</code>
and <code>export_name</code> attributes) wrong usage of which causes undefined
behavior.</p>
<h2 id="unsafe-op-in-unsafe-fn"><a class="header" href="#unsafe-op-in-unsafe-fn">unsafe-op-in-unsafe-fn</a></h2>
<p>The <code>unsafe_op_in_unsafe_fn</code> lint detects unsafe operations in unsafe
functions without an explicit unsafe block.</p>
<h3 id="example-48"><a class="header" href="#example-48">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unsafe_op_in_unsafe_fn)]

unsafe fn foo() {}

unsafe fn bar() {
    foo();
}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function `foo` is unsafe and requires unsafe block
 --&gt; lint_example.rs:6:5
  |
6 |     foo();
  |     ^^^^^ call to unsafe function
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html&gt;
  = note: consult the function's documentation for information on how to avoid undefined behavior
note: an unsafe function restricts its caller, but its body is safe by default
 --&gt; lint_example.rs:5:1
  |
5 | unsafe fn bar() {
  | ^^^^^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unsafe_op_in_unsafe_fn)]
  |         ^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-50"><a class="header" href="#explanation-50">Explanation</a></h3>
<p>Currently, an <a href="https://doc.rust-lang.org/reference/unsafe-functions.html"><code>unsafe fn</code></a> allows any <a href="https://doc.rust-lang.org/reference/unsafety.html">unsafe</a> operation within its
body. However, this can increase the surface area of code that needs
to be scrutinized for proper behavior. The <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks"><code>unsafe</code> block</a> provides a
convenient way to make it clear exactly which parts of the code are
performing unsafe operations. In the future, it is desired to change
it so that unsafe operations cannot be performed in an <code>unsafe fn</code>
without an <code>unsafe</code> block.</p>
<p>The fix to this is to wrap the unsafe code in an <code>unsafe</code> block.</p>
<p>This lint is “allow” by default on editions up to 2021, from 2024 it is
“warn” by default; the plan for increasing severity further is
still being considered. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2585-unsafe-block-in-unsafe-fn.md">RFC #2585</a> and <a href="https://github.com/rust-lang/rust/issues/71668">issue #71668</a> for more
details.</p>
<h2 id="unstable-features"><a class="header" href="#unstable-features">unstable-features</a></h2>
<p>The <code>unstable_features</code> lint detects uses of <code>#![feature]</code>.</p>
<h3 id="example-49"><a class="header" href="#example-49">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unstable_features)]
#![feature(test)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: use of an unstable feature
 --&gt; lint_example.rs:2:12
  |
2 | #![feature(test)]
  |            ^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unstable_features)]
  |         ^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-51"><a class="header" href="#explanation-51">Explanation</a></h3>
<p>In larger nightly-based projects which</p>
<ul>
<li>consist of a multitude of crates where a subset of crates has to compile on
stable either unconditionally or depending on a <code>cfg</code> flag to for example
allow stable users to depend on them,</li>
<li>don’t use nightly for experimental features but for, e.g., unstable options only,</li>
</ul>
<p>this lint may come in handy to enforce policies of these kinds.</p>
<h2 id="unused-crate-dependencies"><a class="header" href="#unused-crate-dependencies">unused-crate-dependencies</a></h2>
<p>The <code>unused_crate_dependencies</code> lint detects crate dependencies that
are never used.</p>
<h3 id="example-50"><a class="header" href="#example-50">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#![deny(unused_crate_dependencies)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: extern crate `regex` is unused in crate `lint_example`
  |
  = help: remove the dependency or add `use regex as _;` to the crate root
note: the lint level is defined here
 --&gt; src/lib.rs:1:9
  |
1 | #![deny(unused_crate_dependencies)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<h3 id="explanation-52"><a class="header" href="#explanation-52">Explanation</a></h3>
<p>After removing the code that uses a dependency, this usually also
requires removing the dependency from the build configuration.
However, sometimes that step can be missed, which leads to time wasted
building dependencies that are no longer used. This lint can be
enabled to detect dependencies that are never used (more specifically,
any dependency passed with the <code>--extern</code> command-line flag that is
never referenced via <a href="https://doc.rust-lang.org/reference/items/use-declarations.html"><code>use</code></a>, <a href="https://doc.rust-lang.org/reference/items/extern-crates.html"><code>extern crate</code></a>, or in any <a href="https://doc.rust-lang.org/reference/paths.html">path</a>).</p>
<p>This lint is “allow” by default because it can provide false positives
depending on how the build system is configured. For example, when
using Cargo, a “package” consists of multiple crates (such as a
library and a binary), but the dependencies are defined for the
package as a whole. If there is a dependency that is only used in the
binary, but not the library, then the lint will be incorrectly issued
in the library.</p>
<h2 id="unused-extern-crates"><a class="header" href="#unused-extern-crates">unused-extern-crates</a></h2>
<p>The <code>unused_extern_crates</code> lint guards against <code>extern crate</code> items
that are never used.</p>
<h3 id="example-51"><a class="header" href="#example-51">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_extern_crates)]
#![deny(warnings)]
extern crate proc_macro;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unused extern crate
 --&gt; lint_example.rs:4:1
  |
4 | extern crate proc_macro;
  | ^^^^^^^^^^^^^^^^^^^^^^^^ unused
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_extern_crates)]
  |         ^^^^^^^^^^^^^^^^^^^^
help: remove the unused `extern crate`
  |
4 - extern crate proc_macro;
  |

</code></pre>
<h3 id="explanation-53"><a class="header" href="#explanation-53">Explanation</a></h3>
<p><code>extern crate</code> items that are unused have no effect and should be
removed. Note that there are some cases where specifying an <code>extern crate</code> is desired for the side effect of ensuring the given crate is
linked, even though it is not otherwise directly referenced. The lint
can be silenced by aliasing the crate to an underscore, such as
<code>extern crate foo as _</code>. Also note that it is no longer idiomatic to
use <code>extern crate</code> in the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate">2018 edition</a>, as extern crates are now
automatically added in scope.</p>
<p>This lint is “allow” by default because it can be noisy, and produce
false-positives. If a dependency is being removed from a project, it
is recommended to remove it from the build configuration (such as
<code>Cargo.toml</code>) to ensure stale build entries aren’t left behind.</p>
<h2 id="unused-import-braces"><a class="header" href="#unused-import-braces">unused-import-braces</a></h2>
<p>The <code>unused_import_braces</code> lint catches unnecessary braces around an
imported item.</p>
<h3 id="example-52"><a class="header" href="#example-52">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_import_braces)]
use test::{A};

pub mod test {
    pub struct A;
}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: braces around A is unnecessary
 --&gt; lint_example.rs:2:1
  |
2 | use test::{A};
  | ^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_import_braces)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-54"><a class="header" href="#explanation-54">Explanation</a></h3>
<p>If there is only a single item, then remove the braces (<code>use test::A;</code>
for example).</p>
<p>This lint is “allow” by default because it is only enforcing a
stylistic choice.</p>
<h2 id="unused-lifetimes"><a class="header" href="#unused-lifetimes">unused-lifetimes</a></h2>
<p>The <code>unused_lifetimes</code> lint detects lifetime parameters that are never
used.</p>
<h3 id="example-53"><a class="header" href="#example-53">Example</a></h3>
<pre><code class="language-rust compile_fail">#[deny(unused_lifetimes)]

pub fn foo&lt;'a&gt;() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: lifetime parameter `'a` never used
 --&gt; lint_example.rs:4:12
  |
4 | pub fn foo&lt;'a&gt;() {}
  |           -^^- help: elide the unused lifetime
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:8
  |
2 | #[deny(unused_lifetimes)]
  |        ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-55"><a class="header" href="#explanation-55">Explanation</a></h3>
<p>Unused lifetime parameters may signal a mistake or unfinished code.
Consider removing the parameter.</p>
<h2 id="unused-macro-rules"><a class="header" href="#unused-macro-rules">unused-macro-rules</a></h2>
<p>The <code>unused_macro_rules</code> lint detects macro rules that were not used.</p>
<p>Note that the lint is distinct from the <code>unused_macros</code> lint, which
fires if the entire macro is never called, while this lint fires for
single unused rules of the macro that is otherwise used.
<code>unused_macro_rules</code> fires only if <code>unused_macros</code> wouldn’t fire.</p>
<h3 id="example-54"><a class="header" href="#example-54">Example</a></h3>
<pre><code class="language-rust">#[warn(unused_macro_rules)]
macro_rules! unused_empty {
    (hello) =&gt; { println!("Hello, world!") }; // This rule is unused
    () =&gt; { println!("empty") }; // This rule is used
}

fn main() {
    unused_empty!(hello);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: rule #2 of macro `unused_empty` is never used
 --&gt; lint_example.rs:4:5
  |
4 |     () =&gt; { println!("empty") }; // This rule is used
  |     ^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:8
  |
1 | #[warn(unused_macro_rules)]
  |        ^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-56"><a class="header" href="#explanation-56">Explanation</a></h3>
<p>Unused macro rules may signal a mistake or unfinished code. Furthermore,
they slow down compilation. Right now, silencing the warning is not
supported on a single rule level, so you have to add an allow to the
entire macro definition.</p>
<p>If you intended to export the macro to make it
available outside of the crate, use the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope"><code>macro_export</code> attribute</a>.</p>
<h2 id="unused-qualifications"><a class="header" href="#unused-qualifications">unused-qualifications</a></h2>
<p>The <code>unused_qualifications</code> lint detects unnecessarily qualified
names.</p>
<h3 id="example-55"><a class="header" href="#example-55">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_qualifications)]
mod foo {
    pub fn bar() {}
}

fn main() {
    use foo::bar;
    foo::bar();
    bar();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unnecessary qualification
 --&gt; lint_example.rs:8:5
  |
8 |     foo::bar();
  |     ^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_qualifications)]
  |         ^^^^^^^^^^^^^^^^^^^^^
help: remove the unnecessary path segments
  |
8 -     foo::bar();
8 +     bar();
  |

</code></pre>
<h3 id="explanation-57"><a class="header" href="#explanation-57">Explanation</a></h3>
<p>If an item from another module is already brought into scope, then
there is no need to qualify it in this case. You can call <code>bar()</code>
directly, without the <code>foo::</code>.</p>
<p>This lint is “allow” by default because it is somewhat pedantic, and
doesn’t indicate an actual problem, but rather a stylistic choice, and
can be noisy when refactoring or moving around code.</p>
<h2 id="unused-results"><a class="header" href="#unused-results">unused-results</a></h2>
<p>The <code>unused_results</code> lint checks for the unused result of an
expression in a statement.</p>
<h3 id="example-56"><a class="header" href="#example-56">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_results)]
fn foo&lt;T&gt;() -&gt; T { panic!() }

fn main() {
    foo::&lt;usize&gt;();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unused result of type `usize`
 --&gt; lint_example.rs:5:5
  |
5 |     foo::&lt;usize&gt;();
  |     ^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_results)]
  |         ^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-58"><a class="header" href="#explanation-58">Explanation</a></h3>
<p>Ignoring the return value of a function may indicate a mistake. In
cases were it is almost certain that the result should be used, it is
recommended to annotate the function with the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code> attribute</a>.
Failure to use such a return value will trigger the <a href="#unused-must-use"><code>unused_must_use</code>
lint</a> which is warn-by-default. The <code>unused_results</code> lint is
essentially the same, but triggers for <em>all</em> return values.</p>
<p>This lint is “allow” by default because it can be noisy, and may not be
an actual problem. For example, calling the <code>remove</code> method of a <code>Vec</code>
or <code>HashMap</code> returns the previous value, which you may not care about.
Using this lint would require explicitly ignoring or discarding such
values.</p>
<h2 id="variant-size-differences"><a class="header" href="#variant-size-differences">variant-size-differences</a></h2>
<p>The <code>variant_size_differences</code> lint detects enums with widely varying
variant sizes.</p>
<h3 id="example-57"><a class="header" href="#example-57">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(variant_size_differences)]
enum En {
    V0(u8),
    VBig([u8; 1024]),
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: enum variant is more than three times larger (1024 bytes) than the next largest
 --&gt; lint_example.rs:5:5
  |
5 |     VBig([u8; 1024]),
  |     ^^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(variant_size_differences)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-59"><a class="header" href="#explanation-59">Explanation</a></h3>
<p>It can be a mistake to add a variant to an enum that is much larger
than the other variants, bloating the overall size required for all
variants. This can impact performance and memory usage. This is
triggered if one variant is more than 3 times larger than the
second-largest variant.</p>
<p>Consider placing the large variant’s contents on the heap (for example
via <a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box</code></a>) to keep the overall size of the enum itself down.</p>
<p>This lint is “allow” by default because it can be noisy, and may not be
an actual problem. Decisions about this should be guided with
profiling and benchmarking.</p>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
    var fragments = {
        "#single-use-lifetime": "allowed-by-default.html#single-use-lifetimes",
        "#elided-lifetime-in-path": "allowed-by-default.html#elided-lifetimes-in-paths",
        "#async-idents": "allowed-by-default.html#keyword-idents",
        "#disjoint-capture-migration": "allowed-by-default.html#rust-2021-incompatible-closure-captures",
        "#keyword-idents": "allowed-by-default.html#keyword-idents-2018",
        "#or-patterns-back-compat": "allowed-by-default.html#rust-2021-incompatible-or-patterns",
};
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
});
</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="warn-by-default-lints"><a class="header" href="#warn-by-default-lints">Warn-by-default Lints</a></h1>
<p>These lints are all set to the ‘warn’ level by default.</p>
<ul>
<li><a href="#aarch64-softfloat-neon"><code>aarch64_softfloat_neon</code></a></li>
<li><a href="#ambiguous-glob-imported-traits"><code>ambiguous_glob_imported_traits</code></a></li>
<li><a href="#ambiguous-glob-imports"><code>ambiguous_glob_imports</code></a></li>
<li><a href="#ambiguous-glob-reexports"><code>ambiguous_glob_reexports</code></a></li>
<li><a href="#ambiguous-panic-imports"><code>ambiguous_panic_imports</code></a></li>
<li><a href="#ambiguous-wide-pointer-comparisons"><code>ambiguous_wide_pointer_comparisons</code></a></li>
<li><a href="#anonymous-parameters"><code>anonymous_parameters</code></a></li>
<li><a href="#array-into-iter"><code>array_into_iter</code></a></li>
<li><a href="#asm-sub-register"><code>asm_sub_register</code></a></li>
<li><a href="#async-fn-in-trait"><code>async_fn_in_trait</code></a></li>
<li><a href="#bad-asm-style"><code>bad_asm_style</code></a></li>
<li><a href="#bare-trait-object"><code>bare-trait-object</code></a></li>
<li><a href="#bare-trait-objects"><code>bare_trait_objects</code></a></li>
<li><a href="#boxed-slice-into-iter"><code>boxed_slice_into_iter</code></a></li>
<li><a href="#break-with-label-and-loop"><code>break_with_label_and_loop</code></a></li>
<li><a href="#clashing-extern-declarations"><code>clashing_extern_declarations</code></a></li>
<li><a href="#coherence-leak-check"><code>coherence_leak_check</code></a></li>
<li><a href="#confusable-idents"><code>confusable_idents</code></a></li>
<li><a href="#const-evaluatable-unchecked"><code>const_evaluatable_unchecked</code></a></li>
<li><a href="#const-item-interior-mutations"><code>const_item_interior_mutations</code></a></li>
<li><a href="#const-item-mutation"><code>const_item_mutation</code></a></li>
<li><a href="#dangling-pointers-from-locals"><code>dangling_pointers_from_locals</code></a></li>
<li><a href="#dangling-pointers-from-temporaries"><code>dangling_pointers_from_temporaries</code></a></li>
<li><a href="#dead-code"><code>dead_code</code></a></li>
<li><a href="#deprecated"><code>deprecated</code></a></li>
<li><a href="#deprecated-where-clause-location"><code>deprecated_where_clause_location</code></a></li>
<li><a href="#double-negations"><code>double_negations</code></a></li>
<li><a href="#drop-bounds"><code>drop_bounds</code></a></li>
<li><a href="#dropping-copy-types"><code>dropping_copy_types</code></a></li>
<li><a href="#dropping-references"><code>dropping_references</code></a></li>
<li><a href="#duplicate-macro-attributes"><code>duplicate_macro_attributes</code></a></li>
<li><a href="#dyn-drop"><code>dyn_drop</code></a></li>
<li><a href="#ellipsis-inclusive-range-patterns"><code>ellipsis_inclusive_range_patterns</code></a></li>
<li><a href="#exported-private-dependencies"><code>exported_private_dependencies</code></a></li>
<li><a href="#for-loops-over-fallibles"><code>for_loops_over_fallibles</code></a></li>
<li><a href="#forbidden-lint-groups"><code>forbidden_lint_groups</code></a></li>
<li><a href="#forgetting-copy-types"><code>forgetting_copy_types</code></a></li>
<li><a href="#forgetting-references"><code>forgetting_references</code></a></li>
<li><a href="#function-casts-as-integer"><code>function_casts_as_integer</code></a></li>
<li><a href="#function-item-references"><code>function_item_references</code></a></li>
<li><a href="#hidden-glob-reexports"><code>hidden_glob_reexports</code></a></li>
<li><a href="#improper-ctypes"><code>improper_ctypes</code></a></li>
<li><a href="#improper-ctypes-definitions"><code>improper_ctypes_definitions</code></a></li>
<li><a href="#improper-gpu-kernel-arg"><code>improper_gpu_kernel_arg</code></a></li>
<li><a href="#incomplete-features"><code>incomplete_features</code></a></li>
<li><a href="#inline-always-mismatching-target-features"><code>inline_always_mismatching_target_features</code></a></li>
<li><a href="#inline-no-sanitize"><code>inline_no_sanitize</code></a></li>
<li><a href="#integer-to-ptr-transmutes"><code>integer_to_ptr_transmutes</code></a></li>
<li><a href="#internal-features"><code>internal_features</code></a></li>
<li><a href="#invalid-from-utf8"><code>invalid_from_utf8</code></a></li>
<li><a href="#invalid-nan-comparisons"><code>invalid_nan_comparisons</code></a></li>
<li><a href="#invalid-value"><code>invalid_value</code></a></li>
<li><a href="#irrefutable-let-patterns"><code>irrefutable_let_patterns</code></a></li>
<li><a href="#large-assignments"><code>large_assignments</code></a></li>
<li><a href="#late-bound-lifetime-arguments"><code>late_bound_lifetime_arguments</code></a></li>
<li><a href="#malformed-diagnostic-attributes"><code>malformed_diagnostic_attributes</code></a></li>
<li><a href="#malformed-diagnostic-format-literals"><code>malformed_diagnostic_format_literals</code></a></li>
<li><a href="#map-unit-fn"><code>map_unit_fn</code></a></li>
<li><a href="#mismatched-lifetime-syntaxes"><code>mismatched_lifetime_syntaxes</code></a></li>
<li><a href="#misplaced-diagnostic-attributes"><code>misplaced_diagnostic_attributes</code></a></li>
<li><a href="#missing-abi"><code>missing_abi</code></a></li>
<li><a href="#missing-gpu-kernel-export-name"><code>missing_gpu_kernel_export_name</code></a></li>
<li><a href="#mixed-script-confusables"><code>mixed_script_confusables</code></a></li>
<li><a href="#named-arguments-used-positionally"><code>named_arguments_used_positionally</code></a></li>
<li><a href="#no-mangle-generic-items"><code>no_mangle_generic_items</code></a></li>
<li><a href="#non-fmt-panic"><code>non-fmt-panic</code></a></li>
<li><a href="#non-camel-case-types"><code>non_camel_case_types</code></a></li>
<li><a href="#non-contiguous-range-endpoints"><code>non_contiguous_range_endpoints</code></a></li>
<li><a href="#non-fmt-panics"><code>non_fmt_panics</code></a></li>
<li><a href="#non-local-definitions"><code>non_local_definitions</code></a></li>
<li><a href="#non-shorthand-field-patterns"><code>non_shorthand_field_patterns</code></a></li>
<li><a href="#non-snake-case"><code>non_snake_case</code></a></li>
<li><a href="#non-upper-case-globals"><code>non_upper_case_globals</code></a></li>
<li><a href="#noop-method-call"><code>noop_method_call</code></a></li>
<li><a href="#opaque-hidden-inferred-bound"><code>opaque_hidden_inferred_bound</code></a></li>
<li><a href="#overlapping-patterns"><code>overlapping-patterns</code></a></li>
<li><a href="#overlapping-range-endpoints"><code>overlapping_range_endpoints</code></a></li>
<li><a href="#path-statements"><code>path_statements</code></a></li>
<li><a href="#private-bounds"><code>private_bounds</code></a></li>
<li><a href="#private-interfaces"><code>private_interfaces</code></a></li>
<li><a href="#ptr-to-integer-transmute-in-consts"><code>ptr_to_integer_transmute_in_consts</code></a></li>
<li><a href="#redundant-semicolon"><code>redundant-semicolon</code></a></li>
<li><a href="#redundant-semicolons"><code>redundant_semicolons</code></a></li>
<li><a href="#refining-impl-trait-internal"><code>refining_impl_trait_internal</code></a></li>
<li><a href="#refining-impl-trait-reachable"><code>refining_impl_trait_reachable</code></a></li>
<li><a href="#renamed-and-removed-lints"><code>renamed_and_removed_lints</code></a></li>
<li><a href="#repr-c-enums-larger-than-int"><code>repr_c_enums_larger_than_int</code></a></li>
<li><a href="#rtsan-nonblocking-async"><code>rtsan_nonblocking_async</code></a></li>
<li><a href="#self-constructor-from-outer-item"><code>self_constructor_from_outer_item</code></a></li>
<li><a href="#special-module-name"><code>special_module_name</code></a></li>
<li><a href="#stable-features"><code>stable_features</code></a></li>
<li><a href="#static-mut-ref"><code>static-mut-ref</code></a></li>
<li><a href="#static-mut-refs"><code>static_mut_refs</code></a></li>
<li><a href="#suspicious-double-ref-op"><code>suspicious_double_ref_op</code></a></li>
<li><a href="#tail-call-track-caller"><code>tail_call_track_caller</code></a></li>
<li><a href="#trivial-bounds"><code>trivial_bounds</code></a></li>
<li><a href="#type-alias-bounds"><code>type_alias_bounds</code></a></li>
<li><a href="#tyvar-behind-raw-pointer"><code>tyvar_behind_raw_pointer</code></a></li>
<li><a href="#uncommon-codepoints"><code>uncommon_codepoints</code></a></li>
<li><a href="#unconditional-recursion"><code>unconditional_recursion</code></a></li>
<li><a href="#uncovered-param-in-projection"><code>uncovered_param_in_projection</code></a></li>
<li><a href="#unexpected-cfgs"><code>unexpected_cfgs</code></a></li>
<li><a href="#unfulfilled-lint-expectations"><code>unfulfilled_lint_expectations</code></a></li>
<li><a href="#ungated-async-fn-track-caller"><code>ungated_async_fn_track_caller</code></a></li>
<li><a href="#uninhabited-static"><code>uninhabited_static</code></a></li>
<li><a href="#unknown-diagnostic-attributes"><code>unknown_diagnostic_attributes</code></a></li>
<li><a href="#unknown-lints"><code>unknown_lints</code></a></li>
<li><a href="#unnameable-test-items"><code>unnameable_test_items</code></a></li>
<li><a href="#unnecessary-transmutes"><code>unnecessary_transmutes</code></a></li>
<li><a href="#unpredictable-function-pointer-comparisons"><code>unpredictable_function_pointer_comparisons</code></a></li>
<li><a href="#unreachable-code"><code>unreachable_code</code></a></li>
<li><a href="#unreachable-patterns"><code>unreachable_patterns</code></a></li>
<li><a href="#unstable-name-collision"><code>unstable-name-collision</code></a></li>
<li><a href="#unstable-name-collisions"><code>unstable_name_collisions</code></a></li>
<li><a href="#unstable-syntax-pre-expansion"><code>unstable_syntax_pre_expansion</code></a></li>
<li><a href="#unsupported-calling-conventions"><code>unsupported_calling_conventions</code></a></li>
<li><a href="#unsupported-fn-ptr-calling-conventions"><code>unsupported_fn_ptr_calling_conventions</code></a></li>
<li><a href="#unused-doc-comment"><code>unused-doc-comment</code></a></li>
<li><a href="#unused-tuple-struct-fields"><code>unused-tuple-struct-fields</code></a></li>
<li><a href="#unused-allocation"><code>unused_allocation</code></a></li>
<li><a href="#unused-assignments"><code>unused_assignments</code></a></li>
<li><a href="#unused-associated-type-bounds"><code>unused_associated_type_bounds</code></a></li>
<li><a href="#unused-attributes"><code>unused_attributes</code></a></li>
<li><a href="#unused-braces"><code>unused_braces</code></a></li>
<li><a href="#unused-comparisons"><code>unused_comparisons</code></a></li>
<li><a href="#unused-doc-comments"><code>unused_doc_comments</code></a></li>
<li><a href="#unused-features"><code>unused_features</code></a></li>
<li><a href="#unused-imports"><code>unused_imports</code></a></li>
<li><a href="#unused-labels"><code>unused_labels</code></a></li>
<li><a href="#unused-macros"><code>unused_macros</code></a></li>
<li><a href="#unused-must-use"><code>unused_must_use</code></a></li>
<li><a href="#unused-mut"><code>unused_mut</code></a></li>
<li><a href="#unused-parens"><code>unused_parens</code></a></li>
<li><a href="#unused-unsafe"><code>unused_unsafe</code></a></li>
<li><a href="#unused-variables"><code>unused_variables</code></a></li>
<li><a href="#unused-visibilities"><code>unused_visibilities</code></a></li>
<li><a href="#useless-ptr-null-checks"><code>useless_ptr_null_checks</code></a></li>
<li><a href="#uses-power-alignment"><code>uses_power_alignment</code></a></li>
<li><a href="#varargs-without-pattern"><code>varargs_without_pattern</code></a></li>
<li><a href="#warnings"><code>warnings</code></a></li>
<li><a href="#while-true"><code>while_true</code></a></li>
</ul>
<h2 id="aarch64-softfloat-neon"><a class="header" href="#aarch64-softfloat-neon">aarch64-softfloat-neon</a></h2>
<p>The <code>aarch64_softfloat_neon</code> lint detects usage of <code>#[target_feature(enable = "neon")]</code> on
softfloat aarch64 targets. Enabling this target feature causes LLVM to alter the ABI of
function calls, making this attribute unsound to use.</p>
<h3 id="example-58"><a class="header" href="#example-58">Example</a></h3>
<pre><code class="language-rust ignore (needs aarch64-unknown-none-softfloat)">#[target_feature(enable = "neon")]
fn with_neon() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: enabling the `neon` target feature on the current target is unsound due to ABI issues
  --&gt; $DIR/abi-incompatible-target-feature-attribute-fcw.rs:11:18
   |
   | #[target_feature(enable = "neon")]
   |                  ^^^^^^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #134375 &lt;https://github.com/rust-lang/rust/issues/134375&gt;
</code></pre>
<h3 id="explanation-60"><a class="header" href="#explanation-60">Explanation</a></h3>
<p>If a function like <code>with_neon</code> above ends up containing calls to LLVM builtins, those will
not use the correct ABI. This is caused by a lack of support in LLVM for mixing code with
and without the <code>neon</code> target feature. The target feature should never have been stabilized
on this target due to this issue, but the problem was not known at the time of
stabilization.</p>
<h2 id="ambiguous-glob-imported-traits"><a class="header" href="#ambiguous-glob-imported-traits">ambiguous-glob-imported-traits</a></h2>
<p>The <code>ambiguous_glob_imported_traits</code> lint reports uses of traits that are
imported ambiguously via glob imports. Previously, this was not enforced
due to a bug in rustc.</p>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_glob_imported_traits)]
mod m1 {
   pub trait Trait {
           fn method1(&amp;self) {}
       }
       impl Trait for u8 {}
   }
   mod m2 {
       pub trait Trait {
           fn method2(&amp;self) {}
       }
       impl Trait for u8 {}
   }

 fn main() {
     use m1::*;
     use m2::*;
     0u8.method1();
     0u8.method2();
 }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: Use of ambiguously glob imported trait `Trait`
  --&gt; lint_example.rs:18:10
   |
16 |      use m1::*;
   |          -- `Trait` imported ambiguously here
17 |      use m2::*;
18 |      0u8.method1();
   |          ^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #147992 &lt;https://github.com/rust-lang/rust/issues/147992&gt;
   = help: Import `Trait` explicitly
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_glob_imported_traits)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-1-1"><a class="header" href="#explanation-1-1">Explanation</a></h3>
<p>When multiple traits with the same name are brought into scope through glob imports,
one trait becomes the “primary” one while the others are shadowed. Methods from the
shadowed traits (e.g. <code>method2</code>) become inaccessible, while methods from the “primary”
trait (e.g. <code>method1</code>) still resolve. Ideally, none of the ambiguous traits would be in scope,
but we have to allow this for now because of backwards compatibility.
This lint reports uses of these “primary” traits that are ambiguous.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="ambiguous-glob-imports"><a class="header" href="#ambiguous-glob-imports">ambiguous-glob-imports</a></h2>
<p>The <code>ambiguous_glob_imports</code> lint detects glob imports that should report ambiguity
errors, but previously didn’t do that due to rustc bugs.</p>
<h3 id="example-2-1"><a class="header" href="#example-2-1">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_glob_imports)]
pub fn foo() -&gt; u32 {
    use sub::*;
    C
}

mod sub {
    mod mod1 { pub const C: u32 = 1; }
    mod mod2 { pub const C: u32 = 2; }

    pub use mod1::*;
    pub use mod2::*;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `C` is ambiguous
  --&gt; lint_example.rs:5:5
   |
 5 |     C
   |     ^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 &lt;https://github.com/rust-lang/rust/issues/114095&gt;
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `C` could refer to the constant imported here
  --&gt; lint_example.rs:12:13
   |
12 |     pub use mod1::*;
   |             ^^^^^^^
   = help: consider adding an explicit import of `C` to disambiguate
note: `C` could also refer to the constant imported here
  --&gt; lint_example.rs:13:13
   |
13 |     pub use mod2::*;
   |             ^^^^^^^
   = help: consider adding an explicit import of `C` to disambiguate
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_glob_imports)]
   |         ^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-2-1"><a class="header" href="#explanation-2-1">Explanation</a></h3>
<p>Previous versions of Rust compile it successfully because it
had lost the ambiguity error when resolve <code>use sub::mod2::*</code>.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="ambiguous-glob-reexports"><a class="header" href="#ambiguous-glob-reexports">ambiguous-glob-reexports</a></h2>
<p>The <code>ambiguous_glob_reexports</code> lint detects cases where names re-exported via globs
collide. Downstream users trying to use the same name re-exported from multiple globs
will receive a warning pointing out redefinition of the same name.</p>
<h3 id="example-3-1"><a class="header" href="#example-3-1">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_glob_reexports)]
pub mod foo {
    pub type X = u8;
}

pub mod bar {
    pub type Y = u8;
    pub type X = u8;
}

pub use foo::*;
pub use bar::*;


pub fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: ambiguous glob re-exports
  --&gt; lint_example.rs:11:9
   |
11 | pub use foo::*;
   |         ^^^^^^ the name `X` in the type namespace is first re-exported here
12 | pub use bar::*;
   |         ------ but the name `X` in the type namespace is also re-exported here
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_glob_reexports)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-3-1"><a class="header" href="#explanation-3-1">Explanation</a></h3>
<p>This was previously accepted but it could silently break a crate’s downstream users code.
For example, if <code>foo::*</code> and <code>bar::*</code> were re-exported before <code>bar::X</code> was added to the
re-exports, down stream users could use <code>this_crate::X</code> without problems. However, adding
<code>bar::X</code> would cause compilation errors in downstream crates because <code>X</code> is defined
multiple times in the same namespace of <code>this_crate</code>.</p>
<h2 id="ambiguous-panic-imports"><a class="header" href="#ambiguous-panic-imports">ambiguous-panic-imports</a></h2>
<p>The <code>ambiguous_panic_imports</code> lint detects ambiguous core and std panic imports, but
previously didn’t do that due to <code>#[macro_use]</code> prelude macro import.</p>
<h3 id="example-4-1"><a class="header" href="#example-4-1">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_panic_imports)]
#![no_std]

extern crate std;
use std::prelude::v1::*;

fn xx() {
    panic!(); // resolves to core::panic
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `panic` is ambiguous
  --&gt; lint_example.rs:9:5
   |
 9 |     panic!(); // resolves to core::panic
   |     ^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #147319 &lt;https://github.com/rust-lang/rust/issues/147319&gt;
   = note: ambiguous because of a conflict between a name from a glob import and an outer scope during import or macro resolution
note: `panic` could refer to the macro imported here
  --&gt; lint_example.rs:6:5
   |
 6 | use std::prelude::v1::*;
   |     ^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `panic` to disambiguate
note: `panic` could also refer to the macro defined here
  --&gt; /Users/runner/work/rust/rust/library/core/src/prelude/mod.rs:59:13
   |
59 |     pub use super::v1::*;
   |             ^^^^^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_panic_imports)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-4-1"><a class="header" href="#explanation-4-1">Explanation</a></h3>
<p>Future versions of Rust will no longer accept the ambiguous resolution.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the future.</p>
<h2 id="ambiguous-wide-pointer-comparisons"><a class="header" href="#ambiguous-wide-pointer-comparisons">ambiguous-wide-pointer-comparisons</a></h2>
<p>The <code>ambiguous_wide_pointer_comparisons</code> lint checks comparison
of <code>*const/*mut ?Sized</code> as the operands.</p>
<h3 id="example-5-1"><a class="header" href="#example-5-1">Example</a></h3>
<pre><code class="language-rust"><span class="boring">struct A;
</span><span class="boring">struct B;
</span>
<span class="boring">trait T {}
</span><span class="boring">impl T for A {}
</span><span class="boring">impl T for B {}
</span>
let ab = (A, B);
let a = &amp;ab.0 as *const dyn T;
let b = &amp;ab.1 as *const dyn T;

let _ = a == b;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: ambiguous wide pointer comparison, the comparison includes metadata which may not be expected
  --&gt; lint_example.rs:13:9
   |
13 | let _ = a == b;
   |         ^^^^^^
   |
   = note: `#[warn(ambiguous_wide_pointer_comparisons)]` on by default
help: use `std::ptr::addr_eq` or untyped pointers to only compare their addresses
   |
13 - let _ = a == b;
13 + let _ = std::ptr::addr_eq(a, b);
   |

</code></pre>
<h3 id="explanation-5-1"><a class="header" href="#explanation-5-1">Explanation</a></h3>
<p>The comparison includes metadata which may not be expected.</p>
<h2 id="anonymous-parameters"><a class="header" href="#anonymous-parameters">anonymous-parameters</a></h2>
<p>The <code>anonymous_parameters</code> lint detects anonymous parameters in trait
definitions.</p>
<h3 id="example-6-1"><a class="header" href="#example-6-1">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(anonymous_parameters)]
// edition 2015
pub trait Foo {
    fn foo(usize);
}
fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: anonymous parameters are deprecated and will be removed in the next edition
 --&gt; lint_example.rs:4:12
  |
4 |     fn foo(usize);
  |            ^^^^^ help: try naming the parameter or explicitly ignoring it: `_: usize`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/trait-fn-parameters.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(anonymous_parameters)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-6-1"><a class="header" href="#explanation-6-1">Explanation</a></h3>
<p>This syntax is mostly a historical accident, and can be worked around
quite easily by adding an <code>_</code> pattern or a descriptive identifier:</p>
<pre><code class="language-rust">trait Foo {
    fn foo(_: usize);
}</code></pre>
<p>This syntax is now a hard error in the 2018 edition. In the 2015
edition, this lint is “warn” by default. This lint
enables the <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag to
automatically transition old code from the 2015 edition to 2018. The
tool will run this lint and automatically apply the
suggested fix from the compiler (which is to add <code>_</code> to each
parameter). This provides a completely automated way to update old
code for a new edition. See <a href="https://github.com/rust-lang/rust/issues/41686">issue #41686</a> for more details.</p>
<h2 id="array-into-iter"><a class="header" href="#array-into-iter">array-into-iter</a></h2>
<p>The <code>array_into_iter</code> lint detects calling <code>into_iter</code> on arrays.</p>
<h3 id="example-7-1"><a class="header" href="#example-7-1">Example</a></h3>
<pre><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span>[1, 2, 3].into_iter().for_each(|n| { *n; });</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this method call resolves to `&lt;&amp;[T; N] as IntoIterator&gt;::into_iter` (due to backwards compatibility), but will resolve to `&lt;[T; N] as IntoIterator&gt;::into_iter` in Rust 2021
 --&gt; lint_example.rs:3:11
  |
3 | [1, 2, 3].into_iter().for_each(|n| { *n; });
  |           ^^^^^^^^^
  |
  = warning: this changes meaning in Rust 2021
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html&gt;
  = note: `#[warn(array_into_iter)]` (part of `#[warn(rust_2021_compatibility)]`) on by default
help: use `.iter()` instead of `.into_iter()` to avoid ambiguity
  |
3 - [1, 2, 3].into_iter().for_each(|n| { *n; });
3 + [1, 2, 3].iter().for_each(|n| { *n; });
  |
help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value
  |
3 - [1, 2, 3].into_iter().for_each(|n| { *n; });
3 + IntoIterator::into_iter([1, 2, 3]).for_each(|n| { *n; });
  |

</code></pre>
<h3 id="explanation-7-1"><a class="header" href="#explanation-7-1">Explanation</a></h3>
<p>Since Rust 1.53, arrays implement <code>IntoIterator</code>. However, to avoid
breakage, <code>array.into_iter()</code> in Rust 2015 and 2018 code will still
behave as <code>(&amp;array).into_iter()</code>, returning an iterator over
references, just like in Rust 1.52 and earlier.
This only applies to the method call syntax <code>array.into_iter()</code>, not to
any other syntax such as <code>for _ in array</code> or <code>IntoIterator::into_iter(array)</code>.</p>
<h2 id="asm-sub-register"><a class="header" href="#asm-sub-register">asm-sub-register</a></h2>
<p>The <code>asm_sub_register</code> lint detects using only a subset of a register
for inline asm inputs.</p>
<h3 id="example-8-1"><a class="header" href="#example-8-1">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-x86_64)">#[cfg(target_arch="x86_64")]
use std::arch::asm;

fn main() {
    #[cfg(target_arch="x86_64")]
    unsafe {
        asm!("mov {0}, {0}", in(reg) 0i16);
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: formatting may not be suitable for sub-register argument
 --&gt; src/main.rs:7:19
  |
7 |         asm!("mov {0}, {0}", in(reg) 0i16);
  |                   ^^^  ^^^           ---- for this argument
  |
  = note: `#[warn(asm_sub_register)]` on by default
  = help: use the `x` modifier to have the register formatted as `ax`
  = help: or use the `r` modifier to keep the default formatting of `rax`
</code></pre>
<h3 id="explanation-8-1"><a class="header" href="#explanation-8-1">Explanation</a></h3>
<p>Registers on some architectures can use different names to refer to a
subset of the register. By default, the compiler will use the name for
the full register size. To explicitly use a subset of the register,
you can override the default by using a modifier on the template
string operand to specify when subregister to use. This lint is issued
if you pass in a value with a smaller data type than the default
register size, to alert you of possibly using the incorrect width. To
fix this, add the suggested modifier to the template, or cast the
value to the correct size.</p>
<p>See <a href="https://doc.rust-lang.org/nightly/reference/inline-assembly.html#template-modifiers">register template modifiers</a> in the reference for more details.</p>
<h2 id="async-fn-in-trait"><a class="header" href="#async-fn-in-trait">async-fn-in-trait</a></h2>
<p>The <code>async_fn_in_trait</code> lint detects use of <code>async fn</code> in the
definition of a publicly-reachable trait.</p>
<h3 id="example-9-1"><a class="header" href="#example-9-1">Example</a></h3>
<pre><code class="language-rust">pub trait Trait {
    async fn method(&amp;self);
}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
 --&gt; lint_example.rs:2:5
  |
2 |     async fn method(&amp;self);
  |     ^^^^^
  |
  = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
  = note: `#[warn(async_fn_in_trait)]` on by default
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
  |
2 -     async fn method(&amp;self);
2 +     fn method(&amp;self) -&gt; impl std::future::Future&lt;Output = ()&gt; + Send;
  |

</code></pre>
<h3 id="explanation-9-1"><a class="header" href="#explanation-9-1">Explanation</a></h3>
<p>When <code>async fn</code> is used in a trait definition, the trait does not
promise that the opaque <a href="https://doc.rust-lang.org/core/future/trait.Future.html"><code>Future</code></a> returned by the associated function
or method will implement any <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">auto traits</a> such as <a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a>. This may
be surprising and may make the associated functions or methods on the
trait less useful than intended. On traits exposed publicly from a
crate, this may affect downstream crates whose authors cannot alter
the trait definition.</p>
<p>For example, this code is invalid:</p>
<pre><code class="language-rust compile_fail">pub trait Trait {
    async fn method(&amp;self) {}
}

fn test&lt;T: Trait&gt;(x: T) {
    fn spawn&lt;T: Send&gt;(_: T) {}
    spawn(x.method()); // Not OK.
}</code></pre>
<p>This lint exists to warn authors of publicly-reachable traits that
they may want to consider desugaring the <code>async fn</code> to a normal <code>fn</code>
that returns an opaque <code>impl Future&lt;..&gt; + Send</code> type.</p>
<p>For example, instead of:</p>
<pre><code class="language-rust">pub trait Trait {
    async fn method(&amp;self) {}
}</code></pre>
<p>The author of the trait may want to write:</p>
<pre><code class="language-rust">use core::future::Future;
pub trait Trait {
    fn method(&amp;self) -&gt; impl Future&lt;Output = ()&gt; + Send { async {} }
}</code></pre>
<p>This still allows the use of <code>async fn</code> within impls of the trait.
However, it also means that the trait will never be compatible with
impls where the returned <a href="https://doc.rust-lang.org/core/future/trait.Future.html"><code>Future</code></a> of the method does not implement
<code>Send</code>.</p>
<p>Conversely, if the trait is used only locally, if it is never used in
generic functions, or if it is only used in single-threaded contexts
that do not care whether the returned <a href="https://doc.rust-lang.org/core/future/trait.Future.html"><code>Future</code></a> implements <a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a>,
then the lint may be suppressed.</p>
<h2 id="bad-asm-style"><a class="header" href="#bad-asm-style">bad-asm-style</a></h2>
<p>The <code>bad_asm_style</code> lint detects the use of the <code>.intel_syntax</code> and
<code>.att_syntax</code> directives.</p>
<h3 id="example-10-1"><a class="header" href="#example-10-1">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-x86_64)">#[cfg(target_arch="x86_64")]
use std::arch::asm;

fn main() {
    #[cfg(target_arch="x86_64")]
    unsafe {
        asm!(
            ".att_syntax",
            "movq %{0}, %{0}", in(reg) 0usize
        );
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead
 --&gt; src/main.rs:8:14
  |
8 |             ".att_syntax",
  |              ^^^^^^^^^^^
  |
  = note: `#[warn(bad_asm_style)]` on by default
</code></pre>
<h3 id="explanation-10-1"><a class="header" href="#explanation-10-1">Explanation</a></h3>
<p>On x86, <code>asm!</code> uses the intel assembly syntax by default. While this
can be switched using assembler directives like <code>.att_syntax</code>, using the
<code>att_syntax</code> option is recommended instead because it will also properly
prefix register placeholders with <code>%</code> as required by AT&amp;T syntax.</p>
<h2 id="bare-trait-object"><a class="header" href="#bare-trait-object">bare-trait-object</a></h2>
<p>The lint <code>bare-trait-object</code> has been renamed to <a href="#bare-trait-objects"><code>bare-trait-objects</code></a>.</p>
<h2 id="bare-trait-objects"><a class="header" href="#bare-trait-objects">bare-trait-objects</a></h2>
<p>The <code>bare_trait_objects</code> lint suggests using <code>dyn Trait</code> for trait
objects.</p>
<h3 id="example-11-1"><a class="header" href="#example-11-1">Example</a></h3>
<pre><code class="language-rust edition2018">trait Trait { }

fn takes_trait_object(_: Box&lt;Trait&gt;) {
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: trait objects without an explicit `dyn` are deprecated
 --&gt; lint_example.rs:4:30
  |
4 | fn takes_trait_object(_: Box&lt;Trait&gt;) {
  |                              ^^^^^
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;
  = note: `#[warn(bare_trait_objects)]` (part of `#[warn(rust_2021_compatibility)]`) on by default
help: if this is a dyn-compatible trait, use `dyn`
  |
4 | fn takes_trait_object(_: Box&lt;dyn Trait&gt;) {
  |                              +++

</code></pre>
<h3 id="explanation-11-1"><a class="header" href="#explanation-11-1">Explanation</a></h3>
<p>Without the <code>dyn</code> indicator, it can be ambiguous or confusing when
reading code as to whether or not you are looking at a trait object.
The <code>dyn</code> keyword makes it explicit, and adds a symmetry to contrast
with <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters"><code>impl Trait</code></a>.</p>
<h2 id="boxed-slice-into-iter"><a class="header" href="#boxed-slice-into-iter">boxed-slice-into-iter</a></h2>
<p>The <code>boxed_slice_into_iter</code> lint detects calling <code>into_iter</code> on boxed slices.</p>
<h3 id="example-12-1"><a class="header" href="#example-12-1">Example</a></h3>
<pre><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this method call resolves to `&lt;&amp;Box&lt;[T]&gt; as IntoIterator&gt;::into_iter` (due to backwards compatibility), but will resolve to `&lt;Box&lt;[T]&gt; as IntoIterator&gt;::into_iter` in Rust 2024
 --&gt; lint_example.rs:3:34
  |
3 | vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });
  |                                  ^^^^^^^^^
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/intoiterator-box-slice.html&gt;
  = note: `#[warn(boxed_slice_into_iter)]` (part of `#[warn(rust_2024_compatibility)]`) on by default
help: use `.iter()` instead of `.into_iter()` to avoid ambiguity
  |
3 - vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });
3 + vec![1, 2, 3].into_boxed_slice().iter().for_each(|n| { *n; });
  |
help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value
  |
3 - vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });
3 + IntoIterator::into_iter(vec![1, 2, 3].into_boxed_slice()).for_each(|n| { *n; });
  |

</code></pre>
<h3 id="explanation-12-1"><a class="header" href="#explanation-12-1">Explanation</a></h3>
<p>Since Rust 1.80.0, boxed slices implement <code>IntoIterator</code>. However, to avoid
breakage, <code>boxed_slice.into_iter()</code> in Rust 2015, 2018, and 2021 code will still
behave as <code>(&amp;boxed_slice).into_iter()</code>, returning an iterator over
references, just like in Rust 1.79.0 and earlier.
This only applies to the method call syntax <code>boxed_slice.into_iter()</code>, not to
any other syntax such as <code>for _ in boxed_slice</code> or <code>IntoIterator::into_iter(boxed_slice)</code>.</p>
<h2 id="break-with-label-and-loop"><a class="header" href="#break-with-label-and-loop">break-with-label-and-loop</a></h2>
<p>The <code>break_with_label_and_loop</code> lint detects labeled <code>break</code> expressions with
an unlabeled loop as their value expression.</p>
<h3 id="example-13-1"><a class="header" href="#example-13-1">Example</a></h3>
<pre><code class="language-rust">'label: loop {
    break 'label loop { break 42; };
};</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression
 --&gt; lint_example.rs:3:5
  |
3 |     break 'label loop { break 42; };
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(break_with_label_and_loop)]` on by default
help: wrap this expression in parentheses
  |
3 |     break 'label (loop { break 42; });
  |                  +                  +

</code></pre>
<h3 id="explanation-13-1"><a class="header" href="#explanation-13-1">Explanation</a></h3>
<p>In Rust, loops can have a label, and <code>break</code> expressions can refer to that label to
break out of specific loops (and not necessarily the innermost one). <code>break</code> expressions
can also carry a value expression, which can be another loop. A labeled <code>break</code> with an
unlabeled loop as its value expression is easy to confuse with an unlabeled break with
a labeled loop and is thus discouraged (but allowed for compatibility); use parentheses
around the loop expression to silence this warning. Unlabeled <code>break</code> expressions with
labeled loops yield a hard error, which can also be silenced by wrapping the expression
in parentheses.</p>
<h2 id="clashing-extern-declarations"><a class="header" href="#clashing-extern-declarations">clashing-extern-declarations</a></h2>
<p>The <code>clashing_extern_declarations</code> lint detects when an <code>extern fn</code>
has been declared with the same name but different types.</p>
<h3 id="example-14-1"><a class="header" href="#example-14-1">Example</a></h3>
<pre><code class="language-rust">mod m {
    unsafe extern "C" {
        fn foo();
    }
}

unsafe extern "C" {
    fn foo(_: u32);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `foo` redeclared with a different signature
 --&gt; lint_example.rs:9:5
  |
4 |         fn foo();
  |         --------- `foo` previously declared here
...
9 |     fn foo(_: u32);
  |     ^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration
  |
  = note: expected `unsafe extern "C" fn()`
             found `unsafe extern "C" fn(u32)`
  = note: `#[warn(clashing_extern_declarations)]` on by default

</code></pre>
<h3 id="explanation-14-1"><a class="header" href="#explanation-14-1">Explanation</a></h3>
<p>Because two symbols of the same name cannot be resolved to two
different functions at link time, and one function cannot possibly
have two types, a clashing extern declaration is almost certainly a
mistake. Check to make sure that the <code>extern</code> definitions are correct
and equivalent, and possibly consider unifying them in one location.</p>
<p>This lint does not run between crates because a project may have
dependencies which both rely on the same extern function, but declare
it in a different (but valid) way. For example, they may both declare
an opaque type for one or more of the arguments (which would end up
distinct types), or use types that are valid conversions in the
language the <code>extern fn</code> is defined in. In these cases, the compiler
can’t say that the clashing declaration is incorrect.</p>
<h2 id="coherence-leak-check"><a class="header" href="#coherence-leak-check">coherence-leak-check</a></h2>
<p>The <code>coherence_leak_check</code> lint detects conflicting implementations of
a trait that are only distinguished by the old leak-check code.</p>
<h3 id="example-15-1"><a class="header" href="#example-15-1">Example</a></h3>
<pre><code class="language-rust">trait SomeTrait { }
impl SomeTrait for for&lt;'a&gt; fn(&amp;'a u8) { }
impl&lt;'a&gt; SomeTrait for fn(&amp;'a u8) { }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: conflicting implementations of trait `SomeTrait` for type `for&lt;'a&gt; fn(&amp;'a u8)`
 --&gt; lint_example.rs:4:1
  |
3 | impl SomeTrait for for&lt;'a&gt; fn(&amp;'a u8) { }
  | ------------------------------------- first implementation here
4 | impl&lt;'a&gt; SomeTrait for fn(&amp;'a u8) { }
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for&lt;'a&gt; fn(&amp;'a u8)`
  |
  = warning: the behavior may change in a future release
  = note: for more information, see issue #56105 &lt;https://github.com/rust-lang/rust/issues/56105&gt;
  = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details
  = note: `#[warn(coherence_leak_check)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-15-1"><a class="header" href="#explanation-15-1">Explanation</a></h3>
<p>In the past, the compiler would accept trait implementations for
identical functions that differed only in where the lifetime binder
appeared. Due to a change in the borrow checker implementation to fix
several bugs, this is no longer allowed. However, since this affects
existing code, this is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future.</p>
<p>Code relying on this pattern should introduce “<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">newtypes</a>”,
like <code>struct Foo(for&lt;'a&gt; fn(&amp;'a u8))</code>.</p>
<p>See <a href="https://github.com/rust-lang/rust/issues/56105">issue #56105</a> for more details.</p>
<h2 id="confusable-idents"><a class="header" href="#confusable-idents">confusable-idents</a></h2>
<p>The <code>confusable_idents</code> lint detects visually confusable pairs between
identifiers.</p>
<h3 id="example-16-1"><a class="header" href="#example-16-1">Example</a></h3>
<pre><code class="language-rust">// Latin Capital Letter E With Caron
pub const Ě: i32 = 1;
// Latin Capital Letter E With Breve
pub const Ĕ: i32 = 2;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: found both `Ě` and `Ĕ` as identifiers, which look alike
 --&gt; lint_example.rs:5:11
  |
3 | pub const Ě: i32 = 1;
  |           - other identifier used here
4 | // Latin Capital Letter E With Breve
5 | pub const Ĕ: i32 = 2;
  |           ^ this identifier can be confused with `Ě`
  |
  = note: `#[warn(confusable_idents)]` on by default

</code></pre>
<h3 id="explanation-16-1"><a class="header" href="#explanation-16-1">Explanation</a></h3>
<p>This lint warns when different identifiers may appear visually similar,
which can cause confusion.</p>
<p>The confusable detection algorithm is based on <a href="https://www.unicode.org/reports/tr39/#Confusable_Detection">Unicode® Technical
Standard #39 Unicode Security Mechanisms Section 4 Confusable
Detection</a>. For every distinct identifier X execute
the function <code>skeleton(X)</code>. If there exist two distinct identifiers X
and Y in the same crate where <code>skeleton(X) = skeleton(Y)</code> report it.
The compiler uses the same mechanism to check if an identifier is too
similar to a keyword.</p>
<p>Note that the set of confusable characters may change over time.
Beware that if you “forbid” this lint that existing code may fail in
the future.</p>
<h2 id="const-evaluatable-unchecked"><a class="header" href="#const-evaluatable-unchecked">const-evaluatable-unchecked</a></h2>
<p>The <code>const_evaluatable_unchecked</code> lint detects a generic constant used
in a type.</p>
<h3 id="example-17-1"><a class="header" href="#example-17-1">Example</a></h3>
<pre><code class="language-rust">const fn foo&lt;T&gt;() -&gt; usize {
    if size_of::&lt;*mut T&gt;() &lt; 8 { // size of *mut T does not depend on T
        4
    } else {
        8
    }
}

fn test&lt;T&gt;() {
    let _ = [0; foo::&lt;T&gt;()];
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot use constants which depend on generic parameters in types
  --&gt; lint_example.rs:11:17
   |
11 |     let _ = [0; foo::&lt;T&gt;()];
   |                 ^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #76200 &lt;https://github.com/rust-lang/rust/issues/76200&gt;
   = note: `#[warn(const_evaluatable_unchecked)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-17-1"><a class="header" href="#explanation-17-1">Explanation</a></h3>
<p>In the 1.43 release, some uses of generic parameters in array repeat
expressions were accidentally allowed. This is a <a href="#future-incompatible-lints">future-incompatible</a>
lint to transition this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/76200">issue
#76200</a> for a more detailed description and possible fixes.</p>
<h2 id="const-item-interior-mutations"><a class="header" href="#const-item-interior-mutations">const-item-interior-mutations</a></h2>
<p>The <code>const_item_interior_mutations</code> lint checks for calls which
mutates an interior mutable const-item.</p>
<h3 id="example-18-1"><a class="header" href="#example-18-1">Example</a></h3>
<pre><code class="language-rust">use std::sync::Once;

const INIT: Once = Once::new(); // using `INIT` will always create a temporary and
                                // never modify it-self on use, should be a `static`
                                // instead for shared use

fn init() {
    INIT.call_once(|| {
        println!("Once::call_once first call");
    });
    INIT.call_once(|| {                          // this second will also print
        println!("Once::call_once second call"); // as each call to `INIT` creates
    });                                          // new temporary
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: mutation of an interior mutable `const` item with call to `call_once`
  --&gt; lint_example.rs:9:5
   |
 9 |       INIT.call_once(|| {
   |       ^---
   |       |
   |  _____`INIT` is a interior mutable `const` item of type `std::sync::Once`
   | |
10 | |         println!("Once::call_once first call");
11 | |     });
   | |______^
   |
   = note: each usage of a `const` item creates a new temporary
   = note: only the temporaries and never the original `const INIT` will be modified
   = help: for more details on interior mutability see &lt;https://doc.rust-lang.org/reference/interior-mutability.html&gt;
   = note: `#[warn(const_item_interior_mutations)]` on by default
help: for a shared instance of `INIT`, consider making it a `static` item instead
   |
 4 - const INIT: Once = Once::new(); // using `INIT` will always create a temporary and
 4 + static INIT: Once = Once::new(); // using `INIT` will always create a temporary and
   |


warning: mutation of an interior mutable `const` item with call to `call_once`
  --&gt; lint_example.rs:12:5
   |
12 |       INIT.call_once(|| {                          // this second will also print
   |       ^---
   |       |
   |  _____`INIT` is a interior mutable `const` item of type `std::sync::Once`
   | |
13 | |         println!("Once::call_once second call"); // as each call to `INIT` creates
14 | |     });                                          // new temporary
   | |______^
   |
   = note: each usage of a `const` item creates a new temporary
   = note: only the temporaries and never the original `const INIT` will be modified
   = help: for more details on interior mutability see &lt;https://doc.rust-lang.org/reference/interior-mutability.html&gt;
help: for a shared instance of `INIT`, consider making it a `static` item instead
   |
 4 - const INIT: Once = Once::new(); // using `INIT` will always create a temporary and
 4 + static INIT: Once = Once::new(); // using `INIT` will always create a temporary and
   |

</code></pre>
<h3 id="explanation-18-1"><a class="header" href="#explanation-18-1">Explanation</a></h3>
<p>Calling a method which mutates an interior mutable type has no effect as const-item
are essentially inlined wherever they are used, meaning that they are copied
directly into the relevant context when used rendering modification through
interior mutability ineffective across usage of that const-item.</p>
<p>The current implementation of this lint only warns on significant <code>std</code> and
<code>core</code> interior mutable types, like <code>Once</code>, <code>AtomicI32</code>, … this is done out
of prudence to avoid false-positive and may be extended in the future.</p>
<h2 id="const-item-mutation"><a class="header" href="#const-item-mutation">const-item-mutation</a></h2>
<p>The <code>const_item_mutation</code> lint detects attempts to mutate a <code>const</code>
item.</p>
<h3 id="example-19-1"><a class="header" href="#example-19-1">Example</a></h3>
<pre><code class="language-rust">const FOO: [i32; 1] = [0];

fn main() {
    FOO[0] = 1;
    // This will print "[0]".
    println!("{:?}", FOO);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: attempting to modify a `const` item
 --&gt; lint_example.rs:4:5
  |
4 |     FOO[0] = 1;
  |     ^^^^^^^^^^
  |
  = note: each usage of a `const` item creates a new temporary; the original `const` item will not be modified
note: `const` item defined here
 --&gt; lint_example.rs:1:1
  |
1 | const FOO: [i32; 1] = [0];
  | ^^^^^^^^^^^^^^^^^^^
  = note: `#[warn(const_item_mutation)]` on by default

</code></pre>
<h3 id="explanation-19-1"><a class="header" href="#explanation-19-1">Explanation</a></h3>
<p>Trying to directly mutate a <code>const</code> item is almost always a mistake.
What is happening in the example above is that a temporary copy of the
<code>const</code> is mutated, but the original <code>const</code> is not. Each time you
refer to the <code>const</code> by name (such as <code>FOO</code> in the example above), a
separate copy of the value is inlined at that location.</p>
<p>This lint checks for writing directly to a field (<code>FOO.field = some_value</code>) or array entry (<code>FOO[0] = val</code>), or taking a mutable
reference to the const item (<code>&amp;mut FOO</code>), including through an
autoderef (<code>FOO.some_mut_self_method()</code>).</p>
<p>There are various alternatives depending on what you are trying to
accomplish:</p>
<ul>
<li>First, always reconsider using mutable globals, as they can be
difficult to use correctly, and can make the code more difficult to
use or understand.</li>
<li>If you are trying to perform a one-time initialization of a global:
<ul>
<li>If the value can be computed at compile-time, consider using
const-compatible values (see <a href="https://doc.rust-lang.org/reference/const_eval.html">Constant Evaluation</a>).</li>
<li>For more complex single-initialization cases, consider using
<a href="https://doc.rust-lang.org/stable/std/sync/struct.LazyLock.html"><code>std::sync::LazyLock</code></a>.</li>
</ul>
</li>
<li>If you truly need a mutable global, consider using a <a href="https://doc.rust-lang.org/reference/items/static-items.html"><code>static</code></a>,
which has a variety of options:
<ul>
<li>Simple data types can be directly defined and mutated with an
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>atomic</code></a> type.</li>
<li>More complex types can be placed in a synchronization primitive
like a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, which can be initialized with one of the options
listed above.</li>
<li>A <a href="https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics">mutable <code>static</code></a> is a low-level primitive, requiring unsafe.
Typically This should be avoided in preference of something
higher-level like one of the above.</li>
</ul>
</li>
</ul>
<h2 id="dangling-pointers-from-locals"><a class="header" href="#dangling-pointers-from-locals">dangling-pointers-from-locals</a></h2>
<p>The <code>dangling_pointers_from_locals</code> lint detects getting a pointer to data
of a local that will be dropped at the end of the function.</p>
<h3 id="example-20-1"><a class="header" href="#example-20-1">Example</a></h3>
<pre><code class="language-rust">fn f() -&gt; *const u8 {
    let x = 0;
    &amp;x // returns a dangling ptr to `x`
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function returns a dangling pointer to dropped local variable `x`
 --&gt; lint_example.rs:4:5
  |
2 | fn f() -&gt; *const u8 {
  |           --------- return type is `*const u8`
3 |     let x = 0;
  |         - local variable `x` is dropped at the end of the function
4 |     &amp;x // returns a dangling ptr to `x`
  |     ^^
  |
  = note: a dangling pointer is safe, but dereferencing one is undefined behavior
  = note: for more information, see &lt;https://doc.rust-lang.org/reference/destructors.html&gt;
  = note: `#[warn(dangling_pointers_from_locals)]` on by default

</code></pre>
<h3 id="explanation-20-1"><a class="header" href="#explanation-20-1">Explanation</a></h3>
<p>Returning a pointer from a local value will not prolong its lifetime,
which means that the value can be dropped and the allocation freed
while the pointer still exists, making the pointer dangling.
This is not an error (as far as the type system is concerned)
but probably is not what the user intended either.</p>
<p>If you need stronger guarantees, consider using references instead,
as they are statically verified by the borrow-checker to never dangle.</p>
<h2 id="dangling-pointers-from-temporaries"><a class="header" href="#dangling-pointers-from-temporaries">dangling-pointers-from-temporaries</a></h2>
<p>The <code>dangling_pointers_from_temporaries</code> lint detects getting a pointer to data
of a temporary that will immediately get dropped.</p>
<h3 id="example-21-1"><a class="header" href="#example-21-1">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">unsafe fn use_data(ptr: *const u8) { }
</span>fn gather_and_use(bytes: impl Iterator&lt;Item = u8&gt;) {
    let x: *const u8 = bytes.collect::&lt;Vec&lt;u8&gt;&gt;().as_ptr();
    unsafe { use_data(x) }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this creates a dangling pointer because temporary `Vec&lt;u8&gt;` is dropped at end of statement
 --&gt; lint_example.rs:5:51
  |
5 |     let x: *const u8 = bytes.collect::&lt;Vec&lt;u8&gt;&gt;().as_ptr();
  |                        -------------------------- ^^^^^^ pointer created here
  |                        |
  |                        this `Vec&lt;u8&gt;` is dropped at end of statement
  |
  = help: bind the `Vec&lt;u8&gt;` to a variable such that it outlives the pointer returned by `as_ptr`
  = note: a dangling pointer is safe, but dereferencing one is undefined behavior
  = note: returning a pointer to a local variable will always result in a dangling pointer
  = note: for more information, see &lt;https://doc.rust-lang.org/reference/destructors.html&gt;
  = note: `#[warn(dangling_pointers_from_temporaries)]` on by default

</code></pre>
<h3 id="explanation-21-1"><a class="header" href="#explanation-21-1">Explanation</a></h3>
<p>Getting a pointer from a temporary value will not prolong its lifetime,
which means that the value can be dropped and the allocation freed
while the pointer still exists, making the pointer dangling.
This is not an error (as far as the type system is concerned)
but probably is not what the user intended either.</p>
<p>If you need stronger guarantees, consider using references instead,
as they are statically verified by the borrow-checker to never dangle.</p>
<h2 id="dead-code"><a class="header" href="#dead-code">dead-code</a></h2>
<p>The <code>dead_code</code> lint detects unused, unexported items.</p>
<h3 id="example-22-1"><a class="header" href="#example-22-1">Example</a></h3>
<pre><code class="language-rust">fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function `foo` is never used
 --&gt; lint_example.rs:2:4
  |
2 | fn foo() {}
  |    ^^^
  |
  = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-22-1"><a class="header" href="#explanation-22-1">Explanation</a></h3>
<p>Dead code may signal a mistake or unfinished code. To silence the
warning for individual items, prefix the name with an underscore such
as <code>_foo</code>. If it was intended to expose the item outside of the crate,
consider adding a visibility modifier like <code>pub</code>.</p>
<p>To preserve the numbering of tuple structs with unused fields,
change the unused fields to have unit type or use
<code>PhantomData</code>.</p>
<p>Otherwise consider removing the unused code.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Removing fields that are only used for side-effects and never
read will result in behavioral changes. Examples of this
include:</p>
<ul>
<li>If a field’s value performs an action when it is dropped.</li>
<li>If a field’s type does not implement an auto trait
(e.g. <code>Send</code>, <code>Sync</code>, <code>Unpin</code>).</li>
</ul>
<p>For side-effects from dropping field values, this lint should
be allowed on those fields. For side-effects from containing
field types, <code>PhantomData</code> should be used.</p>
<h2 id="deprecated"><a class="header" href="#deprecated">deprecated</a></h2>
<p>The <code>deprecated</code> lint detects use of deprecated items.</p>
<h3 id="example-23-1"><a class="header" href="#example-23-1">Example</a></h3>
<pre><code class="language-rust">#[deprecated]
fn foo() {}

fn bar() {
    foo();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of deprecated function `main::foo`
 --&gt; lint_example.rs:6:5
  |
6 |     foo();
  |     ^^^
  |
  = note: `#[warn(deprecated)]` on by default

</code></pre>
<h3 id="explanation-23-1"><a class="header" href="#explanation-23-1">Explanation</a></h3>
<p>Items may be marked “deprecated” with the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code> attribute</a> to
indicate that they should no longer be used. Usually the attribute
should include a note on what to use instead, or check the
documentation.</p>
<h2 id="deprecated-where-clause-location"><a class="header" href="#deprecated-where-clause-location">deprecated-where-clause-location</a></h2>
<p>The <code>deprecated_where_clause_location</code> lint detects when a where clause in front of the equals
in an associated type.</p>
<h3 id="example-24-1"><a class="header" href="#example-24-1">Example</a></h3>
<pre><code class="language-rust">trait Trait {
  type Assoc&lt;'a&gt; where Self: 'a;
}

impl Trait for () {
  type Assoc&lt;'a&gt; where Self: 'a = ();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: where clause not allowed here
 --&gt; lint_example.rs:7:18
  |
7 |   type Assoc&lt;'a&gt; where Self: 'a = ();
  |                  ^^^^^^^^^^^^^^
  |
  = note: see issue #89122 &lt;https://github.com/rust-lang/rust/issues/89122&gt; for more information
  = note: `#[warn(deprecated_where_clause_location)]` on by default
help: move it to the end of the type declaration
  |
7 -   type Assoc&lt;'a&gt; where Self: 'a = ();
7 +   type Assoc&lt;'a&gt;  = () where Self: 'a;
  |

</code></pre>
<h3 id="explanation-24-1"><a class="header" href="#explanation-24-1">Explanation</a></h3>
<p>The preferred location for where clauses on associated types
is after the type. However, for most of generic associated types development,
it was only accepted before the equals. To provide a transition period and
further evaluate this change, both are currently accepted. At some point in
the future, this may be disallowed at an edition boundary; but, that is
undecided currently.</p>
<h2 id="double-negations"><a class="header" href="#double-negations">double-negations</a></h2>
<p>The <code>double_negations</code> lint detects expressions of the form <code>--x</code>.</p>
<h3 id="example-25-1"><a class="header" href="#example-25-1">Example</a></h3>
<pre><code class="language-rust">fn main() {
    let x = 1;
    let _b = --x;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of a double negation
 --&gt; lint_example.rs:3:14
  |
3 |     let _b = --x;
  |              ^^^
  |
  = note: the prefix `--` could be misinterpreted as a decrement operator which exists in other languages
  = note: use `-= 1` if you meant to decrement the value
  = note: `#[warn(double_negations)]` on by default
help: add parentheses for clarity
  |
3 |     let _b = -(-x);
  |               +  +

</code></pre>
<h3 id="explanation-25-1"><a class="header" href="#explanation-25-1">Explanation</a></h3>
<p>Negating something twice is usually the same as not negating it at all.
However, a double negation in Rust can easily be confused with the
prefix decrement operator that exists in many languages derived from C.
Use <code>-(-x)</code> if you really wanted to negate the value twice.</p>
<p>To decrement a value, use <code>x -= 1</code> instead.</p>
<h2 id="drop-bounds"><a class="header" href="#drop-bounds">drop-bounds</a></h2>
<p>The <code>drop_bounds</code> lint checks for generics with <code>std::ops::Drop</code> as
bounds.</p>
<h3 id="example-26-1"><a class="header" href="#example-26-1">Example</a></h3>
<pre><code class="language-rust">fn foo&lt;T: Drop&gt;() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped
 --&gt; lint_example.rs:2:11
  |
2 | fn foo&lt;T: Drop&gt;() {}
  |           ^^^^
  |
  = note: `#[warn(drop_bounds)]` on by default

</code></pre>
<h3 id="explanation-26-1"><a class="header" href="#explanation-26-1">Explanation</a></h3>
<p>A generic trait bound of the form <code>T: Drop</code> is most likely misleading
and not what the programmer intended (they probably should have used
<code>std::mem::needs_drop</code> instead).</p>
<p><code>Drop</code> bounds do not actually indicate whether a type can be trivially
dropped or not, because a composite type containing <code>Drop</code> types does
not necessarily implement <code>Drop</code> itself. Naïvely, one might be tempted
to write an implementation that assumes that a type can be trivially
dropped while also supplying a specialization for <code>T: Drop</code> that
actually calls the destructor. However, this breaks down e.g. when <code>T</code>
is <code>String</code>, which does not implement <code>Drop</code> itself but contains a
<code>Vec</code>, which does implement <code>Drop</code>, so assuming <code>T</code> can be trivially
dropped would lead to a memory leak here.</p>
<p>Furthermore, the <code>Drop</code> trait only contains one method, <code>Drop::drop</code>,
which may not be called explicitly in user code (<code>E0040</code>), so there is
really no use case for using <code>Drop</code> in trait bounds, save perhaps for
some obscure corner cases, which can use <code>#[allow(drop_bounds)]</code>.</p>
<h2 id="dropping-copy-types"><a class="header" href="#dropping-copy-types">dropping-copy-types</a></h2>
<p>The <code>dropping_copy_types</code> lint checks for calls to <code>std::mem::drop</code> with a value
that derives the Copy trait.</p>
<h3 id="example-27-1"><a class="header" href="#example-27-1">Example</a></h3>
<pre><code class="language-rust">let x: i32 = 42; // i32 implements Copy
std::mem::drop(x); // A copy of x is passed to the function, leaving the
                   // original unaffected</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a value that implements `Copy` does nothing
 --&gt; lint_example.rs:3:1
  |
3 | std::mem::drop(x); // A copy of x is passed to the function, leaving the
  | ^^^^^^^^^^^^^^^-^
  |                |
  |                argument has type `i32`
  |
  = note: `#[warn(dropping_copy_types)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
3 - std::mem::drop(x); // A copy of x is passed to the function, leaving the
3 + let _ = x; // A copy of x is passed to the function, leaving the
  |

</code></pre>
<h3 id="explanation-27-1"><a class="header" href="#explanation-27-1">Explanation</a></h3>
<p>Calling <code>std::mem::drop</code> <a href="https://doc.rust-lang.org/std/mem/fn.drop.html">does nothing for types that
implement Copy</a>, since the
value will be copied and moved into the function on invocation.</p>
<h2 id="dropping-references"><a class="header" href="#dropping-references">dropping-references</a></h2>
<p>The <code>dropping_references</code> lint checks for calls to <code>std::mem::drop</code> with a reference
instead of an owned value.</p>
<h3 id="example-28-1"><a class="header" href="#example-28-1">Example</a></h3>
<pre><code class="language-rust"><span class="boring">fn operation_that_requires_mutex_to_be_unlocked() {} // just to make it compile
</span><span class="boring">let mutex = std::sync::Mutex::new(1); // just to make it compile
</span>let mut lock_guard = mutex.lock();
std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex
// still locked
operation_that_requires_mutex_to_be_unlocked();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a reference instead of an owned value does nothing
 --&gt; lint_example.rs:5:1
  |
5 | std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex
  | ^^^^^^^^^^^^^^^-----------^
  |                |
  |                argument has type `&amp;Result&lt;std::sync::MutexGuard&lt;'_, i32&gt;, PoisonError&lt;std::sync::MutexGuard&lt;'_, i32&gt;&gt;&gt;`
  |
  = note: `#[warn(dropping_references)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
5 - std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex
5 + let _ = &amp;lock_guard; // Should have been drop(lock_guard), mutex
  |

</code></pre>
<h3 id="explanation-28-1"><a class="header" href="#explanation-28-1">Explanation</a></h3>
<p>Calling <code>drop</code> on a reference will only drop the
reference itself, which is a no-op. It will not call the <code>drop</code> method (from
the <code>Drop</code> trait implementation) on the underlying referenced value, which
is likely what was intended.</p>
<h2 id="duplicate-macro-attributes"><a class="header" href="#duplicate-macro-attributes">duplicate-macro-attributes</a></h2>
<p>The <code>duplicate_macro_attributes</code> lint detects when a <code>#[test]</code>-like built-in macro
attribute is duplicated on an item. This lint may trigger on <code>bench</code>, <code>cfg_eval</code>, <code>test</code>
and <code>test_case</code>.</p>
<h3 id="example-29-1"><a class="header" href="#example-29-1">Example</a></h3>
<pre><code class="language-rust ignore (needs --test)">#[test]
#[test]
fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: duplicated attribute
 --&gt; src/lib.rs:2:1
  |
2 | #[test]
  | ^^^^^^^
  |
  = note: `#[warn(duplicate_macro_attributes)]` on by default
</code></pre>
<h3 id="explanation-29-1"><a class="header" href="#explanation-29-1">Explanation</a></h3>
<p>A duplicated attribute may erroneously originate from a copy-paste and the effect of it
being duplicated may not be obvious or desirable.</p>
<p>For instance, doubling the <code>#[test]</code> attributes registers the test to be run twice with no
change to its environment.</p>
<h2 id="dyn-drop"><a class="header" href="#dyn-drop">dyn-drop</a></h2>
<p>The <code>dyn_drop</code> lint checks for trait objects with <code>std::ops::Drop</code>.</p>
<h3 id="example-30-1"><a class="header" href="#example-30-1">Example</a></h3>
<pre><code class="language-rust">fn foo(_x: Box&lt;dyn Drop&gt;) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped
 --&gt; lint_example.rs:2:20
  |
2 | fn foo(_x: Box&lt;dyn Drop&gt;) {}
  |                    ^^^^
  |
  = note: `#[warn(dyn_drop)]` on by default

</code></pre>
<h3 id="explanation-30-1"><a class="header" href="#explanation-30-1">Explanation</a></h3>
<p>A trait object bound of the form <code>dyn Drop</code> is most likely misleading
and not what the programmer intended.</p>
<p><code>Drop</code> bounds do not actually indicate whether a type can be trivially
dropped or not, because a composite type containing <code>Drop</code> types does
not necessarily implement <code>Drop</code> itself. Naïvely, one might be tempted
to write a deferred drop system, to pull cleaning up memory out of a
latency-sensitive code path, using <code>dyn Drop</code> trait objects. However,
this breaks down e.g. when <code>T</code> is <code>String</code>, which does not implement
<code>Drop</code>, but should probably be accepted.</p>
<p>To write a trait object bound that accepts anything, use a placeholder
trait with a blanket implementation.</p>
<pre><code class="language-rust">trait Placeholder {}
impl&lt;T&gt; Placeholder for T {}
fn foo(_x: Box&lt;dyn Placeholder&gt;) {}</code></pre>
<h2 id="ellipsis-inclusive-range-patterns"><a class="header" href="#ellipsis-inclusive-range-patterns">ellipsis-inclusive-range-patterns</a></h2>
<p>The <code>ellipsis_inclusive_range_patterns</code> lint detects the <a href="https://doc.rust-lang.org/reference/patterns.html#range-patterns"><code>...</code> range
pattern</a>, which is deprecated.</p>
<h3 id="example-31-1"><a class="header" href="#example-31-1">Example</a></h3>
<pre><code class="language-rust edition2018">let x = 123;
match x {
    0...100 =&gt; {}
    _ =&gt; {}
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `...` range patterns are deprecated
 --&gt; lint_example.rs:4:6
  |
4 |     0...100 =&gt; {}
  |      ^^^ help: use `..=` for an inclusive range
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;
  = note: `#[warn(ellipsis_inclusive_range_patterns)]` (part of `#[warn(rust_2021_compatibility)]`) on by default

</code></pre>
<h3 id="explanation-31-1"><a class="header" href="#explanation-31-1">Explanation</a></h3>
<p>The <code>...</code> range pattern syntax was changed to <code>..=</code> to avoid potential
confusion with the <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html"><code>..</code> range expression</a>. Use the new form instead.</p>
<h2 id="exported-private-dependencies"><a class="header" href="#exported-private-dependencies">exported-private-dependencies</a></h2>
<p>The <code>exported_private_dependencies</code> lint detects private dependencies
that are exposed in a public interface.</p>
<h3 id="example-32-1"><a class="header" href="#example-32-1">Example</a></h3>
<pre><code class="language-rust ignore (needs-dependency)">pub fn foo() -&gt; Option&lt;some_private_dependency::Thing&gt; {
    None
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type `bar::Thing` from private dependency 'bar' in public interface
 --&gt; src/lib.rs:3:1
  |
3 | pub fn foo() -&gt; Option&lt;bar::Thing&gt; {
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(exported_private_dependencies)]` on by default
</code></pre>
<h3 id="explanation-32-1"><a class="header" href="#explanation-32-1">Explanation</a></h3>
<p>Dependencies can be marked as “private” to indicate that they are not
exposed in the public interface of a crate. This can be used by Cargo
to independently resolve those dependencies because it can assume it
does not need to unify them with other packages using that same
dependency. This lint is an indication of a violation of that
contract.</p>
<p>To fix this, avoid exposing the dependency in your public interface.
Or, switch the dependency to a public dependency.</p>
<p>Note that support for this is only available on the nightly channel.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/1977-public-private-dependencies.md">RFC 1977</a> for more details, as well as the <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#public-dependency">Cargo documentation</a>.</p>
<h2 id="for-loops-over-fallibles"><a class="header" href="#for-loops-over-fallibles">for-loops-over-fallibles</a></h2>
<p>The <code>for_loops_over_fallibles</code> lint checks for <code>for</code> loops over <code>Option</code> or <code>Result</code> values.</p>
<h3 id="example-33-1"><a class="header" href="#example-33-1">Example</a></h3>
<pre><code class="language-rust">let opt = Some(1);
for x in opt { /* ... */}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: for loop over an `Option`. This is more readably written as an `if let` statement
 --&gt; lint_example.rs:3:10
  |
3 | for x in opt { /* ... */}
  |          ^^^
  |
  = note: `#[warn(for_loops_over_fallibles)]` on by default
help: to check pattern in a loop use `while let`
  |
3 - for x in opt { /* ... */}
3 + while let Some(x) = opt { /* ... */}
  |
help: consider using `if let` to clear intent
  |
3 - for x in opt { /* ... */}
3 + if let Some(x) = opt { /* ... */}
  |

</code></pre>
<h3 id="explanation-33-1"><a class="header" href="#explanation-33-1">Explanation</a></h3>
<p>Both <code>Option</code> and <code>Result</code> implement <code>IntoIterator</code> trait, which allows using them in a <code>for</code> loop.
<code>for</code> loop over <code>Option</code> or <code>Result</code> will iterate either 0 (if the value is <code>None</code>/<code>Err(_)</code>)
or 1 time (if the value is <code>Some(_)</code>/<code>Ok(_)</code>). This is not very useful and is more clearly expressed
via <code>if let</code>.</p>
<p><code>for</code> loop can also be accidentally written with the intention to call a function multiple times,
while the function returns <code>Some(_)</code>, in these cases <code>while let</code> loop should be used instead.</p>
<p>The “intended” use of <code>IntoIterator</code> implementations for <code>Option</code> and <code>Result</code> is passing them to
generic code that expects something implementing <code>IntoIterator</code>. For example using <code>.chain(option)</code>
to optionally add a value to an iterator.</p>
<h2 id="forbidden-lint-groups"><a class="header" href="#forbidden-lint-groups">forbidden-lint-groups</a></h2>
<p>The <code>forbidden_lint_groups</code> lint detects violations of
<code>forbid</code> applied to a lint group. Due to a bug in the compiler,
these used to be overlooked entirely. They now generate a warning.</p>
<h3 id="example-34-1"><a class="header" href="#example-34-1">Example</a></h3>
<pre><code class="language-rust">#![forbid(warnings)]
#![warn(bad_style)]

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: warn(bad_style) incompatible with previous forbid
 --&gt; lint_example.rs:2:9
  |
1 | #![forbid(warnings)]
  |           -------- `forbid` level set here
2 | #![warn(bad_style)]
  |         ^^^^^^^^^ overruled by previous forbid
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #81670 &lt;https://github.com/rust-lang/rust/issues/81670&gt;
  = note: `#[warn(forbidden_lint_groups)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="recommended-fix"><a class="header" href="#recommended-fix">Recommended fix</a></h3>
<p>If your crate is using <code>#![forbid(warnings)]</code>,
we recommend that you change to <code>#![deny(warnings)]</code>.</p>
<h3 id="explanation-34-1"><a class="header" href="#explanation-34-1">Explanation</a></h3>
<p>Due to a compiler bug, applying <code>forbid</code> to lint groups
previously had no effect. The bug is now fixed but instead of
enforcing <code>forbid</code> we issue this future-compatibility warning
to avoid breaking existing crates.</p>
<h2 id="forgetting-copy-types"><a class="header" href="#forgetting-copy-types">forgetting-copy-types</a></h2>
<p>The <code>forgetting_copy_types</code> lint checks for calls to <code>std::mem::forget</code> with a value
that derives the Copy trait.</p>
<h3 id="example-35-1"><a class="header" href="#example-35-1">Example</a></h3>
<pre><code class="language-rust">let x: i32 = 42; // i32 implements Copy
std::mem::forget(x); // A copy of x is passed to the function, leaving the
                     // original unaffected</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::forget` with a value that implements `Copy` does nothing
 --&gt; lint_example.rs:3:1
  |
3 | std::mem::forget(x); // A copy of x is passed to the function, leaving the
  | ^^^^^^^^^^^^^^^^^-^
  |                  |
  |                  argument has type `i32`
  |
  = note: `#[warn(forgetting_copy_types)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
3 - std::mem::forget(x); // A copy of x is passed to the function, leaving the
3 + let _ = x; // A copy of x is passed to the function, leaving the
  |

</code></pre>
<h3 id="explanation-35-1"><a class="header" href="#explanation-35-1">Explanation</a></h3>
<p>Calling <code>std::mem::forget</code> <a href="https://doc.rust-lang.org/std/mem/fn.drop.html">does nothing for types that
implement Copy</a> since the
value will be copied and moved into the function on invocation.</p>
<p>An alternative, but also valid, explanation is that Copy types do not
implement the Drop trait, which means they have no destructors. Without a
destructor, there is nothing for <code>std::mem::forget</code> to ignore.</p>
<h2 id="forgetting-references"><a class="header" href="#forgetting-references">forgetting-references</a></h2>
<p>The <code>forgetting_references</code> lint checks for calls to <code>std::mem::forget</code> with a reference
instead of an owned value.</p>
<h3 id="example-36-1"><a class="header" href="#example-36-1">Example</a></h3>
<pre><code class="language-rust">let x = Box::new(1);
std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::forget` with a reference instead of an owned value does nothing
 --&gt; lint_example.rs:3:1
  |
3 | std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped
  | ^^^^^^^^^^^^^^^^^--^
  |                  |
  |                  argument has type `&amp;Box&lt;i32&gt;`
  |
  = note: `#[warn(forgetting_references)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
3 - std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped
3 + let _ = &amp;x; // Should have been forget(x), x will still be dropped
  |

</code></pre>
<h3 id="explanation-36-1"><a class="header" href="#explanation-36-1">Explanation</a></h3>
<p>Calling <code>forget</code> on a reference will only forget the
reference itself, which is a no-op. It will not forget the underlying
referenced value, which is likely what was intended.</p>
<h2 id="function-casts-as-integer"><a class="header" href="#function-casts-as-integer">function-casts-as-integer</a></h2>
<p>The <code>function_casts_as_integer</code> lint detects cases where a function item is cast
to an integer.</p>
<h3 id="example-37-1"><a class="header" href="#example-37-1">Example</a></h3>
<pre><code class="language-rust">fn foo() {}
let x = foo as usize;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: direct cast of function item into an integer
 --&gt; lint_example.rs:3:13
  |
3 | let x = foo as usize;
  |             ^^^^^^^^
  |
  = note: `#[warn(function_casts_as_integer)]` on by default
help: first cast to a pointer `as *const ()`
  |
3 | let x = foo as *const () as usize;
  |             ++++++++++++

</code></pre>
<h3 id="explanation-37-1"><a class="header" href="#explanation-37-1">Explanation</a></h3>
<p>When casting a function item to an integer, it implicitly creates a
function pointer that will in turn be cast to an integer. By making
it explicit, it improves readability of the code and prevents bugs.</p>
<h2 id="function-item-references"><a class="header" href="#function-item-references">function-item-references</a></h2>
<p>The <code>function_item_references</code> lint detects function references that are
formatted with <a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> or transmuted.</p>
<h3 id="example-38-1"><a class="header" href="#example-38-1">Example</a></h3>
<pre><code class="language-rust">fn foo() { }

fn main() {
    println!("{:p}", &amp;foo);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: taking a reference to a function item does not give a function pointer
 --&gt; lint_example.rs:4:22
  |
4 |     println!("{:p}", &amp;foo);
  |                      ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn()`
  |
  = note: `#[warn(function_item_references)]` on by default

</code></pre>
<h3 id="explanation-38-1"><a class="header" href="#explanation-38-1">Explanation</a></h3>
<p>Taking a reference to a function may be mistaken as a way to obtain a
pointer to that function. This can give unexpected results when
formatting the reference as a pointer or transmuting it. This lint is
issued when function references are formatted as pointers, passed as
arguments bound by <a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> or transmuted.</p>
<h2 id="hidden-glob-reexports"><a class="header" href="#hidden-glob-reexports">hidden-glob-reexports</a></h2>
<p>The <code>hidden_glob_reexports</code> lint detects cases where glob re-export items are shadowed by
private items.</p>
<h3 id="example-39-1"><a class="header" href="#example-39-1">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(hidden_glob_reexports)]

pub mod upstream {
    mod inner { pub struct Foo {}; pub struct Bar {}; }
    pub use self::inner::*;
    struct Foo {} // private item shadows `inner::Foo`
}

// mod downstream {
//     fn test() {
//         let _ = crate::upstream::Foo; // inaccessible
//     }
// }

pub fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: private item shadows public glob re-export
 --&gt; lint_example.rs:6:5
  |
6 |     struct Foo {} // private item shadows `inner::Foo`
  |     ^^^^^^^^^^^^^
  |
note: the name `Foo` in the type namespace is supposed to be publicly re-exported here
 --&gt; lint_example.rs:5:13
  |
5 |     pub use self::inner::*;
  |             ^^^^^^^^^^^^^^
note: but the private item here shadows it
 --&gt; lint_example.rs:6:5
  |
6 |     struct Foo {} // private item shadows `inner::Foo`
  |     ^^^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(hidden_glob_reexports)]
  |         ^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-39-1"><a class="header" href="#explanation-39-1">Explanation</a></h3>
<p>This was previously accepted without any errors or warnings but it could silently break a
crate’s downstream user code. If the <code>struct Foo</code> was added, <code>dep::inner::Foo</code> would
silently become inaccessible and trigger a “<code>struct </code>Foo<code> is private</code>” visibility error at
the downstream use site.</p>
<h2 id="improper-ctypes"><a class="header" href="#improper-ctypes">improper-ctypes</a></h2>
<p>The <code>improper_ctypes</code> lint detects incorrect use of types in foreign
modules.</p>
<h3 id="example-40-1"><a class="header" href="#example-40-1">Example</a></h3>
<pre><code class="language-rust">unsafe extern "C" {
    static STATIC: String;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `extern` block uses type `String`, which is not FFI-safe
 --&gt; lint_example.rs:3:20
  |
3 |     static STATIC: String;
  |                    ^^^^^^ not FFI-safe
  |
  = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct
  = note: this struct has unspecified layout
  = note: `#[warn(improper_ctypes)]` on by default

</code></pre>
<h3 id="explanation-40-1"><a class="header" href="#explanation-40-1">Explanation</a></h3>
<p>The compiler has several checks to verify that types used in <code>extern</code>
blocks are safe and follow certain rules to ensure proper
compatibility with the foreign interfaces. This lint is issued when it
detects a probable mistake in a definition. The lint usually should
provide a description of the issue, along with possibly a hint on how
to resolve it.</p>
<h2 id="improper-ctypes-definitions"><a class="header" href="#improper-ctypes-definitions">improper-ctypes-definitions</a></h2>
<p>The <code>improper_ctypes_definitions</code> lint detects incorrect use of
<a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier"><code>extern</code> function</a> definitions.</p>
<h3 id="example-41-1"><a class="header" href="#example-41-1">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>pub extern "C" fn str_type(p: &amp;str) { }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `extern` fn uses type `str`, which is not FFI-safe
 --&gt; lint_example.rs:3:31
  |
3 | pub extern "C" fn str_type(p: &amp;str) { }
  |                               ^^^^ not FFI-safe
  |
  = help: consider using `*const u8` and a length instead
  = note: string slices have no C equivalent
  = note: `#[warn(improper_ctypes_definitions)]` on by default

</code></pre>
<h3 id="explanation-41-1"><a class="header" href="#explanation-41-1">Explanation</a></h3>
<p>There are many parameter and return types that may be specified in an
<code>extern</code> function that are not compatible with the given ABI. This
lint is an alert that these types should not be used. The lint usually
should provide a description of the issue, along with possibly a hint
on how to resolve it.</p>
<h2 id="improper-gpu-kernel-arg"><a class="header" href="#improper-gpu-kernel-arg">improper-gpu-kernel-arg</a></h2>
<p>The <code>improper_gpu_kernel_arg</code> lint detects incorrect use of types in <code>gpu-kernel</code>
arguments.</p>
<h3 id="example-42-1"><a class="header" href="#example-42-1">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-GPU targets)">#[unsafe(no_mangle)]
extern "gpu-kernel" fn kernel(_: [i32; 10]) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: passing type `[i32; 10]` to a function with "gpu-kernel" ABI may have unexpected behavior
 --&gt; t.rs:2:34
  |
2 | extern "gpu-kernel" fn kernel(_: [i32; 10]) {}
  |                                  ^^^^^^^^^
  |
  = help: use primitive types and raw pointers to get reliable behavior
  = note: `#[warn(improper_gpu_kernel_arg)]` on by default
</code></pre>
<h3 id="explanation-42-1"><a class="header" href="#explanation-42-1">Explanation</a></h3>
<p>The compiler has several checks to verify that types used as arguments in <code>gpu-kernel</code>
functions follow certain rules to ensure proper compatibility with the foreign interfaces.
This lint is issued when it detects a probable mistake in a signature.</p>
<h2 id="incomplete-features"><a class="header" href="#incomplete-features">incomplete-features</a></h2>
<p>The <code>incomplete_features</code> lint detects unstable features enabled with
the <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that may function improperly in some or all
cases.</p>
<h3 id="example-43-1"><a class="header" href="#example-43-1">Example</a></h3>
<pre><code class="language-rust">#![feature(generic_const_exprs)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(generic_const_exprs)]
  |            ^^^^^^^^^^^^^^^^^^^
  |
  = note: see issue #76560 &lt;https://github.com/rust-lang/rust/issues/76560&gt; for more information
  = note: `#[warn(incomplete_features)]` on by default

</code></pre>
<h3 id="explanation-43-1"><a class="header" href="#explanation-43-1">Explanation</a></h3>
<p>Although it is encouraged for people to experiment with unstable
features, some of them are known to be incomplete or faulty. This lint
is a signal that the feature has not yet been finished, and you may
experience problems with it.</p>
<h2 id="inline-always-mismatching-target-features"><a class="header" href="#inline-always-mismatching-target-features">inline-always-mismatching-target-features</a></h2>
<p>The <code>inline_always_mismatching_target_features</code> lint will trigger when a
function with the <code>#[inline(always)]</code> and <code>#[target_feature(enable = "...")]</code>
attributes is called and cannot be inlined due to missing target features in the caller.</p>
<h3 id="example-44-1"><a class="header" href="#example-44-1">Example</a></h3>
<pre><code class="language-rust ignore (fails on x86_64)">#[inline(always)]
#[target_feature(enable = "fp16")]
unsafe fn callee() {
    // operations using fp16 types
}

// Caller does not enable the required target feature
fn caller() {
    unsafe { callee(); }
}

fn main() {
    caller();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: call to `#[inline(always)]`-annotated `callee` requires the same target features. Function will not have `alwaysinline` attribute applied
  --&gt; $DIR/builtin.rs:5192:14
   |
10 |     unsafe { callee(); }
   |              ^^^^^^^^
   |
note: `fp16` target feature enabled in `callee` here but missing from `caller`
  --&gt; $DIR/builtin.rs:5185:1
   |
3  | #[target_feature(enable = "fp16")]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4  | unsafe fn callee() {
   | ------------------
   = note: `#[warn(inline_always_mismatching_target_features)]` on by default
warning: 1 warning emitted
</code></pre>
<h3 id="explanation-44-1"><a class="header" href="#explanation-44-1">Explanation</a></h3>
<p>Inlining a function with a target feature attribute into a caller that
lacks the corresponding target feature can lead to unsound behavior.
LLVM may select the wrong instructions or registers, or reorder
operations, potentially resulting in runtime errors.</p>
<h2 id="inline-no-sanitize"><a class="header" href="#inline-no-sanitize">inline-no-sanitize</a></h2>
<p>The <code>inline_no_sanitize</code> lint detects incompatible use of
<a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline(always)]</code></a> and <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[sanitize(xyz = "off")]</code></a>.</p>
<h3 id="example-45-1"><a class="header" href="#example-45-1">Example</a></h3>
<pre><code class="language-rust">#![feature(sanitize)]

#[inline(always)]
#[sanitize(address = "off")]
fn x() {}

fn main() {
    x()
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: non-default `sanitize` will have no effect after inlining
 --&gt; lint_example.rs:4:1
  |
4 | #[sanitize(address = "off")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: inlining requested here
 --&gt; lint_example.rs:3:1
  |
3 | #[inline(always)]
  | ^^^^^^^^^^^^^^^^^
  = note: `#[warn(inline_no_sanitize)]` on by default

</code></pre>
<h3 id="explanation-45-1"><a class="header" href="#explanation-45-1">Explanation</a></h3>
<p>The use of the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline(always)]</code></a> attribute prevents the
the <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[sanitize(xyz = "off")]</code></a> attribute from working.
Consider temporarily removing <code>inline</code> attribute.</p>
<h2 id="integer-to-ptr-transmutes"><a class="header" href="#integer-to-ptr-transmutes">integer-to-ptr-transmutes</a></h2>
<p>The <code>integer_to_ptr_transmutes</code> lint detects integer to pointer
transmutes where the resulting pointers are undefined behavior to dereference.</p>
<h3 id="example-46-1"><a class="header" href="#example-46-1">Example</a></h3>
<pre><code class="language-rust">fn foo(a: usize) -&gt; *const u8 {
   unsafe {
       std::mem::transmute::&lt;usize, *const u8&gt;(a)
   }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: transmuting an integer to a pointer creates a pointer without provenance
 --&gt; lint_example.rs:4:8
  |
4 |        std::mem::transmute::&lt;usize, *const u8&gt;(a)
  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
  = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
  = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
  = help: for more information about transmute, see &lt;https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers&gt;
  = help: for more information about exposed provenance, see &lt;https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance&gt;
  = note: `#[warn(integer_to_ptr_transmutes)]` on by default
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
  |
4 -        std::mem::transmute::&lt;usize, *const u8&gt;(a)
4 +        std::ptr::with_exposed_provenance::&lt;u8&gt;(a)
  |

</code></pre>
<h3 id="explanation-46-1"><a class="header" href="#explanation-46-1">Explanation</a></h3>
<p>Any attempt to use the resulting pointers are undefined behavior as the resulting
pointers won’t have any provenance.</p>
<p>Alternatively, <a href="https://doc.rust-lang.org/std/ptr/fn.with_exposed_provenance.html"><code>std::ptr::with_exposed_provenance</code></a> should be used, as they do not
carry the provenance requirement. If wanting to create pointers without provenance
<a href="https://doc.rust-lang.org/std/ptr/fn.without_provenance.html"><code>std::ptr::without_provenance</code></a> should be used instead.</p>
<p>See <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> in the reference for more details.</p>
<h2 id="internal-features"><a class="header" href="#internal-features">internal-features</a></h2>
<p>The <code>internal_features</code> lint detects unstable features enabled with
the <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that are internal to the compiler or standard
library.</p>
<h3 id="example-47-1"><a class="header" href="#example-47-1">Example</a></h3>
<pre><code class="language-rust">#![feature(rustc_attrs)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `rustc_attrs` is internal to the compiler or standard library
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(rustc_attrs)]
  |            ^^^^^^^^^^^
  |
  = note: using it is strongly discouraged
  = note: `#[warn(internal_features)]` on by default

</code></pre>
<h3 id="explanation-47-1"><a class="header" href="#explanation-47-1">Explanation</a></h3>
<p>These features are an implementation detail of the compiler and standard
library and are not supposed to be used in user code.</p>
<h2 id="invalid-from-utf8"><a class="header" href="#invalid-from-utf8">invalid-from-utf8</a></h2>
<p>The <code>invalid_from_utf8</code> lint checks for calls to
<code>std::str::from_utf8</code> and <code>std::str::from_utf8_mut</code>
with a known invalid UTF-8 value.</p>
<h3 id="example-48-1"><a class="header" href="#example-48-1">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#[allow(unused)]
</span>std::str::from_utf8(b"Ru\x82st");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::str::from_utf8` with an invalid literal always return an error
 --&gt; lint_example.rs:3:1
  |
3 | std::str::from_utf8(b"Ru\x82st");
  | ^^^^^^^^^^^^^^^^^^^^-----------^
  |                     |
  |                     the literal was valid UTF-8 up to the 2 bytes
  |
  = note: `#[warn(invalid_from_utf8)]` on by default

</code></pre>
<h3 id="explanation-48-1"><a class="header" href="#explanation-48-1">Explanation</a></h3>
<p>Trying to create such a <code>str</code> would always return an error as per documentation
for <code>std::str::from_utf8</code> and <code>std::str::from_utf8_mut</code>.</p>
<h2 id="invalid-nan-comparisons"><a class="header" href="#invalid-nan-comparisons">invalid-nan-comparisons</a></h2>
<p>The <code>invalid_nan_comparisons</code> lint checks comparison with <code>f32::NAN</code> or <code>f64::NAN</code>
as one of the operand.</p>
<h3 id="example-49-1"><a class="header" href="#example-49-1">Example</a></h3>
<pre><code class="language-rust">let a = 2.3f32;
if a == f32::NAN {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: incorrect NaN comparison, NaN cannot be directly compared to itself
 --&gt; lint_example.rs:3:4
  |
3 | if a == f32::NAN {}
  |    ^^^^^^^^^^^^^
  |
  = note: `#[warn(invalid_nan_comparisons)]` on by default
help: use `f32::is_nan()` or `f64::is_nan()` instead
  |
3 - if a == f32::NAN {}
3 + if a.is_nan() {}
  |

</code></pre>
<h3 id="explanation-49-1"><a class="header" href="#explanation-49-1">Explanation</a></h3>
<p>NaN does not compare meaningfully to anything – not
even itself – so those comparisons are always false.</p>
<h2 id="invalid-value"><a class="header" href="#invalid-value">invalid-value</a></h2>
<p>The <code>invalid_value</code> lint detects creating a value that is not valid,
such as a null reference.</p>
<h3 id="example-50-1"><a class="header" href="#example-50-1">Example</a></h3>
<pre><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>unsafe {
    let x: &amp;'static i32 = std::mem::zeroed();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the type `&amp;i32` does not permit zero-initialization
 --&gt; lint_example.rs:4:27
  |
4 |     let x: &amp;'static i32 = std::mem::zeroed();
  |                           ^^^^^^^^^^^^^^^^^^
  |                           |
  |                           this code causes undefined behavior when executed
  |                           help: use `MaybeUninit&lt;T&gt;` instead, and only call `assume_init` after initialization is done
  |
  = note: references must be non-null
  = note: `#[warn(invalid_value)]` on by default

</code></pre>
<h3 id="explanation-50-1"><a class="header" href="#explanation-50-1">Explanation</a></h3>
<p>In some situations the compiler can detect that the code is creating
an invalid value, which should be avoided.</p>
<p>In particular, this lint will check for improper use of
<a href="https://doc.rust-lang.org/std/mem/fn.zeroed.html"><code>mem::zeroed</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>mem::transmute</code></a>, and
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.assume_init"><code>MaybeUninit::assume_init</code></a> that can cause <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>. The
lint should provide extra information to indicate what the problem is
and a possible solution.</p>
<h2 id="irrefutable-let-patterns"><a class="header" href="#irrefutable-let-patterns">irrefutable-let-patterns</a></h2>
<p>The <code>irrefutable_let_patterns</code> lint detects <a href="https://doc.rust-lang.org/reference/patterns.html#refutability">irrefutable patterns</a>
in <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code></a>s, <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>s, and <code>if let</code> guards.</p>
<h3 id="example-51-1"><a class="header" href="#example-51-1">Example</a></h3>
<pre><code class="language-rust">if let _ = 123 {
    println!("always runs!");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: irrefutable `if let` pattern
 --&gt; lint_example.rs:2:4
  |
2 | if let _ = 123 {
  |    ^^^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

</code></pre>
<h3 id="explanation-51-1"><a class="header" href="#explanation-51-1">Explanation</a></h3>
<p>There usually isn’t a reason to have an irrefutable pattern in an
<code>if let</code> or <code>while let</code> statement, because the pattern will always match
successfully. A <a href="https://doc.rust-lang.org/reference/statements.html#let-statements"><code>let</code></a> or <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops"><code>loop</code></a> statement will suffice. However,
when generating code with a macro, forbidding irrefutable patterns
would require awkward workarounds in situations where the macro
doesn’t know if the pattern is refutable or not. This lint allows
macros to accept this form, while alerting for a possibly incorrect
use in normal code.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2086-allow-if-let-irrefutables.md">RFC 2086</a> for more details.</p>
<h2 id="large-assignments"><a class="header" href="#large-assignments">large-assignments</a></h2>
<p>The <code>large_assignments</code> lint detects when objects of large
types are being moved around.</p>
<h3 id="example-52-1"><a class="header" href="#example-52-1">Example</a></h3>
<pre><code class="language-rust ignore (can crash on some platforms)">let x = [0; 50000];
let y = x;</code></pre>
<p>produces:</p>
<pre><code class="language-text">warning: moving a large value
  --&gt; $DIR/move-large.rs:1:3
  let y = x;
          - Copied large value here
</code></pre>
<h3 id="explanation-52-1"><a class="header" href="#explanation-52-1">Explanation</a></h3>
<p>When using a large type in a plain assignment or in a function
argument, idiomatic code can be inefficient.
Ideally appropriate optimizations would resolve this, but such
optimizations are only done in a best-effort manner.
This lint will trigger on all sites of large moves and thus allow the
user to resolve them in code.</p>
<h2 id="late-bound-lifetime-arguments"><a class="header" href="#late-bound-lifetime-arguments">late-bound-lifetime-arguments</a></h2>
<p>The <code>late_bound_lifetime_arguments</code> lint detects generic lifetime
arguments in path segments with late bound lifetime parameters.</p>
<h3 id="example-53-1"><a class="header" href="#example-53-1">Example</a></h3>
<pre><code class="language-rust">struct S;

impl S {
    fn late(self, _: &amp;u8, _: &amp;u8) {}
}

fn main() {
    S.late::&lt;'static&gt;(&amp;0, &amp;0);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present
 --&gt; lint_example.rs:8:14
  |
4 |     fn late(self, _: &amp;u8, _: &amp;u8) {}
  |                      - the late bound lifetime parameter is introduced here
...
8 |     S.late::&lt;'static&gt;(&amp;0, &amp;0);
  |              ^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #42868 &lt;https://github.com/rust-lang/rust/issues/42868&gt;
  = note: `#[warn(late_bound_lifetime_arguments)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-53-1"><a class="header" href="#explanation-53-1">Explanation</a></h3>
<p>It is not clear how to provide arguments for early-bound lifetime
parameters if they are intermixed with late-bound parameters in the
same list. For now, providing any explicit arguments will trigger this
lint if late-bound parameters are present, so in the future a solution
can be adopted without hitting backward compatibility issues. This is
a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/42868">issue #42868</a> for more details, along with a description
of the difference between early and late-bound parameters.</p>
<h2 id="malformed-diagnostic-attributes"><a class="header" href="#malformed-diagnostic-attributes">malformed-diagnostic-attributes</a></h2>
<p>The <code>malformed_diagnostic_attributes</code> lint detects malformed diagnostic attributes.</p>
<h3 id="example-54-1"><a class="header" href="#example-54-1">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::do_not_recommend(message = "message")]
trait Trait {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[diagnostic::do_not_recommend]` does not expect any arguments
 --&gt; lint_example.rs:2:1
  |
2 | #[diagnostic::do_not_recommend(message = "message")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(malformed_diagnostic_attributes)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-54-1"><a class="header" href="#explanation-54-1">Explanation</a></h3>
<p>It is usually a mistake to use options or syntax that is not supported. Check the spelling,
and check the diagnostic attribute listing for the correct name and syntax. Also consider if
you are using an old version of the compiler; perhaps the option or syntax is only available
in a newer version. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for a list of diagnostic attributes and the syntax
of each.</p>
<h2 id="malformed-diagnostic-format-literals"><a class="header" href="#malformed-diagnostic-format-literals">malformed-diagnostic-format-literals</a></h2>
<p>The <code>malformed_diagnostic_format_literals</code> lint detects malformed diagnostic format
literals.</p>
<h3 id="example-55-1"><a class="header" href="#example-55-1">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::on_unimplemented(message = "{Self}} does not implement `Trait`")]
trait Trait {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unmatched `}` found
 --&gt; lint_example.rs:2:42
  |
2 | #[diagnostic::on_unimplemented(message = "{Self}} does not implement `Trait`")]
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(malformed_diagnostic_format_literals)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-55-1"><a class="header" href="#explanation-55-1">Explanation</a></h3>
<p>The <code>#[diagnostic::on_unimplemented]</code> attribute accepts string literal values that are
similar to <code>format!</code>’s string literal. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for details on what is permitted
in this string literal.</p>
<h2 id="map-unit-fn"><a class="header" href="#map-unit-fn">map-unit-fn</a></h2>
<p>The <code>map_unit_fn</code> lint checks for <code>Iterator::map</code> receive
a callable that returns <code>()</code>.</p>
<h3 id="example-56-1"><a class="header" href="#example-56-1">Example</a></h3>
<pre><code class="language-rust">fn foo(items: &amp;mut Vec&lt;u8&gt;) {
    items.sort();
}

fn main() {
    let mut x: Vec&lt;Vec&lt;u8&gt;&gt; = vec![
        vec![0, 2, 1],
        vec![5, 4, 3],
    ];
    x.iter_mut().map(foo);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `Iterator::map` call that discard the iterator's values
  --&gt; lint_example.rs:10:18
   |
 1 | fn foo(items: &amp;mut Vec&lt;u8&gt;) {
   | --------------------------- this function returns `()`, which is likely not what you wanted
...
10 |     x.iter_mut().map(foo);
   |                  ^^^^---^
   |                  |   |
   |                  |   called `Iterator::map` with callable that returns `()`
   |                  after this call to map, the resulting iterator is `impl Iterator&lt;Item = ()&gt;`, which means the only information carried by the iterator is the number of items
   |
   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated
   = note: `#[warn(map_unit_fn)]` (part of `#[warn(unused)]`) on by default
help: you might have meant to use `Iterator::for_each`
   |
10 -     x.iter_mut().map(foo);
10 +     x.iter_mut().for_each(foo);
   |

</code></pre>
<h3 id="explanation-56-1"><a class="header" href="#explanation-56-1">Explanation</a></h3>
<p>Mapping to <code>()</code> is almost always a mistake.</p>
<h2 id="mismatched-lifetime-syntaxes"><a class="header" href="#mismatched-lifetime-syntaxes">mismatched-lifetime-syntaxes</a></h2>
<p>The <code>mismatched_lifetime_syntaxes</code> lint detects when the same
lifetime is referred to by different syntaxes between function
arguments and return values.</p>
<p>The three kinds of syntaxes are:</p>
<ol>
<li>
<p>Named lifetimes. These are references (<code>&amp;'a str</code>) or paths
(<code>Person&lt;'a&gt;</code>) that use a lifetime with a name, such as
<code>'static</code> or <code>'a</code>.</p>
</li>
<li>
<p>Elided lifetimes. These are references with no explicit
lifetime (<code>&amp;str</code>), references using the anonymous lifetime
(<code>&amp;'_ str</code>), and paths using the anonymous lifetime
(<code>Person&lt;'_&gt;</code>).</p>
</li>
<li>
<p>Hidden lifetimes. These are paths that do not contain any
visual indication that it contains a lifetime (<code>Person</code>).</p>
</li>
</ol>
<h3 id="example-57-1"><a class="header" href="#example-57-1">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(mismatched_lifetime_syntaxes)]

pub fn mixing_named_with_elided(v: &amp;'static u8) -&gt; &amp;u8 {
    v
}

struct Person&lt;'a&gt; {
    name: &amp;'a str,
}

pub fn mixing_hidden_with_elided(v: Person) -&gt; Person&lt;'_&gt; {
    v
}

struct Foo;

impl Foo {
    // Lifetime elision results in the output lifetime becoming
    // `'static`, which is not what was intended.
    pub fn get_mut(&amp;'static self, x: &amp;mut u8) -&gt; &amp;mut u8 {
        unsafe { &amp;mut *(x as *mut _) }
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: eliding a lifetime that's named elsewhere is confusing
 --&gt; lint_example.rs:4:52
  |
4 | pub fn mixing_named_with_elided(v: &amp;'static u8) -&gt; &amp;u8 {
  |                                     -------        ^^^ the same lifetime is elided here
  |                                     |
  |                                     the lifetime is named here
  |
  = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(mismatched_lifetime_syntaxes)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consistently use `'static`
  |
4 | pub fn mixing_named_with_elided(v: &amp;'static u8) -&gt; &amp;'static u8 {
  |                                                     +++++++


error: hiding a lifetime that's elided elsewhere is confusing
  --&gt; lint_example.rs:12:37
   |
12 | pub fn mixing_hidden_with_elided(v: Person) -&gt; Person&lt;'_&gt; {
   |                                     ^^^^^^            ^^ the same lifetime is elided here
   |                                     |
   |                                     the lifetime is hidden here
   |
   = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: consistently use `'_`
   |
12 | pub fn mixing_hidden_with_elided(v: Person&lt;'_&gt;) -&gt; Person&lt;'_&gt; {
   |                                           ++++


error: eliding a lifetime that's named elsewhere is confusing
  --&gt; lint_example.rs:21:50
   |
21 |     pub fn get_mut(&amp;'static self, x: &amp;mut u8) -&gt; &amp;mut u8 {
   |                     -------                      ^^^^^^^ the same lifetime is elided here
   |                     |
   |                     the lifetime is named here
   |
   = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: consistently use `'static`
   |
21 |     pub fn get_mut(&amp;'static self, x: &amp;mut u8) -&gt; &amp;'static mut u8 {
   |                                                   +++++++

</code></pre>
<h3 id="explanation-57-1"><a class="header" href="#explanation-57-1">Explanation</a></h3>
<p>Lifetime elision is useful because it frees you from having to
give each lifetime its own name and show the relation of input
and output lifetimes for common cases. However, a lifetime
that uses inconsistent syntax between related arguments and
return values is more confusing.</p>
<p>In certain <code>unsafe</code> code, lifetime elision combined with
inconsistent lifetime syntax may result in unsound code.</p>
<h2 id="misplaced-diagnostic-attributes"><a class="header" href="#misplaced-diagnostic-attributes">misplaced-diagnostic-attributes</a></h2>
<p>The <code>misplaced_diagnostic_attributes</code> lint detects wrongly placed diagnostic attributes.</p>
<h3 id="example-58-1"><a class="header" href="#example-58-1">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::do_not_recommend]
struct NotUserFacing;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[diagnostic::do_not_recommend]` can only be placed on trait implementations
 --&gt; lint_example.rs:2:1
  |
2 | #[diagnostic::do_not_recommend]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(misplaced_diagnostic_attributes)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-58-1"><a class="header" href="#explanation-58-1">Explanation</a></h3>
<p>It is usually a mistake to specify a diagnostic attribute on an item it is not meant for.
For example, <code>#[diagnostic::do_not_recommend]</code> can only be placed on trait implementations,
and does nothing if placed elsewhere. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for a list of diagnostic
attributes and their correct positions.</p>
<h2 id="missing-abi"><a class="header" href="#missing-abi">missing-abi</a></h2>
<p>The <code>missing_abi</code> lint detects cases where the ABI is omitted from
<code>extern</code> declarations.</p>
<h3 id="example-59"><a class="header" href="#example-59">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_abi)]

extern fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `extern` declarations without an explicit ABI are deprecated
 --&gt; lint_example.rs:4:1
  |
4 | extern fn foo() {}
  | ^^^^^^ help: explicitly specify the "C" ABI: `extern "C"`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_abi)]
  |         ^^^^^^^^^^^

</code></pre>
<h3 id="explanation-59-1"><a class="header" href="#explanation-59-1">Explanation</a></h3>
<p>For historic reasons, Rust implicitly selects <code>C</code> as the default ABI for
<code>extern</code> declarations. <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#abi">Other ABIs</a> like <code>C-unwind</code> and <code>system</code> have
been added since then, and especially with their addition seeing the ABI
easily makes code review easier.</p>
<h2 id="missing-gpu-kernel-export-name"><a class="header" href="#missing-gpu-kernel-export-name">missing-gpu-kernel-export-name</a></h2>
<p>The <code>missing_gpu_kernel_export_name</code> lint detects <code>gpu-kernel</code> functions that have a mangled name.</p>
<h3 id="example-60"><a class="header" href="#example-60">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-GPU targets)">extern "gpu-kernel" fn kernel() { }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function with the "gpu-kernel" ABI has a mangled name
 --&gt; t.rs:1:1
  |
1 | extern "gpu-kernel" fn kernel() {}
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: use `unsafe(no_mangle)` or `unsafe(export_name = "&lt;name&gt;")`
  = note: mangled names make it hard to find the kernel, this is usually not intended
  = note: `#[warn(missing_gpu_kernel_export_name)]` on by default
</code></pre>
<h3 id="explanation-60-1"><a class="header" href="#explanation-60-1">Explanation</a></h3>
<p><code>gpu-kernel</code> functions are usually searched by name in the compiled file.
A mangled name is usually unintentional as it would need to be searched by the mangled name.</p>
<p>To use an unmangled name for the kernel, either <code>no_mangle</code> or <code>export_name</code> can be used.</p>
<pre><code class="language-rust ignore (fails on non-GPU targets)">// Can be found by the name "kernel"
#[unsafe(no_mangle)]
extern "gpu-kernel" fn kernel() { }

// Can be found by the name "new_name"
#[unsafe(export_name = "new_name")]
extern "gpu-kernel" fn other_kernel() { }</code></pre>
<h2 id="mixed-script-confusables"><a class="header" href="#mixed-script-confusables">mixed-script-confusables</a></h2>
<p>The <code>mixed_script_confusables</code> lint detects visually confusable
characters in identifiers between different <a href="https://en.wikipedia.org/wiki/Script_(Unicode)">scripts</a>.</p>
<h3 id="example-61"><a class="header" href="#example-61">Example</a></h3>
<pre><code class="language-rust">// The Japanese katakana character エ can be confused with the Han character 工.
const エ: &amp;'static str = "アイウ";</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the usage of Script Group `Japanese, Katakana` in this crate consists solely of mixed script confusables
 --&gt; lint_example.rs:3:7
  |
3 | const エ: &amp;'static str = "アイウ";
  |       ^^
  |
  = note: the usage includes 'エ' (U+30A8)
  = note: please recheck to make sure their usages are indeed what you want
  = note: `#[warn(mixed_script_confusables)]` on by default

</code></pre>
<h3 id="explanation-61"><a class="header" href="#explanation-61">Explanation</a></h3>
<p>This lint warns when characters between different scripts may appear
visually similar, which can cause confusion.</p>
<p>If the crate contains other identifiers in the same script that have
non-confusable characters, then this lint will <em>not</em> be issued. For
example, if the example given above has another identifier with
katakana characters (such as <code>let カタカナ = 123;</code>), then this indicates
that you are intentionally using katakana, and it will not warn about
it.</p>
<p>Note that the set of confusable characters may change over time.
Beware that if you “forbid” this lint that existing code may fail in
the future.</p>
<h2 id="named-arguments-used-positionally"><a class="header" href="#named-arguments-used-positionally">named-arguments-used-positionally</a></h2>
<p>The <code>named_arguments_used_positionally</code> lint detects cases where named arguments are only
used positionally in format strings. This usage is valid but potentially very confusing.</p>
<h3 id="example-62"><a class="header" href="#example-62">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(named_arguments_used_positionally)]
fn main() {
    let _x = 5;
    println!("{}", _x = 1); // Prints 1, will trigger lint

    println!("{}", _x); // Prints 5, no lint emitted
    println!("{_x}", _x = _x); // Prints 5, no lint emitted
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: named argument `_x` is not used by name
 --&gt; lint_example.rs:4:20
  |
4 |     println!("{}", _x = 1); // Prints 1, will trigger lint
  |               --   ^^ this named argument is referred to by position in formatting string
  |               |
  |               this formatting argument uses named argument `_x` by position
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(named_arguments_used_positionally)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use the named argument by name to avoid ambiguity
  |
4 |     println!("{_x}", _x = 1); // Prints 1, will trigger lint
  |                ++

</code></pre>
<h3 id="explanation-62"><a class="header" href="#explanation-62">Explanation</a></h3>
<p>Rust formatting strings can refer to named arguments by their position, but this usage is
potentially confusing. In particular, readers can incorrectly assume that the declaration
of named arguments is an assignment (which would produce the unit type).
For backwards compatibility, this is not a hard error.</p>
<h2 id="no-mangle-generic-items"><a class="header" href="#no-mangle-generic-items">no-mangle-generic-items</a></h2>
<p>The <code>no_mangle_generic_items</code> lint detects generic items that must be
mangled.</p>
<h3 id="example-63"><a class="header" href="#example-63">Example</a></h3>
<pre><code class="language-rust">#[unsafe(no_mangle)]
fn foo&lt;T&gt;(t: T) {}

#[unsafe(export_name = "bar")]
fn bar&lt;T&gt;(t: T) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: functions generic over types or consts must be mangled
 --&gt; lint_example.rs:3:1
  |
2 | #[unsafe(no_mangle)]
  | -------------------- help: remove this attribute
3 | fn foo&lt;T&gt;(t: T) {}
  | ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(no_mangle_generic_items)]` on by default


warning: functions generic over types or consts must be mangled
 --&gt; lint_example.rs:6:1
  |
5 | #[unsafe(export_name = "bar")]
  | ------------------------------ help: remove this attribute
6 | fn bar&lt;T&gt;(t: T) {}
  | ^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-63"><a class="header" href="#explanation-63">Explanation</a></h3>
<p>A function with generics must have its symbol mangled to accommodate
the generic parameter. The <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> and <a href="https://doc.rust-lang.org/reference/abi.html#the-export_name-attribute"><code>export_name</code></a> attributes
have no effect in this situation, and should be removed.</p>
<h2 id="non-fmt-panic"><a class="header" href="#non-fmt-panic">non-fmt-panic</a></h2>
<p>The lint <code>non-fmt-panic</code> has been renamed to <a href="#non-fmt-panics"><code>non-fmt-panics</code></a>.</p>
<h2 id="non-camel-case-types"><a class="header" href="#non-camel-case-types">non-camel-case-types</a></h2>
<p>The <code>non_camel_case_types</code> lint detects types, variants, traits and
type parameters that don’t have camel case names.</p>
<h3 id="example-64"><a class="header" href="#example-64">Example</a></h3>
<pre><code class="language-rust">struct my_struct;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type `my_struct` should have an upper camel case name
 --&gt; lint_example.rs:2:8
  |
2 | struct my_struct;
  |        ^^^^^^^^^ help: convert the identifier to upper camel case: `MyStruct`
  |
  = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

</code></pre>
<h3 id="explanation-64"><a class="header" href="#explanation-64">Explanation</a></h3>
<p>The preferred style for these identifiers is to use “camel case”, such
as <code>MyStruct</code>, where the first letter should not be lowercase, and
should not use underscores between letters. Underscores are allowed at
the beginning and end of the identifier, as well as between
non-letters (such as <code>X86_64</code>).</p>
<h2 id="non-contiguous-range-endpoints"><a class="header" href="#non-contiguous-range-endpoints">non-contiguous-range-endpoints</a></h2>
<p>The <code>non_contiguous_range_endpoints</code> lint detects likely off-by-one errors when using
exclusive <a href="https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns">range patterns</a>.</p>
<h3 id="example-65"><a class="header" href="#example-65">Example</a></h3>
<pre><code class="language-rust">let x = 123u32;
match x {
    0..100 =&gt; { println!("small"); }
    101..1000 =&gt; { println!("large"); }
    _ =&gt; { println!("larger"); }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: multiple ranges are one apart
 --&gt; lint_example.rs:4:5
  |
4 |     0..100 =&gt; { println!("small"); }
  |     ^^^^^^
  |     |
  |     this range doesn't match `100_u32` because `..` is an exclusive range
  |     help: use an inclusive range instead: `0_u32..=100_u32`
5 |     101..1000 =&gt; { println!("large"); }
  |     --------- this could appear to continue range `0_u32..100_u32`, but `100_u32` isn't matched by either of them
  |
  = note: `#[warn(non_contiguous_range_endpoints)]` on by default

</code></pre>
<h3 id="explanation-65"><a class="header" href="#explanation-65">Explanation</a></h3>
<p>It is likely a mistake to have range patterns in a match expression that miss out a single
number. Check that the beginning and end values are what you expect, and keep in mind that
with <code>..=</code> the right bound is inclusive, and with <code>..</code> it is exclusive.</p>
<h2 id="non-fmt-panics"><a class="header" href="#non-fmt-panics">non-fmt-panics</a></h2>
<p>The <code>non_fmt_panics</code> lint detects <code>panic!(..)</code> invocations where the first
argument is not a formatting string.</p>
<h3 id="example-66"><a class="header" href="#example-66">Example</a></h3>
<pre><code class="language-rust no_run edition2018">panic!("{}");
panic!(123);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: panic message contains an unused formatting placeholder
 --&gt; lint_example.rs:2:9
  |
2 | panic!("{}");
  |         ^^
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&gt;
  = note: this message is not used as a format string when given without arguments, but will be in Rust 2021
  = note: `#[warn(non_fmt_panics)]` (part of `#[warn(rust_2021_compatibility)]`) on by default
help: add the missing argument
  |
2 | panic!("{}", ...);
  |            +++++
help: or add a "{}" format string to use the message literally
  |
2 | panic!("{}", "{}");
  |        +++++


warning: panic message is not a string literal
 --&gt; lint_example.rs:3:8
  |
3 | panic!(123);
  |        ^^^
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&gt;
  = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&gt;
help: add a "{}" format string to `Display` the message
  |
3 | panic!("{}", 123);
  |        +++++
help: or use std::panic::panic_any instead
  |
3 - panic!(123);
3 + std::panic::panic_any(123);
  |

</code></pre>
<h3 id="explanation-66"><a class="header" href="#explanation-66">Explanation</a></h3>
<p>In Rust 2018 and earlier, <code>panic!(x)</code> directly uses <code>x</code> as the message.
That means that <code>panic!("{}")</code> panics with the message <code>"{}"</code> instead
of using it as a formatting string, and <code>panic!(123)</code> will panic with
an <code>i32</code> as message.</p>
<p>Rust 2021 always interprets the first argument as format string.</p>
<h2 id="non-local-definitions"><a class="header" href="#non-local-definitions">non-local-definitions</a></h2>
<p>The <code>non_local_definitions</code> lint checks for <code>impl</code> blocks and <code>#[macro_export]</code>
macro inside bodies (functions, enum discriminant, …).</p>
<h3 id="example-67"><a class="header" href="#example-67">Example</a></h3>
<pre><code class="language-rust">#![warn(non_local_definitions)]
trait MyTrait {}
struct MyStruct;

fn foo() {
    impl MyTrait for MyStruct {}
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: non-local `impl` definition, `impl` blocks should be written at the same level as their item
 --&gt; lint_example.rs:7:5
  |
6 | fn foo() {
  | -------- move the `impl` block outside of this function `foo` and up 2 bodies
7 |     impl MyTrait for MyStruct {}
  |     ^^^^^-------^^^^^--------
  |          |           |
  |          |           `MyStruct` is not local
  |          `MyTrait` is not local
  |
  = note: an `impl` is never scoped, even when it is nested inside an item, as it may impact type checking outside of that item, which can be the case if neither the trait or the self type are at the same nesting level as the `impl`
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(non_local_definitions)]
  |         ^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-67"><a class="header" href="#explanation-67">Explanation</a></h3>
<p>Creating non-local definitions go against expectation and can create discrepancies
in tooling. It should be avoided. It may become deny-by-default in edition 2024
and higher, see the tracking issue <a href="https://github.com/rust-lang/rust/issues/120363">https://github.com/rust-lang/rust/issues/120363</a>.</p>
<p>An <code>impl</code> definition is non-local if it is nested inside an item and neither
the type nor the trait are at the same nesting level as the <code>impl</code> block.</p>
<p>All nested bodies (functions, enum discriminant, array length, consts) (expect for
<code>const _: Ty = { ... }</code> in top-level module, which is still undecided) are checked.</p>
<h2 id="non-shorthand-field-patterns"><a class="header" href="#non-shorthand-field-patterns">non-shorthand-field-patterns</a></h2>
<p>The <code>non_shorthand_field_patterns</code> lint detects using <code>Struct { x: x }</code>
instead of <code>Struct { x }</code> in a pattern.</p>
<h3 id="example-68"><a class="header" href="#example-68">Example</a></h3>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}


fn main() {
    let p = Point {
        x: 5,
        y: 5,
    };

    match p {
        Point { x: x, y: y } =&gt; (),
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the `x:` in this pattern is redundant
  --&gt; lint_example.rs:14:17
   |
14 |         Point { x: x, y: y } =&gt; (),
   |                 ^^^^ help: use shorthand field pattern: `x`
   |
   = note: `#[warn(non_shorthand_field_patterns)]` on by default


warning: the `y:` in this pattern is redundant
  --&gt; lint_example.rs:14:23
   |
14 |         Point { x: x, y: y } =&gt; (),
   |                       ^^^^ help: use shorthand field pattern: `y`

</code></pre>
<h3 id="explanation-68"><a class="header" href="#explanation-68">Explanation</a></h3>
<p>The preferred style is to avoid the repetition of specifying both the
field name and the binding name if both identifiers are the same.</p>
<h2 id="non-snake-case"><a class="header" href="#non-snake-case">non-snake-case</a></h2>
<p>The <code>non_snake_case</code> lint detects variables, methods, functions,
lifetime parameters and modules that don’t have snake case names.</p>
<h3 id="example-69"><a class="header" href="#example-69">Example</a></h3>
<pre><code class="language-rust">let MY_VALUE = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable `MY_VALUE` should have a snake case name
 --&gt; lint_example.rs:2:5
  |
2 | let MY_VALUE = 5;
  |     ^^^^^^^^ help: convert the identifier to snake case: `my_value`
  |
  = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

</code></pre>
<h3 id="explanation-69"><a class="header" href="#explanation-69">Explanation</a></h3>
<p>The preferred style for these identifiers is to use “snake case”,
where all the characters are in lowercase, with words separated with a
single underscore, such as <code>my_value</code>.</p>
<h2 id="non-upper-case-globals"><a class="header" href="#non-upper-case-globals">non-upper-case-globals</a></h2>
<p>The <code>non_upper_case_globals</code> lint detects static items that don’t have
uppercase identifiers.</p>
<h3 id="example-70"><a class="header" href="#example-70">Example</a></h3>
<pre><code class="language-rust">static max_points: i32 = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static variable `max_points` should have an upper case name
 --&gt; lint_example.rs:2:8
  |
2 | static max_points: i32 = 5;
  |        ^^^^^^^^^^ help: convert the identifier to upper case: `MAX_POINTS`
  |
  = note: `#[warn(non_upper_case_globals)]` (part of `#[warn(nonstandard_style)]`) on by default

</code></pre>
<h3 id="explanation-70"><a class="header" href="#explanation-70">Explanation</a></h3>
<p>The preferred style is for static item names to use all uppercase
letters such as <code>MAX_POINTS</code>.</p>
<h2 id="noop-method-call"><a class="header" href="#noop-method-call">noop-method-call</a></h2>
<p>The <code>noop_method_call</code> lint detects specific calls to noop methods
such as a calling <code>&lt;&amp;T as Clone&gt;::clone</code> where <code>T: !Clone</code>.</p>
<h3 id="example-71"><a class="header" href="#example-71">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>struct Foo;
let foo = &amp;Foo;
let clone: &amp;Foo = foo.clone();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: call to `.clone()` on a reference in this situation does nothing
 --&gt; lint_example.rs:5:22
  |
5 | let clone: &amp;Foo = foo.clone();
  |                      ^^^^^^^^
  |
  = note: the type `Foo` does not implement `Clone`, so calling `clone` on `&amp;Foo` copies the reference, which does not do anything and can be removed
  = note: `#[warn(noop_method_call)]` on by default
help: remove this redundant call
  |
5 - let clone: &amp;Foo = foo.clone();
5 + let clone: &amp;Foo = foo;
  |
help: if you meant to clone `Foo`, implement `Clone` for it
  |
3 + #[derive(Clone)]
4 | struct Foo;
  |

</code></pre>
<h3 id="explanation-71"><a class="header" href="#explanation-71">Explanation</a></h3>
<p>Some method calls are noops meaning that they do nothing. Usually such methods
are the result of blanket implementations that happen to create some method invocations
that end up not doing anything. For instance, <code>Clone</code> is implemented on all <code>&amp;T</code>, but
calling <code>clone</code> on a <code>&amp;T</code> where <code>T</code> does not implement clone, actually doesn’t do anything
as references are copy. This lint detects these calls and warns the user about them.</p>
<h2 id="opaque-hidden-inferred-bound"><a class="header" href="#opaque-hidden-inferred-bound">opaque-hidden-inferred-bound</a></h2>
<p>The <code>opaque_hidden_inferred_bound</code> lint detects cases in which nested
<code>impl Trait</code> in associated type bounds are not written generally enough
to satisfy the bounds of the associated type.</p>
<h3 id="explanation-72"><a class="header" href="#explanation-72">Explanation</a></h3>
<p>This functionality was removed in #97346, but then rolled back in #99860
because it caused regressions.</p>
<p>We plan on reintroducing this as a hard error, but in the meantime,
this lint serves to warn and suggest fixes for any use-cases which rely
on this behavior.</p>
<h3 id="example-72"><a class="header" href="#example-72">Example</a></h3>
<pre><code class="language-rust">#![feature(type_alias_impl_trait)]

trait Duh {}

impl Duh for i32 {}

trait Trait {
    type Assoc: Duh;
}

impl&lt;F: Duh&gt; Trait for F {
    type Assoc = F;
}

type Tait = impl Sized;

#[define_opaque(Tait)]
fn test() -&gt; impl Trait&lt;Assoc = Tait&gt; {
    42
}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: opaque type `impl Trait&lt;Assoc = Tait&gt;` does not satisfy its associated type bounds
  --&gt; lint_example.rs:18:25
   |
 8 |     type Assoc: Duh;
   |                 --- this associated type bound is unsatisfied for `Tait`
...
18 | fn test() -&gt; impl Trait&lt;Assoc = Tait&gt; {
   |                         ^^^^^^^^^^^^
   |
   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default

</code></pre>
<p>In this example, <code>test</code> declares that the associated type <code>Assoc</code> for
<code>impl Trait</code> is <code>impl Sized</code>, which does not satisfy the bound <code>Duh</code>
on the associated type.</p>
<p>Although the hidden type, <code>i32</code> does satisfy this bound, we do not
consider the return type to be well-formed with this lint. It can be
fixed by changing <code>Tait = impl Sized</code> into <code>Tait = impl Sized + Duh</code>.</p>
<h2 id="overlapping-patterns"><a class="header" href="#overlapping-patterns">overlapping-patterns</a></h2>
<p>The lint <code>overlapping-patterns</code> has been renamed to <a href="#overlapping-range-endpoints"><code>overlapping-range-endpoints</code></a>.</p>
<h2 id="overlapping-range-endpoints"><a class="header" href="#overlapping-range-endpoints">overlapping-range-endpoints</a></h2>
<p>The <code>overlapping_range_endpoints</code> lint detects <code>match</code> arms that have <a href="https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns">range patterns</a> that
overlap on their endpoints.</p>
<h3 id="example-73"><a class="header" href="#example-73">Example</a></h3>
<pre><code class="language-rust">let x = 123u8;
match x {
    0..=100 =&gt; { println!("small"); }
    100..=255 =&gt; { println!("large"); }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: multiple patterns overlap on their endpoints
 --&gt; lint_example.rs:5:5
  |
4 |     0..=100 =&gt; { println!("small"); }
  |     ------- this range overlaps on `100_u8`...
5 |     100..=255 =&gt; { println!("large"); }
  |     ^^^^^^^^^ ... with this range
  |
  = note: you likely meant to write mutually exclusive ranges
  = note: `#[warn(overlapping_range_endpoints)]` on by default

</code></pre>
<h3 id="explanation-73"><a class="header" href="#explanation-73">Explanation</a></h3>
<p>It is likely a mistake to have range patterns in a match expression that overlap in this
way. Check that the beginning and end values are what you expect, and keep in mind that
with <code>..=</code> the left and right bounds are inclusive.</p>
<h2 id="path-statements"><a class="header" href="#path-statements">path-statements</a></h2>
<p>The <code>path_statements</code> lint detects path statements with no effect.</p>
<h3 id="example-74"><a class="header" href="#example-74">Example</a></h3>
<pre><code class="language-rust">let x = 42;

x;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: path statement with no effect
 --&gt; lint_example.rs:4:1
  |
4 | x;
  | ^^
  |
  = note: `#[warn(path_statements)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-74"><a class="header" href="#explanation-74">Explanation</a></h3>
<p>It is usually a mistake to have a statement that has no effect.</p>
<h2 id="private-bounds"><a class="header" href="#private-bounds">private-bounds</a></h2>
<p>The <code>private_bounds</code> lint detects types in a secondary interface of an item,
that are more private than the item itself. Secondary interface of an item consists of
bounds on generic parameters and where clauses, including supertraits for trait items.</p>
<h3 id="example-75"><a class="header" href="#example-75">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(private_bounds)]

struct PrivTy;
pub struct S
    where PrivTy:
{}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type `PrivTy` is more private than the item `S`
 --&gt; lint_example.rs:5:1
  |
5 | pub struct S
  | ^^^^^^^^^^^^ struct `S` is reachable at visibility `pub`
  |
note: but type `PrivTy` is only usable at visibility `pub(crate)`
 --&gt; lint_example.rs:4:1
  |
4 | struct PrivTy;
  | ^^^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(private_bounds)]
  |         ^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-75"><a class="header" href="#explanation-75">Explanation</a></h3>
<p>Having private types or traits in item bounds makes it less clear what interface
the item actually provides.</p>
<h2 id="private-interfaces"><a class="header" href="#private-interfaces">private-interfaces</a></h2>
<p>The <code>private_interfaces</code> lint detects types in a primary interface of an item,
that are more private than the item itself. Primary interface of an item is all
its interface except for bounds on generic parameters and where clauses.</p>
<h3 id="example-76"><a class="header" href="#example-76">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(private_interfaces)]
struct SemiPriv;

mod m1 {
    struct Priv;
    impl crate::SemiPriv {
        pub fn f(_: Priv) {}
    }
}

<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type `Priv` is more private than the item `m1::&lt;impl SemiPriv&gt;::f`
 --&gt; lint_example.rs:8:9
  |
8 |         pub fn f(_: Priv) {}
  |         ^^^^^^^^^^^^^^^^^ associated function `m1::&lt;impl SemiPriv&gt;::f` is reachable at visibility `pub(crate)`
  |
note: but type `Priv` is only usable at visibility `pub(self)`
 --&gt; lint_example.rs:6:5
  |
6 |     struct Priv;
  |     ^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(private_interfaces)]
  |         ^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-76"><a class="header" href="#explanation-76">Explanation</a></h3>
<p>Having something private in primary interface guarantees that
the item will be unusable from outer modules due to type privacy.</p>
<h2 id="ptr-to-integer-transmute-in-consts"><a class="header" href="#ptr-to-integer-transmute-in-consts">ptr-to-integer-transmute-in-consts</a></h2>
<p>The <code>ptr_to_integer_transmute_in_consts</code> lint detects pointer to integer
transmute in const functions and associated constants.</p>
<h3 id="example-77"><a class="header" href="#example-77">Example</a></h3>
<pre><code class="language-rust">const fn foo(ptr: *const u8) -&gt; usize {
   unsafe {
       std::mem::transmute::&lt;*const u8, usize&gt;(ptr)
   }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: pointers cannot be transmuted to integers during const eval
 --&gt; lint_example.rs:4:8
  |
4 |        std::mem::transmute::&lt;*const u8, usize&gt;(ptr)
  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: at compile-time, pointers do not have an integer value
  = note: avoiding this restriction via `union` or raw pointers leads to compile-time undefined behavior
  = help: for more information, see https://doc.rust-lang.org/std/mem/fn.transmute.html
  = note: `#[warn(ptr_to_integer_transmute_in_consts)]` on by default

</code></pre>
<h3 id="explanation-77"><a class="header" href="#explanation-77">Explanation</a></h3>
<p>Transmuting pointers to integers in a <code>const</code> context is undefined behavior.
Any attempt to use the resulting integer will abort const-evaluation.</p>
<p>But sometimes the compiler might not emit an error for pointer to integer transmutes
inside const functions and associated consts because they are evaluated only when referenced.
Therefore, this lint serves as an extra layer of defense to prevent any undefined behavior
from compiling without any warnings or errors.</p>
<p>See <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html">std::mem::transmute</a> in the reference for more details.</p>
<h2 id="redundant-semicolon"><a class="header" href="#redundant-semicolon">redundant-semicolon</a></h2>
<p>The lint <code>redundant-semicolon</code> has been renamed to <a href="#redundant-semicolons"><code>redundant-semicolons</code></a>.</p>
<h2 id="redundant-semicolons"><a class="header" href="#redundant-semicolons">redundant-semicolons</a></h2>
<p>The <code>redundant_semicolons</code> lint detects unnecessary trailing
semicolons.</p>
<h3 id="example-78"><a class="header" href="#example-78">Example</a></h3>
<pre><code class="language-rust">let _ = 123;;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary trailing semicolon
 --&gt; lint_example.rs:2:13
  |
2 | let _ = 123;;
  |             ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-78"><a class="header" href="#explanation-78">Explanation</a></h3>
<p>Extra semicolons are not needed, and may be removed to avoid confusion
and visual clutter.</p>
<h2 id="refining-impl-trait-internal"><a class="header" href="#refining-impl-trait-internal">refining-impl-trait-internal</a></h2>
<p>The <code>refining_impl_trait_internal</code> lint detects <code>impl Trait</code> return
types in method signatures that are refined by a trait implementation,
meaning the implementation adds information about the return type that
is not present in the trait.</p>
<h3 id="example-79"><a class="header" href="#example-79">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(refining_impl_trait)]

use std::fmt::Display;

trait AsDisplay {
    fn as_display(&amp;self) -&gt; impl Display;
}

impl&lt;'s&gt; AsDisplay for &amp;'s str {
    fn as_display(&amp;self) -&gt; Self {
        *self
    }
}

fn main() {
    // users can observe that the return type of
    // `&lt;&amp;str as AsDisplay&gt;::as_display()` is `&amp;str`.
    let _x: &amp;str = "".as_display();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: impl trait in impl method signature does not match trait method signature
  --&gt; lint_example.rs:10:29
   |
 6 |     fn as_display(&amp;self) -&gt; impl Display;
   |                             ------------ return type from trait method defined here
...
10 |     fn as_display(&amp;self) -&gt; Self {
   |                             ^^^^
   |
   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate
   = note: we are soliciting feedback, see issue #121718 &lt;https://github.com/rust-lang/rust/issues/121718&gt; for more information
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(refining_impl_trait)]
   |         ^^^^^^^^^^^^^^^^^^^
   = note: `#[deny(refining_impl_trait_internal)]` implied by `#[deny(refining_impl_trait)]`
help: replace the return type so that it matches the trait
   |
10 -     fn as_display(&amp;self) -&gt; Self {
10 +     fn as_display(&amp;self) -&gt; impl std::fmt::Display {
   |

</code></pre>
<h3 id="explanation-79"><a class="header" href="#explanation-79">Explanation</a></h3>
<p>Callers of methods for types where the implementation is known are
able to observe the types written in the impl signature. This may be
intended behavior, but may also lead to implementation details being
revealed unintentionally. In particular, it may pose a semver hazard
for authors of libraries who do not wish to make stronger guarantees
about the types than what is written in the trait signature.</p>
<p><code>refining_impl_trait</code> is a lint group composed of two lints:</p>
<ul>
<li><code>refining_impl_trait_reachable</code>, for refinements that are publically
reachable outside a crate, and</li>
<li><code>refining_impl_trait_internal</code>, for refinements that are only visible
within a crate.</li>
</ul>
<p>We are seeking feedback on each of these lints; see issue
<a href="https://github.com/rust-lang/rust/issues/121718">#121718</a> for more
information.</p>
<h2 id="refining-impl-trait-reachable"><a class="header" href="#refining-impl-trait-reachable">refining-impl-trait-reachable</a></h2>
<p>The <code>refining_impl_trait_reachable</code> lint detects <code>impl Trait</code> return
types in method signatures that are refined by a publically reachable
trait implementation, meaning the implementation adds information about
the return type that is not present in the trait.</p>
<h3 id="example-80"><a class="header" href="#example-80">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(refining_impl_trait)]

use std::fmt::Display;

pub trait AsDisplay {
    fn as_display(&amp;self) -&gt; impl Display;
}

impl&lt;'s&gt; AsDisplay for &amp;'s str {
    fn as_display(&amp;self) -&gt; Self {
        *self
    }
}

fn main() {
    // users can observe that the return type of
    // `&lt;&amp;str as AsDisplay&gt;::as_display()` is `&amp;str`.
    let _x: &amp;str = "".as_display();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: impl trait in impl method signature does not match trait method signature
  --&gt; lint_example.rs:10:29
   |
 6 |     fn as_display(&amp;self) -&gt; impl Display;
   |                             ------------ return type from trait method defined here
...
10 |     fn as_display(&amp;self) -&gt; Self {
   |                             ^^^^
   |
   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate
   = note: we are soliciting feedback, see issue #121718 &lt;https://github.com/rust-lang/rust/issues/121718&gt; for more information
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(refining_impl_trait)]
   |         ^^^^^^^^^^^^^^^^^^^
   = note: `#[deny(refining_impl_trait_reachable)]` implied by `#[deny(refining_impl_trait)]`
help: replace the return type so that it matches the trait
   |
10 -     fn as_display(&amp;self) -&gt; Self {
10 +     fn as_display(&amp;self) -&gt; impl std::fmt::Display {
   |

</code></pre>
<h3 id="explanation-80"><a class="header" href="#explanation-80">Explanation</a></h3>
<p>Callers of methods for types where the implementation is known are
able to observe the types written in the impl signature. This may be
intended behavior, but may also lead to implementation details being
revealed unintentionally. In particular, it may pose a semver hazard
for authors of libraries who do not wish to make stronger guarantees
about the types than what is written in the trait signature.</p>
<p><code>refining_impl_trait</code> is a lint group composed of two lints:</p>
<ul>
<li><code>refining_impl_trait_reachable</code>, for refinements that are publically
reachable outside a crate, and</li>
<li><code>refining_impl_trait_internal</code>, for refinements that are only visible
within a crate.</li>
</ul>
<p>We are seeking feedback on each of these lints; see issue
<a href="https://github.com/rust-lang/rust/issues/121718">#121718</a> for more
information.</p>
<h2 id="renamed-and-removed-lints"><a class="header" href="#renamed-and-removed-lints">renamed-and-removed-lints</a></h2>
<p>The <code>renamed_and_removed_lints</code> lint detects lints that have been
renamed or removed.</p>
<h3 id="example-81"><a class="header" href="#example-81">Example</a></h3>
<pre><code class="language-rust">#![deny(raw_pointer_derive)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: lint `raw_pointer_derive` has been removed: using derive with raw pointers is ok
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(raw_pointer_derive)]
  |         ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(renamed_and_removed_lints)]` on by default

</code></pre>
<h3 id="explanation-81"><a class="header" href="#explanation-81">Explanation</a></h3>
<p>To fix this, either remove the lint or use the new name. This can help
avoid confusion about lints that are no longer valid, and help
maintain consistency for renamed lints.</p>
<h2 id="repr-c-enums-larger-than-int"><a class="header" href="#repr-c-enums-larger-than-int">repr-c-enums-larger-than-int</a></h2>
<p>The <code>repr_c_enums_larger_than_int</code> lint detects <code>repr(C)</code> enums with discriminant
values that do not fit into a C <code>int</code> or <code>unsigned int</code>.</p>
<h3 id="example-82"><a class="header" href="#example-82">Example</a></h3>
<pre><code class="language-rust ignore (only errors on 64bit)">#[repr(C)]
enum E {
    V = 9223372036854775807, // i64::MAX
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `repr(C)` enum discriminant does not fit into C `int` nor into C `unsigned int`
  --&gt; $DIR/repr-c-big-discriminant1.rs:16:5
   |
LL |     A = 9223372036854775807, // i64::MAX
   |     ^
   |
   = note: `repr(C)` enums with big discriminants are non-portable, and their size in Rust might not match their size in C
   = help: use `repr($int_ty)` instead to explicitly set the size of this enum
</code></pre>
<h3 id="explanation-82"><a class="header" href="#explanation-82">Explanation</a></h3>
<p>In C, enums with discriminants that do not all fit into an <code>int</code> or all fit into an
<code>unsigned int</code> are a portability hazard: such enums are only permitted since C23, and not
supported e.g. by MSVC.</p>
<p>Furthermore, Rust interprets the discriminant values of <code>repr(C)</code> enums as expressions of
type <code>isize</code>. This makes it impossible to implement the C23 behavior of enums where the enum
discriminants have no predefined type and instead the enum uses a type large enough to hold
all discriminants.</p>
<p>Therefore, <code>repr(C)</code> enums in Rust require that either all discriminants to fit into a C
<code>int</code> or they all fit into an <code>unsigned int</code>.</p>
<h2 id="rtsan-nonblocking-async"><a class="header" href="#rtsan-nonblocking-async">rtsan-nonblocking-async</a></h2>
<p>The <code>rtsan_nonblocking_async</code> lint detects incompatible use of
<a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[sanitize(realtime = "nonblocking")]</code></a> on async functions.</p>
<h3 id="example-83"><a class="header" href="#example-83">Example</a></h3>
<pre><code class="language-rust no_run">#![feature(sanitize)]

#[sanitize(realtime = "nonblocking")]
async fn x() {}

fn main() {
    x();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the async executor can run blocking code, without realtime sanitizer catching it
 --&gt; lint_example.rs:3:1
  |
3 | #[sanitize(realtime = "nonblocking")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(rtsan_nonblocking_async)]` on by default

</code></pre>
<h3 id="explanation-83"><a class="header" href="#explanation-83">Explanation</a></h3>
<p>The sanitizer only considers the async function body nonblocking. The executor, which runs on
every <code>.await</code> point can run non-realtime code, without the sanitizer catching it.</p>
<h2 id="self-constructor-from-outer-item"><a class="header" href="#self-constructor-from-outer-item">self-constructor-from-outer-item</a></h2>
<p>The <code>self_constructor_from_outer_item</code> lint detects cases where the <code>Self</code> constructor
was silently allowed due to a bug in the resolver, and which may produce surprising
and unintended behavior.</p>
<p>Using a <code>Self</code> type alias from an outer item was never intended, but was silently allowed.
This is deprecated – and is a hard error when the <code>Self</code> type alias references generics
that are not in scope.</p>
<h3 id="example-84"><a class="header" href="#example-84">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(self_constructor_from_outer_item)]

struct S0(usize);

impl S0 {
    fn foo() {
        const C: S0 = Self(0);
        fn bar() -&gt; S0 {
            Self(0)
        }
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: can't reference `Self` constructor from outer item
 --&gt; lint_example.rs:8:23
  |
6 | impl S0 {
  | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference
7 |     fn foo() {
8 |         const C: S0 = Self(0);
  |               -       ^^^^ help: replace `Self` with the actual type: `S0`
  |               |
  |               `Self` used in this inner item
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #124186 &lt;https://github.com/rust-lang/rust/issues/124186&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(self_constructor_from_outer_item)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error: can't reference `Self` constructor from outer item
  --&gt; lint_example.rs:10:13
   |
 6 | impl S0 {
   | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference
...
 9 |         fn bar() -&gt; S0 {
   |            --- `Self` used in this inner item
10 |             Self(0)
   |             ^^^^ help: replace `Self` with the actual type: `S0`
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #124186 &lt;https://github.com/rust-lang/rust/issues/124186&gt;

</code></pre>
<h3 id="explanation-84"><a class="header" href="#explanation-84">Explanation</a></h3>
<p>The <code>Self</code> type alias should not be reachable because nested items are not associated with
the scope of the parameters from the parent item.</p>
<h2 id="special-module-name"><a class="header" href="#special-module-name">special-module-name</a></h2>
<p>The <code>special_module_name</code> lint detects module
declarations for files that have a special meaning.</p>
<h3 id="example-85"><a class="header" href="#example-85">Example</a></h3>
<pre><code class="language-rust compile_fail">mod lib;

fn main() {
    lib::run();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: found module declaration for lib.rs
 --&gt; lint_example.rs:1:1
  |
1 | mod lib;
  | ^^^^^^^^
  |
  = note: lib.rs is the root of this crate's library target
  = help: to refer to it from other targets, use the library's name as the path
  = note: `#[warn(special_module_name)]` on by default

</code></pre>
<h3 id="explanation-85"><a class="header" href="#explanation-85">Explanation</a></h3>
<p>Cargo recognizes <code>lib.rs</code> and <code>main.rs</code> as the root of a
library or binary crate, so declaring them as modules
will lead to miscompilation of the crate unless configured
explicitly.</p>
<p>To access a library from a binary target within the same crate,
use <code>your_crate_name::</code> as the path instead of <code>lib::</code>:</p>
<pre><code class="language-rust compile_fail">// bar/src/lib.rs
fn run() {
    // ...
}

// bar/src/main.rs
fn main() {
    bar::run();
}</code></pre>
<p>Binary targets cannot be used as libraries and so declaring
one as a module is not allowed.</p>
<h2 id="stable-features"><a class="header" href="#stable-features">stable-features</a></h2>
<p>The <code>stable_features</code> lint detects a <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that
has since been made stable.</p>
<h3 id="example-86"><a class="header" href="#example-86">Example</a></h3>
<pre><code class="language-rust">#![feature(test_accepted_feature)]
fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `test_accepted_feature` has been stable since 1.0.0 and no longer requires an attribute to enable
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(test_accepted_feature)]
  |            ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(stable_features)]` on by default

</code></pre>
<h3 id="explanation-86"><a class="header" href="#explanation-86">Explanation</a></h3>
<p>When a feature is stabilized, it is no longer necessary to include a
<code>#![feature]</code> attribute for it. To fix, simply remove the
<code>#![feature]</code> attribute.</p>
<h2 id="static-mut-ref"><a class="header" href="#static-mut-ref">static-mut-ref</a></h2>
<p>The lint <code>static-mut-ref</code> has been renamed to <a href="#static-mut-refs"><code>static-mut-refs</code></a>.</p>
<h2 id="static-mut-refs"><a class="header" href="#static-mut-refs">static-mut-refs</a></h2>
<p>The <code>static_mut_refs</code> lint checks for shared or mutable references
of mutable static inside <code>unsafe</code> blocks and <code>unsafe</code> functions.</p>
<h3 id="example-87"><a class="header" href="#example-87">Example</a></h3>
<pre><code class="language-rust edition2021">fn main() {
    static mut X: i32 = 23;
    static mut Y: i32 = 24;

    unsafe {
        let y = &amp;X;
        let ref x = X;
        let (x, y) = (&amp;X, &amp;Y);
        foo(&amp;X);
    }
}

unsafe fn _foo() {
    static mut X: i32 = 23;
    static mut Y: i32 = 24;

    let y = &amp;X;
    let ref x = X;
    let (x, y) = (&amp;X, &amp;Y);
    foo(&amp;X);
}

fn foo&lt;'a&gt;(_x: &amp;'a i32) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:6:17
  |
6 |         let y = &amp;X;
  |                 ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
  = note: `#[warn(static_mut_refs)]` (part of `#[warn(rust_2024_compatibility)]`) on by default
help: use `&amp;raw const` instead to create a raw pointer
  |
6 |         let y = &amp;raw const X;
  |                  +++++++++


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:7:21
  |
7 |         let ref x = X;
  |                     ^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:8:23
  |
8 |         let (x, y) = (&amp;X, &amp;Y);
  |                       ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
  |
8 |         let (x, y) = (&amp;raw const X, &amp;Y);
  |                        +++++++++


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:8:27
  |
8 |         let (x, y) = (&amp;X, &amp;Y);
  |                           ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
  |
8 |         let (x, y) = (&amp;X, &amp;raw const Y);
  |                            +++++++++


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:9:13
  |
9 |         foo(&amp;X);
  |             ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
  |
9 |         foo(&amp;raw const X);
  |              +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:17:13
   |
17 |     let y = &amp;X;
   |             ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
17 |     let y = &amp;raw const X;
   |              +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:18:17
   |
18 |     let ref x = X;
   |                 ^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:19:19
   |
19 |     let (x, y) = (&amp;X, &amp;Y);
   |                   ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
19 |     let (x, y) = (&amp;raw const X, &amp;Y);
   |                    +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:19:23
   |
19 |     let (x, y) = (&amp;X, &amp;Y);
   |                       ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
19 |     let (x, y) = (&amp;X, &amp;raw const Y);
   |                        +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:20:9
   |
20 |     foo(&amp;X);
   |         ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
20 |     foo(&amp;raw const X);
   |          +++++++++

</code></pre>
<h3 id="explanation-87"><a class="header" href="#explanation-87">Explanation</a></h3>
<p>Shared or mutable references of mutable static are almost always a mistake and
can lead to undefined behavior and various other problems in your code.</p>
<p>This lint is “warn” by default on editions up to 2021, in 2024 is “deny”.</p>
<h2 id="suspicious-double-ref-op"><a class="header" href="#suspicious-double-ref-op">suspicious-double-ref-op</a></h2>
<p>The <code>suspicious_double_ref_op</code> lint checks for usage of <code>.clone()</code>/<code>.borrow()</code>/<code>.deref()</code>
on an <code>&amp;&amp;T</code> when <code>T: !Deref/Borrow/Clone</code>, which means the call will return the inner <code>&amp;T</code>,
instead of performing the operation on the underlying <code>T</code> and can be confusing.</p>
<h3 id="example-88"><a class="header" href="#example-88">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>struct Foo;
let foo = &amp;&amp;Foo;
let clone: &amp;Foo = foo.clone();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: using `.clone()` on a double reference, which returns `&amp;Foo` instead of cloning the inner type
 --&gt; lint_example.rs:5:22
  |
5 | let clone: &amp;Foo = foo.clone();
  |                      ^^^^^^^^
  |
  = note: `#[warn(suspicious_double_ref_op)]` on by default

</code></pre>
<h3 id="explanation-88"><a class="header" href="#explanation-88">Explanation</a></h3>
<p>Since <code>Foo</code> doesn’t implement <code>Clone</code>, running <code>.clone()</code> only dereferences the double
reference, instead of cloning the inner type which should be what was intended.</p>
<h2 id="tail-call-track-caller"><a class="header" href="#tail-call-track-caller">tail-call-track-caller</a></h2>
<p>The <code>tail_call_track_caller</code> lint detects usage of <code>become</code> attempting to tail call
a function marked with <code>#[track_caller]</code>.</p>
<h3 id="example-89"><a class="header" href="#example-89">Example</a></h3>
<pre><code class="language-rust">#![feature(explicit_tail_calls)]
#![expect(incomplete_features)]

#[track_caller]
fn f() {}

fn g() {
    become f();
}

g();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: tail calling a function marked with `#[track_caller]` has no special effect
 --&gt; lint_example.rs:9:12
  |
9 |     become f();
  |            ^^^
  |
  = note: `#[warn(tail_call_track_caller)]` on by default

</code></pre>
<h3 id="explanation-89"><a class="header" href="#explanation-89">Explanation</a></h3>
<p>Due to implementation details of tail calls and <code>#[track_caller]</code> attribute, calls to
functions marked with <code>#[track_caller]</code> cannot become tail calls. As such using <code>become</code>
is no different than a normal call (except for changes in drop order).</p>
<h2 id="trivial-bounds"><a class="header" href="#trivial-bounds">trivial-bounds</a></h2>
<p>The <code>trivial_bounds</code> lint detects trait bounds that don’t depend on
any type parameters.</p>
<h3 id="example-90"><a class="header" href="#example-90">Example</a></h3>
<pre><code class="language-rust">#![feature(trivial_bounds)]
pub struct A where i32: Copy;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: trait bound i32: Copy does not depend on any type or lifetime parameters
 --&gt; lint_example.rs:3:25
  |
3 | pub struct A where i32: Copy;
  |                         ^^^^
  |
  = note: `#[warn(trivial_bounds)]` on by default

</code></pre>
<h3 id="explanation-90"><a class="header" href="#explanation-90">Explanation</a></h3>
<p>Usually you would not write a trait bound that you know is always
true, or never true. However, when using macros, the macro may not
know whether or not the constraint would hold or not at the time when
generating the code. Currently, the compiler does not alert you if the
constraint is always true, and generates an error if it is never true.
The <code>trivial_bounds</code> feature changes this to be a warning in both
cases, giving macros more freedom and flexibility to generate code,
while still providing a signal when writing non-macro code that
something is amiss.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2056-allow-trivial-where-clause-constraints.md">RFC 2056</a> for more details. This feature is currently only
available on the nightly channel, see <a href="https://github.com/rust-lang/rust/issues/48214">tracking issue #48214</a>.</p>
<h2 id="type-alias-bounds"><a class="header" href="#type-alias-bounds">type-alias-bounds</a></h2>
<p>The <code>type_alias_bounds</code> lint detects bounds in type aliases.</p>
<h3 id="example-91"><a class="header" href="#example-91">Example</a></h3>
<pre><code class="language-rust">type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: bounds on generic parameters in type aliases are not enforced
 --&gt; lint_example.rs:2:17
  |
2 | type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;
  |               --^^^^
  |               | |
  |               | will not be checked at usage sites of the type alias
  |               help: remove this bound
  |
  = note: this is a known limitation of the type checker that may be lifted in a future edition.
          see issue #112792 &lt;https://github.com/rust-lang/rust/issues/112792&gt; for more information
  = help: add `#![feature(lazy_type_alias)]` to the crate attributes to enable the desired semantics
  = note: `#[warn(type_alias_bounds)]` on by default

</code></pre>
<h3 id="explanation-91"><a class="header" href="#explanation-91">Explanation</a></h3>
<p>Trait and lifetime bounds on generic parameters and in where clauses of
type aliases are not checked at usage sites of the type alias. Moreover,
they are not thoroughly checked for correctness at their definition site
either similar to the aliased type.</p>
<p>This is a known limitation of the type checker that may be lifted in a
future edition. Permitting such bounds in light of this was unintentional.</p>
<p>While these bounds may have secondary effects such as enabling the use of
“shorthand” associated type paths<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> and affecting the default trait
object lifetime<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> of trait object types passed to the type alias, this
should not have been allowed until the aforementioned restrictions of the
type checker have been lifted.</p>
<p>Using such bounds is highly discouraged as they are actively misleading.</p>
<h2 id="tyvar-behind-raw-pointer"><a class="header" href="#tyvar-behind-raw-pointer">tyvar-behind-raw-pointer</a></h2>
<p>The <code>tyvar_behind_raw_pointer</code> lint detects raw pointer to an
inference variable.</p>
<h3 id="example-92"><a class="header" href="#example-92">Example</a></h3>
<pre><code class="language-rust edition2015">// edition 2015
let data = std::ptr::null();
let _ = &amp;data as *const *const ();

if data.is_null() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type annotations needed
 --&gt; lint_example.rs:6:9
  |
6 | if data.is_null() {}
  |         ^^^^^^^
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/tyvar-behind-raw-pointer.html&gt;
  = note: `#[warn(tyvar_behind_raw_pointer)]` (part of `#[warn(rust_2018_compatibility)]`) on by default

</code></pre>
<h3 id="explanation-92"><a class="header" href="#explanation-92">Explanation</a></h3>
<p>This kind of inference was previously allowed, but with the future
arrival of <a href="https://github.com/rust-lang/rust/issues/44874">arbitrary self types</a>, this can introduce ambiguity. To
resolve this, use an explicit type instead of relying on type
inference.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the 2018 edition. See <a href="https://github.com/rust-lang/rust/issues/46906">issue #46906</a> for more details. This
is currently a hard-error on the 2018 edition, and is “warn” by
default in the 2015 edition.</p>
<h2 id="uncommon-codepoints"><a class="header" href="#uncommon-codepoints">uncommon-codepoints</a></h2>
<p>The <code>uncommon_codepoints</code> lint detects uncommon Unicode codepoints in
identifiers.</p>
<h3 id="example-93"><a class="header" href="#example-93">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>const µ: f64 = 0.000001;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: identifier contains a non normalized (NFKC) character: 'µ'
 --&gt; lint_example.rs:3:7
  |
3 | const µ: f64 = 0.000001;
  |       ^
  |
  = note: this character is included in the Not_NFKC Unicode general security profile
  = note: `#[warn(uncommon_codepoints)]` on by default

</code></pre>
<h3 id="explanation-93"><a class="header" href="#explanation-93">Explanation</a></h3>
<p>This lint warns about using characters which are not commonly used, and may
cause visual confusion.</p>
<p>This lint is triggered by identifiers that contain a codepoint that is
not part of the set of “Allowed” codepoints as described by <a href="https://www.unicode.org/reports/tr39/#General_Security_Profile">Unicode®
Technical Standard #39 Unicode Security Mechanisms Section 3.1 General
Security Profile for Identifiers</a>.</p>
<p>Note that the set of uncommon codepoints may change over time. Beware
that if you “forbid” this lint that existing code may fail in the
future.</p>
<h2 id="unconditional-recursion"><a class="header" href="#unconditional-recursion">unconditional-recursion</a></h2>
<p>The <code>unconditional_recursion</code> lint detects functions that cannot
return without calling themselves.</p>
<h3 id="example-94"><a class="header" href="#example-94">Example</a></h3>
<pre><code class="language-rust">fn foo() {
    foo();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function cannot return without recursing
 --&gt; lint_example.rs:2:1
  |
2 | fn foo() {
  | ^^^^^^^^ cannot return without recursing
3 |     foo();
  |     ----- recursive call site
  |
  = help: a `loop` may express intention better if this is on purpose
  = note: `#[warn(unconditional_recursion)]` on by default

</code></pre>
<h3 id="explanation-94"><a class="header" href="#explanation-94">Explanation</a></h3>
<p>It is usually a mistake to have a recursive call that does not have
some condition to cause it to terminate. If you really intend to have
an infinite loop, using a <code>loop</code> expression is recommended.</p>
<h2 id="uncovered-param-in-projection"><a class="header" href="#uncovered-param-in-projection">uncovered-param-in-projection</a></h2>
<p>The <code>uncovered_param_in_projection</code> lint detects a violation of one of Rust’s orphan rules for
foreign trait implementations that concerns the use of type parameters inside trait associated
type paths (“projections”) whose output may not be a local type that is mistakenly considered
to “cover” said parameters which is <strong>unsound</strong> and which may be rejected by a future version
of the compiler.</p>
<p>Originally reported in <a href="https://github.com/rust-lang/rust/issues/99554">#99554</a>.</p>
<h3 id="example-95"><a class="header" href="#example-95">Example</a></h3>
<pre><code class="language-rust ignore (dependent)">// dependency.rs
#![crate_type = "lib"]

pub trait Trait&lt;T, U&gt; {}</code></pre>
<pre><code class="language-edition2021 ignore (needs dependency)">// dependent.rs
trait Identity {
    type Output;
}

impl&lt;T&gt; Identity for T {
    type Output = T;
}

struct Local;

impl&lt;T&gt; dependency::Trait&lt;Local, T&gt; for &lt;T as Identity&gt;::Output {}

fn main() {}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)
  --&gt; dependent.rs:11:6
   |
11 | impl&lt;T&gt; dependency::Trait&lt;Local, T&gt; for &lt;T as Identity&gt;::Output {}
   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #124559 &lt;https://github.com/rust-lang/rust/issues/124559&gt;
   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type
   = note: in this case, 'before' refers to the following order: `impl&lt;..&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0`, where `T0` is the first and `Tn` is the last
   = note: `#[warn(uncovered_param_in_projection)]` on by default
</code></pre>
<h3 id="explanation-95"><a class="header" href="#explanation-95">Explanation</a></h3>
<p>FIXME(fmease): Write explainer.</p>
<h2 id="unexpected-cfgs"><a class="header" href="#unexpected-cfgs">unexpected-cfgs</a></h2>
<p>The <code>unexpected_cfgs</code> lint detects unexpected conditional compilation conditions.</p>
<h3 id="example-96"><a class="header" href="#example-96">Example</a></h3>
<pre><code class="language-text">rustc --check-cfg 'cfg()'
</code></pre>
<pre><code class="language-rust ignore (needs command line option)">#[cfg(widnows)]
fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unexpected `cfg` condition name: `widnows`
 --&gt; lint_example.rs:1:7
  |
1 | #[cfg(widnows)]
  |       ^^^^^^^
  |
  = note: `#[warn(unexpected_cfgs)]` on by default
</code></pre>
<h3 id="explanation-96"><a class="header" href="#explanation-96">Explanation</a></h3>
<p>This lint is only active when <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html"><code>--check-cfg</code></a> arguments are being
passed to the compiler and triggers whenever an unexpected condition name or value is
used.</p>
<p>See the <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html">Checking Conditional Configurations</a> section for more
details.</p>
<p>See the <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html#check-cfg-in-lintsrust-table">Cargo Specifics</a> section for configuring this lint in
<code>Cargo.toml</code>.</p>
<h2 id="unfulfilled-lint-expectations"><a class="header" href="#unfulfilled-lint-expectations">unfulfilled-lint-expectations</a></h2>
<p>The <code>unfulfilled_lint_expectations</code> lint detects when a lint expectation is
unfulfilled.</p>
<h3 id="example-97"><a class="header" href="#example-97">Example</a></h3>
<pre><code class="language-rust">#[expect(unused_variables)]
let x = 10;
println!("{}", x);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this lint expectation is unfulfilled
 --&gt; lint_example.rs:2:10
  |
2 | #[expect(unused_variables)]
  |          ^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unfulfilled_lint_expectations)]` on by default

</code></pre>
<h3 id="explanation-97"><a class="header" href="#explanation-97">Explanation</a></h3>
<p>The <code>#[expect]</code> attribute can be used to create a lint expectation. The
expectation is fulfilled, if a <code>#[warn]</code> attribute at the same location
would result in a lint emission. If the expectation is unfulfilled,
because no lint was emitted, this lint will be emitted on the attribute.</p>
<h2 id="ungated-async-fn-track-caller"><a class="header" href="#ungated-async-fn-track-caller">ungated-async-fn-track-caller</a></h2>
<p>The <code>ungated_async_fn_track_caller</code> lint warns when the
<code>#[track_caller]</code> attribute is used on an async function
without enabling the corresponding unstable feature flag.</p>
<h3 id="example-98"><a class="header" href="#example-98">Example</a></h3>
<pre><code class="language-rust">#[track_caller]
async fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[track_caller]` on async functions is a no-op
 --&gt; lint_example.rs:2:1
  |
2 | #[track_caller]
  | ^^^^^^^^^^^^^^^
3 | async fn foo() {}
  | ----------------- this function will not propagate the caller location
  |
  = note: see issue #110011 &lt;https://github.com/rust-lang/rust/issues/110011&gt; for more information
  = help: add `#![feature(async_fn_track_caller)]` to the crate attributes to enable
  = note: this compiler was built on 2026-01-21; consider upgrading it if it is out of date
  = note: `#[warn(ungated_async_fn_track_caller)]` on by default

</code></pre>
<h3 id="explanation-98"><a class="header" href="#explanation-98">Explanation</a></h3>
<p>The attribute must be used in conjunction with the
<a href="https://doc.rust-lang.org/beta/unstable-book/language-features/async-fn-track-caller.html"><code>async_fn_track_caller</code> feature flag</a>. Otherwise, the <code>#[track_caller]</code>
annotation will function as a no-op.</p>
<h2 id="uninhabited-static"><a class="header" href="#uninhabited-static">uninhabited-static</a></h2>
<p>The <code>uninhabited_static</code> lint detects uninhabited statics.</p>
<h3 id="example-99"><a class="header" href="#example-99">Example</a></h3>
<pre><code class="language-rust">enum Void {}
unsafe extern {
    static EXTERN: Void;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static of uninhabited type
 --&gt; lint_example.rs:4:5
  |
4 |     static EXTERN: Void;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #74840 &lt;https://github.com/rust-lang/rust/issues/74840&gt;
  = note: uninhabited statics cannot be initialized, and any access would be an immediate error
  = note: `#[warn(uninhabited_static)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-99"><a class="header" href="#explanation-99">Explanation</a></h3>
<p>Statics with an uninhabited type can never be initialized, so they are impossible to define.
However, this can be side-stepped with an <code>extern static</code>, leading to problems later in the
compiler which assumes that there are no initialized uninhabited places (such as locals or
statics). This was accidentally allowed, but is being phased out.</p>
<h2 id="unknown-diagnostic-attributes"><a class="header" href="#unknown-diagnostic-attributes">unknown-diagnostic-attributes</a></h2>
<p>The <code>unknown_diagnostic_attributes</code> lint detects unknown diagnostic attributes.</p>
<h3 id="example-100"><a class="header" href="#example-100">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::does_not_exist]
struct Thing;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unknown diagnostic attribute
 --&gt; lint_example.rs:2:15
  |
2 | #[diagnostic::does_not_exist]
  |               ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unknown_diagnostic_attributes)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-100"><a class="header" href="#explanation-100">Explanation</a></h3>
<p>It is usually a mistake to specify a diagnostic attribute that does not exist. Check the
spelling, and check the diagnostic attribute listing for the correct name. Also consider if
you are using an old version of the compiler and the attribute is only available in a newer
version. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for the list of diagnostic attributes.</p>
<h2 id="unknown-lints"><a class="header" href="#unknown-lints">unknown-lints</a></h2>
<p>The <code>unknown_lints</code> lint detects unrecognized lint attributes.</p>
<h3 id="example-101"><a class="header" href="#example-101">Example</a></h3>
<pre><code class="language-rust">#![allow(not_a_real_lint)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unknown lint: `not_a_real_lint`
 --&gt; lint_example.rs:1:10
  |
1 | #![allow(not_a_real_lint)]
  |          ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unknown_lints)]` on by default

</code></pre>
<h3 id="explanation-101"><a class="header" href="#explanation-101">Explanation</a></h3>
<p>It is usually a mistake to specify a lint that does not exist. Check
the spelling, and check the lint listing for the correct name. Also
consider if you are using an old version of the compiler, and the lint
is only available in a newer version.</p>
<h2 id="unnameable-test-items"><a class="header" href="#unnameable-test-items">unnameable-test-items</a></h2>
<p>The <code>unnameable_test_items</code> lint detects <a href="https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> functions
that are not able to be run by the test harness because they are in a
position where they are not nameable.</p>
<h3 id="example-102"><a class="header" href="#example-102">Example</a></h3>
<pre><code class="language-rust test">fn main() {
    #[test]
    fn foo() {
        // This test will not fail because it does not run.
        assert_eq!(1, 2);
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot test inner items
 --&gt; lint_example.rs:2:5
  |
2 |     #[test]
  |     ^^^^^^^
  |
  = note: `#[warn(unnameable_test_items)]` on by default

</code></pre>
<h3 id="explanation-102"><a class="header" href="#explanation-102">Explanation</a></h3>
<p>In order for the test harness to run a test, the test function must be
located in a position where it can be accessed from the crate root.
This generally means it must be defined in a module, and not anywhere
else such as inside another function. The compiler previously allowed
this without an error, so a lint was added as an alert that a test is
not being used. Whether or not this should be allowed has not yet been
decided, see <a href="https://github.com/rust-lang/rfcs/pull/2471#issuecomment-397414443">RFC 2471</a> and <a href="https://github.com/rust-lang/rust/issues/36629">issue #36629</a>.</p>
<h2 id="unnecessary-transmutes"><a class="header" href="#unnecessary-transmutes">unnecessary-transmutes</a></h2>
<p>The <code>unnecessary_transmutes</code> lint detects transmutations that have safer alternatives.</p>
<h3 id="example-103"><a class="header" href="#example-103">Example</a></h3>
<pre><code class="language-rust">fn bytes_at_home(x: [u8; 4]) -&gt; u32 {
  unsafe { std::mem::transmute(x) }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary transmute
 --&gt; lint_example.rs:3:12
  |
3 |   unsafe { std::mem::transmute(x) }
  |            -------------------^^^
  |            |
  |            help: replace this with: `u32::from_ne_bytes`
  |
  = help: there's also `from_le_bytes` and `from_be_bytes` if you expect a particular byte order
  = note: `#[warn(unnecessary_transmutes)]` on by default

</code></pre>
<h3 id="explanation-103"><a class="header" href="#explanation-103">Explanation</a></h3>
<p>Using an explicit method is preferable over calls to
<a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>transmute</code></a> as
they more clearly communicate the intent, are easier to review, and
are less likely to accidentally result in unsoundness.</p>
<h2 id="unpredictable-function-pointer-comparisons"><a class="header" href="#unpredictable-function-pointer-comparisons">unpredictable-function-pointer-comparisons</a></h2>
<p>The <code>unpredictable_function_pointer_comparisons</code> lint checks comparison
of function pointer as the operands.</p>
<h3 id="example-104"><a class="header" href="#example-104">Example</a></h3>
<pre><code class="language-rust">fn a() {}
fn b() {}

let f: fn() = a;
let g: fn() = b;

let _ = f == g;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique
 --&gt; lint_example.rs:8:9
  |
8 | let _ = f == g;
  |         ^^^^^^
  |
  = note: the address of the same function can vary between different codegen units
  = note: furthermore, different functions could have the same address after being merged together
  = note: for more information visit &lt;https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html&gt;
  = note: `#[warn(unpredictable_function_pointer_comparisons)]` on by default
help: refactor your code, or use `std::ptr::fn_addr_eq` to suppress the lint
  |
8 - let _ = f == g;
8 + let _ = std::ptr::fn_addr_eq(f, g);
  |

</code></pre>
<h3 id="explanation-104"><a class="header" href="#explanation-104">Explanation</a></h3>
<p>Function pointers comparisons do not produce meaningful result since
they are never guaranteed to be unique and could vary between different
code generation units. Furthermore, different functions could have the
same address after being merged together.</p>
<h2 id="unreachable-code"><a class="header" href="#unreachable-code">unreachable-code</a></h2>
<p>The <code>unreachable_code</code> lint detects unreachable code paths.</p>
<h3 id="example-105"><a class="header" href="#example-105">Example</a></h3>
<pre><code class="language-rust no_run">panic!("we never go past here!");

let x = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable statement
 --&gt; lint_example.rs:4:1
  |
2 | panic!("we never go past here!");
  | -------------------------------- any code following this expression is unreachable
3 |
4 | let x = 5;
  | ^^^^^^^^^^ unreachable statement
  |
  = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-105"><a class="header" href="#explanation-105">Explanation</a></h3>
<p>Unreachable code may signal a mistake or unfinished code. If the code
is no longer in use, consider removing it.</p>
<h2 id="unreachable-patterns"><a class="header" href="#unreachable-patterns">unreachable-patterns</a></h2>
<p>The <code>unreachable_patterns</code> lint detects unreachable patterns.</p>
<h3 id="example-106"><a class="header" href="#example-106">Example</a></h3>
<pre><code class="language-rust">let x = 5;
match x {
    y =&gt; (),
    5 =&gt; (),
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; lint_example.rs:5:5
  |
4 |     y =&gt; (),
  |     - matches any value
5 |     5 =&gt; (),
  |     ^ no value can reach this
  |
  = note: `#[warn(unreachable_patterns)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-106"><a class="header" href="#explanation-106">Explanation</a></h3>
<p>This usually indicates a mistake in how the patterns are specified or
ordered. In this example, the <code>y</code> pattern will always match, so the
five is impossible to reach. Remember, match arms match in order, you
probably wanted to put the <code>5</code> case above the <code>y</code> case.</p>
<h2 id="unstable-name-collision"><a class="header" href="#unstable-name-collision">unstable-name-collision</a></h2>
<p>The lint <code>unstable-name-collision</code> has been renamed to <a href="#unstable-name-collisions"><code>unstable-name-collisions</code></a>.</p>
<h2 id="unstable-name-collisions"><a class="header" href="#unstable-name-collisions">unstable-name-collisions</a></h2>
<p>The <code>unstable_name_collisions</code> lint detects that you have used a name
that the standard library plans to add in the future.</p>
<h3 id="example-107"><a class="header" href="#example-107">Example</a></h3>
<pre><code class="language-rust">trait MyIterator : Iterator {
    // is_partitioned is an unstable method that already exists on the Iterator trait
    fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; bool
    where
        Self: Sized,
        P: FnMut(Self::Item) -&gt; bool,
    {true}
}

impl&lt;T: ?Sized&gt; MyIterator for T where T: Iterator { }

let x = vec![1, 2, 3];
let _ = x.iter().is_partitioned(|_| true);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: a method with this name may be added to the standard library in the future
  --&gt; lint_example.rs:14:18
   |
14 | let _ = x.iter().is_partitioned(|_| true);
   |                  ^^^^^^^^^^^^^^
   |
   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!
   = note: for more information, see issue #48919 &lt;https://github.com/rust-lang/rust/issues/48919&gt;
   = help: call with fully qualified syntax `MyIterator::is_partitioned(...)` to keep using the current method
   = note: `#[warn(unstable_name_collisions)]` (part of `#[warn(future_incompatible)]`) on by default
help: add `#![feature(iter_is_partitioned)]` to the crate attributes to enable `is_partitioned`
   |
 1 + #![feature(iter_is_partitioned)]
   |

</code></pre>
<h3 id="explanation-107"><a class="header" href="#explanation-107">Explanation</a></h3>
<p>When new methods are added to traits in the standard library, they are
usually added in an “unstable” form which is only available on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a> with a <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a>. If there is any
preexisting code which extends a trait to have a method with the same
name, then the names will collide. In the future, when the method is
stabilized, this will cause an error due to the ambiguity. This lint
is an early-warning to let you know that there may be a collision in
the future. This can be avoided by adding type annotations to
disambiguate which trait method you intend to call, such as
<code>MyIterator::is_partitioned(my_iter, my_predicate)</code> or renaming or removing the method.</p>
<h2 id="unstable-syntax-pre-expansion"><a class="header" href="#unstable-syntax-pre-expansion">unstable-syntax-pre-expansion</a></h2>
<p>The <code>unstable_syntax_pre_expansion</code> lint detects the use of unstable
syntax that is discarded during attribute expansion.</p>
<h3 id="example-108"><a class="header" href="#example-108">Example</a></h3>
<pre><code class="language-rust">#[cfg(FALSE)]
macro foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `macro` is experimental
 --&gt; lint_example.rs:3:1
  |
3 | macro foo() {}
  | ^^^^^^^^^^^^^^
  |
  = note: see issue #39412 &lt;https://github.com/rust-lang/rust/issues/39412&gt; for more information
  = help: add `#![feature(decl_macro)]` to the crate attributes to enable
  = note: this compiler was built on 2026-01-21; consider upgrading it if it is out of date
  = warning: unstable syntax can change at any point in the future, causing a hard error!
  = note: for more information, see issue #65860 &lt;https://github.com/rust-lang/rust/issues/65860&gt;

</code></pre>
<h3 id="explanation-108"><a class="header" href="#explanation-108">Explanation</a></h3>
<p>The input to active attributes such as <code>#[cfg]</code> or procedural macro
attributes is required to be valid syntax. Previously, the compiler only
gated the use of unstable syntax features after resolving <code>#[cfg]</code> gates
and expanding procedural macros.</p>
<p>To avoid relying on unstable syntax, move the use of unstable syntax
into a position where the compiler does not parse the syntax, such as a
functionlike macro.</p>
<pre><code class="language-rust"><span class="boring">#![deny(unstable_syntax_pre_expansion)]
</span>
macro_rules! identity {
   ( $($tokens:tt)* ) =&gt; { $($tokens)* }
}

#[cfg(FALSE)]
identity! {
   macro foo() {}
}</code></pre>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/65860">issue #65860</a> for more details.</p>
<h2 id="unsupported-calling-conventions"><a class="header" href="#unsupported-calling-conventions">unsupported-calling-conventions</a></h2>
<p>The <code>unsupported_calling_conventions</code> lint is output whenever there is a use of the
<code>stdcall</code>, <code>fastcall</code>, and <code>cdecl</code> calling conventions (or their unwind
variants) on targets that cannot meaningfully be supported for the requested target.</p>
<p>For example <code>stdcall</code> does not make much sense for a x86_64 or, more apparently, powerpc
code, because this calling convention was never specified for those targets.</p>
<p>Historically MSVC toolchains have fallen back to the regular C calling convention for
targets other than x86, but Rust doesn’t really see a similar need to introduce a similar
hack across many more targets.</p>
<h3 id="example-109"><a class="header" href="#example-109">Example</a></h3>
<pre><code class="language-rust ignore (needs specific targets)">extern "stdcall" fn stdcall() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of calling convention not supported on this target
  --&gt; $DIR/unsupported.rs:39:1
   |
LL | extern "stdcall" fn stdcall() {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unsupported_calling_conventions)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out;
              it will become a hard error in a future release!
   = note: for more information, see issue ...
</code></pre>
<h3 id="explanation-109"><a class="header" href="#explanation-109">Explanation</a></h3>
<p>On most of the targets the behaviour of <code>stdcall</code> and similar calling conventions is not
defined at all, but was previously accepted due to a bug in the implementation of the
compiler.</p>
<h2 id="unsupported-fn-ptr-calling-conventions"><a class="header" href="#unsupported-fn-ptr-calling-conventions">unsupported-fn-ptr-calling-conventions</a></h2>
<p>The <code>unsupported_fn_ptr_calling_conventions</code> lint is output whenever there is a use of
a target dependent calling convention on a target that does not support this calling
convention on a function pointer.</p>
<p>For example <code>stdcall</code> does not make much sense for a x86_64 or, more apparently, powerpc
code, because this calling convention was never specified for those targets.</p>
<h3 id="example-110"><a class="header" href="#example-110">Example</a></h3>
<pre><code class="language-rust ignore (needs specific targets)">fn stdcall_ptr(f: extern "stdcall" fn ()) {
    f()
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the calling convention `"stdcall"` is not supported on this target
  --&gt; $DIR/unsupported.rs:34:15
   |
LL | fn stdcall_ptr(f: extern "stdcall" fn()) {
   |               ^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #130260 &lt;https://github.com/rust-lang/rust/issues/130260&gt;
   = note: `#[warn(unsupported_fn_ptr_calling_conventions)]` on by default
</code></pre>
<h3 id="explanation-110"><a class="header" href="#explanation-110">Explanation</a></h3>
<p>On most of the targets the behaviour of <code>stdcall</code> and similar calling conventions is not
defined at all, but was previously accepted due to a bug in the implementation of the
compiler.</p>
<h2 id="unused-doc-comment"><a class="header" href="#unused-doc-comment">unused-doc-comment</a></h2>
<p>The lint <code>unused-doc-comment</code> has been renamed to <a href="#unused-doc-comments"><code>unused-doc-comments</code></a>.</p>
<h2 id="unused-tuple-struct-fields"><a class="header" href="#unused-tuple-struct-fields">unused-tuple-struct-fields</a></h2>
<p>The lint <code>unused-tuple-struct-fields</code> has been renamed to <a href="#dead-code"><code>dead-code</code></a>.</p>
<h2 id="unused-allocation"><a class="header" href="#unused-allocation">unused-allocation</a></h2>
<p>The <code>unused_allocation</code> lint detects unnecessary allocations that can
be eliminated.</p>
<h3 id="example-111"><a class="header" href="#example-111">Example</a></h3>
<pre><code class="language-rust">fn main() {
    let a = Box::new([1, 2, 3]).len();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary allocation, use `&amp;` instead
 --&gt; lint_example.rs:2:13
  |
2 |     let a = Box::new([1, 2, 3]).len();
  |             ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_allocation)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-111"><a class="header" href="#explanation-111">Explanation</a></h3>
<p>When a <code>box</code> expression is immediately coerced to a reference, then
the allocation is unnecessary, and a reference (using <code>&amp;</code> or <code>&amp;mut</code>)
should be used instead to avoid the allocation.</p>
<h2 id="unused-assignments"><a class="header" href="#unused-assignments">unused-assignments</a></h2>
<p>The <code>unused_assignments</code> lint detects assignments that will never be read.</p>
<h3 id="example-112"><a class="header" href="#example-112">Example</a></h3>
<pre><code class="language-rust">let mut x = 5;
x = 6;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: value assigned to `x` is never read
 --&gt; lint_example.rs:3:1
  |
3 | x = 6;
  | ^^^^^
  |
  = help: maybe it is overwritten before being read?
  = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-112"><a class="header" href="#explanation-112">Explanation</a></h3>
<p>Unused assignments may signal a mistake or unfinished code. If the
variable is never used after being assigned, then the assignment can
be removed. Variables with an underscore prefix such as <code>_x</code> will not
trigger this lint.</p>
<h2 id="unused-associated-type-bounds"><a class="header" href="#unused-associated-type-bounds">unused-associated-type-bounds</a></h2>
<p>The <code>unused_associated_type_bounds</code> lint is emitted when an
associated type bound is added to a trait object, but the associated
type has a <code>where Self: Sized</code> bound, and is thus unavailable on the
trait object anyway.</p>
<h3 id="example-113"><a class="header" href="#example-113">Example</a></h3>
<pre><code class="language-rust">trait Foo {
    type Bar where Self: Sized;
}
type Mop = dyn Foo&lt;Bar = ()&gt;;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary associated type bound for dyn-incompatible associated type
 --&gt; lint_example.rs:5:20
  |
5 | type Mop = dyn Foo&lt;Bar = ()&gt;;
  |                    ^^^^^^^^ help: remove this bound
  |
  = note: this associated type has a `where Self: Sized` bound, and while the associated type can be specified, it cannot be used because trait objects are never `Sized`
  = note: `#[warn(unused_associated_type_bounds)]` on by default

</code></pre>
<h3 id="explanation-113"><a class="header" href="#explanation-113">Explanation</a></h3>
<p>Just like methods with <code>Self: Sized</code> bounds are unavailable on trait
objects, associated types can be removed from the trait object.</p>
<h2 id="unused-attributes"><a class="header" href="#unused-attributes">unused-attributes</a></h2>
<p>The <code>unused_attributes</code> lint detects attributes that were not used by
the compiler.</p>
<h3 id="example-114"><a class="header" href="#example-114">Example</a></h3>
<pre><code class="language-rust">#![ignore]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[ignore]` attribute cannot be used on crates
 --&gt; lint_example.rs:1:1
  |
1 | #![ignore]
  | ^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = help: `#[ignore]` can only be applied to functions
  = note: `#[warn(unused_attributes)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-114"><a class="header" href="#explanation-114">Explanation</a></h3>
<p>Unused <a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a> may indicate the attribute is placed in the wrong
position. Consider removing it, or placing it in the correct position.
Also consider if you intended to use an <em>inner attribute</em> (with a <code>!</code>
such as <code>#![allow(unused)]</code>) which applies to the item the attribute
is within, or an <em>outer attribute</em> (without a <code>!</code> such as
<code>#[allow(unused)]</code>) which applies to the item <em>following</em> the
attribute.</p>
<h2 id="unused-braces"><a class="header" href="#unused-braces">unused-braces</a></h2>
<p>The <code>unused_braces</code> lint detects unnecessary braces around an
expression.</p>
<h3 id="example-115"><a class="header" href="#example-115">Example</a></h3>
<pre><code class="language-rust">if { true } {
    // ...
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary braces around `if` condition
 --&gt; lint_example.rs:2:4
  |
2 | if { true } {
  |    ^^    ^^
  |
  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default
help: remove these braces
  |
2 - if { true } {
2 + if true  {
  |

</code></pre>
<h3 id="explanation-115"><a class="header" href="#explanation-115">Explanation</a></h3>
<p>The braces are not needed, and should be removed. This is the
preferred style for writing these expressions.</p>
<h2 id="unused-comparisons"><a class="header" href="#unused-comparisons">unused-comparisons</a></h2>
<p>The <code>unused_comparisons</code> lint detects comparisons made useless by
limits of the types involved.</p>
<h3 id="example-116"><a class="header" href="#example-116">Example</a></h3>
<pre><code class="language-rust">fn foo(x: u8) {
    x &gt;= 0;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: comparison is useless due to type limits
 --&gt; lint_example.rs:3:5
  |
3 |     x &gt;= 0;
  |     ^^^^^^
  |
  = note: `#[warn(unused_comparisons)]` on by default

</code></pre>
<h3 id="explanation-116"><a class="header" href="#explanation-116">Explanation</a></h3>
<p>A useless comparison may indicate a mistake, and should be fixed or
removed.</p>
<h2 id="unused-doc-comments"><a class="header" href="#unused-doc-comments">unused-doc-comments</a></h2>
<p>The <code>unused_doc_comments</code> lint detects doc comments that aren’t used
by <code>rustdoc</code>.</p>
<h3 id="example-117"><a class="header" href="#example-117">Example</a></h3>
<pre><code class="language-rust">/// docs for x
let x = 12;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused doc comment
 --&gt; lint_example.rs:2:1
  |
2 | /// docs for x
  | ^^^^^^^^^^^^^^
3 | let x = 12;
  | ----------- rustdoc does not generate documentation for statements
  |
  = help: use `//` for a plain comment
  = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-117"><a class="header" href="#explanation-117">Explanation</a></h3>
<p><code>rustdoc</code> does not use doc comments in all positions, and so the doc
comment will be ignored. Try changing it to a normal comment with <code>//</code>
to avoid the warning.</p>
<h2 id="unused-features"><a class="header" href="#unused-features">unused-features</a></h2>
<p>The <code>unused_features</code> lint detects unused or unknown features found in
crate-level <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attributes</a>.</p>
<p>Note: This lint is currently not functional, see <a href="https://github.com/rust-lang/rust/issues/44232">issue #44232</a> for
more details.</p>
<h2 id="unused-imports"><a class="header" href="#unused-imports">unused-imports</a></h2>
<p>The <code>unused_imports</code> lint detects imports that are never used.</p>
<h3 id="example-118"><a class="header" href="#example-118">Example</a></h3>
<pre><code class="language-rust">use std::collections::HashMap;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused import: `std::collections::HashMap`
 --&gt; lint_example.rs:2:5
  |
2 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-118"><a class="header" href="#explanation-118">Explanation</a></h3>
<p>Unused imports may signal a mistake or unfinished code, and clutter
the code, and should be removed. If you intended to re-export the item
to make it available outside of the module, add a visibility modifier
like <code>pub</code>.</p>
<h2 id="unused-labels"><a class="header" href="#unused-labels">unused-labels</a></h2>
<p>The <code>unused_labels</code> lint detects <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#loop-labels">labels</a> that are never used.</p>
<h3 id="example-119"><a class="header" href="#example-119">Example</a></h3>
<pre><code class="language-rust no_run">'unused_label: loop {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused label
 --&gt; lint_example.rs:2:1
  |
2 | 'unused_label: loop {}
  | ^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_labels)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-119"><a class="header" href="#explanation-119">Explanation</a></h3>
<p>Unused labels may signal a mistake or unfinished code. To silence the
warning for the individual label, prefix it with an underscore such as
<code>'_my_label:</code>.</p>
<h2 id="unused-macros"><a class="header" href="#unused-macros">unused-macros</a></h2>
<p>The <code>unused_macros</code> lint detects macros that were not used.</p>
<p>Note that this lint is distinct from the <code>unused_macro_rules</code> lint,
which checks for single rules that never match of an otherwise used
macro, and thus never expand.</p>
<h3 id="example-120"><a class="header" href="#example-120">Example</a></h3>
<pre><code class="language-rust">macro_rules! unused {
    () =&gt; {};
}

fn main() {
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused macro definition: `unused`
 --&gt; lint_example.rs:1:14
  |
1 | macro_rules! unused {
  |              ^^^^^^
  |
  = note: `#[warn(unused_macros)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-120"><a class="header" href="#explanation-120">Explanation</a></h3>
<p>Unused macros may signal a mistake or unfinished code. To silence the
warning for the individual macro, prefix the name with an underscore
such as <code>_my_macro</code>. If you intended to export the macro to make it
available outside of the crate, use the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope"><code>macro_export</code> attribute</a>.</p>
<h2 id="unused-must-use"><a class="header" href="#unused-must-use">unused-must-use</a></h2>
<p>The <code>unused_must_use</code> lint detects unused result of a type flagged as
<code>#[must_use]</code>.</p>
<h3 id="example-121"><a class="header" href="#example-121">Example</a></h3>
<pre><code class="language-rust">fn returns_result() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    returns_result();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused `Result` that must be used
 --&gt; lint_example.rs:6:5
  |
6 |     returns_result();
  |     ^^^^^^^^^^^^^^^^
  |
  = note: this `Result` may be an `Err` variant, which should be handled
  = note: `#[warn(unused_must_use)]` (part of `#[warn(unused)]`) on by default
help: use `let _ = ...` to ignore the resulting value
  |
6 |     let _ = returns_result();
  |     +++++++

</code></pre>
<h3 id="explanation-121"><a class="header" href="#explanation-121">Explanation</a></h3>
<p>The <code>#[must_use]</code> attribute is an indicator that it is a mistake to
ignore the value. See <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute">the reference</a> for more details.</p>
<h2 id="unused-mut"><a class="header" href="#unused-mut">unused-mut</a></h2>
<p>The <code>unused_mut</code> lint detects mut variables which don’t need to be
mutable.</p>
<h3 id="example-122"><a class="header" href="#example-122">Example</a></h3>
<pre><code class="language-rust">let mut x = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable does not need to be mutable
 --&gt; lint_example.rs:2:5
  |
2 | let mut x = 5;
  |     ----^
  |     |
  |     help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-122"><a class="header" href="#explanation-122">Explanation</a></h3>
<p>The preferred style is to only mark variables as <code>mut</code> if it is
required.</p>
<h2 id="unused-parens"><a class="header" href="#unused-parens">unused-parens</a></h2>
<p>The <code>unused_parens</code> lint detects <code>if</code>, <code>match</code>, <code>while</code> and <code>return</code>
with parentheses; they do not need them.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-rust">if(true) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary parentheses around `if` condition
 --&gt; lint_example.rs:2:3
  |
2 | if(true) {}
  |   ^    ^
  |
  = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
  |
2 - if(true) {}
2 + if true  {}
  |

</code></pre>
<h3 id="explanation-123"><a class="header" href="#explanation-123">Explanation</a></h3>
<p>The parentheses are not needed, and should be removed. This is the
preferred style for writing these expressions.</p>
<h2 id="unused-unsafe"><a class="header" href="#unused-unsafe">unused-unsafe</a></h2>
<p>The <code>unused_unsafe</code> lint detects unnecessary use of an <code>unsafe</code> block.</p>
<h3 id="example-123"><a class="header" href="#example-123">Example</a></h3>
<pre><code class="language-rust">unsafe {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary `unsafe` block
 --&gt; lint_example.rs:2:1
  |
2 | unsafe {}
  | ^^^^^^ unnecessary `unsafe` block
  |
  = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-124"><a class="header" href="#explanation-124">Explanation</a></h3>
<p>If nothing within the block requires <code>unsafe</code>, then remove the
<code>unsafe</code> marker because it is not required and may cause confusion.</p>
<h2 id="unused-variables"><a class="header" href="#unused-variables">unused-variables</a></h2>
<p>The <code>unused_variables</code> lint detects variables which are not used in
any way.</p>
<h3 id="example-124"><a class="header" href="#example-124">Example</a></h3>
<pre><code class="language-rust">let x = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused variable: `x`
 --&gt; lint_example.rs:2:5
  |
2 | let x = 5;
  |     ^ help: if this is intentional, prefix it with an underscore: `_x`
  |
  = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-125"><a class="header" href="#explanation-125">Explanation</a></h3>
<p>Unused variables may signal a mistake or unfinished code. To silence
the warning for the individual variable, prefix it with an underscore
such as <code>_x</code>.</p>
<h2 id="unused-visibilities"><a class="header" href="#unused-visibilities">unused-visibilities</a></h2>
<p>The <code>unused_visibilities</code> lint detects visibility qualifiers (like <code>pub</code>)
on a <code>const _</code> item.</p>
<h3 id="example-125"><a class="header" href="#example-125">Example</a></h3>
<pre><code class="language-rust">pub const _: () = {};</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: visibility qualifiers have no effect on `const _` declarations
 --&gt; lint_example.rs:2:1
  |
2 | pub const _: () = {};
  | ^^^ help: remove the qualifier
  |
  = note: `const _` does not declare a name, so there is nothing for the qualifier to apply to
  = note: `#[warn(unused_visibilities)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-126"><a class="header" href="#explanation-126">Explanation</a></h3>
<p>These qualifiers have no effect, as <code>const _</code> items are unnameable.</p>
<h2 id="useless-ptr-null-checks"><a class="header" href="#useless-ptr-null-checks">useless-ptr-null-checks</a></h2>
<p>The <code>useless_ptr_null_checks</code> lint checks for useless null checks against pointers
obtained from non-null types.</p>
<h3 id="example-126"><a class="header" href="#example-126">Example</a></h3>
<pre><code class="language-rust"><span class="boring">fn test() {}
</span>let fn_ptr: fn() = /* somehow obtained nullable function pointer */
<span class="boring">  test;
</span>
if (fn_ptr as *const ()).is_null() { /* ... */ }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function pointers are not nullable, so checking them for null will always return false
 --&gt; lint_example.rs:6:4
  |
6 | if (fn_ptr as *const ()).is_null() { /* ... */ }
  |    ^------^^^^^^^^^^^^^^^^^^^^^^^^
  |     |
  |     expression has type `fn()`
  |
  = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value
  = note: `#[warn(useless_ptr_null_checks)]` on by default

</code></pre>
<h3 id="explanation-127"><a class="header" href="#explanation-127">Explanation</a></h3>
<p>Function pointers and references are assumed to be non-null, checking them for null
will always return false.</p>
<h2 id="uses-power-alignment"><a class="header" href="#uses-power-alignment">uses-power-alignment</a></h2>
<p>The <code>uses_power_alignment</code> lint detects specific <code>repr(C)</code>
aggregates on AIX.
In its platform C ABI, AIX uses the “power” (as in PowerPC) alignment
rule (detailed in https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1?topic=data-using-alignment-modes#alignment),
which can also be set for XLC by <code>#pragma align(power)</code> or
<code>-qalign=power</code>. Aggregates with a floating-point type as the
recursively first field (as in “at offset 0”) modify the layout of
<em>subsequent</em> fields of the associated structs to use an alignment value
where the floating-point type is aligned on a 4-byte boundary.</p>
<p>Effectively, subsequent floating-point fields act as-if they are <code>repr(packed(4))</code>. This
would be unsound to do in a <code>repr(C)</code> type without all the restrictions that come with
<code>repr(packed)</code>. Rust instead chooses a layout that maintains soundness of Rust code, at the
expense of incompatibility with C code.</p>
<h3 id="example-127"><a class="header" href="#example-127">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-powerpc64-ibm-aix)">#[repr(C)]
pub struct Floats {
    a: f64,
    b: u8,
    c: f64,
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: repr(C) does not follow the power alignment rule. This may affect platform C ABI compatibility for this type
 --&gt; &lt;source&gt;:5:3
  |
5 |   c: f64,
  |   ^^^^^^
  |
  = note: `#[warn(uses_power_alignment)]` on by default
</code></pre>
<h3 id="explanation-128"><a class="header" href="#explanation-128">Explanation</a></h3>
<p>The power alignment rule specifies that the above struct has the
following alignment:</p>
<ul>
<li>offset_of!(Floats, a) == 0</li>
<li>offset_of!(Floats, b) == 8</li>
<li>offset_of!(Floats, c) == 12</li>
</ul>
<p>However, Rust currently aligns <code>c</code> at <code>offset_of!(Floats, c) == 16</code>.
Using offset 12 would be unsound since <code>f64</code> generally must be 8-aligned on this target.
Thus, a warning is produced for the above struct.</p>
<h2 id="varargs-without-pattern"><a class="header" href="#varargs-without-pattern">varargs-without-pattern</a></h2>
<p>The <code>varargs_without_pattern</code> lint detects when <code>...</code> is used as an argument to a
non-foreign function without any pattern being specified.</p>
<h3 id="example-128"><a class="header" href="#example-128">Example</a></h3>
<pre><code class="language-rust">// Using `...` in non-foreign function definitions is unstable, however stability is
// currently only checked after attributes are expanded, so using `#[cfg(false)]` here will
// allow this to compile on stable Rust.
#[cfg(false)]
fn foo(...) {

}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: missing pattern for `...` argument
 --&gt; lint_example.rs:6:8
  |
6 | fn foo(...) {
  |        ^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #145544 &lt;https://github.com/rust-lang/rust/issues/145544&gt;
  = note: `#[warn(varargs_without_pattern)]` (part of `#[warn(future_incompatible)]`) on by default
help: name the argument, or use `_` to continue ignoring it
  |
6 | fn foo(_: ...) {
  |        ++

</code></pre>
<h3 id="explanation-129"><a class="header" href="#explanation-129">Explanation</a></h3>
<p>Patterns are currently required for all non-<code>...</code> arguments in function definitions (with
some exceptions in the 2015 edition). Requiring <code>...</code> arguments to have patterns in
non-foreign function definitions makes the language more consistent, and removes a source of
confusion for the unstable C variadic feature. <code>...</code> arguments without a pattern are already
stable and widely used in foreign function definitions; this lint only affects non-foreign
function definitions.</p>
<p>Using <code>...</code> (C varargs) in a non-foreign function definition is currently unstable. However,
stability checking for the <code>...</code> syntax in non-foreign function definitions is currently
implemented after attributes have been expanded, meaning that if the attribute removes the
use of the unstable syntax (e.g. <code>#[cfg(false)]</code>, or a procedural macro), the code will
compile on stable Rust; this is the only situation where this lint affects code that
compiles on stable Rust.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the future.</p>
<h2 id="warnings"><a class="header" href="#warnings">warnings</a></h2>
<p>The <code>warnings</code> lint allows you to change the level of other
lints which produce warnings.</p>
<h3 id="example-129"><a class="header" href="#example-129">Example</a></h3>
<pre><code class="language-rust">#![deny(warnings)]
fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: function `foo` is never used
 --&gt; lint_example.rs:3:4
  |
3 | fn foo() {}
  |    ^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(warnings)]
  |         ^^^^^^^^
  = note: `#[deny(dead_code)]` implied by `#[deny(warnings)]`

</code></pre>
<h3 id="explanation-130"><a class="header" href="#explanation-130">Explanation</a></h3>
<p>The <code>warnings</code> lint is a bit special; by changing its level, you
change every other warning that would produce a warning to whatever
value you’d like. As such, you won’t ever trigger this lint in your
code directly.</p>
<h2 id="while-true"><a class="header" href="#while-true">while-true</a></h2>
<p>The <code>while_true</code> lint detects <code>while true { }</code>.</p>
<h3 id="example-130"><a class="header" href="#example-130">Example</a></h3>
<pre><code class="language-rust no_run">while true {

}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: denote infinite loops with `loop { ... }`
 --&gt; lint_example.rs:2:1
  |
2 | while true {
  | ^^^^^^^^^^ help: use `loop`
  |
  = note: `#[warn(while_true)]` on by default

</code></pre>
<h3 id="explanation-131"><a class="header" href="#explanation-131">Explanation</a></h3>
<p><code>while true</code> should be replaced with <code>loop</code>. A <code>loop</code> expression is
the preferred way to write an infinite loop because it more directly
expresses the intent of the loop.</p>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
    var fragments = {
        "#bare-trait-object": "warn-by-default.html#bare-trait-objects",
        "#unstable-name-collision": "warn-by-default.html#unstable-name-collisions",
        "#unused-doc-comment": "warn-by-default.html#unused-doc-comments",
        "#redundant-semicolon": "warn-by-default.html#redundant-semicolons",
        "#overlapping-patterns": "warn-by-default.html#overlapping-range-endpoints",
        "#non-fmt-panic": "warn-by-default.html#non-fmt-panics",
        "#unused-tuple-struct-fields": "warn-by-default.html#dead-code",
        "#static-mut-ref": "warn-by-default.html#static-mut-refs",
};
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
});
</script>
<hr>
<ol class="footnote-definition">
<li id="footnote-1">
<p>I.e., paths of the form <code>T::Assoc</code> where <code>T</code> is a type parameter
bounded by trait <code>Trait</code> which defines an associated type called <code>Assoc</code>
as opposed to a fully qualified path of the form <code>&lt;T as Trait&gt;::Assoc</code>. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p><a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes</a> <a href="#fr-2-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deny-by-default-lints"><a class="header" href="#deny-by-default-lints">Deny-by-default Lints</a></h1>
<p>These lints are all set to the ‘deny’ level by default.</p>
<ul>
<li><a href="#ambiguous-associated-items"><code>ambiguous_associated_items</code></a></li>
<li><a href="#arithmetic-overflow"><code>arithmetic_overflow</code></a></li>
<li><a href="#binary-asm-labels"><code>binary_asm_labels</code></a></li>
<li><a href="#bindings-with-variant-name"><code>bindings_with_variant_name</code></a></li>
<li><a href="#conflicting-repr-hints"><code>conflicting_repr_hints</code></a></li>
<li><a href="#dangerous-implicit-autorefs"><code>dangerous_implicit_autorefs</code></a></li>
<li><a href="#default-overrides-default-fields"><code>default_overrides_default_fields</code></a></li>
<li><a href="#dependency-on-unit-never-type-fallback"><code>dependency_on_unit_never_type_fallback</code></a></li>
<li><a href="#deref-nullptr"><code>deref_nullptr</code></a></li>
<li><a href="#elided-lifetimes-in-associated-constant"><code>elided_lifetimes_in_associated_constant</code></a></li>
<li><a href="#enum-intrinsics-non-enums"><code>enum_intrinsics_non_enums</code></a></li>
<li><a href="#exceeding-bitshifts"><code>exceeding-bitshifts</code></a></li>
<li><a href="#explicit-builtin-cfgs-in-flags"><code>explicit_builtin_cfgs_in_flags</code></a></li>
<li><a href="#ill-formed-attribute-input"><code>ill_formed_attribute_input</code></a></li>
<li><a href="#incomplete-include"><code>incomplete_include</code></a></li>
<li><a href="#ineffective-unstable-trait-impl"><code>ineffective_unstable_trait_impl</code></a></li>
<li><a href="#invalid-atomic-ordering"><code>invalid_atomic_ordering</code></a></li>
<li><a href="#invalid-doc-attributes"><code>invalid_doc_attributes</code></a></li>
<li><a href="#invalid-from-utf8-unchecked"><code>invalid_from_utf8_unchecked</code></a></li>
<li><a href="#invalid-macro-export-arguments"><code>invalid_macro_export_arguments</code></a></li>
<li><a href="#invalid-null-arguments"><code>invalid_null_arguments</code></a></li>
<li><a href="#invalid-reference-casting"><code>invalid_reference_casting</code></a></li>
<li><a href="#invalid-type-param-default"><code>invalid_type_param_default</code></a></li>
<li><a href="#legacy-derive-helpers"><code>legacy_derive_helpers</code></a></li>
<li><a href="#let-underscore-lock"><code>let_underscore_lock</code></a></li>
<li><a href="#long-running-const-eval"><code>long_running_const_eval</code></a></li>
<li><a href="#macro-expanded-macro-exports-accessed-by-absolute-paths"><code>macro_expanded_macro_exports_accessed_by_absolute_paths</code></a></li>
<li><a href="#mutable-transmutes"><code>mutable_transmutes</code></a></li>
<li><a href="#named-asm-labels"><code>named_asm_labels</code></a></li>
<li><a href="#never-type-fallback-flowing-into-unsafe"><code>never_type_fallback_flowing_into_unsafe</code></a></li>
<li><a href="#no-mangle-const-items"><code>no_mangle_const_items</code></a></li>
<li><a href="#out-of-scope-macro-calls"><code>out_of_scope_macro_calls</code></a></li>
<li><a href="#overflowing-literals"><code>overflowing_literals</code></a></li>
<li><a href="#patterns-in-fns-without-body"><code>patterns_in_fns_without_body</code></a></li>
<li><a href="#private-macro-use"><code>private_macro_use</code></a></li>
<li><a href="#proc-macro-derive-resolution-fallback"><code>proc_macro_derive_resolution_fallback</code></a></li>
<li><a href="#pub-use-of-private-extern-crate"><code>pub_use_of_private_extern_crate</code></a></li>
<li><a href="#repr-transparent-non-zst-fields"><code>repr_transparent_non_zst_fields</code></a></li>
<li><a href="#semicolon-in-expressions-from-macros"><code>semicolon_in_expressions_from_macros</code></a></li>
<li><a href="#soft-unstable"><code>soft_unstable</code></a></li>
<li><a href="#test-unstable-lint"><code>test_unstable_lint</code></a></li>
<li><a href="#text-direction-codepoint-in-comment"><code>text_direction_codepoint_in_comment</code></a></li>
<li><a href="#text-direction-codepoint-in-literal"><code>text_direction_codepoint_in_literal</code></a></li>
<li><a href="#unconditional-panic"><code>unconditional_panic</code></a></li>
<li><a href="#undropped-manually-drops"><code>undropped_manually_drops</code></a></li>
<li><a href="#unknown-crate-types"><code>unknown_crate_types</code></a></li>
<li><a href="#useless-deprecated"><code>useless_deprecated</code></a></li>
</ul>
<h2 id="ambiguous-associated-items"><a class="header" href="#ambiguous-associated-items">ambiguous-associated-items</a></h2>
<p>The <code>ambiguous_associated_items</code> lint detects ambiguity between
<a href="https://doc.rust-lang.org/reference/items/associated-items.html">associated items</a> and <a href="https://doc.rust-lang.org/reference/items/enumerations.html">enum variants</a>.</p>
<h3 id="example-131"><a class="header" href="#example-131">Example</a></h3>
<pre><code class="language-rust compile_fail">enum E {
    V
}

trait Tr {
    type V;
    fn foo() -&gt; Self::V;
}

impl Tr for E {
    type V = u8;
    // `Self::V` is ambiguous because it may refer to the associated type or
    // the enum variant.
    fn foo() -&gt; Self::V { 0 }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: ambiguous associated item
  --&gt; lint_example.rs:15:17
   |
15 |     fn foo() -&gt; Self::V { 0 }
   |                 ^^^^^^^ help: use fully-qualified syntax: `&lt;E as Tr&gt;::V`
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #57644 &lt;https://github.com/rust-lang/rust/issues/57644&gt;
note: `V` could refer to the variant defined here
  --&gt; lint_example.rs:3:5
   |
 3 |     V
   |     ^
note: `V` could also refer to the associated type defined here
  --&gt; lint_example.rs:7:5
   |
 7 |     type V;
   |     ^^^^^^
   = note: `#[deny(ambiguous_associated_items)]` (part of `#[deny(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-132"><a class="header" href="#explanation-132">Explanation</a></h3>
<p>Previous versions of Rust did not allow accessing enum variants
through <a href="https://doc.rust-lang.org/reference/items/type-aliases.html#type-aliases">type aliases</a>. When this ability was added (see <a href="https://github.com/rust-lang/rfcs/blob/master/text/2338-type-alias-enum-variants.md">RFC 2338</a>), this
introduced some situations where it can be ambiguous what a type
was referring to.</p>
<p>To fix this ambiguity, you should use a <a href="https://doc.rust-lang.org/reference/paths.html#qualified-paths">qualified path</a> to explicitly
state which type to use. For example, in the above example the
function can be written as <code>fn f() -&gt; &lt;Self as Tr&gt;::V { 0 }</code> to
specifically refer to the associated type.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the future. See <a href="https://github.com/rust-lang/rust/issues/57644">issue #57644</a> for more details.</p>
<h2 id="arithmetic-overflow"><a class="header" href="#arithmetic-overflow">arithmetic-overflow</a></h2>
<p>The <code>arithmetic_overflow</code> lint detects that an arithmetic operation
will <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">overflow</a>.</p>
<h3 id="example-1-2"><a class="header" href="#example-1-2">Example</a></h3>
<pre><code class="language-rust compile_fail">1_i32 &lt;&lt; 32;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this arithmetic operation will overflow
 --&gt; lint_example.rs:2:1
  |
2 | 1_i32 &lt;&lt; 32;
  | ^^^^^^^^^^^ attempt to shift left by `32_i32`, which would overflow
  |
  = note: `#[deny(arithmetic_overflow)]` on by default

</code></pre>
<h3 id="explanation-1-2"><a class="header" href="#explanation-1-2">Explanation</a></h3>
<p>It is very likely a mistake to perform an arithmetic operation that
overflows its value. If the compiler is able to detect these kinds of
overflows at compile-time, it will trigger this lint. Consider
adjusting the expression to avoid overflow, or use a data type that
will not overflow.</p>
<h2 id="binary-asm-labels"><a class="header" href="#binary-asm-labels">binary-asm-labels</a></h2>
<p>The <code>binary_asm_labels</code> lint detects the use of numeric labels containing only binary
digits in the inline <code>asm!</code> macro.</p>
<h3 id="example-2-2"><a class="header" href="#example-2-2">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-x86_64)">#![cfg(target_arch = "x86_64")]

use std::arch::asm;

fn main() {
    unsafe {
        asm!("0: jmp 0b");
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: avoid using labels containing only the digits `0` and `1` in inline assembly
 --&gt; &lt;source&gt;:7:15
  |
7 |         asm!("0: jmp 0b");
  |               ^ use a different label that doesn't start with `0` or `1`
  |
  = help: start numbering with `2` instead
  = note: an LLVM bug makes these labels ambiguous with a binary literal number on x86
  = note: see &lt;https://github.com/llvm/llvm-project/issues/99547&gt; for more information
  = note: `#[deny(binary_asm_labels)]` on by default
</code></pre>
<h3 id="explanation-2-2"><a class="header" href="#explanation-2-2">Explanation</a></h3>
<p>An <a href="https://github.com/llvm/llvm-project/issues/99547">LLVM bug</a> causes this code to fail to compile because it interprets the <code>0b</code> as a binary
literal instead of a reference to the previous local label <code>0</code>. To work around this bug,
don’t use labels that could be confused with a binary literal.</p>
<p>This behavior is platform-specific to x86 and x86-64.</p>
<p>See the explanation in <a href="https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels">Rust By Example</a> for more details.</p>
<h2 id="bindings-with-variant-name"><a class="header" href="#bindings-with-variant-name">bindings-with-variant-name</a></h2>
<p>The <code>bindings_with_variant_name</code> lint detects pattern bindings with
the same name as one of the matched variants.</p>
<h3 id="example-3-2"><a class="header" href="#example-3-2">Example</a></h3>
<pre><code class="language-rust compile_fail">pub enum Enum {
    Foo,
    Bar,
}

pub fn foo(x: Enum) {
    match x {
        Foo =&gt; {}
        Bar =&gt; {}
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `main::Enum`
 --&gt; lint_example.rs:9:9
  |
9 |         Foo =&gt; {}
  |         ^^^ help: to match on the variant, qualify the path: `main::Enum::Foo`
  |
  = note: `#[deny(bindings_with_variant_name)]` on by default

</code></pre>
<h3 id="explanation-3-2"><a class="header" href="#explanation-3-2">Explanation</a></h3>
<p>It is usually a mistake to specify an enum variant name as an
<a href="https://doc.rust-lang.org/reference/patterns.html#identifier-patterns">identifier pattern</a>. In the example above, the <code>match</code> arms are
specifying a variable name to bind the value of <code>x</code> to. The second arm
is ignored because the first one matches <em>all</em> values. The likely
intent is that the arm was intended to match on the enum variant.</p>
<p>Two possible solutions are:</p>
<ul>
<li>Specify the enum variant using a <a href="https://doc.rust-lang.org/reference/patterns.html#path-patterns">path pattern</a>, such as
<code>Enum::Foo</code>.</li>
<li>Bring the enum variants into local scope, such as adding <code>use Enum::*;</code> to the beginning of the <code>foo</code> function in the example
above.</li>
</ul>
<h2 id="conflicting-repr-hints"><a class="header" href="#conflicting-repr-hints">conflicting-repr-hints</a></h2>
<p>The <code>conflicting_repr_hints</code> lint detects <a href="https://doc.rust-lang.org/reference/type-layout.html#representations"><code>repr</code> attributes</a> with
conflicting hints.</p>
<h3 id="example-4-2"><a class="header" href="#example-4-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#[repr(u32, u64)]
enum Foo {
    Variant1,
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error[E0566]: conflicting representation hints
 --&gt; lint_example.rs:2:8
  |
2 | #[repr(u32, u64)]
  |        ^^^  ^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #68585 &lt;https://github.com/rust-lang/rust/issues/68585&gt;
  = note: `#[deny(conflicting_repr_hints)]` (part of `#[deny(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-4-2"><a class="header" href="#explanation-4-2">Explanation</a></h3>
<p>The compiler incorrectly accepted these conflicting representations in
the past. This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/68585">issue #68585</a> for more details.</p>
<p>To correct the issue, remove one of the conflicting hints.</p>
<h2 id="dangerous-implicit-autorefs"><a class="header" href="#dangerous-implicit-autorefs">dangerous-implicit-autorefs</a></h2>
<p>The <code>dangerous_implicit_autorefs</code> lint checks for implicitly taken references
to dereferences of raw pointers.</p>
<h3 id="example-5-2"><a class="header" href="#example-5-2">Example</a></h3>
<pre><code class="language-rust compile_fail">unsafe fn fun(ptr: *mut [u8]) -&gt; *mut [u8] {
    unsafe { &amp;raw mut (*ptr)[..16] }
    //                      ^^^^^^ this calls `IndexMut::index_mut(&amp;mut ..., ..16)`,
    //                             implicitly creating a reference
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: implicit autoref creates a reference to the dereference of a raw pointer
 --&gt; lint_example.rs:3:23
  |
3 |     unsafe { &amp;raw mut (*ptr)[..16] }
  |                       ^^---^^^^^^^
  |                         |
  |                         this raw pointer has type `*mut [u8]`
  |
  = note: creating a reference requires the pointer target to be valid and imposes aliasing requirements
note: autoref is being applied to this expression, resulting in: `&amp;mut [u8]`
 --&gt; lint_example.rs:3:23
  |
3 |     unsafe { &amp;raw mut (*ptr)[..16] }
  |                       ^^^^^^
  = note: `#[deny(dangerous_implicit_autorefs)]` on by default
help: try using a raw pointer method instead; or if this reference is intentional, make it explicit
  |
3 |     unsafe { &amp;raw mut (&amp;mut (*ptr))[..16] }
  |                       +++++       +

</code></pre>
<h3 id="explanation-5-2"><a class="header" href="#explanation-5-2">Explanation</a></h3>
<p>When working with raw pointers it’s usually undesirable to create references,
since they inflict additional safety requirements. Unfortunately, it’s possible
to take a reference to the dereference of a raw pointer implicitly, which inflicts
the usual reference requirements.</p>
<p>If you are sure that you can soundly take a reference, then you can take it explicitly:</p>
<pre><code class="language-rust">unsafe fn fun(ptr: *mut [u8]) -&gt; *mut [u8] {
    unsafe { &amp;raw mut (&amp;mut *ptr)[..16] }
}</code></pre>
<p>Otherwise try to find an alternative way to achieve your goals using only raw pointers:</p>
<pre><code class="language-rust">use std::ptr;

fn fun(ptr: *mut [u8]) -&gt; *mut [u8] {
    ptr::slice_from_raw_parts_mut(ptr.cast(), 16)
}</code></pre>
<h2 id="default-overrides-default-fields"><a class="header" href="#default-overrides-default-fields">default-overrides-default-fields</a></h2>
<p>The <code>default_overrides_default_fields</code> lint checks for manual <code>impl</code> blocks of the
<code>Default</code> trait of types with default field values.</p>
<h3 id="example-6-2"><a class="header" href="#example-6-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![feature(default_field_values)]
struct Foo {
    x: i32 = 101,
    y: NonDefault,
}

struct NonDefault;

#[deny(default_overrides_default_fields)]
impl Default for Foo {
    fn default() -&gt; Foo {
        Foo { x: 100, y: NonDefault }
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `Default` impl doesn't use the declared default field values
  --&gt; lint_example.rs:11:1
   |
11 | / impl Default for Foo {
12 | |     fn default() -&gt; Foo {
13 | |         Foo { x: 100, y: NonDefault }
   | |                  --- this field has a default value
14 | |     }
15 | | }
   | |_^
   |
   = help: use the default values in the `impl` with `Struct { mandatory_field, .. }` to avoid them diverging over time
note: the lint level is defined here
  --&gt; lint_example.rs:10:8
   |
10 | #[deny(default_overrides_default_fields)]
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-6-2"><a class="header" href="#explanation-6-2">Explanation</a></h3>
<p>Manually writing a <code>Default</code> implementation for a type that has
default field values runs the risk of diverging behavior between
<code>Type { .. }</code> and <code>&lt;Type as Default&gt;::default()</code>, which would be a
foot-gun for users of that type that would expect these to be
equivalent. If <code>Default</code> can’t be derived due to some fields not
having a <code>Default</code> implementation, we encourage the use of <code>..</code> for
the fields that do have a default field value.</p>
<h2 id="dependency-on-unit-never-type-fallback"><a class="header" href="#dependency-on-unit-never-type-fallback">dependency-on-unit-never-type-fallback</a></h2>
<p>The <code>dependency_on_unit_never_type_fallback</code> lint detects cases where code compiles with
<a href="https://doc.rust-lang.org/nightly/core/primitive.never.html#never-type-fallback">never type fallback</a> being <a href="https://doc.rust-lang.org/core/primitive.unit.html"><code>()</code></a>, but will stop compiling with fallback being <a href="https://doc.rust-lang.org/core/primitive.never.html"><code>!</code></a>.</p>
<h3 id="example-7-2"><a class="header" href="#example-7-2">Example</a></h3>
<pre><code class="language-rust compile_fail edition2021"><span class="boring">#![deny(dependency_on_unit_never_type_fallback)]
</span>fn main() {
    if true {
        // return has type `!` which, is some cases, causes never type fallback
        return
    } else {
        // the type produced by this call is not specified explicitly,
        // so it will be inferred from the previous branch
        Default::default()
    };
    // depending on the fallback, this may compile (because `()` implements `Default`),
    // or it may not (because `!` does not implement `Default`)
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this function depends on never type fallback being `()`
 --&gt; lint_example.rs:2:1
  |
2 | fn main() {
  | ^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html&gt;
  = help: specify the types explicitly
note: in edition 2024, the requirement `!: Default` will fail
 --&gt; lint_example.rs:9:9
  |
9 |         Default::default()
  |         ^^^^^^^^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(dependency_on_unit_never_type_fallback)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use `()` annotations to avoid fallback changes
  |
9 |         &lt;() as Default&gt;::default()
  |         ++++++        +

</code></pre>
<h3 id="explanation-7-2"><a class="header" href="#explanation-7-2">Explanation</a></h3>
<p>Due to historic reasons never type fallback was <code>()</code>, meaning that <code>!</code> got spontaneously
coerced to <code>()</code>. There are plans to change that, but they may make the code such as above
not compile. Instead of depending on the fallback, you should specify the type explicitly:</p>
<pre><code>if true {
    return
} else {
    // type is explicitly specified, fallback can't hurt us no more
    &lt;() as Default&gt;::default()
};
</code></pre>
<p>See <a href="https://github.com/rust-lang/rust/issues/123748">Tracking Issue for making <code>!</code> fall back to <code>!</code></a>.</p>
<h2 id="deref-nullptr"><a class="header" href="#deref-nullptr">deref-nullptr</a></h2>
<p>The <code>deref_nullptr</code> lint detects when a null pointer is dereferenced,
which causes <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>.</p>
<h3 id="example-8-2"><a class="header" href="#example-8-2">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>use std::ptr;
unsafe {
    let x = &amp;*ptr::null::&lt;i32&gt;();
    let x = ptr::addr_of!(*ptr::null::&lt;i32&gt;());
    let x = *(0 as *const i32);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: dereferencing a null pointer
 --&gt; lint_example.rs:5:14
  |
5 |     let x = &amp;*ptr::null::&lt;i32&gt;();
  |              ^^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed
  |
  = note: `#[deny(deref_nullptr)]` on by default


error: dereferencing a null pointer
 --&gt; lint_example.rs:7:13
  |
7 |     let x = *(0 as *const i32);
  |             ^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed

</code></pre>
<h3 id="explanation-8-2"><a class="header" href="#explanation-8-2">Explanation</a></h3>
<p>Dereferencing a null pointer causes <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a> if it is accessed
(loaded from or stored to).</p>
<h2 id="elided-lifetimes-in-associated-constant"><a class="header" href="#elided-lifetimes-in-associated-constant">elided-lifetimes-in-associated-constant</a></h2>
<p>The <code>elided_lifetimes_in_associated_constant</code> lint detects elided lifetimes
in associated constants when there are other lifetimes in scope. This was
accidentally supported, and this lint was later relaxed to allow eliding
lifetimes to <code>'static</code> when there are no lifetimes in scope.</p>
<h3 id="example-9-2"><a class="header" href="#example-9-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(elided_lifetimes_in_associated_constant)]

struct Foo&lt;'a&gt;(&amp;'a ());

impl&lt;'a&gt; Foo&lt;'a&gt; {
    const STR: &amp;str = "hello, world";
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `&amp;` without an explicit lifetime name cannot be used here
 --&gt; lint_example.rs:7:16
  |
7 |     const STR: &amp;str = "hello, world";
  |                ^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #115010 &lt;https://github.com/rust-lang/rust/issues/115010&gt;
note: cannot automatically infer `'static` because of other lifetimes in scope
 --&gt; lint_example.rs:6:6
  |
6 | impl&lt;'a&gt; Foo&lt;'a&gt; {
  |      ^^
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(elided_lifetimes_in_associated_constant)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use the `'static` lifetime
  |
7 |     const STR: &amp;'static str = "hello, world";
  |                 +++++++

</code></pre>
<h3 id="explanation-9-2"><a class="header" href="#explanation-9-2">Explanation</a></h3>
<p>Previous version of Rust</p>
<p>Implicit static-in-const behavior was decided <a href="https://github.com/rust-lang/rust/issues/38831">against</a> for associated
constants because of ambiguity. This, however, regressed and the compiler
erroneously treats elided lifetimes in associated constants as lifetime
parameters on the impl.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="enum-intrinsics-non-enums"><a class="header" href="#enum-intrinsics-non-enums">enum-intrinsics-non-enums</a></h2>
<p>The <code>enum_intrinsics_non_enums</code> lint detects calls to
intrinsic functions that require an enum (<a href="https://doc.rust-lang.org/core/mem/fn.discriminant.html"><code>core::mem::discriminant</code></a>,
<a href="https://doc.rust-lang.org/core/mem/fn.variant_count.html"><code>core::mem::variant_count</code></a>), but are called with a non-enum type.</p>
<h3 id="example-10-2"><a class="header" href="#example-10-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(enum_intrinsics_non_enums)]
core::mem::discriminant::&lt;i32&gt;(&amp;123);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the return value of `mem::discriminant` is unspecified when called with a non-enum type
 --&gt; lint_example.rs:3:1
  |
3 | core::mem::discriminant::&lt;i32&gt;(&amp;123);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum
 --&gt; lint_example.rs:3:32
  |
3 | core::mem::discriminant::&lt;i32&gt;(&amp;123);
  |                                ^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(enum_intrinsics_non_enums)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-10-2"><a class="header" href="#explanation-10-2">Explanation</a></h3>
<p>In order to accept any enum, the <code>mem::discriminant</code> and
<code>mem::variant_count</code> functions are generic over a type <code>T</code>.
This makes it technically possible for <code>T</code> to be a non-enum,
in which case the return value is unspecified.</p>
<p>This lint prevents such incorrect usage of these functions.</p>
<h2 id="exceeding-bitshifts"><a class="header" href="#exceeding-bitshifts">exceeding-bitshifts</a></h2>
<p>The lint <code>exceeding-bitshifts</code> has been renamed to <a href="#arithmetic-overflow"><code>arithmetic-overflow</code></a>.</p>
<h2 id="explicit-builtin-cfgs-in-flags"><a class="header" href="#explicit-builtin-cfgs-in-flags">explicit-builtin-cfgs-in-flags</a></h2>
<p>The <code>explicit_builtin_cfgs_in_flags</code> lint detects builtin cfgs set via the <code>--cfg</code> flag.</p>
<h3 id="example-11-2"><a class="header" href="#example-11-2">Example</a></h3>
<pre><code class="language-text">rustc --cfg unix
</code></pre>
<pre><code class="language-rust ignore (needs command line option)">fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unexpected `--cfg unix` flag
  |
  = note: config `unix` is only supposed to be controlled by `--target`
  = note: manually setting a built-in cfg can and does create incoherent behaviors
  = note: `#[deny(explicit_builtin_cfgs_in_flags)]` on by default
</code></pre>
<h3 id="explanation-11-2"><a class="header" href="#explanation-11-2">Explanation</a></h3>
<p>Setting builtin cfgs can and does produce incoherent behavior, it’s better to the use
the appropriate <code>rustc</code> flag that controls the config. For example setting the <code>windows</code>
cfg but on Linux based target.</p>
<h2 id="ill-formed-attribute-input"><a class="header" href="#ill-formed-attribute-input">ill-formed-attribute-input</a></h2>
<p>The <code>ill_formed_attribute_input</code> lint detects ill-formed attribute
inputs that were previously accepted and used in practice.</p>
<h3 id="example-12-2"><a class="header" href="#example-12-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#[inline = "this is not valid"]
fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: valid forms for the attribute are `#[inline(always)]`, `#[inline(never)]`, and `#[inline]`
 --&gt; lint_example.rs:2:1
  |
2 | #[inline = "this is not valid"]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #57571 &lt;https://github.com/rust-lang/rust/issues/57571&gt;
  = note: `#[deny(ill_formed_attribute_input)]` (part of `#[deny(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-12-2"><a class="header" href="#explanation-12-2">Explanation</a></h3>
<p>Previously, inputs for many built-in attributes weren’t validated and
nonsensical attribute inputs were accepted. After validation was
added, it was determined that some existing projects made use of these
invalid forms. This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/57571">issue #57571</a> for more details.</p>
<p>Check the <a href="https://doc.rust-lang.org/nightly/reference/attributes.html">attribute reference</a> for details on the valid inputs for
attributes.</p>
<h2 id="incomplete-include"><a class="header" href="#incomplete-include">incomplete-include</a></h2>
<p>The <code>incomplete_include</code> lint detects the use of the <a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code></a>
macro with a file that contains more than one expression.</p>
<h3 id="example-13-2"><a class="header" href="#example-13-2">Example</a></h3>
<pre><code class="language-rust ignore (needs separate file)">fn main() {
    include!("foo.txt");
}</code></pre>
<p>where the file <code>foo.txt</code> contains:</p>
<pre><code class="language-text">println!("hi!");
</code></pre>
<p>produces:</p>
<pre><code class="language-text">error: include macro expected single expression in source
 --&gt; foo.txt:1:14
  |
1 | println!("1");
  |              ^
  |
  = note: `#[deny(incomplete_include)]` on by default
</code></pre>
<h3 id="explanation-13-2"><a class="header" href="#explanation-13-2">Explanation</a></h3>
<p>The <a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code></a> macro is currently only intended to be used to
include a single <a href="https://doc.rust-lang.org/reference/expressions.html">expression</a> or multiple <a href="https://doc.rust-lang.org/reference/items.html">items</a>. Historically it
would ignore any contents after the first expression, but that can be
confusing. In the example above, the <code>println!</code> expression ends just
before the semicolon, making the semicolon “extra” information that is
ignored. Perhaps even more surprising, if the included file had
multiple print statements, the subsequent ones would be ignored!</p>
<p>One workaround is to place the contents in braces to create a <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">block
expression</a>. Also consider alternatives, like using functions to
encapsulate the expressions, or use <a href="https://doc.rust-lang.org/reference/procedural-macros.html">proc-macros</a>.</p>
<p>This is a lint instead of a hard error because existing projects were
found to hit this error. To be cautious, it is a lint for now. The
future semantics of the <code>include!</code> macro are also uncertain, see
<a href="https://github.com/rust-lang/rust/issues/35560">issue #35560</a>.</p>
<h2 id="ineffective-unstable-trait-impl"><a class="header" href="#ineffective-unstable-trait-impl">ineffective-unstable-trait-impl</a></h2>
<p>The <code>ineffective_unstable_trait_impl</code> lint detects <code>#[unstable]</code> attributes which are not used.</p>
<h3 id="example-14-2"><a class="header" href="#example-14-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![feature(staged_api)]

#[derive(Clone)]
#[stable(feature = "x", since = "1")]
struct S {}

#[unstable(feature = "y", issue = "none")]
impl Copy for S {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: an `#[unstable]` annotation here has no effect
 --&gt; lint_example.rs:8:1
  |
8 | #[unstable(feature = "y", issue = "none")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: see issue #55436 &lt;https://github.com/rust-lang/rust/issues/55436&gt; for more information
  = note: `#[deny(ineffective_unstable_trait_impl)]` on by default

</code></pre>
<h3 id="explanation-14-2"><a class="header" href="#explanation-14-2">Explanation</a></h3>
<p><code>staged_api</code> does not currently support using a stability attribute on <code>impl</code> blocks.
<code>impl</code>s are always stable if both the type and trait are stable, and always unstable otherwise.</p>
<h2 id="invalid-atomic-ordering"><a class="header" href="#invalid-atomic-ordering">invalid-atomic-ordering</a></h2>
<p>The <code>invalid_atomic_ordering</code> lint detects passing an <code>Ordering</code>
to an atomic operation that does not support that ordering.</p>
<h3 id="example-15-2"><a class="header" href="#example-15-2">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">use core::sync::atomic::{AtomicU8, Ordering};
</span>let atom = AtomicU8::new(0);
let value = atom.load(Ordering::Release);
<span class="boring">let _ = value;</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: atomic loads cannot have `Release` or `AcqRel` ordering
 --&gt; lint_example.rs:4:23
  |
4 | let value = atom.load(Ordering::Release);
  |                       ^^^^^^^^^^^^^^^^^
  |
  = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`
  = note: `#[deny(invalid_atomic_ordering)]` on by default

</code></pre>
<h3 id="explanation-15-2"><a class="header" href="#explanation-15-2">Explanation</a></h3>
<p>Some atomic operations are only supported for a subset of the
<code>atomic::Ordering</code> variants. Passing an unsupported variant will cause
an unconditional panic at runtime, which is detected by this lint.</p>
<p>This lint will trigger in the following cases: (where <code>AtomicType</code> is an
atomic type from <code>core::sync::atomic</code>, such as <code>AtomicBool</code>,
<code>AtomicPtr</code>, <code>AtomicUsize</code>, or any of the other integer atomics).</p>
<ul>
<li>
<p>Passing <code>Ordering::Acquire</code> or <code>Ordering::AcqRel</code> to
<code>AtomicType::store</code>.</p>
</li>
<li>
<p>Passing <code>Ordering::Release</code> or <code>Ordering::AcqRel</code> to
<code>AtomicType::load</code>.</p>
</li>
<li>
<p>Passing <code>Ordering::Relaxed</code> to <code>core::sync::atomic::fence</code> or
<code>core::sync::atomic::compiler_fence</code>.</p>
</li>
<li>
<p>Passing <code>Ordering::Release</code> or <code>Ordering::AcqRel</code> as the failure
ordering for any of <code>AtomicType::compare_exchange</code>,
<code>AtomicType::compare_exchange_weak</code>, <code>AtomicType::update</code>, or
<code>AtomicType::try_update</code>.</p>
</li>
</ul>
<h2 id="invalid-doc-attributes"><a class="header" href="#invalid-doc-attributes">invalid-doc-attributes</a></h2>
<p>The <code>invalid_doc_attributes</code> lint detects when the <code>#[doc(...)]</code> is
misused.</p>
<h3 id="example-16-2"><a class="header" href="#example-16-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(warnings)]

pub mod submodule {
    #![doc(test(no_crate_inject))]
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this attribute can only be applied at the crate level
 --&gt; lint_example.rs:5:17
  |
5 |     #![doc(test(no_crate_inject))]
  |                 ^^^^^^^^^^^^^^^
  |
  = note: read &lt;https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level&gt; for more information
  = note: `#[deny(invalid_doc_attributes)]` on by default

</code></pre>
<h3 id="explanation-16-2"><a class="header" href="#explanation-16-2">Explanation</a></h3>
<p>Previously, incorrect usage of the <code>#[doc(..)]</code> attribute was not
being validated. Usually these should be rejected as a hard error,
but this lint was introduced to avoid breaking any existing
crates which included them.</p>
<h2 id="invalid-from-utf8-unchecked"><a class="header" href="#invalid-from-utf8-unchecked">invalid-from-utf8-unchecked</a></h2>
<p>The <code>invalid_from_utf8_unchecked</code> lint checks for calls to
<code>std::str::from_utf8_unchecked</code> and <code>std::str::from_utf8_unchecked_mut</code>
with a known invalid UTF-8 value.</p>
<h3 id="example-17-2"><a class="header" href="#example-17-2">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#[allow(unused)]
</span>unsafe {
    std::str::from_utf8_unchecked(b"Ru\x82st");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: calls to `std::str::from_utf8_unchecked` with an invalid literal are undefined behavior
 --&gt; lint_example.rs:4:5
  |
4 |     std::str::from_utf8_unchecked(b"Ru\x82st");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------^
  |                                   |
  |                                   the literal was valid UTF-8 up to the 2 bytes
  |
  = note: `#[deny(invalid_from_utf8_unchecked)]` on by default

</code></pre>
<h3 id="explanation-17-2"><a class="header" href="#explanation-17-2">Explanation</a></h3>
<p>Creating such a <code>str</code> would result in undefined behavior as per documentation
for <code>std::str::from_utf8_unchecked</code> and <code>std::str::from_utf8_unchecked_mut</code>.</p>
<h2 id="invalid-macro-export-arguments"><a class="header" href="#invalid-macro-export-arguments">invalid-macro-export-arguments</a></h2>
<p>The <code>invalid_macro_export_arguments</code> lint detects cases where <code>#[macro_export]</code> is being used with invalid arguments.</p>
<h3 id="example-18-2"><a class="header" href="#example-18-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(invalid_macro_export_arguments)]

#[macro_export(invalid_parameter)]
macro_rules! myMacro {
   () =&gt; {
        // [...]
   }
}

#[macro_export(too, many, items)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: valid forms for the attribute are `#[macro_export(local_inner_macros)]` and `#[macro_export]`
 --&gt; lint_example.rs:4:1
  |
4 | #[macro_export(invalid_parameter)]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #57571 &lt;https://github.com/rust-lang/rust/issues/57571&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(invalid_macro_export_arguments)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-18-2"><a class="header" href="#explanation-18-2">Explanation</a></h3>
<p>The only valid argument is <code>#[macro_export(local_inner_macros)]</code> or no argument (<code>#[macro_export]</code>).
You can’t have multiple arguments in a <code>#[macro_export(..)]</code>, or mention arguments other than <code>local_inner_macros</code>.</p>
<h2 id="invalid-null-arguments"><a class="header" href="#invalid-null-arguments">invalid-null-arguments</a></h2>
<p>The <code>invalid_null_arguments</code> lint checks for invalid usage of null pointers in arguments.</p>
<h3 id="example-19-2"><a class="header" href="#example-19-2">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">use std::{slice, ptr};
</span>// Undefined behavior
<span class="boring">let _slice: &amp;[u8] =
</span>unsafe { slice::from_raw_parts(ptr::null(), 0) };</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: calling this function with a null pointer is undefined behavior, even if the result of the function is unused
 --&gt; lint_example.rs:5:10
  |
5 | unsafe { slice::from_raw_parts(ptr::null(), 0) };
  |          ^^^^^^^^^^^^^^^^^^^^^^-----------^^^^
  |                                |
  |                                null pointer originates from here
  |
  = help: for more information, visit &lt;https://doc.rust-lang.org/std/ptr/index.html&gt; and &lt;https://doc.rust-lang.org/reference/behavior-considered-undefined.html&gt;
  = note: `#[deny(invalid_null_arguments)]` on by default

</code></pre>
<h3 id="explanation-19-2"><a class="header" href="#explanation-19-2">Explanation</a></h3>
<p>Calling methods whos safety invariants requires non-null ptr with a null pointer
is <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">Undefined Behavior</a>!</p>
<h2 id="invalid-reference-casting"><a class="header" href="#invalid-reference-casting">invalid-reference-casting</a></h2>
<p>The <code>invalid_reference_casting</code> lint checks for casts of <code>&amp;T</code> to <code>&amp;mut T</code>
without using interior mutability.</p>
<h3 id="example-20-2"><a class="header" href="#example-20-2">Example</a></h3>
<pre><code class="language-rust compile_fail">fn x(r: &amp;i32) {
    unsafe {
        *(r as *const i32 as *mut i32) += 1;
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: assigning to `&amp;T` is undefined behavior, consider using an `UnsafeCell`
 --&gt; lint_example.rs:4:9
  |
4 |         *(r as *const i32 as *mut i32) += 1;
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: for more information, visit &lt;https://doc.rust-lang.org/book/ch15-05-interior-mutability.html&gt;
  = note: `#[deny(invalid_reference_casting)]` on by default

</code></pre>
<h3 id="explanation-20-2"><a class="header" href="#explanation-20-2">Explanation</a></h3>
<p>Casting <code>&amp;T</code> to <code>&amp;mut T</code> without using interior mutability is undefined behavior,
as it’s a violation of Rust reference aliasing requirements.</p>
<p><code>UnsafeCell</code> is the only way to obtain aliasable data that is considered
mutable.</p>
<h2 id="invalid-type-param-default"><a class="header" href="#invalid-type-param-default">invalid-type-param-default</a></h2>
<p>The <code>invalid_type_param_default</code> lint detects type parameter defaults
erroneously allowed in an invalid location.</p>
<h3 id="example-21-2"><a class="header" href="#example-21-2">Example</a></h3>
<pre><code class="language-rust compile_fail">fn foo&lt;T=i32&gt;(t: T) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: defaults for generic parameters are not allowed here
 --&gt; lint_example.rs:2:8
  |
2 | fn foo&lt;T=i32&gt;(t: T) {}
  |        ^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #36887 &lt;https://github.com/rust-lang/rust/issues/36887&gt;
  = note: `#[deny(invalid_type_param_default)]` (part of `#[deny(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-21-2"><a class="header" href="#explanation-21-2">Explanation</a></h3>
<p>Default type parameters were only intended to be allowed in certain
situations, but historically the compiler allowed them everywhere.
This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the future. See <a href="https://github.com/rust-lang/rust/issues/36887">issue #36887</a> for more details.</p>
<h2 id="legacy-derive-helpers"><a class="header" href="#legacy-derive-helpers">legacy-derive-helpers</a></h2>
<p>The <code>legacy_derive_helpers</code> lint detects derive helper attributes
that are used before they are introduced.</p>
<h3 id="example-22-2"><a class="header" href="#example-22-2">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#[serde(rename_all = "camelCase")]
#[derive(Deserialize)]
struct S { /* fields */ }</code></pre>
<p>produces:</p>
<pre><code class="language-text">warning: derive helper attribute is used before it is introduced
  --&gt; $DIR/legacy-derive-helpers.rs:1:3
   |
 1 | #[serde(rename_all = "camelCase")]
   |   ^^^^^
...
 2 | #[derive(Deserialize)]
   |          ----------- the attribute is introduced here
</code></pre>
<h3 id="explanation-22-2"><a class="header" href="#explanation-22-2">Explanation</a></h3>
<p>Attributes like this work for historical reasons, but attribute expansion works in
left-to-right order in general, so, to resolve <code>#[serde]</code>, compiler has to try to “look
into the future” at not yet expanded part of the item , but such attempts are not always
reliable.</p>
<p>To fix the warning place the helper attribute after its corresponding derive.</p>
<pre><code class="language-rust ignore (needs extern crate)">#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct S { /* fields */ }</code></pre>
<h2 id="let-underscore-lock"><a class="header" href="#let-underscore-lock">let-underscore-lock</a></h2>
<p>The <code>let_underscore_lock</code> lint checks for statements which don’t bind
a mutex to anything, causing the lock to be released immediately instead
of at end of scope, which is typically incorrect.</p>
<h3 id="example-23-2"><a class="header" href="#example-23-2">Example</a></h3>
<pre><code class="language-rust compile_fail">use std::sync::{Arc, Mutex};
use std::thread;
let data = Arc::new(Mutex::new(0));

thread::spawn(move || {
    // The lock is immediately released instead of at the end of the
    // scope, which is probably not intended.
    let _ = data.lock().unwrap();
    println!("doing some work");
    let mut lock = data.lock().unwrap();
    *lock += 1;
});</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: non-binding let on a synchronization lock
 --&gt; lint_example.rs:9:9
  |
9 |     let _ = data.lock().unwrap();
  |         ^ this lock is not assigned to a binding and is immediately dropped
  |
  = note: `#[deny(let_underscore_lock)]` (part of `#[deny(let_underscore)]`) on by default
help: consider binding to an unused variable to avoid immediately dropping the value
  |
9 |     let _unused = data.lock().unwrap();
  |          ++++++
help: consider immediately dropping the value
  |
9 -     let _ = data.lock().unwrap();
9 +     drop(data.lock().unwrap());
  |

</code></pre>
<h3 id="explanation-23-2"><a class="header" href="#explanation-23-2">Explanation</a></h3>
<p>Statements which assign an expression to an underscore causes the
expression to immediately drop instead of extending the expression’s
lifetime to the end of the scope. This is usually unintended,
especially for types like <code>MutexGuard</code>, which are typically used to
lock a mutex for the duration of an entire scope.</p>
<p>If you want to extend the expression’s lifetime to the end of the scope,
assign an underscore-prefixed name (such as <code>_foo</code>) to the expression.
If you do actually want to drop the expression immediately, then
calling <code>std::mem::drop</code> on the expression is clearer and helps convey
intent.</p>
<h2 id="long-running-const-eval"><a class="header" href="#long-running-const-eval">long-running-const-eval</a></h2>
<p>The <code>long_running_const_eval</code> lint is emitted when const
eval is running for a long time to ensure rustc terminates
even if you accidentally wrote an infinite loop.</p>
<h3 id="example-24-2"><a class="header" href="#example-24-2">Example</a></h3>
<pre><code class="language-rust compile_fail">const FOO: () = loop {};</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: constant evaluation is taking a long time
 --&gt; lint_example.rs:2:17
  |
2 | const FOO: () = loop {};
  |                 ^^^^^^^
  |
  = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.
          If your compilation actually takes a long time, you can safely allow the lint.
help: the constant being evaluated
 --&gt; lint_example.rs:2:1
  |
2 | const FOO: () = loop {};
  | ^^^^^^^^^^^^^
  = note: `#[deny(long_running_const_eval)]` on by default

</code></pre>
<h3 id="explanation-24-2"><a class="header" href="#explanation-24-2">Explanation</a></h3>
<p>Loops allow const evaluation to compute arbitrary code, but may also
cause infinite loops or just very long running computations.
Users can enable long running computations by allowing the lint
on individual constants or for entire crates.</p>
<h3 id="unconditional-warnings"><a class="header" href="#unconditional-warnings">Unconditional warnings</a></h3>
<p>Note that regardless of whether the lint is allowed or set to warn,
the compiler will issue warnings if constant evaluation runs significantly
longer than this lint’s limit. These warnings are also shown to downstream
users from crates.io or similar registries. If you are above the lint’s limit,
both you and downstream users might be exposed to these warnings.
They might also appear on compiler updates, as the compiler makes minor changes
about how complexity is measured: staying below the limit ensures that there
is enough room, and given that the lint is disabled for people who use your
dependency it means you will be the only one to get the warning and can put
out an update in your own time.</p>
<h2 id="macro-expanded-macro-exports-accessed-by-absolute-paths"><a class="header" href="#macro-expanded-macro-exports-accessed-by-absolute-paths">macro-expanded-macro-exports-accessed-by-absolute-paths</a></h2>
<p>The <code>macro_expanded_macro_exports_accessed_by_absolute_paths</code> lint
detects macro-expanded <a href="https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope"><code>macro_export</code></a> macros from the current crate
that cannot be referred to by absolute paths.</p>
<h3 id="example-25-2"><a class="header" href="#example-25-2">Example</a></h3>
<pre><code class="language-rust compile_fail">macro_rules! define_exported {
    () =&gt; {
        #[macro_export]
        macro_rules! exported {
            () =&gt; {};
        }
    };
}

define_exported!();

fn main() {
    crate::exported!();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: macro-expanded `macro_export` macros from the current crate cannot be referred to by absolute paths
  --&gt; lint_example.rs:13:5
   |
13 |     crate::exported!();
   |     ^^^^^^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #52234 &lt;https://github.com/rust-lang/rust/issues/52234&gt;
note: the macro is defined here
  --&gt; lint_example.rs:4:9
   |
 4 | /         macro_rules! exported {
 5 | |             () =&gt; {};
 6 | |         }
   | |_________^
...
10 |   define_exported!();
   |   ------------------ in this macro invocation
   = note: `#[deny(macro_expanded_macro_exports_accessed_by_absolute_paths)]` (part of `#[deny(future_incompatible)]`) on by default
   = note: this error originates in the macro `define_exported` (in Nightly builds, run with -Z macro-backtrace for more info)

</code></pre>
<h3 id="explanation-25-2"><a class="header" href="#explanation-25-2">Explanation</a></h3>
<p>The intent is that all macros marked with the <code>#[macro_export]</code>
attribute are made available in the root of the crate. However, when a
<code>macro_rules!</code> definition is generated by another macro, the macro
expansion is unable to uphold this rule. This is a
<a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/53495">issue #53495</a> for more details.</p>
<h2 id="mutable-transmutes"><a class="header" href="#mutable-transmutes">mutable-transmutes</a></h2>
<p>The <code>mutable_transmutes</code> lint catches transmuting from <code>&amp;T</code> to <code>&amp;mut T</code> because it is <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>.</p>
<h3 id="example-26-2"><a class="header" href="#example-26-2">Example</a></h3>
<pre><code class="language-rust compile_fail">unsafe {
    let y = std::mem::transmute::&lt;&amp;i32, &amp;mut i32&gt;(&amp;5);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: transmuting &amp;T to &amp;mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell
 --&gt; lint_example.rs:3:13
  |
3 |     let y = std::mem::transmute::&lt;&amp;i32, &amp;mut i32&gt;(&amp;5);
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[deny(mutable_transmutes)]` on by default

</code></pre>
<h3 id="explanation-26-2"><a class="header" href="#explanation-26-2">Explanation</a></h3>
<p>Certain assumptions are made about aliasing of data, and this transmute
violates those assumptions. Consider using <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> instead.</p>
<h2 id="named-asm-labels"><a class="header" href="#named-asm-labels">named-asm-labels</a></h2>
<p>The <code>named_asm_labels</code> lint detects the use of named labels in the
inline <code>asm!</code> macro.</p>
<h3 id="example-27-2"><a class="header" href="#example-27-2">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![feature(asm_experimental_arch)]
</span>use std::arch::asm;

fn main() {
    unsafe {
        asm!("foo: bar");
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: avoid using named labels in inline assembly
 --&gt; lint_example.rs:6:15
  |
6 |         asm!("foo: bar");
  |               ^^^
  |
  = help: only local labels of the form `&lt;number&gt;:` should be used in inline asm
  = note: see the asm section of Rust By Example &lt;https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels&gt; for more information
  = note: `#[deny(named_asm_labels)]` on by default

</code></pre>
<h3 id="explanation-27-2"><a class="header" href="#explanation-27-2">Explanation</a></h3>
<p>LLVM is allowed to duplicate inline assembly blocks for any
reason, for example when it is in a function that gets inlined. Because
of this, GNU assembler <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">local labels</a> <em>must</em> be used instead of labels
with a name. Using named labels might cause assembler or linker errors.</p>
<p>See the explanation in <a href="https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels">Rust By Example</a> for more details.</p>
<h2 id="never-type-fallback-flowing-into-unsafe"><a class="header" href="#never-type-fallback-flowing-into-unsafe">never-type-fallback-flowing-into-unsafe</a></h2>
<p>The <code>never_type_fallback_flowing_into_unsafe</code> lint detects cases where never type fallback
affects unsafe function calls.</p>
<h3 id="never-type-fallback"><a class="header" href="#never-type-fallback">Never type fallback</a></h3>
<p>When the compiler sees a value of type <a href="https://doc.rust-lang.org/core/primitive.never.html"><code>!</code></a> it implicitly inserts a coercion (if possible),
to allow type check to infer any type:</p>
<pre><code class="language-ignore (illustrative-and-has-placeholders)">// this
let x: u8 = panic!();

// is (essentially) turned by the compiler into
let x: u8 = absurd(panic!());

// where absurd is a function with the following signature
// (it's sound, because `!` always marks unreachable code):
fn absurd&lt;T&gt;(never: !) -&gt; T { ... }
</code></pre>
<p>While it’s convenient to be able to use non-diverging code in one of the branches (like
<code>if a { b } else { return }</code>) this could lead to compilation errors:</p>
<pre><code class="language-compile_fail">// this
{ panic!() };

// gets turned into this
{ absurd(panic!()) }; // error: can't infer the type of `absurd`
</code></pre>
<p>To prevent such errors, compiler remembers where it inserted <code>absurd</code> calls, and if it
can’t infer their type, it sets the type to fallback. <code>{ absurd::&lt;Fallback&gt;(panic!()) };</code>.
This is what is known as “never type fallback”.</p>
<h3 id="example-28-2"><a class="header" href="#example-28-2">Example</a></h3>
<pre><code class="language-rust compile_fail">fn main() {
    if true {
        // return has type `!` which, is some cases, causes never type fallback
        return
    } else {
        // `zeroed` is an unsafe function, which returns an unbounded type
        unsafe { std::mem::zeroed() }
    };
    // depending on the fallback, `zeroed` may create `()` (which is completely sound),
    // or `!` (which is instant undefined behavior)
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: never type fallback affects this call to an `unsafe` function
 --&gt; lint_example.rs:7:18
  |
7 |         unsafe { std::mem::zeroed() }
  |                  ^^^^^^^^^^^^^^^^^^
  |
  = warning: this changes meaning in Rust 2024 and in a future release in all editions!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html&gt;
  = help: specify the type explicitly
  = note: `#[deny(never_type_fallback_flowing_into_unsafe)]` (part of `#[deny(rust_2024_compatibility)]`) on by default
help: use `()` annotations to avoid fallback changes
  |
7 |         unsafe { std::mem::zeroed::&lt;()&gt;() }
  |                                  ++++++

</code></pre>
<h3 id="explanation-28-2"><a class="header" href="#explanation-28-2">Explanation</a></h3>
<p>Due to historic reasons never type fallback was <code>()</code>, meaning that <code>!</code> got spontaneously
coerced to <code>()</code>. There are plans to change that, but they may make the code such as above
unsound. Instead of depending on the fallback, you should specify the type explicitly:</p>
<pre><code>if true {
    return
} else {
    // type is explicitly specified, fallback can't hurt us no more
    unsafe { std::mem::zeroed::&lt;()&gt;() }
};
</code></pre>
<p>See <a href="https://github.com/rust-lang/rust/issues/123748">Tracking Issue for making <code>!</code> fall back to <code>!</code></a>.</p>
<h2 id="no-mangle-const-items"><a class="header" href="#no-mangle-const-items">no-mangle-const-items</a></h2>
<p>The <code>no_mangle_const_items</code> lint detects any <code>const</code> items with the
<a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code> attribute</a>.</p>
<h3 id="example-29-2"><a class="header" href="#example-29-2">Example</a></h3>
<pre><code class="language-rust compile_fail edition2021">#[no_mangle]
const FOO: i32 = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: const items should never be `#[no_mangle]`
 --&gt; lint_example.rs:3:1
  |
3 | const FOO: i32 = 5;
  | ------^^^^^^^^^^^^^
  | |
  | help: try a static value: `pub static`
  |
  = note: `#[deny(no_mangle_const_items)]` on by default

</code></pre>
<h3 id="explanation-29-2"><a class="header" href="#explanation-29-2">Explanation</a></h3>
<p>Constants do not have their symbols exported, and therefore, this
probably means you meant to use a <a href="https://doc.rust-lang.org/reference/items/static-items.html"><code>static</code></a>, not a <a href="https://doc.rust-lang.org/reference/items/constant-items.html"><code>const</code></a>.</p>
<h2 id="out-of-scope-macro-calls"><a class="header" href="#out-of-scope-macro-calls">out-of-scope-macro-calls</a></h2>
<p>The <code>out_of_scope_macro_calls</code> lint detects <code>macro_rules</code> called when they are not in scope,
above their definition, which may happen in key-value attributes.</p>
<h3 id="example-30-2"><a class="header" href="#example-30-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![doc = in_root!()]

macro_rules! in_root { () =&gt; { "" } }

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: cannot find macro `in_root` in the current scope when looking from the crate root
 --&gt; lint_example.rs:1:10
  |
1 | #![doc = in_root!()]
  |          ^^^^^^^ not found from the crate root
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #124535 &lt;https://github.com/rust-lang/rust/issues/124535&gt;
  = help: import `macro_rules` with `use` to make it callable above its definition
  = note: `#[deny(out_of_scope_macro_calls)]` (part of `#[deny(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-30-2"><a class="header" href="#explanation-30-2">Explanation</a></h3>
<p>The scope in which a <code>macro_rules</code> item is visible starts at that item and continues
below it. This is more similar to <code>let</code> than to other items, which are in scope both above
and below their definition.
Due to a bug <code>macro_rules</code> were accidentally in scope inside some key-value attributes
above their definition. The lint catches such cases.
To address the issue turn the <code>macro_rules</code> into a regularly scoped item by importing it
with <code>use</code>.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="overflowing-literals"><a class="header" href="#overflowing-literals">overflowing-literals</a></h2>
<p>The <code>overflowing_literals</code> lint detects literals out of range for their type.</p>
<h3 id="example-31-2"><a class="header" href="#example-31-2">Example</a></h3>
<pre><code class="language-rust compile_fail">let x: u8 = 1000;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: literal out of range for `u8`
 --&gt; lint_example.rs:2:13
  |
2 | let x: u8 = 1000;
  |             ^^^^
  |
  = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`
  = note: `#[deny(overflowing_literals)]` on by default

</code></pre>
<h3 id="explanation-31-2"><a class="header" href="#explanation-31-2">Explanation</a></h3>
<p>It is usually a mistake to use a literal that overflows its type
Change either the literal or its type such that the literal is
within the range of its type.</p>
<h2 id="patterns-in-fns-without-body"><a class="header" href="#patterns-in-fns-without-body">patterns-in-fns-without-body</a></h2>
<p>The <code>patterns_in_fns_without_body</code> lint detects <code>mut</code> identifier
patterns as a parameter in functions without a body.</p>
<h3 id="example-32-2"><a class="header" href="#example-32-2">Example</a></h3>
<pre><code class="language-rust compile_fail">trait Trait {
    fn foo(mut arg: u8);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: patterns aren't allowed in functions without bodies
 --&gt; lint_example.rs:3:12
  |
3 |     fn foo(mut arg: u8);
  |            ^^^^^^^ help: remove `mut` from the parameter: `arg`
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #35203 &lt;https://github.com/rust-lang/rust/issues/35203&gt;
  = note: `#[deny(patterns_in_fns_without_body)]` (part of `#[deny(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-32-2"><a class="header" href="#explanation-32-2">Explanation</a></h3>
<p>To fix this, remove <code>mut</code> from the parameter in the trait definition;
it can be used in the implementation. That is, the following is OK:</p>
<pre><code class="language-rust">trait Trait {
    fn foo(arg: u8); // Removed `mut` here
}

impl Trait for i32 {
    fn foo(mut arg: u8) { // `mut` here is OK

    }
}</code></pre>
<p>Trait definitions can define functions without a body to specify a
function that implementors must define. The parameter names in the
body-less functions are only allowed to be <code>_</code> or an <a href="https://doc.rust-lang.org/reference/identifiers.html">identifier</a> for
documentation purposes (only the type is relevant). Previous versions
of the compiler erroneously allowed <a href="https://doc.rust-lang.org/reference/patterns.html#identifier-patterns">identifier patterns</a> with the
<code>mut</code> keyword, but this was not intended to be allowed. This is a
<a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/35203">issue #35203</a> for more details.</p>
<h2 id="private-macro-use"><a class="header" href="#private-macro-use">private-macro-use</a></h2>
<p>The <code>private_macro_use</code> lint detects private macros that are imported
with <code>#[macro_use]</code>.</p>
<h3 id="example-33-2"><a class="header" href="#example-33-2">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">// extern_macro.rs
macro_rules! foo_ { () =&gt; {}; }
use foo_ as foo;

// code.rs

#![deny(private_macro_use)]

#[macro_use]
extern crate extern_macro;

fn main() {
    foo!();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: cannot find macro `foo` in this scope
</code></pre>
<h3 id="explanation-33-2"><a class="header" href="#explanation-33-2">Explanation</a></h3>
<p>This lint arises from overlooking visibility checks for macros
in an external crate.</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="proc-macro-derive-resolution-fallback"><a class="header" href="#proc-macro-derive-resolution-fallback">proc-macro-derive-resolution-fallback</a></h2>
<p>The <code>proc_macro_derive_resolution_fallback</code> lint detects proc macro
derives using inaccessible names from parent modules.</p>
<h3 id="example-34-2"><a class="header" href="#example-34-2">Example</a></h3>
<pre><code class="language-rust ignore (proc-macro)">// foo.rs
#![crate_type = "proc-macro"]

extern crate proc_macro;

use proc_macro::*;

#[proc_macro_derive(Foo)]
pub fn foo1(a: TokenStream) -&gt; TokenStream {
    drop(a);
    "mod __bar { static mut BAR: Option&lt;Something&gt; = None; }".parse().unwrap()
}</code></pre>
<pre><code class="language-rust ignore (needs-dependency)">// bar.rs
#[macro_use]
extern crate foo;

struct Something;

#[derive(Foo)]
struct Another;

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot find type `Something` in this scope
 --&gt; src/main.rs:8:10
  |
8 | #[derive(Foo)]
  |          ^^^ names from parent modules are not accessible without an explicit import
  |
  = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #50504 &lt;https://github.com/rust-lang/rust/issues/50504&gt;
</code></pre>
<h3 id="explanation-34-2"><a class="header" href="#explanation-34-2">Explanation</a></h3>
<p>If a proc-macro generates a module, the compiler unintentionally
allowed items in that module to refer to items in the crate root
without importing them. This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to
transition this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/50504">issue #50504</a> for
more details.</p>
<h2 id="pub-use-of-private-extern-crate"><a class="header" href="#pub-use-of-private-extern-crate">pub-use-of-private-extern-crate</a></h2>
<p>The <code>pub_use_of_private_extern_crate</code> lint detects a specific
situation of re-exporting a private <code>extern crate</code>.</p>
<h3 id="example-35-2"><a class="header" href="#example-35-2">Example</a></h3>
<pre><code class="language-rust compile_fail">extern crate core;
pub use core as reexported_core;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error[E0365]: extern crate `core` is private and cannot be re-exported
 --&gt; lint_example.rs:3:9
  |
3 | pub use core as reexported_core;
  |         ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #127909 &lt;https://github.com/rust-lang/rust/issues/127909&gt;
  = note: `#[deny(pub_use_of_private_extern_crate)]` (part of `#[deny(future_incompatible)]`) on by default
help: consider making the `extern crate` item publicly accessible
  |
2 | pub extern crate core;
  | +++

</code></pre>
<h3 id="explanation-35-2"><a class="header" href="#explanation-35-2">Explanation</a></h3>
<p>A public <code>use</code> declaration should not be used to publically re-export a
private <code>extern crate</code>. <code>pub extern crate</code> should be used instead.</p>
<p>This was historically allowed, but is not the intended behavior
according to the visibility rules. This is a <a href="#future-incompatible-lints">future-incompatible</a>
lint to transition this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/127909">issue
#127909</a> for more details.</p>
<h2 id="repr-transparent-non-zst-fields"><a class="header" href="#repr-transparent-non-zst-fields">repr-transparent-non-zst-fields</a></h2>
<p>The <code>repr_transparent_non_zst_fields</code> lint
detects types marked <code>#[repr(transparent)]</code> that (transitively)
contain a type that is not guaranteed to remain a ZST type under all configurations.</p>
<h3 id="example-36-2"><a class="header" href="#example-36-2">Example</a></h3>
<pre><code class="language-rust ignore (needs external crate)">#![deny(repr_transparent_external_private_fields)]
use foo::NonExhaustiveZst;

#[repr(C)]
struct CZst([u8; 0]);

#[repr(transparent)]
struct Bar(u32, ([u32; 0], NonExhaustiveZst));
#[repr(transparent)]
struct Baz(u32, CZst);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: zero-sized fields in repr(transparent) cannot contain external non-exhaustive types
 --&gt; src/main.rs:5:28
  |
5 | struct Bar(u32, ([u32; 0], NonExhaustiveZst));
  |                            ^^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; src/main.rs:1:9
  |
1 | #![deny(repr_transparent_external_private_fields)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #78586 &lt;https://github.com/rust-lang/rust/issues/78586&gt;
  = note: this field contains `NonExhaustiveZst`, which is marked with `#[non_exhaustive]`, so it could become non-zero-sized in the future.

error: zero-sized fields in repr(transparent) cannot contain `#[repr(C)]` types
 --&gt; src/main.rs:5:28
  |
5 | struct Baz(u32, CZst);
  |                 ^^^^
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #78586 &lt;https://github.com/rust-lang/rust/issues/78586&gt;
  = note: this field contains `CZst`, which is a `#[repr(C)]` type, so it is not guaranteed to be zero-sized on all targets.
</code></pre>
<h3 id="explanation-36-2"><a class="header" href="#explanation-36-2">Explanation</a></h3>
<p>Previous, Rust accepted fields that contain external private zero-sized types, even though
those types could gain a non-zero-sized field in a future, semver-compatible update.</p>
<p>Rust also accepted fields that contain <code>repr(C)</code> zero-sized types, even though those types
are not guaranteed to be zero-sized on all targets, and even though those types can
make a difference for the ABI (and therefore cannot be ignored by <code>repr(transparent)</code>).</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/78586">issue #78586</a> for more details.</p>
<h2 id="semicolon-in-expressions-from-macros"><a class="header" href="#semicolon-in-expressions-from-macros">semicolon-in-expressions-from-macros</a></h2>
<p>The <code>semicolon_in_expressions_from_macros</code> lint detects trailing semicolons
in macro bodies when the macro is invoked in expression position.
This was previous accepted, but is being phased out.</p>
<h3 id="example-37-2"><a class="header" href="#example-37-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(semicolon_in_expressions_from_macros)]
macro_rules! foo {
    () =&gt; { true; }
}

fn main() {
    let val = match true {
        true =&gt; false,
        _ =&gt; foo!()
    };
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trailing semicolon in macro used in expression position
 --&gt; lint_example.rs:3:17
  |
3 |     () =&gt; { true; }
  |                 ^
...
9 |         _ =&gt; foo!()
  |              ------ in this macro invocation
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #79813 &lt;https://github.com/rust-lang/rust/issues/79813&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(semicolon_in_expressions_from_macros)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = note: this error originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)

</code></pre>
<h3 id="explanation-37-2"><a class="header" href="#explanation-37-2">Explanation</a></h3>
<p>Previous, Rust ignored trailing semicolon in a macro
body when a macro was invoked in expression position.
However, this makes the treatment of semicolons in the language
inconsistent, and could lead to unexpected runtime behavior
in some circumstances (e.g. if the macro author expects
a value to be dropped).</p>
<p>This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/79813">issue #79813</a> for more details.</p>
<h2 id="soft-unstable"><a class="header" href="#soft-unstable">soft-unstable</a></h2>
<p>The <code>soft_unstable</code> lint detects unstable features that were unintentionally allowed on
stable. This is a <a href="#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/64266">issue #64266</a> for more details.</p>
<h2 id="test-unstable-lint"><a class="header" href="#test-unstable-lint">test-unstable-lint</a></h2>
<p>The <code>test_unstable_lint</code> lint tests unstable lints and is perma-unstable.</p>
<h3 id="example-38-2"><a class="header" href="#example-38-2">Example</a></h3>
<pre><code class="language-rust">// This lint is intentionally used to test the compiler's behavior
// when an unstable lint is enabled without the corresponding feature gate.
#![allow(test_unstable_lint)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unknown lint: `test_unstable_lint`
 --&gt; lint_example.rs:4:10
  |
4 | #![allow(test_unstable_lint)]
  |          ^^^^^^^^^^^^^^^^^^
  |
  = note: the `test_unstable_lint` lint is unstable
  = help: add `#![feature(test_unstable_lint)]` to the crate attributes to enable
  = note: this compiler was built on 2026-01-21; consider upgrading it if it is out of date
  = note: `#[warn(unknown_lints)]` on by default

</code></pre>
<h3 id="explanation-38-2"><a class="header" href="#explanation-38-2">Explanation</a></h3>
<p>In order to test the behavior of unstable lints, a permanently-unstable
lint is required. This lint can be used to trigger warnings and errors
from the compiler related to unstable lints.</p>
<h2 id="text-direction-codepoint-in-comment"><a class="header" href="#text-direction-codepoint-in-comment">text-direction-codepoint-in-comment</a></h2>
<p>The <code>text_direction_codepoint_in_comment</code> lint detects Unicode codepoints in comments that
change the visual representation of text on screen in a way that does not correspond to
their on memory representation.</p>
<h3 id="example-39-2"><a class="header" href="#example-39-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(text_direction_codepoint_in_comment)]
fn main() {
    println!("{:?}"); // '‮');
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unicode codepoint changing visible direction of text present in comment
 --&gt; lint_example.rs:3:23
  |
3 |     println!("{:?}"); // '�');
  |                       ^^^^-^^^
  |                       |   |
  |                       |   '\u{202e}'
  |                       this comment contains an invisible unicode text flow control codepoint
  |
  = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(text_direction_codepoint_in_comment)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = help: if their presence wasn't intentional, you can remove them

</code></pre>
<h3 id="explanation-39-2"><a class="header" href="#explanation-39-2">Explanation</a></h3>
<p>Unicode allows changing the visual flow of text on screen in order to support scripts that
are written right-to-left, but a specially crafted comment can make code that will be
compiled appear to be part of a comment, depending on the software used to read the code.
To avoid potential problems or confusion, such as in CVE-2021-42574, by default we deny
their use.</p>
<h2 id="text-direction-codepoint-in-literal"><a class="header" href="#text-direction-codepoint-in-literal">text-direction-codepoint-in-literal</a></h2>
<p>The <code>text_direction_codepoint_in_literal</code> lint detects Unicode codepoints that change the
visual representation of text on screen in a way that does not correspond to their on
memory representation.</p>
<h3 id="explanation-40-2"><a class="header" href="#explanation-40-2">Explanation</a></h3>
<p>The unicode characters <code>\u{202A}</code>, <code>\u{202B}</code>, <code>\u{202D}</code>, <code>\u{202E}</code>, <code>\u{2066}</code>,
<code>\u{2067}</code>, <code>\u{2068}</code>, <code>\u{202C}</code> and <code>\u{2069}</code> make the flow of text on screen change
its direction on software that supports these codepoints. This makes the text “abc” display
as “cba” on screen. By leveraging software that supports these, people can write specially
crafted literals that make the surrounding code seem like it’s performing one action, when
in reality it is performing another. Because of this, we proactively lint against their
presence to avoid surprises.</p>
<h3 id="example-40-2"><a class="header" href="#example-40-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(text_direction_codepoint_in_literal)]
fn main() {
    println!("{:?}", '‮');
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unicode codepoint changing visible direction of text present in literal
 --&gt; lint_example.rs:3:22
  |
3 |     println!("{:?}", '�');
  |                      ^-^
  |                      ||
  |                      |'\u{202e}'
  |                      this literal contains an invisible unicode text flow control codepoint
  |
  = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(text_direction_codepoint_in_literal)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = help: if their presence wasn't intentional, you can remove them
help: if you want to keep them but make them visible in your source code, you can escape them
  |
3 -     println!("{:?}", '�');
3 +     println!("{:?}", '\u{202e}');
  |

</code></pre>
<h2 id="unconditional-panic"><a class="header" href="#unconditional-panic">unconditional-panic</a></h2>
<p>The <code>unconditional_panic</code> lint detects an operation that will cause a
panic at runtime.</p>
<h3 id="example-41-2"><a class="header" href="#example-41-2">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>let x = 1 / 0;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this operation will panic at runtime
 --&gt; lint_example.rs:3:9
  |
3 | let x = 1 / 0;
  |         ^^^^^ attempt to divide `1_i32` by zero
  |
  = note: `#[deny(unconditional_panic)]` on by default

</code></pre>
<h3 id="explanation-41-2"><a class="header" href="#explanation-41-2">Explanation</a></h3>
<p>This lint detects code that is very likely incorrect because it will
always panic, such as division by zero and out-of-bounds array
accesses. Consider adjusting your code if this is a bug, or using the
<code>panic!</code> or <code>unreachable!</code> macro instead in case the panic is intended.</p>
<h2 id="undropped-manually-drops"><a class="header" href="#undropped-manually-drops">undropped-manually-drops</a></h2>
<p>The <code>undropped_manually_drops</code> lint check for calls to <code>std::mem::drop</code> with
a value of <code>std::mem::ManuallyDrop</code> which doesn’t drop.</p>
<h3 id="example-42-2"><a class="header" href="#example-42-2">Example</a></h3>
<pre><code class="language-rust compile_fail">struct S;
drop(std::mem::ManuallyDrop::new(S));</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: calls to `std::mem::drop` with `std::mem::ManuallyDrop` instead of the inner value does nothing
 --&gt; lint_example.rs:3:1
  |
3 | drop(std::mem::ManuallyDrop::new(S));
  | ^^^^^------------------------------^
  |      |
  |      argument has type `ManuallyDrop&lt;S&gt;`
  |
  = note: `#[deny(undropped_manually_drops)]` on by default
help: use `std::mem::ManuallyDrop::into_inner` to get the inner value
  |
3 | drop(std::mem::ManuallyDrop::into_inner(std::mem::ManuallyDrop::new(S)));
  |      +++++++++++++++++++++++++++++++++++                              +

</code></pre>
<h3 id="explanation-42-2"><a class="header" href="#explanation-42-2">Explanation</a></h3>
<p><code>ManuallyDrop</code> does not drop it’s inner value so calling <code>std::mem::drop</code> will
not drop the inner value of the <code>ManuallyDrop</code> either.</p>
<h2 id="unknown-crate-types"><a class="header" href="#unknown-crate-types">unknown-crate-types</a></h2>
<p>The <code>unknown_crate_types</code> lint detects an unknown crate type found in
a <a href="https://doc.rust-lang.org/reference/linkage.html"><code>crate_type</code> attribute</a>.</p>
<h3 id="example-43-2"><a class="header" href="#example-43-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![crate_type="lol"]
fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: invalid `crate_type` value
 --&gt; lint_example.rs:1:15
  |
1 | #![crate_type="lol"]
  |               ^^^^^
  |
  = note: `#[deny(unknown_crate_types)]` on by default

</code></pre>
<h3 id="explanation-43-2"><a class="header" href="#explanation-43-2">Explanation</a></h3>
<p>An unknown value give to the <code>crate_type</code> attribute is almost
certainly a mistake.</p>
<h2 id="useless-deprecated"><a class="header" href="#useless-deprecated">useless-deprecated</a></h2>
<p>The <code>useless_deprecated</code> lint detects deprecation attributes with no effect.</p>
<h3 id="example-44-2"><a class="header" href="#example-44-2">Example</a></h3>
<pre><code class="language-rust compile_fail">struct X;

#[deprecated = "message"]
impl Default for X {
    fn default() -&gt; Self {
        X
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `#[deprecated]` attribute cannot be used on trait impl blocks
 --&gt; lint_example.rs:4:1
  |
4 | #[deprecated = "message"]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = help: `#[deprecated]` can be applied to associated consts, associated types, constants, crates, data types, enum variants, foreign statics, functions, inherent impl blocks, macro defs, modules, statics, struct fields, traits, type aliases, unions, and use statements
  = note: `#[deny(useless_deprecated)]` on by default

</code></pre>
<h3 id="explanation-44-2"><a class="header" href="#explanation-44-2">Explanation</a></h3>
<p>Deprecation attributes have no effect on trait implementations.</p>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
    var fragments = {
        "#exceeding-bitshifts": "deny-by-default.html#arithmetic-overflow",
};
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
});
</script>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="json-output"><a class="header" href="#json-output">JSON Output</a></h1>
<p>This chapter documents the JSON structures emitted by <code>rustc</code>. JSON may be
enabled with the <a href="#option-error-format"><code>--error-format=json</code> flag</a>. Additional
options may be specified with the <a href="#option-json"><code>--json</code> flag</a> which can
change which messages are generated, and the format of the messages.</p>
<p>JSON messages are emitted one per line to stderr.</p>
<p>If parsing the output with Rust, the
<a href="https://crates.io/crates/cargo_metadata"><code>cargo_metadata</code></a> crate provides
some support for parsing the messages.</p>
<p>Each type of message has a <code>$message_type</code> field which can be used to
distinguish the different formats. When parsing, care should be taken
to be forwards-compatible with future changes to the format. Optional
values may be <code>null</code>. New fields may be added. Enumerated fields like
“level” or “suggestion_applicability” may add new values.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p>Diagnostic messages provide errors or possible concerns generated during
compilation. <code>rustc</code> provides detailed information about where the diagnostic
originates, along with hints and suggestions.</p>
<p>Diagnostics are arranged in a parent/child relationship where the parent
diagnostic value is the core of the diagnostic, and the attached children
provide additional context, help, and information.</p>
<p>Diagnostics have the following format:</p>
<pre><code class="language-javascript">{
    /* Type of this message */
    "$message_type": "diagnostic",
    /* The primary message. */
    "message": "unused variable: `x`",
    /* The diagnostic code.
       Some messages may set this value to null.
    */
    "code": {
        /* A unique string identifying which diagnostic triggered. */
        "code": "unused_variables",
        /* An optional string explaining more detail about the diagnostic code. */
        "explanation": null
    },
    /* The severity of the diagnostic.
       Values may be:
       - "error": A fatal error that prevents compilation.
       - "warning": A possible error or concern.
       - "note": Additional information or context about the diagnostic.
       - "help": A suggestion on how to resolve the diagnostic.
       - "failure-note": A note attached to the message for further information.
       - "error: internal compiler error": Indicates a bug within the compiler.
    */
    "level": "warning",
    /* An array of source code locations to point out specific details about
       where the diagnostic originates from. This may be empty, for example
       for some global messages, or child messages attached to a parent.

       Character offsets are offsets of Unicode Scalar Values.
    */
    "spans": [
        {
            /* The file where the span is located.
               Note that this path may not exist. For example, if the path
               points to the standard library, and the rust src is not
               available in the sysroot, then it may point to a nonexistent
               file. Beware that this may also point to the source of an
               external crate.
            */
            "file_name": "lib.rs",
            /* The byte offset where the span starts (0-based, inclusive). */
            "byte_start": 21,
            /* The byte offset where the span ends (0-based, exclusive). */
            "byte_end": 22,
            /* The first line number of the span (1-based, inclusive). */
            "line_start": 2,
            /* The last line number of the span (1-based, inclusive). */
            "line_end": 2,
            /* The first character offset of the line_start (1-based, inclusive). */
            "column_start": 9,
            /* The last character offset of the line_end (1-based, exclusive). */
            "column_end": 10,
            /* Whether or not this is the "primary" span.

               This indicates that this span is the focal point of the
               diagnostic.

               There are rare cases where multiple spans may be marked as
               primary. For example, "immutable borrow occurs here" and
               "mutable borrow ends here" can be two separate primary spans.

               The top (parent) message should always have at least one
               primary span, unless it has zero spans. Child messages may have
               zero or more primary spans.
            */
            "is_primary": true,
            /* An array of objects showing the original source code for this
               span. This shows the entire lines of text where the span is
               located. A span across multiple lines will have a separate
               value for each line.
            */
            "text": [
                {
                    /* The entire line of the original source code. */
                    "text": "    let x = 123;",
                    /* The first character offset of the line of
                       where the span covers this line (1-based, inclusive). */
                    "highlight_start": 9,
                    /* The last character offset of the line of
                       where the span covers this line (1-based, exclusive). */
                    "highlight_end": 10
                }
            ],
            /* An optional message to display at this span location.
               This is typically null for primary spans.
            */
            "label": null,
            /* An optional string of a suggested replacement for this span to
               solve the issue. Tools may try to replace the contents of the
               span with this text.
            */
            "suggested_replacement": null,
            /* An optional string that indicates the confidence of the
               "suggested_replacement". Tools may use this value to determine
               whether or not suggestions should be automatically applied.

               Possible values may be:
               - "MachineApplicable": The suggestion is definitely what the
                 user intended. This suggestion should be automatically
                 applied.
               - "MaybeIncorrect": The suggestion may be what the user
                 intended, but it is uncertain. The suggestion should result
                 in valid Rust code if it is applied.
               - "HasPlaceholders": The suggestion contains placeholders like
                 `(...)`. The suggestion cannot be applied automatically
                 because it will not result in valid Rust code. The user will
                 need to fill in the placeholders.
               - "Unspecified": The applicability of the suggestion is unknown.
            */
            "suggestion_applicability": null,
            /* An optional object indicating the expansion of a macro within
               this span.

               If a message occurs within a macro invocation, this object will
               provide details of where within the macro expansion the message
               is located.
            */
            "expansion": {
                /* The span of the macro invocation.
                   Uses the same span definition as the "spans" array.
                */
                "span": {/*...*/}
                /* Name of the macro, such as "foo!" or "#[derive(Eq)]". */
                "macro_decl_name": "some_macro!",
                /* Optional span where the relevant part of the macro is
                  defined. */
                "def_site_span": {/*...*/},
            }
        }
    ],
    /* Array of attached diagnostic messages.
       This is an array of objects using the same format as the parent
       message. Children are not nested (children do not themselves
       contain "children" definitions).
    */
    "children": [
        {
            "message": "`#[warn(unused_variables)]` on by default",
            "code": null,
            "level": "note",
            "spans": [],
            "children": [],
            "rendered": null
        },
        {
            "message": "if this is intentional, prefix it with an underscore",
            "code": null,
            "level": "help",
            "spans": [
                {
                    "file_name": "lib.rs",
                    "byte_start": 21,
                    "byte_end": 22,
                    "line_start": 2,
                    "line_end": 2,
                    "column_start": 9,
                    "column_end": 10,
                    "is_primary": true,
                    "text": [
                        {
                            "text": "    let x = 123;",
                            "highlight_start": 9,
                            "highlight_end": 10
                        }
                    ],
                    "label": null,
                    "suggested_replacement": "_x",
                    "suggestion_applicability": "MachineApplicable",
                    "expansion": null
                }
            ],
            "children": [],
            "rendered": null
        }
    ],
    /* Optional string of the rendered version of the diagnostic as displayed
       by rustc. Note that this may be influenced by the `--json` flag.
    */
    "rendered": "warning: unused variable: `x`\n --&gt; lib.rs:2:9\n  |\n2 |     let x = 123;\n  |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\n"
}
</code></pre>
<h2 id="artifact-notifications"><a class="header" href="#artifact-notifications">Artifact notifications</a></h2>
<p>Artifact notifications are emitted when the <a href="#option-json"><code>--json=artifacts</code>
flag</a> is used. They indicate that a file artifact has been saved
to disk. More information about emit kinds may be found in the <a href="#option-emit"><code>--emit</code>
flag</a> documentation. Notifications can contain more than one file
for each type, for example when using multiple codegen units.</p>
<pre><code class="language-javascript">{
    /* Type of this message */
    "$message_type": "artifact",
    /* The filename that was generated. */
    "artifact": "libfoo.rlib",
    /* The kind of artifact that was generated. Possible values:
       - "link": The generated crate as specified by the crate-type.
       - "dep-info": The `.d` file with dependency information in a Makefile-like syntax.
       - "metadata": The Rust `.rmeta` file containing metadata about the crate.
       - "asm": The `.s` file with generated assembly
       - "llvm-ir": The `.ll` file with generated textual LLVM IR
       - "llvm-bc": The `.bc` file with generated LLVM bitcode
       - "mir": The `.mir` file with rustc's mid-level intermediate representation.
       - "obj": The `.o` file with generated native object code
    */
    "emit": "link"
}
</code></pre>
<h2 id="future-incompatible-reports"><a class="header" href="#future-incompatible-reports">Future-incompatible reports</a></h2>
<p>If the <a href="#option-json"><code>--json=future-incompat</code></a> flag is used, then a separate
JSON structure will be emitted if the crate may stop compiling in the future.
This contains diagnostic information about the particular warnings that may be
turned into a hard error in the future. This will include the diagnostic
information, even if the diagnostics have been suppressed (such as with an
<code>#[allow]</code> attribute or the <code>--cap-lints</code> option).</p>
<pre><code class="language-javascript">{
    /* Type of this message */
    "$message_type": "future_incompat",
    /* An array of objects describing a warning that will become a hard error
       in the future.
    */
    "future_incompat_report":
    [
        {
            /* A diagnostic structure as defined in
               https://doc.rust-lang.org/rustc/json.html#diagnostics
            */
            "diagnostic": {...},
        }
    ]
}
</code></pre>
<h2 id="unused-dependency-notifications"><a class="header" href="#unused-dependency-notifications">Unused Dependency Notifications</a></h2>
<p>The options <code>--json=unused-externs</code> and <code>--json=unused-externs-silent</code> in
conjunction with the <code>unused-crate-dependencies</code> lint will emit JSON structures
reporting any crate dependencies (specified with <code>--extern</code>) which never had any
symbols referenced. These are intended to be consumed by the build system which
can then emit diagnostics telling the user to remove the unused dependencies
from <code>Cargo.toml</code> (or whatever build-system file defines dependencies).</p>
<p>The JSON structure is:</p>
<pre><code class="language-json">{
    "lint_level": "deny", /* Level of the warning */
    "unused_names": [
        "foo"  /* Names of unused crates, as specified with --extern foo=libfoo.rlib */
    ],
}
</code></pre>
<p>The warn/deny/forbid lint level (as defined either on the command line or in the
source) dictates the <code>lint_level</code> in the JSON. With <code>unused-externs</code>, a
<code>deny</code> or <code>forbid</code> level diagnostic will also cause <code>rustc</code> to exit with a
failure exit code.</p>
<p><code>unused-externs-silent</code> will report the diagnostic the same way, but will not
cause <code>rustc</code> to exit with failure - it’s up to the consumer to flag failure
appropriately. (This is needed by Cargo which shares the same dependencies
across multiple build targets, so it should only report an unused dependency if
its not used by any of the targets.)</p>
<h2 id="timings"><a class="header" href="#timings">Timings</a></h2>
<p><strong>This setting is currently unstable and requires usage of <code>-Zunstable-options</code>.</strong></p>
<p>The <code>--timings</code> option will tell <code>rustc</code> to emit messages when a certain compilation
section (such as code generation or linking) begins or ends. The messages currently have
the following format:</p>
<pre><code class="language-json">{
    "$message_type": "section_timing", /* Type of this message */
    "event": "start", /* Marks the "start" or "end" of the compilation section */
    "name": "link",  /* The name of the compilation section */
    // Opaque timestamp when the message was emitted, in microseconds
    // The timestamp is currently relative to the beginning of the compilation session
    "time": 12345
}
</code></pre>
<p>Note that the JSON format of the <code>timings</code> messages is unstable and subject to change.</p>
<p>Compilation sections can be nested; for example, if you encounter the start of “foo”,
then the start of “bar”, then the end of “bar” and then the end of “bar”, it means that the
“bar” section happened as a part of the “foo” section.</p>
<p>The timestamp should only be used for computing the duration of each section.</p>
<p>We currently do not guarantee any specific section names to be emitted.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p><code>rustc</code> has a built-in facility for building and running tests for a crate.
More information about writing and running tests may be found in the <a href="../book/ch11-00-testing.html">Testing
Chapter</a> of the Rust Programming Language book.</p>
<p>Tests are written as free functions with the <a href="../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code>
attribute</a>. For example:</p>
<pre><code class="language-rust">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}</code></pre>
<p>Tests “pass” if they return without an error. They “fail” if they <a href="../book/ch09-01-unrecoverable-errors-with-panic.html">panic</a>, or
return a type such as <a href="../std/result/index.html"><code>Result</code></a> that implements the <a href="../std/process/trait.Termination.html"><code>Termination</code></a> trait
with a non-zero value.</p>
<p>By passing the <a href="#option-test"><code>--test</code> option</a> to <code>rustc</code>, the compiler will build the crate
in a special mode to construct an executable that will run the tests in the
crate. The <code>--test</code> flag will make the following changes:</p>
<ul>
<li>The crate will be built as a <code>bin</code> <a href="../reference/linkage.html">crate type</a>, forcing it to be an
executable.</li>
<li>Links the executable with <a href="../test/index.html"><code>libtest</code></a>, the test harness that is part of the
standard library, which handles running the tests.</li>
<li>Synthesizes a <a href="../reference/crates-and-source-files.html#main-functions"><code>main</code> function</a> which will process command-line arguments
and run the tests. This new <code>main</code> function will replace any existing <code>main</code>
function as the entry point of the executable, though the existing <code>main</code>
will still be compiled.</li>
<li>Enables the <a href="../reference/conditional-compilation.html#test"><code>test</code> cfg option</a>, which allows your code to use conditional
compilation to detect if it is being built as a test.</li>
<li>Enables building of functions annotated with the <a href="../reference/attributes/testing.html#the-test-attribute"><code>test</code></a>
and <a href="#benchmarks"><code>bench</code></a> attributes, which will be run by the test
harness.</li>
</ul>
<p>After the executable is created, you can run it to execute the tests and
receive a report on what passes and fails. If you are using <a href="../cargo/index.html">Cargo</a> to manage
your project, it has a built-in <a href="../cargo/commands/cargo-test.html"><code>cargo test</code></a> command which handles all of
this automatically. An example of the output looks like this:</p>
<pre><code class="language-text">running 4 tests
test it_works ... ok
test check_valid_args ... ok
test invalid_characters ... ok
test walks_the_dog ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<blockquote>
<p><strong>Note</strong>: Tests must be built with the <a href="../book/ch09-01-unrecoverable-errors-with-panic.html"><code>unwind</code> panic
strategy</a>. This is because all tests run in the same
process, and they are intended to catch panics, which is not possible with
the <code>abort</code> strategy. See the unstable <a href="https://github.com/rust-lang/rust/issues/67650"><code>-Z panic-abort-tests</code></a> option for
experimental support of the <code>abort</code> strategy by spawning tests in separate
processes.</p>
</blockquote>
<h2 id="test-attributes"><a class="header" href="#test-attributes">Test attributes</a></h2>
<p>Tests are indicated using attributes on free functions. The following
attributes are used for testing, see the linked documentation for more
details:</p>
<ul>
<li><a href="../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> — Indicates a function is a test to be run.</li>
<li><code>#[bench]</code> — Indicates a function is a benchmark to be
run. Benchmarks are currently unstable and only available in the nightly
channel, see the <a href="../unstable-book/library-features/test.html">unstable docs</a> for more details.</li>
<li><a href="../reference/attributes/testing.html#the-should_panic-attribute"><code>#[should_panic]</code></a> — Indicates that the test
function will only pass if the function <a href="../book/ch09-01-unrecoverable-errors-with-panic.html">panics</a>.</li>
<li><a href="../reference/attributes/testing.html#the-ignore-attribute"><code>#[ignore]</code></a> — Indicates that the test function will be
compiled, but not run by default. See the <a href="#--ignored"><code>--ignored</code></a> and
<a href="#--include-ignored"><code>--include-ignored</code></a> options to run these tests.</li>
</ul>
<h2 id="cli-arguments"><a class="header" href="#cli-arguments">CLI arguments</a></h2>
<p>The libtest harness has several command-line arguments to control its
behavior.</p>
<blockquote>
<p>Note: When running with <a href="../cargo/commands/cargo-test.html"><code>cargo test</code></a>, the libtest CLI arguments must be
passed after the <code>--</code> argument to differentiate between flags for Cargo and
those for the harness. For example: <code>cargo test -- --no-capture</code></p>
</blockquote>
<h3 id="filters"><a class="header" href="#filters">Filters</a></h3>
<p>Positional arguments (those without a <code>-</code> prefix) are treated as filters which
will only run tests whose name matches one of those strings. The filter will
match any substring found in the full path of the test function. For example,
if the test function <code>it_works</code> is located in the module
<code>utils::paths::tests</code>, then any of the filters <code>works</code>, <code>path</code>, <code>utils::</code>, or
<code>utils::paths::tests::it_works</code> will match that test.</p>
<p>See <a href="#selection-options">Selection options</a> for more options to control which
tests are run.</p>
<h3 id="action-options"><a class="header" href="#action-options">Action options</a></h3>
<p>The following options perform different actions other than running tests.</p>
<h4 id="--list"><a class="header" href="#--list"><code>--list</code></a></h4>
<p>Prints a list of all tests and benchmarks. Does not run any of the tests.
<a href="#filters">Filters</a> can be used to list only matching tests.</p>
<h4 id="-h---help"><a class="header" href="#-h---help"><code>-h</code>, <code>--help</code></a></h4>
<p>Displays usage information and command-line options.</p>
<h3 id="selection-options"><a class="header" href="#selection-options">Selection options</a></h3>
<p>The following options change how tests are selected.</p>
<h4 id="--test"><a class="header" href="#--test"><code>--test</code></a></h4>
<p>This is the default mode where all tests will be run as well as running all
benchmarks with only a single iteration (to ensure the benchmark works,
without taking the time to actually perform benchmarking). This can be
combined with the <code>--bench</code> flag to run both tests and perform full
benchmarking.</p>
<h4 id="--bench"><a class="header" href="#--bench"><code>--bench</code></a></h4>
<p>This runs in a mode where tests are ignored, and only runs benchmarks. This
can be combined with <code>--test</code> to run both benchmarks and tests.</p>
<h4 id="--exact"><a class="header" href="#--exact"><code>--exact</code></a></h4>
<p>This forces <a href="#filters">filters</a> to match the full path of the test exactly.
For example, if the test <code>it_works</code> is in the module <code>utils::paths::tests</code>,
then only the string <code>utils::paths::tests::it_works</code> will match that test.</p>
<h4 id="--skip-filter"><a class="header" href="#--skip-filter"><code>--skip</code> <em>FILTER</em></a></h4>
<p>Skips any tests whose name contains the given <em>FILTER</em> string. This flag may
be passed multiple times.</p>
<h4 id="--ignored"><a class="header" href="#--ignored"><code>--ignored</code></a></h4>
<p>Runs only tests that are marked with the <a href="../reference/attributes/testing.html#the-ignore-attribute"><code>ignore</code>
attribute</a>.</p>
<h4 id="--include-ignored"><a class="header" href="#--include-ignored"><code>--include-ignored</code></a></h4>
<p>Runs both <a href="#--ignored">ignored</a> and non-ignored tests.</p>
<h4 id="--exclude-should-panic"><a class="header" href="#--exclude-should-panic"><code>--exclude-should-panic</code></a></h4>
<p>Excludes tests marked with the <a href="../reference/attributes/testing.html#the-should_panic-attribute"><code>should_panic</code>
attribute</a>.</p>
<p>⚠️ 🚧 This option is <a href="#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/82348">tracking issue
#82348</a> for more information.</p>
<h3 id="execution-options"><a class="header" href="#execution-options">Execution options</a></h3>
<p>The following options affect how tests are executed.</p>
<h4 id="--fail-fast"><a class="header" href="#--fail-fast"><code>--fail-fast</code></a></h4>
<p>Stops tests after the first failure.</p>
<p>If running tests in parallel (which is the default), then tests that have already been started on
other threads will be allowed to run to completion before the process exits.</p>
<p>Note that when running tests in parallel, the test execution order is non-deterministic:
if multiple tests would fail, the first failure encountered will be reported.</p>
<p>⚠️ 🚧 This requires the <code>-Z unstable-options</code> flag.</p>
<h4 id="--test-threads-num_threads"><a class="header" href="#--test-threads-num_threads"><code>--test-threads</code> <em>NUM_THREADS</em></a></h4>
<p>Sets the number of threads to use for running tests in parallel. By default,
uses the amount of concurrency available on the hardware as indicated by
<a href="../std/thread/fn.available_parallelism.html"><code>available_parallelism</code></a>.</p>
<p>Deprecated: this can also be specified with the <code>RUST_TEST_THREADS</code> environment variable.</p>
<h4 id="--force-run-in-process"><a class="header" href="#--force-run-in-process"><code>--force-run-in-process</code></a></h4>
<p>Forces the tests to run in a single process when using the <a href="../book/ch09-01-unrecoverable-errors-with-panic.html"><code>abort</code> panic
strategy</a>.</p>
<p>⚠️ 🚧 This only works with the unstable <a href="https://github.com/rust-lang/rust/issues/67650"><code>-Z panic-abort-tests</code></a> option, and
requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/67650">tracking issue
#67650</a> for more information.</p>
<h4 id="--ensure-time"><a class="header" href="#--ensure-time"><code>--ensure-time</code></a></h4>
<p>⚠️ 🚧 This option is <a href="#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/64888">tracking issue
#64888</a> and the <a href="../unstable-book/compiler-flags/report-time.html">unstable
docs</a> for more information.</p>
<h4 id="--shuffle"><a class="header" href="#--shuffle"><code>--shuffle</code></a></h4>
<p>Runs the tests in random order, as opposed to the default alphabetical order.</p>
<p>Deprecated: this may also be specified by setting the <code>RUST_TEST_SHUFFLE</code> environment
variable to anything but <code>0</code>.</p>
<p>The random number generator seed that is output can be passed to
<a href="#--shuffle-seed-seed"><code>--shuffle-seed</code></a> to run the tests in the same order
again.</p>
<p>Note that <code>--shuffle</code> does not affect whether the tests are run in parallel. To
run the tests in random order sequentially, use <code>--shuffle --test-threads 1</code>.</p>
<p>⚠️ 🚧 This option is <a href="#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/89583">tracking issue
#89583</a> for more information.</p>
<h4 id="--shuffle-seed-seed"><a class="header" href="#--shuffle-seed-seed"><code>--shuffle-seed</code> <em>SEED</em></a></h4>
<p>Like <a href="#--shuffle"><code>--shuffle</code></a>, but seeds the random number generator with
<em>SEED</em>. Thus, calling the test harness with <code>--shuffle-seed</code> <em>SEED</em> twice runs
the tests in the same order both times.</p>
<p><em>SEED</em> is any 64-bit unsigned integer, for example, one produced by
<a href="#--shuffle"><code>--shuffle</code></a>.</p>
<p>Deprecated: this can also be specified with the <code>RUST_TEST_SHUFFLE_SEED</code> environment
variable.</p>
<p>⚠️ 🚧 This option is <a href="#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/89583">tracking issue
#89583</a> for more information.</p>
<h3 id="output-options"><a class="header" href="#output-options">Output options</a></h3>
<p>The following options affect the output behavior.</p>
<h4 id="-q---quiet"><a class="header" href="#-q---quiet"><code>-q</code>, <code>--quiet</code></a></h4>
<p>Displays one character per test instead of one line per test. This is an alias
for <a href="#--format-format"><code>--format=terse</code></a>.</p>
<h4 id="--no-capture"><a class="header" href="#--no-capture"><code>--no-capture</code></a></h4>
<p>Does not capture the stdout and stderr of the test, and allows tests to print
to the console. Usually the output is captured, and only displayed if the test
fails.</p>
<p>Deprecated: this may also be specified by setting the <code>RUST_TEST_NOCAPTURE</code> environment
variable to anything but <code>0</code>.</p>
<p><code>--nocapture</code> is a deprecated alias for <code>--no-capture</code>.</p>
<h4 id="--show-output"><a class="header" href="#--show-output"><code>--show-output</code></a></h4>
<p>Displays the stdout and stderr of successful tests after all tests have run.</p>
<p>Contrast this with <a href="#--no-capture"><code>--no-capture</code></a> which allows tests to print
<em>while they are running</em>, which can cause interleaved output if there are
multiple tests running in parallel, <code>--show-output</code> ensures the output is
contiguous, but requires waiting for all tests to finish.</p>
<h4 id="--color-color"><a class="header" href="#--color-color"><code>--color</code> <em>COLOR</em></a></h4>
<p>Control when colored terminal output is used. Valid options:</p>
<ul>
<li><code>auto</code>: Colorize if stdout is a tty and <a href="#--no-capture"><code>--no-capture</code></a> is not
used. This is the default.</li>
<li><code>always</code>: Always colorize the output.</li>
<li><code>never</code>: Never colorize the output.</li>
</ul>
<h4 id="--format-format"><a class="header" href="#--format-format"><code>--format</code> <em>FORMAT</em></a></h4>
<p>Controls the format of the output. Valid options:</p>
<ul>
<li><code>pretty</code>: This is the default format, with one line per test.</li>
<li><code>terse</code>: Displays only a single character per test. <a href="#-q---quiet"><code>--quiet</code></a>
is an alias for this option.</li>
<li><code>json</code>: Emits JSON objects, one per line. ⚠️ 🚧 This option is
<a href="#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag.
See <a href="https://github.com/rust-lang/rust/issues/49359">tracking issue #49359</a>
for more information.</li>
</ul>
<h4 id="--logfile-path"><a class="header" href="#--logfile-path"><code>--logfile</code> <em>PATH</em></a></h4>
<p>Writes the results of the tests to the given file.</p>
<p>This option is deprecated.</p>
<h4 id="--report-time"><a class="header" href="#--report-time"><code>--report-time</code></a></h4>
<p>⚠️ 🚧 This option is <a href="#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/64888">tracking issue
#64888</a> and the <a href="../unstable-book/compiler-flags/report-time.html">unstable
docs</a> for more information.</p>
<h3 id="unstable-options"><a class="header" href="#unstable-options">Unstable options</a></h3>
<p>Some CLI options are added in an “unstable” state, where they are intended for
experimentation and testing to determine if the option works correctly, has
the right design, and is useful. The option may not work correctly, break, or
change at any time. To signal that you acknowledge that you are using an
unstable option, they require passing the <code>-Z unstable-options</code> command-line
flag.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>The libtest harness supports running benchmarks for functions annotated with
the <code>#[bench]</code> attribute. Benchmarks are currently unstable, and only
available on the <a href="../book/appendix-07-nightly-rust.html">nightly channel</a>. More information may be found in the
<a href="../unstable-book/library-features/test.html">unstable book</a>.</p>
<h2 id="custom-test-frameworks"><a class="header" href="#custom-test-frameworks">Custom test frameworks</a></h2>
<p>Experimental support for using custom test harnesses is available on the
<a href="../book/appendix-07-nightly-rust.html">nightly channel</a>. See <a href="https://github.com/rust-lang/rust/issues/50297">tracking issue
#50297</a> and the
<a href="../unstable-book/language-features/custom-test-frameworks.html">custom_test_frameworks documentation</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="targets"><a class="header" href="#targets">Targets</a></h1>
<p><code>rustc</code> is a cross-compiler by default. This means that you can use any compiler to build for any
architecture. The list of <em>targets</em> are the possible architectures that you can build for. See
the <a href="#platform-support">Platform Support</a> page for a detailed list of targets, or
<a href="#built-in-targets">Built-in Targets</a> for instructions on how to view what is available for your version
of <code>rustc</code>.</p>
<p>To see all the options that you can set with a target, see the docs
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/struct.Target.html">here</a>.</p>
<p>To compile to a particular target, use the <code>--target</code> flag:</p>
<pre><code class="language-bash">$ rustc src/main.rs --target=wasm32-unknown-unknown
</code></pre>
<h2 id="target-features-1"><a class="header" href="#target-features-1">Target Features</a></h2>
<p><code>x86</code>,  and <code>ARMv8</code> are two popular CPU architectures. Their instruction sets form a common baseline across most CPUs. However, some CPUs extend these with custom instruction sets, e.g. vector (<code>AVX</code>), bitwise manipulation (<code>BMI</code>) or cryptographic (<code>AES</code>).</p>
<p>Developers, who know on which CPUs their compiled code is going to run can choose to add (or remove) CPU specific instruction sets via the <code>-C target-feature=val</code> flag.</p>
<p>Please note, that this flag is generally considered as unsafe. More details can be found in <a href="#known-issues">this section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="built-in-targets"><a class="header" href="#built-in-targets">Built-in Targets</a></h1>
<p><code>rustc</code> ships with the ability to compile to many targets automatically, we
call these “built-in” targets, and they generally correspond to targets that
the team is supporting directly. To see the list of built-in targets, you can
run <code>rustc --print target-list</code>.</p>
<p>Typically, a target needs a compiled copy of the Rust standard library to
work. If using <a href="https://github.com/rust-lang/rustup">rustup</a>, then check out the documentation on
<a href="https://rust-lang.github.io/rustup/cross-compilation.html">Cross-compilation</a> on how to download a pre-built standard
library built by the official Rust distributions. Most targets will need a
system linker, and possibly other things.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-targets"><a class="header" href="#custom-targets">Custom Targets</a></h1>
<p>If you’d like to build for a target that is not yet supported by <code>rustc</code>, you can use a
“custom target specification” to define a target. These target specification files
are JSON. To see the JSON for the host target, you can run:</p>
<pre><code class="language-bash">rustc +nightly -Z unstable-options --print target-spec-json
</code></pre>
<p>To see it for a different target, add the <code>--target</code> flag:</p>
<pre><code class="language-bash">rustc +nightly -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json
</code></pre>
<p>To use a custom target, see the (unstable) <a href="../cargo/reference/unstable.html#build-std"><code>build-std</code> feature</a> of <code>cargo</code>.</p>
<div class="warning">
<p>The target JSON properties are not stable and subject to change.
Always pin your compiler version when using custom targets!</p>
</div>

<h2 id="json-schema"><a class="header" href="#json-schema">JSON Schema</a></h2>
<p><code>rustc</code> provides a JSON schema for the custom target JSON specification.
Because the schema is subject to change, you should always use the schema from the version of rustc which you are passing the target to.</p>
<p>It can be found in <code>etc/target-spec-json-schema.json</code> in the sysroot (<code>rustc --print sysroot</code>) or printed with <code>rustc +nightly -Zunstable-options --print target-spec-json-schema</code>.
The existence and name of this schema is, just like the properties of the JSON specification, not stable and subject to change.</p>
<h2 id="custom-target-lookup-path"><a class="header" href="#custom-target-lookup-path">Custom Target Lookup Path</a></h2>
<p>When <code>rustc</code> is given an option <code>--target=TARGET</code> (where <code>TARGET</code> is any string), it uses the following logic:</p>
<ol>
<li>if <code>TARGET</code> is the name of a built-in target, use that</li>
<li>if <code>TARGET</code> is a path to a file, read that file as a json target</li>
<li>otherwise, search the colon-separated list of directories found
in the <code>RUST_TARGET_PATH</code> environment variable from left to right
for a file named <code>TARGET.json</code>.</li>
</ol>
<p>These steps are tried in order, so if there are multiple potentially valid
interpretations for a target, whichever is found first will take priority.
If none of these methods find a target, an error is thrown.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h1>
<p>This section informs you about known “gotchas”. Keep in mind, that this section is (and always will be) incomplete. For suggestions and amendments, feel free to <a href="#contributing-to-rustc">contribute</a> to this guide.</p>
<h2 id="target-features-2"><a class="header" href="#target-features-2">Target Features</a></h2>
<p>Most target-feature problems arise, when mixing code that have the target-feature <em>enabled</em> with code that have it <em>disabled</em>. If you want to avoid undefined behavior, it is recommended to build <em>all code</em> (including the standard library and imported crates) with a common set of target-features.</p>
<p>By default, compiling your code with the <code>-C target-feature</code> flag will not recompile the entire standard library and/or imported crates with matching target features. Therefore, target features are generally considered as unsafe. Using <code>#[target_feature]</code> on individual functions makes the function unsafe.</p>
<p>Examples:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target-Feature</th><th>Issue</th><th>Seen on</th><th>Description</th><th>Details</th></tr>
</thead>
<tbody>
<tr><td><code>+soft-float</code> <br> and <br> <code>-sse</code></td><td>Segfaults and ABI mismatches</td><td><code>x86</code> and <code>x86-64</code></td><td>The <code>x86</code> and <code>x86_64</code> architecture uses SSE registers (aka <code>xmm</code>) for floating point operations. Using software emulated floats (“soft-floats”) disables usage of <code>xmm</code> registers, but parts of Rust’s core libraries (e.g. <code>std::f32</code> or <code>std::f64</code>) are compiled without soft-floats and expect parameters to be passed in <code>xmm</code> registers. This leads to ABI mismatches. <br><br>  Attempting to compile with disabled SSE causes the same error, too.</td><td><a href="https://github.com/rust-lang/rust/issues/63466">#63466</a></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="profile-guided-optimization"><a class="header" href="#profile-guided-optimization">Profile-guided Optimization</a></h1>
<p><code>rustc</code> supports doing profile-guided optimization (PGO).
This chapter describes what PGO is, what it is good for, and how it can be used.</p>
<h2 id="what-is-profile-guided-optimization"><a class="header" href="#what-is-profile-guided-optimization">What Is Profile-Guided Optimization?</a></h2>
<p>The basic concept of PGO is to collect data about the typical execution of
a program (e.g. which branches it is likely to take) and then use this data
to inform optimizations such as inlining, machine-code layout,
register allocation, etc.</p>
<p>There are different ways of collecting data about a program’s execution.
One is to run the program inside a profiler (such as <code>perf</code>) and another
is to create an instrumented binary, that is, a binary that has data
collection built into it, and run that.
The latter usually provides more accurate data and it is also what is
supported by <code>rustc</code>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Generating a PGO-optimized program involves following a workflow with four steps:</p>
<ol>
<li>Compile the program with instrumentation enabled
(e.g. <code>rustc -Cprofile-generate=/tmp/pgo-data main.rs</code>)</li>
<li>Run the instrumented program (e.g. <code>./main</code>) which generates a
<code>default_&lt;id&gt;.profraw</code> file</li>
<li>Convert the <code>.profraw</code> file into a <code>.profdata</code> file using
LLVM’s <code>llvm-profdata</code> tool</li>
<li>Compile the program again, this time making use of the profiling data
(for example <code>rustc -Cprofile-use=merged.profdata main.rs</code>)</li>
</ol>
<p>An instrumented program will create one or more <code>.profraw</code> files, one for each
instrumented binary. E.g. an instrumented executable that loads two instrumented
dynamic libraries at runtime will generate three <code>.profraw</code> files. Running an
instrumented binary multiple times, on the other hand, will re-use the
respective <code>.profraw</code> files, updating them in place.</p>
<p>These <code>.profraw</code> files have to be post-processed before they can be fed back
into the compiler. This is done by the <code>llvm-profdata</code> tool. This tool
is most easily installed via</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview
</code></pre>
<p>Note that installing the <code>llvm-tools-preview</code> component won’t add
<code>llvm-profdata</code> to the <code>PATH</code>. Rather, the tool can be found in:</p>
<pre><code class="language-bash">~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/&lt;target-triple&gt;/bin/
</code></pre>
<p>Alternatively, an <code>llvm-profdata</code> coming with a recent LLVM or Clang
version usually works too.</p>
<p>The <code>llvm-profdata</code> tool merges multiple <code>.profraw</code> files into a single
<code>.profdata</code> file that can then be fed back into the compiler via
<code>-Cprofile-use</code>:</p>
<pre><code class="language-bash"># STEP 1: Compile the binary with instrumentation
rustc -Cprofile-generate=/tmp/pgo-data -O ./main.rs

# STEP 2: Run the binary a few times, maybe with common sets of args.
#         Each run will create or update `.profraw` files in /tmp/pgo-data
./main mydata1.csv
./main mydata2.csv
./main mydata3.csv

# STEP 3: Merge and post-process all the `.profraw` files in /tmp/pgo-data
llvm-profdata merge -o ./merged.profdata /tmp/pgo-data

# STEP 4: Use the merged `.profdata` file during optimization. All `rustc`
#         flags have to be the same.
rustc -Cprofile-use=./merged.profdata -O ./main.rs
</code></pre>
<h3 id="a-complete-cargo-workflow"><a class="header" href="#a-complete-cargo-workflow">A Complete Cargo Workflow</a></h3>
<p>Using this feature with Cargo works very similar to using it with <code>rustc</code>
directly. Again, we generate an instrumented binary, run it to produce data,
merge the data, and feed it back into the compiler. Some things of note:</p>
<ul>
<li>
<p>We use the <code>RUSTFLAGS</code> environment variable in order to pass the PGO compiler
flags to the compilation of all crates in the program.</p>
</li>
<li>
<p>We pass the <code>--target</code> flag to Cargo, which prevents the <code>RUSTFLAGS</code>
arguments to be passed to Cargo build scripts. We don’t want the build
scripts to generate a bunch of <code>.profraw</code> files.</p>
</li>
<li>
<p>We pass <code>--release</code> to Cargo because that’s where PGO makes the most sense.
In theory, PGO can also be done on debug builds but there is little reason
to do so.</p>
</li>
<li>
<p>It is recommended to use <em>absolute paths</em> for the argument of
<code>-Cprofile-generate</code> and <code>-Cprofile-use</code>. Cargo can invoke <code>rustc</code> with
varying working directories, meaning that <code>rustc</code> will not be able to find
the supplied <code>.profdata</code> file. With absolute paths this is not an issue.</p>
</li>
<li>
<p>It is good practice to make sure that there is no left-over profiling data
from previous compilation sessions. Just deleting the directory is a simple
way of doing so (see <code>STEP 0</code> below).</p>
</li>
</ul>
<p>This is what the entire workflow looks like:</p>
<pre><code class="language-bash"># STEP 0: Make sure there is no left-over profiling data from previous runs
rm -rf /tmp/pgo-data

# STEP 1: Build the instrumented binaries
RUSTFLAGS="-Cprofile-generate=/tmp/pgo-data" \
    cargo build --release --target=x86_64-unknown-linux-gnu

# STEP 2: Run the instrumented binaries with some typical data
./target/x86_64-unknown-linux-gnu/release/myprogram mydata1.csv
./target/x86_64-unknown-linux-gnu/release/myprogram mydata2.csv
./target/x86_64-unknown-linux-gnu/release/myprogram mydata3.csv

# STEP 3: Merge the `.profraw` files into a `.profdata` file
llvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data

# STEP 4: Use the `.profdata` file for guiding optimizations
RUSTFLAGS="-Cprofile-use=/tmp/pgo-data/merged.profdata" \
    cargo build --release --target=x86_64-unknown-linux-gnu
</code></pre>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<ul>
<li>
<p>It is recommended to pass <code>-Cllvm-args=-pgo-warn-missing-function</code> during the
<code>-Cprofile-use</code> phase. LLVM by default does not warn if it cannot find
profiling data for a given function. Enabling this warning will make it
easier to spot errors in your setup.</p>
</li>
<li>
<p>There is a <a href="https://github.com/rust-lang/cargo/issues/7416">known issue</a> in
Cargo prior to version 1.39 that will prevent PGO from working correctly. Be
sure to use Cargo 1.39 or newer when doing PGO.</p>
</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<p><code>rustc</code>’s PGO support relies entirely on LLVM’s implementation of the feature
and is equivalent to what Clang offers via the <code>-fprofile-generate</code> /
<code>-fprofile-use</code> flags. The <a href="https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization">Profile Guided Optimization</a> section
in Clang’s documentation is therefore an interesting read for anyone who wants
to use PGO with Rust.</p>
<h2 id="community-maintained-tools"><a class="header" href="#community-maintained-tools">Community Maintained Tools</a></h2>
<p>As an alternative to directly using the compiler for Profile-Guided Optimization,
you may choose to go with <code>cargo-pgo</code>, which has an intuitive command-line API
and saves you the trouble of doing all the manual work. You can read more about
it in their repository accessible from this link: https://github.com/Kobzol/cargo-pgo</p>
<p>For the sake of completeness, here are the corresponding steps using <code>cargo-pgo</code>:</p>
<pre><code class="language-bash"># Install if you haven't already
cargo install cargo-pgo

cargo pgo build
cargo pgo optimize
</code></pre>
<p>These steps will do the following just as before:</p>
<ol>
<li>Build an instrumented binary from the source code.</li>
<li>Run the instrumented binary to gather PGO profiles.</li>
<li>Use the gathered PGO profiles from the last step to build an optimized binary.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="instrumentation-based-code-coverage"><a class="header" href="#instrumentation-based-code-coverage">Instrumentation-based Code Coverage</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This document describes how to enable and use LLVM instrumentation-based coverage,
via the <code>-C instrument-coverage</code> compiler flag.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>When <code>-C instrument-coverage</code> is enabled, the Rust compiler enhances rust-based libraries and binaries by:</p>
<ul>
<li>Automatically injecting calls to an LLVM intrinsic (<a href="https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic"><code>llvm.instrprof.increment</code></a>), at functions and branches in compiled code, to increment counters when conditional sections of code are executed.</li>
<li>Embedding additional information in the data section of each library and binary (using the <a href="https://llvm.org/docs/CoverageMappingFormat.html">LLVM Code Coverage Mapping Format</a> <em>Version 5</em>, if compiling with LLVM 12, or <em>Version 6</em>, if compiling with LLVM 13 or higher), to define the code regions (start and end positions in the source code) being counted.</li>
</ul>
<p>When running a coverage-instrumented program, the counter values are written to a <code>profraw</code> file at program termination. LLVM bundles tools that read the counter results, combine those results with the coverage map (embedded in the program binary), and generate coverage reports in multiple formats.</p>
<blockquote>
<p><strong>Note</strong>: <code>-C instrument-coverage</code> also automatically enables <code>-C symbol-mangling-version=v0</code> (tracking issue <a href="https://github.com/rust-lang/rust/issues/60705">#60705</a>). The <code>v0</code> symbol mangler is strongly recommended. The <code>v0</code> demangler can be overridden by explicitly adding <code>-Z unstable-options -C symbol-mangling-version=legacy</code>.</p>
</blockquote>
<h2 id="enable-coverage-profiling-in-the-rust-compiler"><a class="header" href="#enable-coverage-profiling-in-the-rust-compiler">Enable coverage profiling in the Rust compiler</a></h2>
<p>Rust’s source-based code coverage requires the Rust “profiler runtime”. Without it, compiling with <code>-C instrument-coverage</code> generates an error that the profiler runtime is missing.</p>
<p>The Rust <code>nightly</code> distribution channel includes the profiler runtime, by default.</p>
<blockquote>
<p><strong>Important</strong>: If you are building the Rust compiler from the source distribution, the profiler runtime is <em>not</em> enabled in the default <code>bootstrap.example.toml</code>. Edit your <code>bootstrap.toml</code> file and ensure the <code>profiler</code> feature is set it to <code>true</code> (either under the <code>[build]</code> section, or under the settings for an individual <code>[target.&lt;triple&gt;]</code>):</p>
<pre><code class="language-toml"># Build the profiler runtime (required when compiling with options that depend
# on this runtime, such as `-C profile-generate` or `-C instrument-coverage`).
profiler = true
</code></pre>
</blockquote>
<h3 id="building-the-demangler"><a class="header" href="#building-the-demangler">Building the demangler</a></h3>
<p>LLVM coverage reporting tools generate results that can include function names and other symbol references, and the raw coverage results report symbols using the compiler’s “mangled” version of the symbol names, which can be difficult to interpret. To work around this issue, LLVM coverage tools also support a user-specified symbol name demangler.</p>
<p>One option for a Rust demangler is <a href="https://crates.io/crates/rustfilt"><code>rustfilt</code></a>, which can be installed with:</p>
<pre><code class="language-shell">cargo install rustfilt
</code></pre>
<h2 id="compiling-with-coverage-enabled"><a class="header" href="#compiling-with-coverage-enabled">Compiling with coverage enabled</a></h2>
<p>Set the <code>-C instrument-coverage</code> compiler flag in order to enable LLVM source-based code coverage profiling.</p>
<p>The default option generates coverage for all functions, including unused (never called) functions and generics. The compiler flag supports an optional value to tailor this behavior. (See <a href="#-c-instrument-coverageoptions"><code>-C instrument-coverage=&lt;options&gt;</code></a>, below.)</p>
<p>With <code>cargo</code>, you can instrument your program binary <em>and</em> dependencies at the same time.</p>
<p>For example (if your project’s Cargo.toml builds a binary by default):</p>
<pre><code class="language-shell">$ cd your-project
$ cargo clean
$ RUSTFLAGS="-C instrument-coverage" cargo build
</code></pre>
<p>If <code>cargo</code> is not configured to use your <code>profiler</code>-enabled version of <code>rustc</code>, set the path explicitly via the <code>RUSTC</code> environment variable. Here is another example, using a <code>stage1</code> build of <code>rustc</code> to compile an <code>example</code> binary (from the <a href="https://crates.io/crates/json5format"><code>json5format</code></a> crate):</p>
<pre><code class="language-shell">$ RUSTC=$HOME/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc \
    RUSTFLAGS="-C instrument-coverage" \
    cargo build --example formatjson5
</code></pre>
<blockquote>
<p><strong>Note</strong>: that some compiler options, combined with <code>-C instrument-coverage</code>, can produce LLVM IR and/or linked binaries that are incompatible with LLVM coverage maps. For example, coverage requires references to actual functions in LLVM IR. If any covered function is optimized out, the coverage tools may not be able to process the coverage results. If you need to pass additional options, with coverage enabled, test them early, to confirm you will get the coverage results you expect.</p>
</blockquote>
<h2 id="running-the-instrumented-binary-to-generate-raw-coverage-profiling-data"><a class="header" href="#running-the-instrumented-binary-to-generate-raw-coverage-profiling-data">Running the instrumented binary to generate raw coverage profiling data</a></h2>
<p>In the previous example, <code>cargo</code> generated the coverage-instrumented binary <code>formatjson5</code>:</p>
<pre><code class="language-shell">$ echo "{some: 'thing'}" | target/debug/examples/formatjson5 -
</code></pre>
<pre><code class="language-json5">{
    some: "thing",
}
</code></pre>
<p>After running this program, a new file named like <code>default_11699812450447639123_0_20944</code> should be in the current working directory.
A new, unique file name will be generated each time the program is run to avoid overwriting previous data.</p>
<pre><code class="language-shell">$ echo "{some: 'thing'}" | target/debug/examples/formatjson5 -
...
$ ls default_*.profraw
default_11699812450447639123_0_20944.profraw
</code></pre>
<p>You can also set a specific file name or path for the generated <code>.profraw</code> files by using the environment variable <code>LLVM_PROFILE_FILE</code>:</p>
<pre><code class="language-shell">$ echo "{some: 'thing'}" \
    | LLVM_PROFILE_FILE="formatjson5.profraw" target/debug/examples/formatjson5 -
...
$ ls formatjson5.profraw
formatjson5.profraw
</code></pre>
<p>If <code>LLVM_PROFILE_FILE</code> contains a path to a nonexistent directory, the missing directory structure will be created. Additionally, the following special pattern strings are rewritten:</p>
<ul>
<li><code>%p</code> - The process ID.</li>
<li><code>%h</code> - The hostname of the machine running the program.</li>
<li><code>%t</code> - The value of the TMPDIR environment variable.</li>
<li><code>%Nm</code> - the instrumented binary’s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. <code>N</code> must be between <code>1</code> and <code>9</code>, and defaults to <code>1</code> if omitted (with simply <code>%m</code>).</li>
<li><code>%c</code> - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.</li>
</ul>
<p>In the first example above, the value <code>11699812450447639123_0</code> in the generated filename is the instrumented binary’s signature,
which replaced the <code>%m</code> pattern and the value <code>20944</code> is the process ID of the binary being executed.</p>
<h2 id="installing-llvm-coverage-tools"><a class="header" href="#installing-llvm-coverage-tools">Installing LLVM coverage tools</a></h2>
<p>LLVM’s supplies two tools—<code>llvm-profdata</code> and <code>llvm-cov</code>—that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 12 or higher, and processing the <em>raw</em> data may require exactly the LLVM version used by the compiler. (<code>llvm-cov --version</code> typically shows the tool’s LLVM version number, and <code>rustc --verbose --version</code> shows the version of LLVM used by the Rust compiler.)</p>
<ul>
<li>You can install compatible versions of these tools via the <code>rustup</code> component <code>llvm-tools-preview</code>. This component is the recommended path, though the specific tools available and their interface is not currently subject to Rust’s usual stability guarantees. In this case, you may also find <code>cargo-binutils</code> useful as a wrapper around these tools.</li>
<li>You can install a compatible version of LLVM tools from your operating system distribution, or from your distribution of LLVM.</li>
<li>If you are building the Rust compiler from source, you can optionally use the bundled LLVM tools, built from source. Those tool binaries can typically be found in your build platform directory at something like: <code>rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-*</code>.</li>
</ul>
<p>The examples in this document show how to use the llvm tools directly.</p>
<h2 id="creating-coverage-reports"><a class="header" href="#creating-coverage-reports">Creating coverage reports</a></h2>
<p>Raw profiles have to be indexed before they can be used to generate coverage reports. This is done using <a href="https://llvm.org/docs/CommandGuide/llvm-profdata.html#profdata-merge"><code>llvm-profdata merge</code></a>, which can combine multiple raw profiles and index them at the same time:</p>
<pre><code class="language-shell">$ llvm-profdata merge -sparse formatjson5.profraw -o formatjson5.profdata
</code></pre>
<p>Finally, the <code>.profdata</code> file is used, in combination with the coverage map (from the program binary) to generate coverage reports using <a href="https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-report"><code>llvm-cov report</code></a>, for a coverage summaries; and <a href="https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-show"><code>llvm-cov show</code></a>, to see detailed coverage of lines and regions (character ranges) overlaid on the original source code.</p>
<p>These commands have several display and filtering options. For example:</p>
<pre><code class="language-shell">$ llvm-cov show -Xdemangler=rustfilt target/debug/examples/formatjson5 \
    -instr-profile=formatjson5.profdata \
    -show-line-counts-or-regions \
    -show-instantiations \
    -name=add_quoted_string
</code></pre>
<img alt="Screenshot of sample `llvm-cov show` result, for function add_quoted_string" src="images/llvm-cov-show-01.png" class="center" />
<br />
<br />
<p>Some of the more notable options in this example include:</p>
<ul>
<li><code>--Xdemangler=rustfilt</code> - the command name or path used to demangle Rust symbols (<code>rustfilt</code> in the example)</li>
<li><code>target/debug/examples/formatjson5</code> - the instrumented binary (from which to extract the coverage map)</li>
<li><code>--instr-profile=&lt;path-to-file&gt;.profdata</code> - the location of the <code>.profdata</code> file created by <code>llvm-profdata merge</code> (from the <code>.profraw</code> file generated by the instrumented binary)</li>
<li><code>--name=&lt;exact-function-name&gt;</code> - to show coverage for a specific function (or, consider using another filter option, such as <code>--name-regex=&lt;pattern&gt;</code>)</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Coverage can also be disabled on an individual function by annotating the function with the [<code>coverage(off)</code> attribute] (which requires the feature flag <code>#![feature(coverage)]</code>).</p>
</blockquote>
<h2 id="interpreting-reports"><a class="header" href="#interpreting-reports">Interpreting reports</a></h2>
<p>There are four statistics tracked in a coverage summary:</p>
<ul>
<li>Function coverage is the percentage of functions that have been executed at least once. A function is considered to be executed if any of its instantiations are executed.</li>
<li>Instantiation coverage is the percentage of function instantiations that have been executed at least once. Generic functions and functions generated from macros are two kinds of functions that may have multiple instantiations.</li>
<li>Line coverage is the percentage of code lines that have been executed at least once. Only executable lines within function bodies are considered to be code lines.</li>
<li>Region coverage is the percentage of code regions that have been executed at least once. A code region may span multiple lines: for example, in a large function body with no control flow. In other cases, a single line can contain multiple code regions: <code>return x || (y &amp;&amp; z)</code> has countable code regions for <code>x</code> (which may resolve the expression, if <code>x</code> is <code>true</code>), <code>|| (y &amp;&amp; z)</code> (executed only if <code>x</code> was <code>false</code>), and <code>return</code> (executed in either situation).</li>
</ul>
<p>Of these four statistics, function coverage is usually the least granular while region coverage is the most granular. The project-wide totals for each statistic are listed in the summary.</p>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test coverage</a></h2>
<p>A typical use case for coverage analysis is test coverage. Rust’s source-based coverage tools can both measure your tests’ code coverage as percentage, and pinpoint functions and branches not tested.</p>
<p>The following example (using the <a href="https://crates.io/crates/json5format"><code>json5format</code></a> crate, for demonstration purposes) show how to generate and analyze coverage results for all tests in a crate.</p>
<p>Since <code>cargo test</code> both builds and runs the tests, we set the additional <code>RUSTFLAGS</code>, to add the <code>-C instrument-coverage</code> flag.</p>
<pre><code class="language-shell">$ RUSTFLAGS="-C instrument-coverage" \
    cargo test --tests
</code></pre>
<blockquote>
<p><strong>Note</strong>: The default for <code>LLVM_PROFILE_FILE</code> is <code>default_%m_%p.profraw</code>. Versions prior to 1.65 had a default of <code>default.profraw</code>, so if using those earlier versions, it is recommended to explicitly set <code>LLVM_PROFILE_FILE="default_%m_%p.profraw"</code> to avoid having multiple tests overwrite the <code>.profraw</code> files.</p>
</blockquote>
<p>Make note of the test binary file paths, displayed after the word “<code>Running</code>” in the test output:</p>
<pre><code class="language-text">   ...
   Compiling json5format v0.1.3 ($HOME/json5format)
    Finished test [unoptimized + debuginfo] target(s) in 14.60s

     Running target/debug/deps/json5format-fececd4653271682
running 25 tests
...
test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/lib-30768f9c53506dc5
running 31 tests
...
test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>You should have one or more <code>.profraw</code> files now, one for each test binary. Run the <code>profdata</code> tool to merge them:</p>
<pre><code class="language-shell">$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata
</code></pre>
<p>Then run the <code>cov</code> tool, with the <code>profdata</code> file and all test binaries:</p>
<pre><code class="language-shell">$ llvm-cov report \
    --use-color --ignore-filename-regex='/.cargo/registry' \
    --instr-profile=json5format.profdata \
    --object target/debug/deps/lib-30768f9c53506dc5 \
    --object target/debug/deps/json5format-fececd4653271682
$ llvm-cov show \
    --use-color --ignore-filename-regex='/.cargo/registry' \
    --instr-profile=json5format.profdata \
    --object target/debug/deps/lib-30768f9c53506dc5 \
    --object target/debug/deps/json5format-fececd4653271682 \
    --show-instantiations --show-line-counts-or-regions \
    --Xdemangler=rustfilt | less -R
</code></pre>
<blockquote>
<p><strong>Note</strong>: If overriding the default <code>profraw</code> file name via the <code>LLVM_PROFILE_FILE</code> environment variable, it’s highly recommended to use the <code>%m</code> and <code>%p</code> special pattern strings to generate unique file names in the case of more than a single test binary being executed.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: The command line option <code>--ignore-filename-regex=/.cargo/registry</code>, which excludes the sources for dependencies from the coverage results._</p>
</blockquote>
<h3 id="tips-for-listing-the-binaries-automatically"><a class="header" href="#tips-for-listing-the-binaries-automatically">Tips for listing the binaries automatically</a></h3>
<p>For <code>bash</code> users, one suggested way to automatically complete the <code>cov</code> command with the list of binaries is with a command like:</p>
<pre><code class="language-bash">$ llvm-cov report \
    $( \
      for file in \
        $( \
          RUSTFLAGS="-C instrument-coverage" \
            cargo test --tests --no-run --message-format=json \
              | jq -r "select(.profile.test == true) | .filenames[]" \
              | grep -v dSYM - \
        ); \
      do \
        printf "%s %s " -object $file; \
      done \
    ) \
  --instr-profile=json5format.profdata --summary-only # and/or other options
</code></pre>
<p>Adding <code>--no-run --message-format=json</code> to the <em>same</em> <code>cargo test</code> command used to run
the tests (including the same environment variables and flags) generates output in a JSON
format that <code>jq</code> can easily query.</p>
<p>The <code>printf</code> command takes this list and generates the <code>--object &lt;binary&gt;</code> arguments
for each listed test binary.</p>
<h3 id="including-doc-tests"><a class="header" href="#including-doc-tests">Including doc tests</a></h3>
<p>The previous examples run <code>cargo test</code> with <code>--tests</code>, which excludes doc tests.<sup class="footnote-reference" id="fr-79417-1"><a href="#footnote-79417">1</a></sup></p>
<p>To include doc tests in the coverage results, drop the <code>--tests</code> flag, and apply the
<code>-C instrument-coverage</code> flag, and some doc-test-specific options in the
<code>RUSTDOCFLAGS</code> environment variable. (The <code>llvm-profdata</code> command does not change.)</p>
<pre><code class="language-bash">$ RUSTFLAGS="-C instrument-coverage" \
  RUSTDOCFLAGS="-C instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins" \
    cargo test
$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata
</code></pre>
<p>The <code>-Z unstable-options --persist-doctests</code> flag is required, to save the test binaries
(with their coverage maps) for <code>llvm-cov</code>.</p>
<pre><code class="language-bash">$ llvm-cov report \
    $( \
      for file in \
        $( \
          RUSTFLAGS="-C instrument-coverage" \
          RUSTDOCFLAGS="-C instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins" \
            cargo test --no-run --message-format=json \
              | jq -r "select(.profile.test == true) | .filenames[]" \
              | grep -v dSYM - \
        ) \
        target/debug/doctestbins/*/rust_out; \
      do \
        [[ -x $file ]] &amp;&amp; printf "%s %s " -object $file; \
      done \
    ) \
  --instr-profile=json5format.profdata --summary-only # and/or other options
</code></pre>
<blockquote>
<p><strong>Note</strong>: The differences in this <code>llvm-cov</code> invocation, compared with the
version without doc tests, include:</p>
</blockquote>
<ul>
<li>The <code>cargo test ... --no-run</code> command is updated with the same environment variables
and flags used to <em>build</em> the tests, <em>including</em> the doc tests.</li>
<li>The file glob pattern <code>target/debug/doctestbins/*/rust_out</code> adds the <code>rust_out</code>
binaries generated for doc tests (note, however, that some <code>rust_out</code> files may not
be executable binaries).</li>
<li><code>[[ -x $file ]] &amp;&amp;</code> filters the files passed on to the <code>printf</code>, to include only
executable binaries.</li>
</ul>
<h2 id="-c-instrument-coverageoptions"><a class="header" href="#-c-instrument-coverageoptions"><code>-C instrument-coverage=&lt;options&gt;</code></a></h2>
<ul>
<li><code>-C instrument-coverage=no</code> (or <code>n</code>/<code>off</code>/<code>false</code>):
Don’t enable coverage instrumentation. No functions will be instrumented for coverage.
<ul>
<li>This is the same as not using the <code>-C instrument-coverage</code> flag at all.</li>
</ul>
</li>
<li><code>-C instrument-coverage=yes</code> (or <code>y</code>/<code>on</code>/<code>true</code>):
Enable coverage instrumentation with the default behaviour.
Currently this instruments all functions, including unused functions and unused generics.
<ul>
<li>This is the same as <code>-C instrument-coverage</code> with no value.</li>
</ul>
</li>
</ul>
<h3 id="other-values"><a class="header" href="#other-values">Other values</a></h3>
<ul>
<li><code>-C instrument-coverage=all</code>:
Currently an alias for <code>yes</code>, but may behave differently in the future if
more fine-grained coverage options are added.
Using this value is currently not recommended.</li>
</ul>
<h2 id="-z-coverage-optionsoptions"><a class="header" href="#-z-coverage-optionsoptions"><code>-Z coverage-options=&lt;options&gt;</code></a></h2>
<p><a href="../unstable-book/compiler-flags/coverage-options.html">This unstable option is described in the Unstable Book.</a></p>
<h2 id="other-references"><a class="header" href="#other-references">Other references</a></h2>
<p>Rust’s implementation and workflow for source-based code coverage is based on the same library and tools used to implement <a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">source-based code coverage in Clang</a>. (This document is partially based on the Clang guide.)</p>
<hr>
<ol class="footnote-definition">
<li id="footnote-79417">
<p>There is ongoing work to resolve a known issue
<a href="https://github.com/rust-lang/rust/issues/79417">(#79417)</a> that doc test coverage
generates incorrect source line numbers in <code>llvm-cov show</code> results. <a href="#fr-79417-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="linker-plugin-based-lto"><a class="header" href="#linker-plugin-based-lto">Linker-plugin-based LTO</a></h1>
<p>The <code>-C linker-plugin-lto</code> flag allows for deferring the LTO optimization
to the actual linking step, which in turn allows for performing
interprocedural optimizations across programming language boundaries if
all the object files being linked were created by LLVM based toolchains.
The prime example here would be linking Rust code together with
Clang-compiled C/C++ code.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>There are two main cases how linker plugin based LTO can be used:</p>
<ul>
<li>compiling a Rust <code>staticlib</code> that is used as a C ABI dependency</li>
<li>compiling a Rust binary where <code>rustc</code> invokes the linker</li>
</ul>
<p>In both cases the Rust code has to be compiled with <code>-C linker-plugin-lto</code> and
the C/C++ code with <code>-flto</code> or <code>-flto=thin</code> so that object files are emitted
as LLVM bitcode.</p>
<h3 id="rust-staticlib-as-dependency-in-cc-program"><a class="header" href="#rust-staticlib-as-dependency-in-cc-program">Rust <code>staticlib</code> as dependency in C/C++ program</a></h3>
<p>In this case the Rust compiler just has to make sure that the object files in
the <code>staticlib</code> are in the right format. For linking, a linker with the
LLVM plugin must be used (e.g. LLD).</p>
<p>Using <code>rustc</code> directly:</p>
<pre><code class="language-bash"># Compile the Rust staticlib
rustc --crate-type=staticlib -Clinker-plugin-lto -Copt-level=2 ./lib.rs
# Compile the C code with `-flto=thin`
clang -c -O2 -flto=thin -o cmain.o ./cmain.c
# Link everything, making sure that we use an appropriate linker
clang -flto=thin -fuse-ld=lld -L . -l"name-of-your-rust-lib" -o main -O2 ./cmain.o
</code></pre>
<p>Using <code>cargo</code>:</p>
<pre><code class="language-bash"># Compile the Rust staticlib
RUSTFLAGS="-Clinker-plugin-lto" cargo build --release
# Compile the C code with `-flto=thin`
clang -c -O2 -flto=thin -o cmain.o ./cmain.c
# Link everything, making sure that we use an appropriate linker
clang -flto=thin -fuse-ld=lld -L . -l"name-of-your-rust-lib" -o main -O2 ./cmain.o
</code></pre>
<h3 id="cc-code-as-a-dependency-in-rust"><a class="header" href="#cc-code-as-a-dependency-in-rust">C/C++ code as a dependency in Rust</a></h3>
<p>In this case the linker will be invoked by <code>rustc</code>. We again have to make sure
that an appropriate linker is used.</p>
<p>Using <code>rustc</code> directly:</p>
<pre><code class="language-bash"># Compile C code with `-flto`
clang ./clib.c -flto=thin -c -o ./clib.o -O2
# Create a static library from the C code
ar crus ./libxyz.a ./clib.o

# Invoke `rustc` with the additional arguments
rustc -Clinker-plugin-lto -L. -Copt-level=2 -Clinker=clang -Clink-arg=-fuse-ld=lld ./main.rs
</code></pre>
<p>Using <code>cargo</code> directly:</p>
<pre><code class="language-bash"># Compile C code with `-flto`
clang ./clib.c -flto=thin -c -o ./clib.o -O2
# Create a static library from the C code
ar crus ./libxyz.a ./clib.o

# Set the linking arguments via RUSTFLAGS
RUSTFLAGS="-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld" cargo build --release
</code></pre>
<h3 id="explicitly-specifying-the-linker-plugin-to-be-used-by-rustc"><a class="header" href="#explicitly-specifying-the-linker-plugin-to-be-used-by-rustc">Explicitly specifying the linker plugin to be used by <code>rustc</code></a></h3>
<p>If one wants to use a linker other than LLD, the LLVM linker plugin has to be
specified explicitly. Otherwise the linker cannot read the object files. The
path to the plugin is passed as an argument to the <code>-Clinker-plugin-lto</code>
option:</p>
<pre><code class="language-bash">rustc -Clinker-plugin-lto="/path/to/LLVMgold.so" -L. -Copt-level=2 ./main.rs
</code></pre>
<h3 id="usage-with-clang-cl-and-x86_64-pc-windows-msvc"><a class="header" href="#usage-with-clang-cl-and-x86_64-pc-windows-msvc">Usage with clang-cl and x86_64-pc-windows-msvc</a></h3>
<p>Cross language LTO can be used with the x86_64-pc-windows-msvc target, but this requires using the
clang-cl compiler instead of the MSVC cl.exe included with Visual Studio Build Tools, and linking
with lld-link. Both clang-cl and lld-link can be downloaded from <a href="https://releases.llvm.org/download.html">LLVM’s download page</a>.
Note that most crates in the ecosystem are likely to assume you are using cl.exe if using this target
and that some things, like for example vcpkg, <a href="https://github.com/microsoft/vcpkg/issues/2087">don’t work very well with clang-cl</a>.</p>
<p>You will want to make sure your rust major LLVM version matches your installed LLVM tooling version,
otherwise it is likely you will get linker errors:</p>
<pre><code class="language-bat">rustc -V --verbose
clang-cl --version
</code></pre>
<p>If you are compiling any proc-macros, you will get this error:</p>
<pre><code class="language-bash">error: Linker plugin based LTO is not supported together with `-C prefer-dynamic` when
targeting Windows-like targets
</code></pre>
<p>This is fixed if you explicitly set the target, for example
<code>cargo build --target x86_64-pc-windows-msvc</code>
Without an explicit –target the flags will be passed to all compiler invocations (including build
scripts and proc macros), see <a href="../cargo/reference/config.html#buildrustflags">cargo docs on rustflags</a></p>
<p>If you have dependencies using the <code>cc</code> crate, you will need to set these
environment variables:</p>
<pre><code class="language-bat">set CC=clang-cl
set CXX=clang-cl
set CFLAGS=/clang:-flto=thin /clang:-fuse-ld=lld-link
set CXXFLAGS=/clang:-flto=thin /clang:-fuse-ld=lld-link
REM Needed because msvc's lib.exe crashes on LLVM LTO .obj files
set AR=llvm-lib
</code></pre>
<p>If you are specifying lld-link as your linker by setting <code>linker = "lld-link.exe"</code> in your cargo config,
you may run into issues with some crates that compile code with separate cargo invocations. You should be
able to get around this problem by setting <code>-Clinker=lld-link</code> in RUSTFLAGS</p>
<h2 id="toolchain-compatibility"><a class="header" href="#toolchain-compatibility">Toolchain Compatibility</a></h2>
<!-- NOTE: to update the below table, you can use this Python script:

```python
from collections import defaultdict
import subprocess
import sys

def minor_version(version):
    return int(version.split('.')[1])

INSTALL_TOOLCHAIN = ["rustup", "toolchain", "install", "--profile", "minimal"]
subprocess.run(INSTALL_TOOLCHAIN + ["nightly"])

LOWER_BOUND = 87
NIGHTLY_VERSION = minor_version(subprocess.run(
    ["rustc", "+nightly", "--version"],
    capture_output=True,
    text=True).stdout)

def llvm_version(toolchain):
    version_text = subprocess.run(
        ["rustc", "+{}".format(toolchain), "-Vv"],
        capture_output=True,
        text=True).stdout
    return int(version_text.split("LLVM")[1].split(':')[1].split('.')[0])

version_map = defaultdict(lambda: [])
for version in range(LOWER_BOUND, NIGHTLY_VERSION - 1):
    toolchain = "1.{}.0".format(version)
    print("Checking", toolchain, file=sys.stderr)
    subprocess.run(
        INSTALL_TOOLCHAIN + ["--no-self-update", toolchain],
        capture_output=True)
    version_map[llvm_version(toolchain)].append(version)

print("| Rust Version | Clang Version |")
print("|--------------|---------------|")
for clang, rust in sorted(version_map.items()):
    if len(rust) > 1:
        rust_range = "1.{} - 1.{}".format(rust[0], rust[-1])
    else:
        rust_range = "1.{}       ".format(rust[0])
    print("| {}  |      {}       |".format(rust_range, clang))
```

-->
<p>In order for this kind of LTO to work, the LLVM linker plugin must be able to
handle the LLVM bitcode produced by both <code>rustc</code> and <code>clang</code>.</p>
<p>Best results are achieved by using a <code>rustc</code> and <code>clang</code> that are based on the
exact same version of LLVM. One can use <code>rustc -vV</code> in order to view the LLVM
used by a given <code>rustc</code> version. Note that the version number given
here is only an approximation as Rust sometimes uses unstable revisions of
LLVM. However, the approximation is usually reliable.</p>
<p>The following table shows known good combinations of toolchain versions.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rust Version</th><th>Clang Version</th></tr>
</thead>
<tbody>
<tr><td>1.34 - 1.37</td><td>8</td></tr>
<tr><td>1.38 - 1.44</td><td>9</td></tr>
<tr><td>1.45 - 1.46</td><td>10</td></tr>
<tr><td>1.47 - 1.51</td><td>11</td></tr>
<tr><td>1.52 - 1.55</td><td>12</td></tr>
<tr><td>1.56 - 1.59</td><td>13</td></tr>
<tr><td>1.60 - 1.64</td><td>14</td></tr>
<tr><td>1.65 - 1.69</td><td>15</td></tr>
<tr><td>1.70 - 1.72</td><td>16</td></tr>
<tr><td>1.73 - 1.77</td><td>17</td></tr>
<tr><td>1.78 - 1.81</td><td>18</td></tr>
<tr><td>1.82 - 1.86</td><td>19</td></tr>
<tr><td>1.87 - 1.90</td><td>20</td></tr>
<tr><td>1.91 - 1.92</td><td>21</td></tr>
</tbody>
</table>
</div>
<p>Note that the compatibility policy for this feature might change in the future.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="checking-conditional-configurations"><a class="header" href="#checking-conditional-configurations">Checking conditional configurations</a></h1>
<p><code>rustc</code> supports checking that every <em>reachable</em><sup class="footnote-reference" id="fr-reachable-1"><a href="#footnote-reachable">1</a></sup> <code>#[cfg]</code> matches a list of the
expected config names and values.</p>
<p>This can help with verifying that the crate is correctly handling conditional compilation for
different target platforms or features. It ensures that the cfg settings are consistent between
what is intended and what is used, helping to catch potential bugs or errors early in the
development process.</p>
<p>In order to accomplish that goal, <code>rustc</code> accepts the <code>--check-cfg</code> flag, which specifies
whether to check conditions and how to check them.</p>
<blockquote>
<p><strong>Note:</strong> For interacting with this through Cargo,
see <a href="#cargo-specifics---checking-conditional-configurations">Cargo Specifics</a> page.</p>
</blockquote>
<h2 id="specifying-expected-names-and-values"><a class="header" href="#specifying-expected-names-and-values">Specifying expected names and values</a></h2>
<p>To specify expected names and values, the <em>check cfg specification</em> provides the <code>cfg(...)</code>
option which enables specifying for an expected config name and it’s expected values.</p>
<blockquote>
<p><strong>Note:</strong> No implicit expectation is added when using <code>--cfg</code>. Users are expected to
pass all expected names and values using the <em>check cfg specification</em>.</p>
</blockquote>
<p>It has this basic form:</p>
<pre><code class="language-bash">rustc --check-cfg 'cfg(name, values("value1", "value2", ... "valueN"))'
</code></pre>
<p>where <code>name</code> is a bare identifier (has no quotes) and each <code>"value"</code> term is a quoted literal
string. <code>name</code> specifies the name of the condition, such as <code>feature</code> or <code>my_cfg</code>.
<code>"value"</code> specify one of the value of that condition name.</p>
<p>When the <code>cfg(...)</code> option is specified, <code>rustc</code> will check every<sup class="footnote-reference" id="fr-reachable-2"><a href="#footnote-reachable">1</a></sup>:</p>
<ul>
<li><code>#[cfg(name = "value")]</code> attribute</li>
<li><code>#[cfg_attr(name = "value")]</code> attribute</li>
<li><code>#[link(name = "a", cfg(name = "value"))]</code> attribute</li>
<li><code>cfg!(name = "value")</code> macro call</li>
</ul>
<blockquote>
<p><em>The command line <code>--cfg</code> arguments are currently NOT checked but may very well be checked
in the future.</em></p>
</blockquote>
<p><code>rustc</code> will check that the <code>"value"</code> specified is present in the list of expected values.
If <code>"value"</code> is not in it, then <code>rustc</code> will report an <code>unexpected_cfgs</code> lint diagnostic.
The default diagnostic level for this lint is <code>Warn</code>.</p>
<p>To check for the <em>none</em> value (ie <code>#[cfg(foo)]</code>) one can use the <code>none()</code> predicate inside
<code>values()</code>: <code>values(none())</code>. It can be followed or preceded by any number of <code>"value"</code>.</p>
<p>To enable checking of values, but to provide an <em>none</em>/empty set of expected values
(ie. expect <code>#[cfg(name)]</code>), use these forms:</p>
<pre><code class="language-bash">rustc --check-cfg 'cfg(name)'
rustc --check-cfg 'cfg(name, values(none()))'
</code></pre>
<p>To enable checking of name but not values, use one of these forms:</p>
<ul>
<li>
<p>No expected values (<em>will lint on every value of <code>name</code></em>):</p>
<pre><code class="language-bash">rustc --check-cfg 'cfg(name, values())'
</code></pre>
</li>
<li>
<p>Unknown expected values (<em>will never lint on value of <code>name</code></em>):</p>
<pre><code class="language-bash">rustc --check-cfg 'cfg(name, values(any()))'
</code></pre>
</li>
</ul>
<p>To avoid repeating the same set of values, use this form:</p>
<pre><code class="language-bash">rustc --check-cfg 'cfg(name1, ..., nameN, values("value1", "value2", ... "valueN"))'
</code></pre>
<p>To enable checking without specifying any names or values, use this form:</p>
<pre><code class="language-bash">rustc --check-cfg 'cfg()'
</code></pre>
<p>The <code>--check-cfg cfg(...)</code> option can be repeated, both for the same condition name and for
different names. If it is repeated for the same condition name, then the sets of values for that
condition are merged together (precedence is given to <code>values(any())</code>).</p>
<blockquote>
<p>To help out an equivalence table between <code>--cfg</code> arguments and <code>--check-cfg</code> is available
<a href="#equivalence-table-with---cfg">down below</a>.</p>
</blockquote>
<h2 id="well-known-names-and-values"><a class="header" href="#well-known-names-and-values">Well known names and values</a></h2>
<p><code>rustc</code> maintains a list of well-known names and their corresponding values in order to avoid
the need to specify them manually.</p>
<p>Well known names and values are implicitly added as long as at least one <code>--check-cfg</code> argument
is present.</p>
<p>As of <code>2025-01-02T</code>, the list of known names is as follows:</p>
<!--- See CheckCfg::fill_well_known in compiler/rustc_session/src/config.rs -->
<ul>
<li><code>clippy</code></li>
<li><code>debug_assertions</code></li>
<li><code>doc</code></li>
<li><code>doctest</code></li>
<li><code>fmt_debug</code></li>
<li><code>miri</code></li>
<li><code>overflow_checks</code></li>
<li><code>panic</code></li>
<li><code>proc_macro</code></li>
<li><code>relocation_model</code></li>
<li><code>rustfmt</code></li>
<li><code>sanitize</code></li>
<li><code>sanitizer_cfi_generalize_pointers</code></li>
<li><code>sanitizer_cfi_normalize_integers</code></li>
<li><code>target_abi</code></li>
<li><code>target_arch</code></li>
<li><code>target_endian</code></li>
<li><code>target_env</code></li>
<li><code>target_family</code></li>
<li><code>target_feature</code></li>
<li><code>target_has_atomic</code></li>
<li><code>target_has_atomic_equal_alignment</code></li>
<li><code>target_has_atomic_load_store</code></li>
<li><code>target_os</code></li>
<li><code>target_pointer_width</code></li>
<li><code>target_thread_local</code></li>
<li><code>target_vendor</code></li>
<li><code>ub_checks</code></li>
<li><code>unix</code></li>
<li><code>windows</code></li>
</ul>
<blockquote>
<p>Starting with 1.85.0, the <code>test</code> cfg is considered to be a “userspace” config
despite being also set by <code>rustc</code> and should be managed by the build system itself.</p>
</blockquote>
<p>Like with <code>values(any())</code>, well known names checking can be disabled by passing <code>cfg(any())</code>
as argument to <code>--check-cfg</code>.</p>
<h2 id="equivalence-table-with---cfg"><a class="header" href="#equivalence-table-with---cfg">Equivalence table with <code>--cfg</code></a></h2>
<p>This table describe the equivalence between a <code>--cfg</code> argument to a <code>--check-cfg</code> argument.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>--cfg</code></th><th><code>--check-cfg</code></th></tr>
</thead>
<tbody>
<tr><td><em>nothing</em></td><td><em>nothing</em> or <code>--check-cfg=cfg()</code> (to enable the checking)</td></tr>
<tr><td><code>--cfg foo</code></td><td><code>--check-cfg=cfg(foo)</code> or <code>--check-cfg=cfg(foo, values(none()))</code></td></tr>
<tr><td><code>--cfg foo=""</code></td><td><code>--check-cfg=cfg(foo, values(""))</code></td></tr>
<tr><td><code>--cfg foo="bar"</code></td><td><code>--check-cfg=cfg(foo, values("bar"))</code></td></tr>
<tr><td><code>--cfg foo="1" --cfg foo="2"</code></td><td><code>--check-cfg=cfg(foo, values("1", "2"))</code></td></tr>
<tr><td><code>--cfg foo="1" --cfg bar="2"</code></td><td><code>--check-cfg=cfg(foo, values("1")) --check-cfg=cfg(bar, values("2"))</code></td></tr>
<tr><td><code>--cfg foo --cfg foo="bar"</code></td><td><code>--check-cfg=cfg(foo, values(none(), "bar"))</code></td></tr>
</tbody>
</table>
</div>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="example-cargo-like-feature-example"><a class="header" href="#example-cargo-like-feature-example">Example: Cargo-like <code>feature</code> example</a></h3>
<p>Consider this command line:</p>
<pre><code class="language-bash">rustc --check-cfg 'cfg(feature, values("lion", "zebra"))' \
      --cfg 'feature="lion"' example.rs
</code></pre>
<blockquote>
<p>This command line indicates that this crate has two features: <code>lion</code> and <code>zebra</code>. The <code>lion</code>
feature is enabled, while the <code>zebra</code> feature is disabled.</p>
</blockquote>
<pre><code class="language-rust">#[cfg(feature = "lion")]     // This condition is expected, as "lion" is an
                             // expected value of `feature`
fn tame_lion(lion: Lion) {}

#[cfg(feature = "zebra")]    // This condition is expected, as "zebra" is an expected
                             // value of `feature` but the condition will evaluate
                             // to false since only --cfg feature="lion" was passed
fn ride_zebra(z: Zebra) {}

#[cfg(feature = "platypus")] // This condition is UNEXPECTED, as "platypus" is NOT
                             // an expected value of `feature` and will cause a
                             // the compiler to emit the `unexpected_cfgs` lint
fn poke_platypus() {}

#[cfg(feechure = "lion")]    // This condition is UNEXPECTED, as 'feechure' is NOT
                             // a expected condition name, no `cfg(feechure, ...)`
                             // was passed in `--check-cfg`
fn tame_lion() {}

#[cfg(windows = "unix")]     // This condition is UNEXPECTED, as the well known
                             // 'windows' cfg doesn't expect any values
fn tame_windows() {}</code></pre>
<h3 id="example-multiple-names-and-values"><a class="header" href="#example-multiple-names-and-values">Example: Multiple names and values</a></h3>
<pre><code class="language-bash">rustc --check-cfg 'cfg(is_embedded, has_feathers)' \
      --check-cfg 'cfg(feature, values("zapping", "lasers"))' \
      --cfg has_feathers --cfg 'feature="zapping"'
</code></pre>
<pre><code class="language-rust">#[cfg(is_embedded)]         // This condition is expected, as 'is_embedded' was
                            // provided in --check-cfg and doesn't take any value
fn do_embedded() {}

#[cfg(has_feathers)]        // This condition is expected, as 'has_feathers' was
                            // provided in --check-cfg and doesn't take any value
fn do_features() {}

#[cfg(has_mumble_frotz)]    // This condition is UNEXPECTED, as 'has_mumble_frotz'
                            // was NEVER provided in any --check-cfg arguments
fn do_mumble_frotz() {}

#[cfg(feature = "lasers")]  // This condition is expected, as "lasers" is an
                            // expected value of `feature`
fn shoot_lasers() {}

#[cfg(feature = "monkeys")] // This condition is UNEXPECTED, as "monkeys" is NOT
                            // an expected value of `feature`
fn write_shakespeare() {}</code></pre>
<h3 id="example-condition-names-without-values"><a class="header" href="#example-condition-names-without-values">Example: Condition names without values</a></h3>
<pre><code class="language-bash">rustc --check-cfg 'cfg(is_embedded, has_feathers, values(any()))' \
      --cfg has_feathers
</code></pre>
<pre><code class="language-rust">#[cfg(is_embedded)]      // This condition is expected, as 'is_embedded' was
                         // provided in --check-cfg as condition name
fn do_embedded() {}

#[cfg(has_feathers)]     // This condition is expected, as "has_feathers" was
                         // provided in --check-cfg as condition name
fn do_features() {}

#[cfg(has_feathers = "zapping")] // This condition is expected, as "has_feathers"
                                 // was provided and because *any* values is
                                 // expected for 'has_feathers' no
                                 // warning is emitted for the value "zapping"
fn do_zapping() {}

#[cfg(has_mumble_frotz)] // This condition is UNEXPECTED, as 'has_mumble_frotz'
                         // was not provided in any --check-cfg arguments
fn do_mumble_frotz() {}</code></pre>
<hr>
<ol class="footnote-definition">
<li id="footnote-reachable">
<p><code>rustc</code> promises to at least check reachable <code>#[cfg]</code>, and while non-reachable
<code>#[cfg]</code> are not currently checked, they may well be checked in the future without it being a
breaking change. <a href="#fr-reachable-1">↩</a> <a href="#fr-reachable-2">↩2</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-specifics---checking-conditional-configurations"><a class="header" href="#cargo-specifics---checking-conditional-configurations">Cargo Specifics - Checking Conditional Configurations</a></h1>
<!--
This page is currently (as of May 2024) the canonical place for describing the interaction
between Cargo and --check-cfg. It is placed in the rustc book rather than the Cargo book
since check-cfg is primarily a Rust/rustc feature and is therefore considered by T-cargo to
be an implementation detail, at least --check-cfg and the unexpected_cfgs are owned by
rustc, not Cargo.
-->
<p>This document is intended to summarize the principal ways Cargo interacts with
the <code>unexpected_cfgs</code> lint and <code>--check-cfg</code> flag.
For individual details, refer to the <a href="#checking-conditional-configurations"><code>--check-cfg</code> documentation</a> and
to the <a href="../cargo/index.html">Cargo book</a>.</p>
<blockquote>
<p>The full list of well known cfgs (aka builtins) can be found under <a href="#well-known-names-and-values">Checking conditional configurations / Well known names and values</a>.</p>
</blockquote>
<h2 id="cargo-feature"><a class="header" href="#cargo-feature">Cargo feature</a></h2>
<p><em>See the <a href="../cargo/reference/features.html"><code>[features]</code> section in the Cargo book</a> for more details.</em></p>
<p>With the <code>[features]</code> table, Cargo provides a mechanism to express conditional compilation and
optional dependencies. Cargo <em>automatically</em> declares corresponding cfgs for every feature as
expected.</p>
<p><code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
serde = ["dep:serde"]
my_feature = []
</code></pre>
<h2 id="check-cfg-in-lintsrust-table"><a class="header" href="#check-cfg-in-lintsrust-table"><code>check-cfg</code> in <code>[lints.rust]</code> table</a></h2>
<!-- Note that T-Cargo considers `lints.rust.unexpected_cfgs.check-cfg` to be an
implementation detail and is therefore documented here and not in Cargo. -->
<p><em>See the <a href="../cargo/reference/manifest.html#the-lints-section"><code>[lints]</code> section in the Cargo book</a> for more details.</em></p>
<p>When using a statically known custom config (i.e., not dependent on a build-script), Cargo provides
the custom lint config <code>check-cfg</code> under <code>[lints.rust.unexpected_cfgs]</code>.</p>
<p>It can be used to set custom static <a href="#checking-conditional-configurations"><code>--check-cfg</code></a> args, it is mainly useful when
the list of expected cfgs is known in advance.</p>
<p><code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(has_foo)'] }
</code></pre>
<h2 id="cargorustc-check-cfg-for-buildrsbuild-script"><a class="header" href="#cargorustc-check-cfg-for-buildrsbuild-script"><code>cargo::rustc-check-cfg</code> for <code>build.rs</code>/build-script</a></h2>
<p><em>See the <a href="../cargo/reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg</code> section in the Cargo book</a> for more details.</em></p>
<p>When setting a custom config with <a href="../cargo/reference/build-scripts.html#rustc-cfg"><code>cargo::rustc-cfg</code></a>, Cargo provides the
corollary instruction: <a href="../cargo/reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg</code></a> to expect custom configs.</p>
<p><code>build.rs</code>:</p>
<pre><code class="language-rust ignore (cannot-test-this-because-has_foo-isnt-declared)">fn main() {
    println!("cargo::rustc-check-cfg=cfg(has_foo)");
    //        ^^^^^^^^^^^^^^^^^^^^^^ new with Cargo 1.80
    if has_foo() {
        println!("cargo::rustc-cfg=has_foo");
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="remap-source-paths"><a class="header" href="#remap-source-paths">Remap source paths</a></h1>
<p><code>rustc</code> supports remapping source paths prefixes <strong>as a best effort</strong> in all compiler generated
output, including compiler diagnostics, debugging information, macro expansions, etc.</p>
<p>This is useful for normalizing build products, for example, by removing the current directory
out of the paths emitted into object files.</p>
<p>The remapping is done via the <code>--remap-path-prefix</code> flag and can be customized via the <code>--remap-path-scope</code> flag.</p>
<h2 id="--remap-path-prefix"><a class="header" href="#--remap-path-prefix"><code>--remap-path-prefix</code></a></h2>
<p>It takes a value of the form <code>FROM=TO</code> where a path prefix equal to <code>FROM</code> is rewritten
to the value <code>TO</code>. <code>FROM</code> may itself contain an <code>=</code> symbol, but <code>TO</code> value may not.</p>
<p>The replacement is purely textual, with no consideration of the current system’s path separator.</p>
<p>When multiple remappings are given and several of them match, the <strong>last</strong> matching one is applied.</p>
<h3 id="relative-paths"><a class="header" href="#relative-paths">Relative paths</a></h3>
<p>Some build systems, such as Cargo, may compile crates using relative paths (for example,
<code>src/main.rs</code> instead of <code>/home/user/project/src/main.rs)</code>.</p>
<p><code>rustc</code> preserves these relative paths where possible. However, certain inputs
(like <code>#[path = "..."]</code>) and outputs (such as debug information) may still contain absolute paths.</p>
<p>To ensure consistency, it’s recommended to remap both relative and absolute paths.</p>
<pre><code class="language-bash">rustc --remap-path-prefix "src/=/redacted/src" --remap-path-prefix "/home/user/project=/redacted"
</code></pre>
<h3 id="example-132"><a class="header" href="#example-132">Example</a></h3>
<pre><code class="language-bash">rustc --remap-path-prefix "/home/user/project=/redacted"
</code></pre>
<p>This example replaces all occurrences of <code>/home/user/project</code> in emitted paths with <code>/redacted</code>.</p>
<h2 id="--remap-path-scope"><a class="header" href="#--remap-path-scope"><code>--remap-path-scope</code></a></h2>
<p>Defines which scopes of paths should be remapped by <code>--remap-path-prefix</code>.</p>
<p>This flag accepts a comma-separated list of values and may be specified multiple times, in which case the scopes are aggregated together.</p>
<p>The valid scopes are:</p>
<ul>
<li><code>macro</code> - apply remappings to the expansion of <code>std::file!()</code> macro. This is where paths in embedded panic messages come from</li>
<li><code>diagnostics</code> - apply remappings to printed compiler diagnostics</li>
<li><code>debuginfo</code> - apply remappings to debug information</li>
<li><code>coverage</code> - apply remappings to coverage information</li>
<li><code>object</code> - apply remappings to all paths in compiled executables or libraries, but not elsewhere. Currently an alias for <code>macro,coverage,debuginfo</code>.</li>
<li><code>all</code> (default) - an alias for all of the above, also equivalent to supplying only <code>--remap-path-prefix</code> without <code>--remap-path-scope</code>.</li>
</ul>
<p>The scopes accepted by <code>--remap-path-scope</code> are not exhaustive - new scopes may be added in future releases for eventual stabilisation.
This implies that the <code>all</code> scope can correspond to different scopes between releases.</p>
<h3 id="example-1-3"><a class="header" href="#example-1-3">Example</a></h3>
<pre><code class="language-sh"># With `object` scope only the build outputs will be remapped, the diagnostics won't be remapped.
rustc --remap-path-prefix=$(PWD)=/remapped --remap-path-scope=object main.rs
</code></pre>
<h2 id="caveats-and-limitations"><a class="header" href="#caveats-and-limitations">Caveats and Limitations</a></h2>
<h3 id="paths-generated-by-linkers"><a class="header" href="#paths-generated-by-linkers">Paths generated by linkers</a></h3>
<p>On some platforms like <code>x86_64-pc-windows-msvc</code>, the linker may embed absolute host paths and compiler
arguments into debug info files (like <code>.pdb</code>) independently of <code>rustc</code>.</p>
<p>Additionally, on Apple platforms, linkers generate <a href="https://wiki.dwarfstd.org/Apple%27s_%22Lazy%22_DWARF_Scheme.md">OSO entries</a> which are not remapped by the compiler
and need to be manually remapped with <code>-oso_prefix</code>.</p>
<p>The <code>--remap-path-prefix</code> option does not affect these linker-generated paths.</p>
<h3 id="textual-replacement-only"><a class="header" href="#textual-replacement-only">Textual replacement only</a></h3>
<p>The remapping is strictly textual and does not account for different path separator conventions across
platforms. Care must be taken when specifying prefixes, especially on Windows, where both <code>/</code> and <code>\</code> may
appear in paths.</p>
<h3 id="external-tools"><a class="header" href="#external-tools">External tools</a></h3>
<p>Paths introduced by external tools or environment variables may not be covered by <code>--remap-path-prefix</code>
unless explicitly accounted for.</p>
<p>For example, generated code introduced by Cargo’s build script may still contain un-remapped paths.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="exploit-mitigations"><a class="header" href="#exploit-mitigations">Exploit Mitigations</a></h1>
<p>This chapter documents the exploit mitigations supported by the Rust compiler,
and is by no means an extensive survey of the Rust programming language’s
security features.</p>
<p>This chapter is for software engineers working with the Rust programming
language, and assumes prior knowledge of the Rust programming language and its
toolchain.</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The Rust programming language provides memory[1] and thread[2] safety
guarantees via its ownership[3], references and borrowing[4], and slice
types[5] features. However, Unsafe Rust[6] introduces unsafe blocks, unsafe
functions and methods, unsafe traits, and new types that are not subject to the
borrowing rules.</p>
<p>Parts of the Rust standard library are implemented as safe abstractions over
unsafe code (and historically have been vulnerable to memory corruption[7]).
Furthermore, the Rust code and documentation encourage creating safe
abstractions over unsafe code. This can cause a false sense of security if
unsafe code is not properly reviewed and tested.</p>
<p>Unsafe Rust introduces features that do not provide the same memory and thread
safety guarantees. This causes programs or libraries to be susceptible to
memory corruption (CWE-119)[8] and concurrency issues (CWE-557)[9]. Modern C
and C++ compilers provide exploit mitigations to increase the difficulty to
exploit vulnerabilities resulting from these issues. Therefore, the Rust
compiler must also support these exploit mitigations in order to mitigate
vulnerabilities resulting from the use of Unsafe Rust. This chapter documents
these exploit mitigations and how they apply to Rust.</p>
<p>This chapter does not discuss the effectiveness of these exploit mitigations as
they vary greatly depending on several factors besides their design and
implementation, but rather describe what they do, so their effectiveness can be
understood within a given context.</p>
<h2 id="exploit-mitigations-1"><a class="header" href="#exploit-mitigations-1">Exploit mitigations</a></h2>
<p>This section documents the exploit mitigations applicable to the Rust compiler
when building programs for the Linux operating system on the AMD64 architecture
and equivalent.<sup class="footnote-reference" id="fr-all-targets-1"><a href="#footnote-all-targets">1</a></sup> All examples in this section were built using
nightly builds of the Rust compiler on Debian testing.</p>
<p>The Rust Programming Language currently has no specification. The Rust compiler
(i.e., rustc) is the language reference implementation. All references to “the
Rust compiler” in this chapter refer to the language reference implementation.</p>
<p>Table I <br>Summary of exploit mitigations supported by the Rust compiler when building
programs for the Linux operating system on the AMD64 architecture and
equivalent.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Exploit mitigation</th><th>Supported</th><th>Enabled by default</th><th>Since</th></tr>
</thead>
<tbody>
<tr><td>Position-independent executable</td><td>Yes</td><td>Yes</td><td>0.12.0 (2014-10-09)</td></tr>
<tr><td>Integer overflow checks</td><td>Yes</td><td>(enabled when debug assertions are enabled, and disabled when debug assertions are disabled)</td><td>1.1.0 (2015-06-25)</td></tr>
<tr><td>Non-executable memory regions</td><td>Yes</td><td>Yes</td><td>1.8.0 (2016-04-14)</td></tr>
<tr><td>Stack clashing protection</td><td>Yes</td><td>Yes</td><td>1.20.0 (2017-08-31)</td></tr>
<tr><td>Read-only relocations and immediate binding</td><td>Yes</td><td>Yes</td><td>1.21.0 (2017-10-12)</td></tr>
<tr><td>Heap corruption protection</td><td>Yes</td><td>Yes</td><td>1.32.0 (2019-01-17) (via operating system default or specified allocator)</td></tr>
<tr><td>Stack smashing protection</td><td>Yes</td><td>No, <code>-Z stack-protector</code></td><td>Nightly</td></tr>
<tr><td>Forward-edge control flow protection</td><td>Yes</td><td>No, <code>-Z sanitizer=cfi</code></td><td>Nightly</td></tr>
<tr><td>Backward-edge control flow protection (e.g., shadow and safe stack)</td><td>Yes</td><td>No, <code>-Z sanitizer=shadow-call-stack,safestack</code></td><td>Nightly</td></tr>
</tbody>
</table>
</div>
<h3 id="position-independent-executable"><a class="header" href="#position-independent-executable">Position-independent executable</a></h3>
<p>Position-independent executable increases the difficulty of the use of code
reuse exploitation techniques, such as return-oriented programming (ROP) and
variants, by generating position-independent code for the executable, and
instructing the dynamic linker to load it similarly to a shared object at a
random load address, thus also benefiting from address-space layout
randomization (ASLR). This is also referred to as “full ASLR”.</p>
<p>The Rust compiler supports position-independent executable, and enables it by
default since version 0.12.0 (2014-10-09)[10]–[13].</p>
<pre><code class="language-text">$ readelf -h target/release/hello-rust | grep Type:
  Type:                              DYN (Shared object file)
</code></pre>
<p>Fig. 1. Checking if an executable is a position-independent executable.</p>
<p>An executable with an object type of <code>ET_DYN</code> (i.e., shared object) and not
<code>ET_EXEC</code> (i.e., executable) is a position-independent executable (see Fig. 1).</p>
<h3 id="integer-overflow-checks"><a class="header" href="#integer-overflow-checks">Integer overflow checks</a></h3>
<p>Integer overflow checks protects programs from undefined and unintended
behavior (which may cause vulnerabilities) by checking for results of signed
and unsigned integer computations that cannot be represented in their type,
resulting in an overflow or wraparound.</p>
<p>The Rust compiler supports integer overflow checks, and enables it when debug
assertions are enabled since version 1.0.0 (2015-05-15)[14]–[17], but support
for it was not completed until version 1.1.0 (2015-06-25)[16]. An option to
control integer overflow checks was later stabilized in version 1.17.0
(2017-04-27)[18]–[20].</p>
<pre><code class="language-compile_fail">fn main() {
    let u: u8 = 255;
    println!("u: {}", u + 1);
}
</code></pre>
<p>Fig. 2. hello-rust-integer program.</p>
<pre><code class="language-text">$ cargo run
   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)
    Finished dev [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/hello-rust-integer`
thread 'main' panicked at 'attempt to add with overflow', src/main.rs:3:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Fig. 3. Build and execution of hello-rust-integer with debug assertions
enabled.</p>
<pre><code class="language-text">$ cargo run --release
   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)
    Finished release [optimized] target(s) in 0.23s
     Running `target/release/hello-rust-integer`
u: 0
</code></pre>
<p>Fig. 4. Build and execution of hello-rust-integer with debug assertions
disabled.</p>
<p>Integer overflow checks are enabled when debug assertions are enabled (see Fig.
3), and disabled when debug assertions are disabled (see Fig. 4). To enable
integer overflow checks independently, use the option to control integer
overflow checks, scoped attributes, or explicit checking methods such as
<code>checked_add</code><sup class="footnote-reference" id="fr-checked-methods-1"><a href="#footnote-checked-methods">2</a></sup>.</p>
<p>It is recommended that explicit wrapping methods such as <code>wrapping_add</code> be used
when wrapping semantics are intended, and that explicit checking and wrapping
methods always be used when using Unsafe Rust.</p>
<h3 id="non-executable-memory-regions"><a class="header" href="#non-executable-memory-regions">Non-executable memory regions</a></h3>
<p>Non-executable memory regions increase the difficulty of exploitation by
limiting the memory regions that can be used to execute arbitrary code. Most
modern processors provide support for the operating system to mark memory
regions as non executable, but it was previously emulated by software, such as
in grsecurity/PaX’s <a href="https://pax.grsecurity.net/docs/pageexec.txt">PAGEEXEC</a>
and <a href="https://pax.grsecurity.net/docs/segmexec.txt">SEGMEXEC</a>, on processors
that did not provide support for it. This is also known as “No Execute (NX)
Bit”, “Execute Disable (XD) Bit”, “Execute Never (XN) Bit”, and others.</p>
<p>The Rust compiler supports non-executable memory regions, and enables it by
default since its initial release, version 0.1 (2012-01-20)[21], [22], but has
regressed since then[23]–[25], and enforced by default since version 1.8.0
(2016-04-14)[25].</p>
<pre><code class="language-text">$ readelf -l target/release/hello-rust | grep -A 1 GNU_STACK
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
</code></pre>
<p>Fig. 5. Checking if non-executable memory regions are enabled for a given
binary.</p>
<p>The presence of an element of type <code>PT_GNU_STACK</code> in the program header table
with the <code>PF_X</code> (i.e., executable) flag unset indicates non-executable memory
regions<sup class="footnote-reference" id="fr-other-regions-1"><a href="#footnote-other-regions">3</a></sup> are enabled for a given binary (see Fig. 5).
Conversely, the presence of an element of type <code>PT_GNU_STACK</code> in the program
header table with the <code>PF_X</code> flag set or the absence of an element of type
<code>PT_GNU_STACK</code> in the program header table indicates non-executable memory
regions are not enabled for a given binary.</p>
<h3 id="stack-clashing-protection"><a class="header" href="#stack-clashing-protection">Stack clashing protection</a></h3>
<p>Stack clashing protection protects the stack from overlapping with another
memory region—allowing arbitrary data in both to be overwritten using each
other—by reading from the stack pages as the stack grows to cause a page fault
when attempting to read from the guard page/region. This is also referred to as
“stack probes” or “stack probing”.</p>
<p>The Rust compiler supports stack clashing protection via stack probing, and
enables it by default since version 1.20.0 (2017-08-31)[26]–[29].</p>
<pre><code class="language-rust">fn main() {
    let v: [u8; 16384] = [1; 16384];
    let first = &amp;v[0];
    println!("The first element is: {first}");
}</code></pre>
<p>Fig. 6. hello-rust-stack-probe-1 program.</p>
<p><img src="images/image1.png" title="The &quot;unrolled loop&quot; stack probe variant in modified hello-rust." alt="Screenshot of IDA Pro listing the “unrolled loop” stack probe variant in modified hello-rust.">
Fig. 7. The “unrolled loop” stack probe variant in modified hello-rust.</p>
<pre><code class="language-rust">fn main() {
    let v: [u8; 65536] = [1; 65536];
    let first = &amp;v[0];
    println!("The first element is: {first}");
}</code></pre>
<p>Fig. 8. hello-rust-stack-probe-2 program.</p>
<p><img src="images/image2.png" title="The &quot;standard loop&quot; stack probe variant in modified hello-rust." alt="Screenshot of IDA Pro listing the “standard loop” stack probe variant in modified hello-rust.">
Fig. 9. The “standard loop” stack probe variant in modified hello-rust.</p>
<p>To check if stack clashing protection is enabled for a given binary, look for
any of the two stack probe variants in the prologue of functions whose stack
size is larger than a page size (see Figs. 6–9).</p>
<h3 id="read-only-relocations-and-immediate-binding"><a class="header" href="#read-only-relocations-and-immediate-binding">Read-only relocations and immediate binding</a></h3>
<p><strong>Read-only relocations</strong> protect segments containing relocations and
relocation information (i.e., <code>.init_array</code>, <code>.fini_array</code>, <code>.dynamic</code>, and
<code>.got</code>) from being overwritten by marking these segments read only. This is
also referred to as “partial RELRO”.</p>
<p>The Rust compiler supports read-only relocations, and enables it by default
since version 1.21.0 (2017-10-12)[30], [31].</p>
<pre><code class="language-text">$ readelf -l target/release/hello-rust | grep GNU_RELRO
  GNU_RELRO      0x000000000002ee00 0x000000000002fe00 0x000000000002fe00
</code></pre>
<p>Fig. 9. Checking if read-only relocations is enabled for a given binary.</p>
<p>The presence of an element of type <code>PT_GNU_RELRO</code> in the program header table
indicates read-only relocations are enabled for a given binary (see Fig. 9).
Conversely, the absence of an element of type <code>PT_GNU_RELRO</code> in the program
header table indicates read-only relocations are not enabled for a given
binary.</p>
<p><strong>Immediate binding</strong> protects additional segments containing relocations
(i.e., <code>.got.plt</code>) from being overwritten by instructing the dynamic linker to
perform all relocations before transferring control to the program during
startup, so all segments containing relocations can be marked read only (when
combined with read-only relocations). This is also referred to as “full RELRO”.</p>
<p>The Rust compiler supports immediate binding, and enables it by default since
version 1.21.0 (2017-10-12)[30], [31].</p>
<pre><code class="language-text">$ readelf -d target/release/hello-rust | grep BIND_NOW
 0x000000000000001e (FLAGS)              BIND_NOW
</code></pre>
<p>Fig. 10. Checking if immediate binding is enabled for a given binary.</p>
<p>The presence of an element with the <code>DT_BIND_NOW</code> tag and the <code>DF_BIND_NOW</code>
flag<sup class="footnote-reference" id="fr-bind-now-1"><a href="#footnote-bind-now">4</a></sup> in the dynamic section indicates immediate binding
is enabled for a given binary (see Fig. 10). Conversely, the absence of an
element with the <code>DT_BIND_NOW</code> tag and the <code>DF_BIND_NOW</code> flag in the dynamic
section indicates immediate binding is not enabled for a given binary.</p>
<p>The presence of both an element of type <code>PT_GNU_RELRO</code> in the program header
table and of an element with the <code>DT_BIND_NOW</code> tag and the <code>DF_BIND_NOW</code> flag
in the dynamic section indicates full RELRO is enabled for a given binary (see
Figs. 9–10).</p>
<h3 id="heap-corruption-protection"><a class="header" href="#heap-corruption-protection">Heap corruption protection</a></h3>
<p>Heap corruption protection protects memory allocated dynamically by performing
several checks, such as checks for corrupted links between list elements,
invalid pointers, invalid sizes, double/multiple “frees” of the same memory
allocated, and many corner cases of these. These checks are implementation
specific, and vary per allocator.</p>
<p><a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety">ARM Memory Tagging Extension
(MTE)</a>,
when available, will provide hardware assistance for a probabilistic mitigation
to detect memory safety violations by tagging memory allocations, and
automatically checking that the correct tag is used on every memory access.</p>
<p>Rust’s default allocator has historically been
<a href="http://jemalloc.net/">jemalloc</a>, and it has long been the cause of issues and
the subject of much discussion[32]–[38]. Consequently, it has been removed as
the default allocator in favor of the operating system’s standard C library
default allocator<sup class="footnote-reference" id="fr-linx-allocator-1"><a href="#footnote-linx-allocator">5</a></sup> since version 1.32.0 (2019-01-17)[39].</p>
<pre><code class="language-rust no_run">fn main() {
    let mut x = Box::new([0; 1024]);

    for i in 0..1026 {
        unsafe {
            let elem = x.get_unchecked_mut(i);
            *elem = 0x4141414141414141u64;
        }
    }
}</code></pre>
<p>Fig. 11. hello-rust-heap program.</p>
<pre><code class="language-text">$ cargo run
   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/hello-rust-heap`
free(): invalid next size (normal)
Aborted
</code></pre>
<p>Fig. 12. Build and execution of hello-rust-heap with debug assertions enabled.</p>
<pre><code class="language-text">$ cargo run --release
   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)
    Finished release [optimized] target(s) in 0.25s
     Running `target/release/hello-rust-heap`
free(): invalid next size (normal)
Aborted
</code></pre>
<p>Fig. 13. Build and execution of hello-rust-heap with debug assertions disabled.</p>
<p>Heap corruption checks are performed when using the default allocator (i.e.,
the GNU Allocator) (see Figs. 12–13).</p>
<h3 id="stack-smashing-protection"><a class="header" href="#stack-smashing-protection">Stack smashing protection</a></h3>
<p>Stack smashing protection protects programs from stack-based buffer overflows
by inserting a random guard value between local variables and the saved return
instruction pointer, and checking if this value has changed when returning from
a function. This is also known as “Stack Protector” or “Stack Smashing
Protector (SSP)”.</p>
<p>The Rust compiler supports stack smashing protection on nightly builds[40].</p>
<p><img src="images/image3.png" title="Cross references to __stack_chk_fail in hello-rust." alt="Screenshot of IDA Pro listing cross references to __stack_chk_fail in hello-rust.">
Fig. 14. IDA Pro listing cross references to <code>__stack_chk_fail</code> in hello-rust.</p>
<p>To check if stack smashing protection is enabled for a given binary, search for
cross references to <code>__stack_chk_fail</code> (see Fig. 14).</p>
<h3 id="forward-edge-control-flow-protection"><a class="header" href="#forward-edge-control-flow-protection">Forward-edge control flow protection</a></h3>
<p>Forward-edge control flow protection protects programs from having its control
flow changed/hijacked by performing checks to ensure that destinations of
indirect branches are one of their valid destinations in the control flow
graph. The comprehensiveness of these checks vary per implementation. This is
also known as “forward-edge control flow integrity (CFI)”.</p>
<p>Newer processors provide hardware assistance for forward-edge control flow
protection, such as ARM Branch Target Identification (BTI), ARM Pointer
Authentication, and Intel Indirect Branch Tracking (IBT) as part of Intel
Control-flow Enforcement Technology (CET). However, ARM BTI and Intel IBT
-based implementations are less comprehensive than software-based
implementations such as <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">LLVM ControlFlowIntegrity
(CFI)</a>, and the
commercially available <a href="https://grsecurity.net/rap_faq">grsecurity/PaX Reuse Attack Protector
(RAP)</a>.</p>
<p>The Rust compiler supports forward-edge control flow protection on nightly
builds[41]-[42] <sup class="footnote-reference" id="fr-win-cfg-1"><a href="#footnote-win-cfg">6</a></sup>.</p>
<pre><code class="language-text">$ readelf -s -W target/release/hello-rust | grep "\.cfi"
     5: 0000000000006480   657 FUNC    LOCAL  DEFAULT   15 _ZN10hello_rust4main17h4e359f1dcd627c83E.cfi
</code></pre>
<p>Fig. 15. Checking if LLVM CFI is enabled for a given binary.</p>
<p>The presence of symbols suffixed with “.cfi” or the <code>__cfi_init</code> symbol (and
references to <code>__cfi_check</code>) indicates that LLVM CFI (i.e., forward-edge
control flow protection) is enabled for a given binary. Conversely, the absence
of symbols suffixed with “.cfi” or the <code>__cfi_init</code> symbol (and references to
<code>__cfi_check</code>) indicates that LLVM CFI is not enabled for a given binary (see
Fig. 15).</p>
<h3 id="backward-edge-control-flow-protection"><a class="header" href="#backward-edge-control-flow-protection">Backward-edge control flow protection</a></h3>
<p><strong>Shadow stack</strong> protects saved return instruction pointers from being
overwritten by storing a copy of them on a separate (shadow) stack, and using
these copies as authoritative values when returning from functions. This is
also known as “ShadowCallStack” and “Return Flow Guard”, and is considered an
implementation of backward-edge control flow protection (or “backward-edge
CFI”).</p>
<p><strong>Safe stack</strong> protects not only the saved return instruction pointers, but
also register spills and some local variables from being overwritten by storing
unsafe variables, such as large arrays, on a separate (unsafe) stack, and using
these unsafe variables on the separate stack instead. This is also known as
“SafeStack”, and is also considered an implementation of backward-edge control
flow protection.</p>
<p>Both shadow and safe stack are intended to be a more comprehensive alternatives
to stack smashing protection as they protect the saved return instruction
pointers (and other data in the case of safe stack) from arbitrary writes and
non-linear out-of-bounds writes.</p>
<p>Newer processors provide hardware assistance for backward-edge control flow
protection, such as ARM Pointer Authentication, and Intel Shadow Stack as part
of Intel CET.</p>
<p>The Rust compiler supports shadow stack for the AArch64 architecture<sup class="footnote-reference" id="fr-amd64-shadow-1"><a href="#footnote-amd64-shadow">7</a></sup> on
nightly builds[43]-[44], and also supports safe stack on nightly
builds[45]-[46].</p>
<pre><code class="language-text">$ readelf -s target/release/hello-rust | grep __safestack_init
   678: 0000000000008c80   426 FUNC    GLOBAL DEFAULT   15 __safestack_init
</code></pre>
<p>Fig. 16. Checking if LLVM SafeStack is enabled for a given binary.</p>
<p>The presence of the <code>__safestack_init</code> symbol indicates that LLVM SafeStack is
enabled for a given binary. Conversely, the absence of the <code>__safestack_init</code>
symbol indicates that LLVM SafeStack is not enabled for a given binary (see
Fig. 16).</p>
<h2 id="appendix"><a class="header" href="#appendix">Appendix</a></h2>
<p>As of the latest version of the <a href="https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/progheader.html">Linux Standard Base (LSB) Core
Specification</a>,
the <code>PT_GNU_STACK</code> program header indicates whether the stack should be
executable, and the absence of this header indicates that the stack should be
executable. However, the Linux kernel currently sets the <code>READ_IMPLIES_EXEC</code>
personality upon loading any executable with the <code>PT_GNU_STACK</code> program header
and the <code>PF_X</code> flag set or with the absence of this header, resulting in not
only the stack, but also all readable virtual memory mappings being executable.</p>
<p>An attempt to fix this <a href="https://lore.kernel.org/lkml/f298f914-2239-44e4-8aa1-a51282e7fac0@zmail15.collab.prod.int.phx2.redhat.com/">was made in
2012</a>,
and another <a href="https://lore.kernel.org/kernel-hardening/20200327064820.12602-1-keescook@chromium.org/">was made in
2020</a>.
The former never landed, and the latter partially fixed it, but introduced
other issues—the absence of the <code>PT_GNU_STACK</code> program header still causes not
only the stack, but also all readable virtual memory mappings to be executable
in some architectures, such as IA-32 and equivalent (or causes the stack to be
non-executable in some architectures, such as AMD64 and equivalent,
contradicting the LSB).</p>
<p>The <code>READ_IMPLIES_EXEC</code> personality needs to be completely separated from the
<code>PT_GNU_STACK</code> program header by having a separate option for it (or setarch -X
could just be used whenever <code>READ_IMPLIES_EXEC</code> is needed), and the absence of
the <code>PT_GNU_STACK</code> program header needs to have more secure defaults (unrelated
to <code>READ_IMPLIES_EXEC</code>).</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li>
<p>D. Hosfelt. “Fearless security: memory safety.” Mozilla Hacks.
<a href="https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/">https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/</a>.</p>
</li>
<li>
<p>D. Hosfelt. “Fearless security: thread safety.” Mozilla Hacks.
<a href="https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/">https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “What Is Ownership?.” The Rust Programming
Language. <a href="../book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “References and Borrowing.” The Rust
Programming Language.
<a href="../book/ch04-02-references-and-borrowing.html">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “The Slice Type.” The Rust Programming
Language. <a href="../book/ch04-03-slices.html">https://doc.rust-lang.org/book/ch04-03-slices.html</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “Unsafe Rust.” The Rust Programming Language.
<a href="../book/ch19-01-unsafe-rust.html">https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html</a>.</p>
</li>
<li>
<p>S. Davidoff. “How Rust’s standard library was vulnerable for years and
nobody noticed.” Medium.
<a href="https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6">https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6</a>.</p>
</li>
<li>
<p>“Improper restriction of operations within the bounds of a memory buffer
(CWE-119).” MITRE CWE List.
<a href="https://cwe.mitre.org/data/definitions/119.html">https://cwe.mitre.org/data/definitions/119.html</a>.</p>
</li>
<li>
<p>“Concurrency issues (CWE-557).” MITRE CWE List.
<a href="https://cwe.mitre.org/data/definitions/557.html">https://cwe.mitre.org/data/definitions/557.html</a>.</p>
</li>
<li>
<p>K. McAllister. “Memory exploit mitigations #15179.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/15179">https://github.com/rust-lang/rust/issues/15179</a>.</p>
</li>
<li>
<p>K. McAllister. “RFC: Memory exploit mitigation #145.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/145">https://github.com/rust-lang/rfcs/pull/145</a>.</p>
</li>
<li>
<p>K. McAllister. “RFC: Memory exploit mitigation.” GitHub.
<a href="https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md">https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md</a>.</p>
</li>
<li>
<p>D. Micay. “Enable PIE by default on Linux for full ASLR #16340.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/16340">https://github.com/rust-lang/rust/pull/16340</a>.</p>
</li>
<li>
<p>N. Matsakis. “Integer overflow #560.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/560">https://github.com/rust-lang/rfcs/pull/560</a>.</p>
</li>
<li>
<p>G. Lehel and N. Matsakis. “Integer overflow.” GitHub.
<a href="https://rust-lang.github.io/rfcs/0560-integer-overflow.html">https://rust-lang.github.io/rfcs/0560-integer-overflow.html</a>.</p>
</li>
<li>
<p>A. Turon. “Tracking issue for integer overflow (RFC 560) #22020.”
GitHub. <a href="https://github.com/rust-lang/rust/issues/22020">https://github.com/rust-lang/rust/issues/22020</a>.</p>
</li>
<li>
<p>H. Wilson. “Myths and legends about integer overflow in Rust.” Huon on
the Internet.
<a href="http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/</a>.</p>
</li>
<li>
<p>B. Anderson. “Stabilize -C overflow-checks #1535.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/1535">https://github.com/rust-lang/rfcs/pull/1535</a>.</p>
</li>
<li>
<p>B. Anderson. “Stable overflow checks.” GitHub.
<a href="https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md">https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md</a>.</p>
</li>
<li>
<p>N. Froyd. “Add -C overflow-checks option #40037.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/40037">https://github.com/rust-lang/rust/pull/40037</a>.</p>
</li>
<li>
<p>R. Á. de Espíndola. “rustc requires executable stack #798.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/798">https://github.com/rust-lang/rust/issues/798</a>.</p>
</li>
<li>
<p>A. Seipp. “Make sure librustrt.so is linked with a non-executable stack.
#1066.” GitHub. <a href="https://github.com/rust-lang/rust/pull/1066">https://github.com/rust-lang/rust/pull/1066</a>.</p>
</li>
<li>
<p>D. Micay. “Rust binaries should not have an executable stack #5643.”
GitHub. <a href="https://github.com/rust-lang/rust/issues/5643">https://github.com/rust-lang/rust/issues/5643</a>.</p>
</li>
<li>
<p>D. Micay. “Mark the assembly object stacks as non-executable #5647.”
GitHub. <a href="https://github.com/rust-lang/rust/pull/5647">https://github.com/rust-lang/rust/pull/5647</a>.</p>
</li>
<li>
<p>A. Clark. “Explicitly disable stack execution on linux and bsd #30859.”
GitHub. <a href="https://github.com/rust-lang/rust/pull/30859">https://github.com/rust-lang/rust/pull/30859</a>.</p>
</li>
<li>
<p>Zoxc. “Replace stack overflow checking with stack probes #16012.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/16012">https://github.com/rust-lang/rust/issues/16012</a>.</p>
</li>
<li>
<p>A. Crichton. “rustc: Implement stack probes for x86 #42816.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/42816">https://github.com/rust-lang/rust/pull/42816</a>.</p>
</li>
<li>
<p>A. Crichton. “Add __rust_probestack intrinsic #175.” GitHub.
<a href="https://github.com/rust-lang/compiler-builtins/pull/175">https://github.com/rust-lang/compiler-builtins/pull/175</a>.</p>
</li>
<li>
<p>S. Guelton, S. Ledru, J. Stone. “Bringing Stack Clash Protection to Clang /
X86 — the Open Source Way.” The LLVM Project Blog.
<a href="https://blog.llvm.org/posts/2021-01-05-stack-clash-protection/">https://blog.llvm.org/posts/2021-01-05-stack-clash-protection/</a>.</p>
</li>
<li>
<p>B. Anderson. “Consider applying -Wl,-z,relro or -Wl,-z,relro,-z,now by
default #29877.” GitHub. <a href="https://github.com/rust-lang/rust/issues/29877">https://github.com/rust-lang/rust/issues/29877</a>.</p>
</li>
<li>
<p>J. Löthberg. “Add support for full RELRO #43170.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/43170">https://github.com/rust-lang/rust/pull/43170</a>.</p>
</li>
<li>
<p>N. Matsakis. “Allocators in Rust.” Baby Steps.
<a href="http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/">http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/</a>.</p>
</li>
<li>
<p>A. Crichton. “RFC: Allow changing the default allocator #1183.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/1183">https://github.com/rust-lang/rfcs/pull/1183</a>.</p>
</li>
<li>
<p>A. Crichton. “RFC: Swap out jemalloc.” GitHub.
<a href="https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html">https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html</a>.</p>
</li>
<li>
<p>A. Crichton. “Tracking issue for changing the global, default allocator
(RFC 1974) #27389.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/27389">https://github.com/rust-lang/rust/issues/27389</a>.</p>
</li>
<li>
<p>S. Fackler. “Prepare global allocators for stabilization #1974.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/1974">https://github.com/rust-lang/rfcs/pull/1974</a>.</p>
</li>
<li>
<p>A. Crichton. “RFC: Global allocators.” GitHub.
<a href="https://rust-lang.github.io/rfcs/1974-global-allocators.html">https://rust-lang.github.io/rfcs/1974-global-allocators.html</a>.</p>
</li>
<li>
<p>B. Anderson. “Switch the default global allocator to System, remove
alloc_jemalloc, use jemallocator in rustc #36963.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/36963">https://github.com/rust-lang/rust/issues/36963</a>.</p>
</li>
<li>
<p>A. Crichton. “Remove the alloc_jemalloc crate #55238.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/55238">https://github.com/rust-lang/rust/pull/55238</a>.</p>
</li>
<li>
<p>bbjornse. “Add codegen option for using LLVM stack smash protection #84197.”
GitHub. <a href="https://github.com/rust-lang/rust/pull/84197">https://github.com/rust-lang/rust/pull/84197</a></p>
</li>
<li>
<p>R. de C. Valle. “Tracking Issue for LLVM Control Flow Integrity (CFI) Support
for Rust #89653.” GitHub. <a href="https://github.com/rust-lang/rust/issues/89653">https://github.com/rust-lang/rust/issues/89653</a>.</p>
</li>
<li>
<p>“ControlFlowIntegrity.” The Rust Unstable Book.
<a href="../unstable-book/compiler-flags/sanitizer.html#controlflowintegrity">https://doc.rust-lang.org/unstable-book/compiler-flags/sanitizer.html#controlflowintegrity</a>.</p>
</li>
<li>
<p>I. Lozano. “Add support for LLVM ShadowCallStack #98208.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/98208">https://github.com/rust-lang/rust/pull/98208</a>.</p>
</li>
<li>
<p>“ShadowCallStack.” The Rust Unstable Book.
<a href="../unstable-book/compiler-flags/sanitizer.html#shadowcallstack">https://doc.rust-lang.org/unstable-book/compiler-flags/sanitizer.html#shadowcallstack</a>.</p>
</li>
<li>
<p>W. Wiser. “Add support for LLVM SafeStack #112000” GitHub.
<a href="https://github.com/rust-lang/rust/pull/112000">https://github.com/rust-lang/rust/pull/112000</a></p>
</li>
<li>
<p>“SafeStack.” The Rust Unstable Book.
<a href="../unstable-book/compiler-flags/sanitizer.html#safestack">https://doc.rust-lang/org/unstable-book/compiler-flags/sanitizer.html#safestack</a>.</p>
</li>
</ol>
<hr>
<ol class="footnote-definition">
<li id="footnote-all-targets">
<p>See <a href="https://github.com/rust-lang/rust/tree/HEAD/compiler/rustc_target/src/spec">https://github.com/rust-lang/rust/tree/HEAD/compiler/rustc_target/src/spec</a>
for a list of targets and their default options. <a href="#fr-all-targets-1">↩</a></p>
</li>
<li id="footnote-checked-methods">
<p>See <a href="../std/primitive.u32.html">the <code>u32</code> docs</a> for more
information on the checked, overflowing, saturating, and wrapping methods
(using u32 as an example). <a href="#fr-checked-methods-1">↩</a></p>
</li>
<li id="footnote-other-regions">
<p>See the <a href="#appendix">Appendix section</a> for more information
on why it affects other memory regions besides the stack. <a href="#fr-other-regions-1">↩</a></p>
</li>
<li id="footnote-bind-now">
<p>And the <code>DF_1_NOW</code> flag for some link editors. <a href="#fr-bind-now-1">↩</a></p>
</li>
<li id="footnote-linx-allocator">
<p>Linux’s standard C library default allocator is the GNU
Allocator, which is derived from ptmalloc (pthreads malloc) by Wolfram Gloger,
which in turn is derived from dlmalloc (Doug Lea malloc) by Doug Lea. <a href="#fr-linx-allocator-1">↩</a></p>
</li>
<li id="footnote-win-cfg">
<p>It also supports Control Flow Guard (CFG) on Windows (see
<a href="https://github.com/rust-lang/rust/issues/68793">https://github.com/rust-lang/rust/issues/68793</a>). <a href="#fr-win-cfg-1">↩</a></p>
</li>
<li id="footnote-amd64-shadow">
<p>The shadow stack implementation for the AMD64 architecture
and equivalent in LLVM was removed due to performance and security issues. <a href="#fr-amd64-shadow-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="symbol-mangling"><a class="header" href="#symbol-mangling">Symbol Mangling</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Name_mangling">Symbol name mangling</a> is used by <code>rustc</code> to encode a unique name for symbols that are used during code generation.
The encoded names are used by the linker to associate the name with the thing it refers to.</p>
<p>The method for mangling the names can be controlled with the <a href="#symbol-mangling-version"><code>-C symbol-mangling-version</code></a> option.</p>
<h2 id="per-item-control"><a class="header" href="#per-item-control">Per-item control</a></h2>
<p>The <a href="../reference/abi.html#the-no_mangle-attribute"><code>#[no_mangle]</code> attribute</a> can be used on items to disable name mangling on that item.</p>
<p>The <a href="../reference/abi.html#the-export_name-attribute"><code>#[export_name]</code>attribute</a> can be used to specify the exact name that will be used for a function or static.</p>
<p>Items listed in an <a href="../reference/items/external-blocks.html"><code>extern</code> block</a> use the identifier of the item without mangling to refer to the item.
The <a href="../reference/items/external-blocks.html#the-link_name-attribute"><code>#[link_name]</code> attribute</a> can be used to change that name.</p>
<!--
FIXME: This is incomplete for wasm, per https://github.com/rust-lang/rust/blob/d4c364347ce65cf083d4419195b8232440928d4d/compiler/rustc_symbol_mangling/src/lib.rs#L191-L210
-->
<h2 id="decoding"><a class="header" href="#decoding">Decoding</a></h2>
<p>The encoded names may need to be decoded in some situations.
For example, debuggers and other tooling may need to demangle the name so that it is more readable to the user.
Recent versions of <code>gdb</code> and <code>lldb</code> have built-in support for demangling Rust identifiers.
In situations where you need to do your own demangling, the <a href="https://crates.io/crates/rustc-demangle"><code>rustc-demangle</code></a> crate can be used to programmatically demangle names.
<a href="https://crates.io/crates/rustfilt"><code>rustfilt</code></a> is a CLI tool which can demangle names.</p>
<p>An example of running rustfilt:</p>
<pre><code class="language-text">$ rustfilt _RNvCskwGfYPst2Cb_3foo16example_function
foo::example_function
</code></pre>
<h2 id="mangling-versions"><a class="header" href="#mangling-versions">Mangling versions</a></h2>
<p><code>rustc</code> supports different mangling versions which encode the names in different ways.
The legacy version (which is currently the default on beta/stable) is not described here.
The “v0” mangling scheme addresses several limitations of the legacy format,
and is described in the <a href="#v0-symbol-format">v0 Symbol Format</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="v0-symbol-format"><a class="header" href="#v0-symbol-format">v0 Symbol Format</a></h1>
<p>The v0 mangling format was introduced in <a href="https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html">RFC 2603</a>.
It has the following properties:</p>
<ul>
<li>It provides an unambiguous string encoding for everything that can end up in a binary’s symbol table.</li>
<li>It encodes information about generic parameters in a reversible way.</li>
<li>The mangled symbols are <em>decodable</em> such that the demangled form should be easily identifiable as some concrete instance of e.g. a polymorphic function.</li>
<li>It has a consistent definition that does not rely on pretty-printing certain language constructs.</li>
<li>Symbols can be restricted to only consist of the characters <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, and <code>_</code>.
This helps ensure that it is platform-independent,
where other characters might have special meaning in some context (e.g. <code>.</code> for MSVC <code>DEF</code> files).
Unicode symbols are optionally supported.</li>
<li>It tries to stay efficient, avoiding unnecessarily long names,
and avoiding computationally expensive operations to demangle.</li>
</ul>
<p>The v0 format is not intended to be compatible with other mangling schemes (such as C++).</p>
<p>The v0 format is not presented as a stable ABI for Rust.
This format is currently intended to be well-defined enough that a demangler can produce a reasonable human-readable form of the symbol.
There are several implementation-defined portions that result in it not being possible to entirely predict how a given Rust entity will be encoded.</p>
<p>The sections below define the encoding of a v0 symbol.
There is no standardized demangled form of the symbols,
though suggestions are provided for how to demangle a symbol.
Implementers may choose to demangle in different ways.</p>
<h2 id="extensions"><a class="header" href="#extensions">Extensions</a></h2>
<p>This format may be extended in the future to add new tags as Rust is extended with new language items.
To be forward compatible, demanglers should gracefully handle symbols that have encodings where it encounters a tag character not described in this document.
For example, they may fall back to displaying the mangled symbol.
The format may be extended anywhere there is a tag character, such as the <a href="#type">type</a> rule.
The meaning of existing tags and encodings will not be changed.</p>
<h2 id="grammar-notation"><a class="header" href="#grammar-notation">Grammar notation</a></h2>
<p>The format of an encoded symbol is illustrated as a context free grammar in an extended BNF-like syntax.
A consolidated summary can be found in the <a href="#symbol-grammar-summary">Symbol grammar summary</a>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Syntax</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Rule</td><td>→</td><td><nobr>A → <em>B</em> <em>C</em></nobr></td><td>A production.</td></tr>
<tr><td>Concatenation</td><td>whitespace</td><td><nobr>A → <em>B</em> <em>C</em> <em>D</em></nobr></td><td>Individual elements in sequence left-to-right.</td></tr>
<tr><td>Alternative</td><td>|</td><td><nobr>A → <em>B</em> | <em>C</em></nobr></td><td>Matches either one or the other.</td></tr>
<tr><td>Grouping</td><td>()</td><td><nobr>A → <em>B</em> (<em>C</em> | <em>D</em>) <em>E</em></nobr></td><td>Groups multiple elements as one.</td></tr>
<tr><td>Repetition</td><td>{}</td><td><nobr>A → {<em>B</em>}</nobr></td><td>Repeats the enclosed zero or more times.</td></tr>
<tr><td>Option</td><td><sub>opt</sub></td><td><nobr>A → <em>B</em><sub>opt</sub> <em>C</em></nobr></td><td>An optional element.</td></tr>
<tr><td>Literal</td><td><code>monospace</code></td><td><nobr>A → <code>G</code></nobr></td><td>A terminal matching the exact characters case-sensitive.</td></tr>
</tbody>
</table>
</div>
<h2 id="symbol-name"><a class="header" href="#symbol-name">Symbol name</a></h2>
<blockquote>
<p>symbol-name → <code>_R</code> <em><a href="#common-rules">decimal-number</a></em><sub>opt</sub> <em><a href="#symbol-path">path</a></em> <em><a href="#instantiating-crate">instantiating-crate</a></em><sub>opt</sub> <em><a href="#vendor-specific-suffix">vendor-specific-suffix</a></em><sub>opt</sub></p>
</blockquote>
<p>A mangled symbol starts with the two characters <code>_R</code> which is a prefix to identify the symbol as a Rust symbol.
The prefix can optionally be followed by a <em><a href="#common-rules">decimal-number</a></em> which specifies the encoding version.
This number is currently not used, and is never present in the current encoding.
Following that is a <em><a href="#symbol-path">path</a></em> which encodes the path to an entity.
The path is followed by an optional <em><a href="#instantiating-crate">instantiating-crate</a></em> which helps to disambiguate entities which may be instantiated multiple times in separate crates.
The final part is an optional <em><a href="#vendor-specific-suffix">vendor-specific-suffix</a></em>.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>symbol-name</em> should be displayed as the <em><a href="#symbol-path">path</a></em>.
The <em><a href="#instantiating-crate">instantiating-crate</a></em> and the <em><a href="#vendor-specific-suffix">vendor-specific-suffix</a></em> usually need not be displayed.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">std::path::PathBuf::new();</code></pre>
<p>The symbol for <code>PathBuf::new</code> in crate <code>mycrate</code> is:</p>
<pre><code class="language-text">_RNvMsr_NtCs3ssYzQotkvD_3std4pathNtB5_7PathBuf3newCs15kBYyAo9fc_7mycrate
├┘└───────────────────────┬──────────────────────┘└──────────┬─────────┘
│                         │                                  │
│                         │                                  └── instantiating-crate path "mycrate"
│                         └───────────────────────────────────── path to std::path::PathBuf::new
└─────────────────────────────────────────────────────────────── `_R` symbol prefix
</code></pre>
<p>Recommended demangling: <code>&lt;std::path::PathBuf&gt;::new</code></p>
</blockquote>
<h2 id="symbol-path"><a class="header" href="#symbol-path">Symbol path</a></h2>
<blockquote>
<p>path → <br>      <em><a href="#path-crate-root">crate-root</a></em> <br>   | <em><a href="#path-inherent-impl">inherent-impl</a></em> <br>   | <em><a href="#path-trait-impl">trait-impl</a></em> <br>   | <em><a href="#path-trait-definition">trait-definition</a></em> <br>   | <em><a href="#path-nested-path">nested-path</a></em> <br>   | <em><a href="#path-generic-arguments">generic-args</a></em> <br>   | <em><a href="#backref">backref</a></em></p>
</blockquote>
<p>A <em>path</em> represents a variant of a <a href="../reference/paths.html">Rust path</a> to some entity.
In addition to typical Rust path segments using identifiers,
it uses extra elements to represent unnameable entities (like an <code>impl</code>) or generic arguments for monomorphized items.</p>
<p>The initial tag character can be used to determine which kind of path it represents:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tag</th><th>Rule</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>C</code></td><td><em><a href="#path-crate-root">crate-root</a></em></td><td>The root of a crate path.</td></tr>
<tr><td><code>M</code></td><td><em><a href="#path-inherent-impl">inherent-impl</a></em></td><td>An inherent implementation.</td></tr>
<tr><td><code>X</code></td><td><em><a href="#path-trait-impl">trait-impl</a></em></td><td>A trait implementation.</td></tr>
<tr><td><code>Y</code></td><td><em><a href="#path-trait-definition">trait-definition</a></em></td><td>A trait definition.</td></tr>
<tr><td><code>N</code></td><td><em><a href="#path-nested-path">nested-path</a></em></td><td>A nested path.</td></tr>
<tr><td><code>I</code></td><td><em><a href="#path-generic-arguments">generic-args</a></em></td><td>Generic arguments.</td></tr>
<tr><td><code>B</code></td><td><em><a href="#backref">backref</a></em></td><td>A back reference.</td></tr>
</tbody>
</table>
</div>
<h3 id="path-crate-root"><a class="header" href="#path-crate-root">Path: Crate root</a></h3>
<blockquote>
<p>crate-root → <code>C</code> <em><a href="#identifier">identifier</a></em></p>
</blockquote>
<p>A <em>crate-root</em> indicates a path referring to the root of a crate’s module tree.
It consists of the character <code>C</code> followed by the crate name as an <em><a href="#identifier">identifier</a></em>.</p>
<p>The crate name is the name as seen from the defining crate.
Since Rust supports linking multiple crates with the same name,
the <em><a href="#disambiguator">disambiguator</a></em> is used to make the name unique across the crate graph.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>crate-root</em> can be displayed as the identifier such as <code>mycrate</code>.</p>
<p>Usually the disambiguator in the identifier need not be displayed,
but as an alternate form the disambiguator can be shown in hex such as
<code>mycrate[ca63f166dbe9294]</code>.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">fn example() {}</code></pre>
<p>The symbol for <code>example</code> in crate <code>mycrate</code> is:</p>
<pre><code class="language-text">_RNvCs15kBYyAo9fc_7mycrate7example
    │└────┬─────┘││└──┬──┘
    │     │      ││   │
    │     │      ││   └── crate-root identifier "mycrate"
    │     │      │└────── length 7 of "mycrate"
    │     │      └─────── end of base-62-number
    │     └────────────── disambiguator for crate-root "mycrate" 0xca63f166dbe9293 + 1
    └──────────────────── crate-root
</code></pre>
<p>Recommended demangling: <code>mycrate::example</code></p>
<p>Note: The compiler may re-use the <em>crate-root</em> form to express arbitrary
unscoped, undisambiguated identifiers, such as for new basic types that have
not been added to the grammar yet. To achieve that, it will emit a <em>crate-root</em>
without an explicit disambiguator, relying on the fact that such an
undisambiguated crate name cannot occur in practice. For example, the basic
type <code>f128</code> would be encode as <code>C4f128</code>. For this to have the desired effect,
demanglers are expected to never render zero disambiguators of crate roots.
I.e. <code>C4f128</code> is expected to be displayed as <code>f128</code> and not <code>f128[0]</code>.</p>
</blockquote>
<h3 id="path-inherent-impl"><a class="header" href="#path-inherent-impl">Path: Inherent impl</a></h3>
<blockquote>
<p>inherent-impl → <code>M</code> <em><a href="#path-impl">impl-path</a></em> <em><a href="#type">type</a></em></p>
</blockquote>
<p>An <em>inherent-impl</em> indicates a path to an <a href="../reference/items/implementations.html#inherent-implementations">inherent implementation</a>.
It consists of the character <code>M</code> followed by an <em><a href="#path-impl">impl-path</a></em>, which uniquely identifies the impl block the item is defined in.
Following that is a <em><a href="#type">type</a></em> representing the <code>Self</code> type of the impl.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>An <em>inherent-impl</em> can be displayed as a qualified path segment to the <em><a href="#type">type</a></em> within angled brackets.
The <em><a href="#path-impl">impl-path</a></em> usually need not be displayed.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">struct Example;
impl Example {
    fn foo() {}
}</code></pre>
<p>The symbol for <code>foo</code> in the impl for <code>Example</code> is:</p>
<pre><code class="language-text">_RNvMs_Cs4Cv8Wi1oAIB_7mycrateNtB4_7Example3foo
    │├┘└─────────┬──────────┘└────┬──────┘
    ││           │                │
    ││           │                └── Self type "Example"
    ││           └─────────────────── path to the impl's parent "mycrate"
    │└─────────────────────────────── disambiguator 1
    └──────────────────────────────── inherent-impl
</code></pre>
<p>Recommended demangling: <code>&lt;mycrate::Example&gt;::foo</code></p>
</blockquote>
<h3 id="path-trait-impl"><a class="header" href="#path-trait-impl">Path: Trait impl</a></h3>
<blockquote>
<p>trait-impl → <code>X</code> <em><a href="#path-impl">impl-path</a></em> <em><a href="#type">type</a></em> <em><a href="#symbol-path">path</a></em></p>
</blockquote>
<p>A <em>trait-impl</em> indicates a path to a <a href="../reference/items/implementations.html#trait-implementations">trait implementation</a>.
It consists of the character <code>X</code> followed by an <em><a href="#path-impl">impl-path</a></em> to the impl’s parent followed by the <em><a href="#type">type</a></em> representing the <code>Self</code> type of the impl followed by a <em><a href="#symbol-path">path</a></em> to the trait.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>trait-impl</em> can be displayed as a qualified path segment using the <code>&lt;</code> <em>type</em> <code>as</code> <em>path</em> <code>&gt;</code> syntax.
The <em><a href="#path-impl">impl-path</a></em> usually need not be displayed.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">struct Example;
trait Trait {
    fn foo();
}
impl Trait for Example {
    fn foo() {}
}</code></pre>
<p>The symbol for <code>foo</code> in the trait impl for <code>Example</code> is:</p>
<pre><code class="language-text">_RNvXCs15kBYyAo9fc_7mycrateNtB2_7ExampleNtB2_5Trait3foo
    │└─────────┬──────────┘└─────┬─────┘└────┬────┘
    │          │                 │           │
    │          │                 │           └── path to the trait "Trait"
    │          │                 └────────────── Self type "Example"
    │          └──────────────────────────────── path to the impl's parent "mycrate"
    └─────────────────────────────────────────── trait-impl
</code></pre>
<p>Recommended demangling: <code>&lt;mycrate::Example as mycrate::Trait&gt;::foo</code></p>
</blockquote>
<h3 id="path-impl"><a class="header" href="#path-impl">Path: Impl</a></h3>
<blockquote>
<p>impl-path → <em><a href="#disambiguator">disambiguator</a></em><sub>opt</sub> <em><a href="#symbol-path">path</a></em></p>
</blockquote>
<p>An <em>impl-path</em> is a path used for <em><a href="#path-inherent-impl">inherent-impl</a></em> and <em><a href="#path-trait-impl">trait-impl</a></em> to indicate the path to parent of an <a href="../reference/items/implementations.html">implementation</a>.
It consists of an optional <em><a href="#disambiguator">disambiguator</a></em> followed by a <em><a href="#symbol-path">path</a></em>.
The <em><a href="#symbol-path">path</a></em> is the path to the parent that contains the impl.
The <em><a href="#disambiguator">disambiguator</a></em> can be used to distinguish between multiple impls within the same parent.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>An <em>impl-path</em> usually need not be displayed (unless the location of the impl is desired).</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">struct Example;
impl Example {
    fn foo() {}
}
impl Example {
    fn bar() {}
}</code></pre>
<p>The symbol for <code>foo</code> in the impl for <code>Example</code> is:</p>
<pre><code class="language-text">_RNvMCs7qp2U7fqm6G_7mycrateNtB2_7Example3foo
     └─────────┬──────────┘
               │
               └── path to the impl's parent crate-root "mycrate"
</code></pre>
<p>The symbol for <code>bar</code> is similar, though it has a disambiguator to indicate it is in a different impl block.</p>
<pre><code class="language-text">_RNvMs_Cs7qp2U7fqm6G_7mycrateNtB4_7Example3bar
     ├┘└─────────┬──────────┘
     │           │
     │           └── path to the impl's parent crate-root "mycrate"
     └────────────── disambiguator 1
</code></pre>
<p>Recommended demangling:</p>
<ul>
<li><code>foo</code>: <code>&lt;mycrate::Example&gt;::foo</code></li>
<li><code>bar</code>: <code>&lt;mycrate::Example&gt;::bar</code></li>
</ul>
</blockquote>
<h3 id="path-trait-definition"><a class="header" href="#path-trait-definition">Path: Trait definition</a></h3>
<blockquote>
<p>trait-definition → <code>Y</code> <em><a href="#type">type</a></em> <em><a href="#symbol-path">path</a></em></p>
</blockquote>
<p>A <em>trait-definition</em> is a path to a <a href="../reference/items/traits.html">trait definition</a>.
It consists of the character <code>Y</code> followed by the <em><a href="#type">type</a></em> which is the <code>Self</code> type of the referrer, followed by the <em><a href="#symbol-path">path</a></em> to the trait definition.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>trait-definition</em> can be displayed as a qualified path segment using the <code>&lt;</code> <em>type</em> <code>as</code> <em>path</em> <code>&gt;</code> syntax.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">trait Trait {
    fn example() {}
}
struct Example;
impl Trait for Example {}</code></pre>
<p>The symbol for <code>example</code> in the trait <code>Trait</code> implemented for <code>Example</code> is:</p>
<pre><code class="language-text">_RNvYNtCs15kBYyAo9fc_7mycrate7ExampleNtB4_5Trait7exampleB4_
    │└──────────────┬───────────────┘└────┬────┘
    │               │                     │
    │               │                     └── path to the trait "Trait"
    │               └──────────────────────── path to the implementing type "mycrate::Example"
    └──────────────────────────────────────── trait-definition
</code></pre>
<p>Recommended demangling: <code>&lt;mycrate::Example as mycrate::Trait&gt;::example</code></p>
</blockquote>
<h3 id="path-nested-path"><a class="header" href="#path-nested-path">Path: Nested path</a></h3>
<blockquote>
<p>nested-path → <code>N</code> <em><a href="#namespace">namespace</a></em> <em><a href="#symbol-path">path</a></em> <em><a href="#identifier">identifier</a></em></p>
</blockquote>
<p>A <em>nested-path</em> is a path representing an optionally named entity.
It consists of the character <code>N</code> followed by a <em><a href="#namespace">namespace</a></em> indicating the namespace of the entity,
followed by a <em><a href="#symbol-path">path</a></em> which is a path representing the parent of the entity,
followed by an <em><a href="#identifier">identifier</a></em> of the entity.</p>
<p>The identifier of the entity may have a length of 0 when the entity is not named.
For example, entities like closures, tuple-like struct constructors, and anonymous constants may not have a name.
The identifier may still have a disambiguator unless the disambiguator is 0.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>nested-path</em> can be displayed by first displaying the <em><a href="#symbol-path">path</a></em> followed by a <code>::</code> separator followed by the <em><a href="#identifier">identifier</a></em>.
If the <em><a href="#identifier">identifier</a></em> is empty, then the separating <code>::</code> should not be displayed.</p>
<p>If a <em><a href="#namespace">namespace</a></em> is specified, then extra context may be added such as: <br><em><a href="#symbol-path">path</a></em> <code>::{</code> <em><a href="#namespace">namespace</a></em> (<code>:</code> <em><a href="#identifier">identifier</a></em>)<sub>opt</sub> <code>#</code> <em>disambiguator</em><sub>as base-10 number</sub> <code>}</code></p>
<p>Here the namespace <code>C</code> may be printed as <code>closure</code> and <code>S</code> as <code>shim</code>.
Others may be printed by their character tag.
The <code>:</code> <em>name</em> portion may be skipped if the name is empty.</p>
<p>The <em><a href="#disambiguator">disambiguator</a></em> in the <em><a href="#identifier">identifier</a></em> may be displayed if a <em><a href="#namespace">namespace</a></em> is specified.
In other situations, it is usually not necessary to display the <em><a href="#disambiguator">disambiguator</a></em>.
If it is displayed, it is recommended to place it in brackets, for example <code>[284a76a8b41a7fd3]</code>.
If the <em><a href="#disambiguator">disambiguator</a></em> is not present, then its value is 0 and it can always be omitted from display.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">fn main() {
    let x = || {};
    let y = || {};
    x();
    y();
}</code></pre>
<p>The symbol for the closure <code>x</code> in crate <code>mycrate</code> is:</p>
<pre><code class="language-text">_RNCNvCsgStHSCytQ6I_7mycrate4main0B3_
  ││└─────────────┬─────────────┘│
  ││              │              │
  ││              │              └── identifier with length 0
  ││              └───────────────── path to "mycrate::main"
  │└──────────────────────────────── closure namespace
  └───────────────────────────────── nested-path
</code></pre>
<p>The symbol for the closure <code>y</code> is similar, with a disambiguator:</p>
<pre><code class="language-text">_RNCNvCsgStHSCytQ6I_7mycrate4mains_0B3_
                                 ││
                                 │└── base-62-number 0
                                 └─── disambiguator 1 (base-62-number+1)
</code></pre>
<p>Recommended demangling:</p>
<ul>
<li><code>x</code>: <code>mycrate::main::{closure#0}</code></li>
<li><code>y</code>: <code>mycrate::main::{closure#1}</code></li>
</ul>
</blockquote>
<h3 id="path-generic-arguments"><a class="header" href="#path-generic-arguments">Path: Generic arguments</a></h3>
<blockquote>
<p>generic-args → <code>I</code> <em><a href="#symbol-path">path</a></em> {<em><a href="#path-generic-arguments">generic-arg</a></em>} <code>E</code></p>
<p>generic-arg → <br>      <em><a href="#lifetime">lifetime</a></em> <br>   | <em><a href="#type">type</a></em> <br>   | <code>K</code> <em><a href="#const">const</a></em></p>
</blockquote>
<p>A <em>generic-args</em> is a path representing a list of generic arguments.
It consists of the character <code>I</code> followed by a <em><a href="#symbol-path">path</a></em> to the defining entity, followed by zero or more <em><a href="#path-generic-arguments">generic-arg</a></em>s terminated by the character <code>E</code>.</p>
<p>Each <em><a href="#path-generic-arguments">generic-arg</a></em> is either a <em><a href="#lifetime">lifetime</a></em> (starting with the character <code>L</code>), a <em><a href="#type">type</a></em>, or the character <code>K</code> followed by a <em><a href="#const">const</a></em> representing a const argument.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>generic-args</em> may be printed as: <em><a href="#symbol-path">path</a></em> <code>::</code><sub>opt</sub> <code>&lt;</code> comma-separated list of args <code>&gt;</code>
The <code>::</code> separator may be elided for type paths (similar to Rust’s rules).</p>
</blockquote>
<blockquote>
<blockquote>
<p>Example:</p>
</blockquote>
<pre><code class="language-rust">fn main() {
    example([123]);
}

fn example&lt;T, const N: usize&gt;(x: [T; N]) {}</code></pre>
<p>The symbol for the function <code>example</code> is:</p>
<pre><code class="language-text">_RINvCsgStHSCytQ6I_7mycrate7examplelKj1_EB2_
  │└──────────────┬───────────────┘││││││
  │               │                │││││└── end of generic-args
  │               │                ││││└─── end of const-data
  │               │                │││└──── const value `1`
  │               │                ││└───── const type `usize`
  │               │                │└────── const generic
  │               │                └─────── generic type i32
  │               └──────────────────────── path to "mycrate::example"
  └──────────────────────────────────────── generic-args
</code></pre>
<p>Recommended demangling: <code>mycrate::example::&lt;i32, 1&gt;</code></p>
</blockquote>
<h3 id="namespace"><a class="header" href="#namespace">Namespace</a></h3>
<blockquote>
<p>namespace → <em><a href="#common-rules">lower</a></em> | <em><a href="#common-rules">upper</a></em></p>
</blockquote>
<p>A <em>namespace</em> is used to segregate names into separate logical groups, allowing identical names to otherwise avoid collisions.
It consists of a single character of an upper or lowercase ASCII letter.
Lowercase letters are reserved for implementation-internal disambiguation categories (and demanglers should never show them).
Uppercase letters are used for special namespaces which demanglers may display in a special way.</p>
<p>Uppercase namespaces are:</p>
<ul>
<li><code>C</code> — A closure.</li>
<li><code>S</code> — A shim. Shims are added by the compiler in some situations where an intermediate is needed.
For example, a <code>fn()</code> pointer to a function with the <a href="../reference/attributes/codegen.html#the-track_caller-attribute"><code>#[track_caller]</code> attribute</a> needs a shim to deal with the implicit caller location.</li>
</ul>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>See <em><a href="#path-nested-path">nested-path</a></em> for recommended demangling.</p>
</blockquote>
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<blockquote>
<p>identifier → <em><a href="#disambiguator">disambiguator</a></em><sub>opt</sub> <em><a href="#identifier">undisambiguated-identifier</a></em></p>
<p>undisambiguated-identifier → <code>u</code><sub>opt</sub> <em><a href="#common-rules">decimal-number</a></em> <code>_</code><sub>opt</sub> <em><a href="#identifier">bytes</a></em></p>
<p>bytes → {<em>UTF-8 bytes</em>}</p>
</blockquote>
<p>An <em>identifier</em> is a named label used in a <em><a href="#symbol-path">path</a></em> to refer to an entity.
It consists of an optional <em><a href="#disambiguator">disambiguator</a></em> followed by an <em><a href="#identifier">undisambiguated-identifier</a></em>.</p>
<p>The disambiguator is used to disambiguate identical identifiers that should not otherwise be considered the same.
For example, closures have no name, so the disambiguator is the only differentiating element between two different closures in the same parent path.</p>
<p>The undisambiguated-identifier starts with an optional <code>u</code> character,
which indicates that the identifier is encoded in <a href="#punycode-identifiers">Punycode</a>.
The next part is a <em><a href="#common-rules">decimal-number</a></em> which indicates the length of the <em>bytes</em>.</p>
<p>Following the identifier size is an optional <code>_</code> character which is used to separate the length value from the identifier itself.
The <code>_</code> is mandatory if the <em>bytes</em> starts with a decimal digit or <code>_</code> in order to keep it unambiguous where the <em>decimal-number</em> ends and the <em>bytes</em> starts.</p>
<p><em>bytes</em> is the identifier itself encoded in UTF-8.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>The display of an <em>identifier</em> can depend on its context.
If it is Punycode-encoded, then it may first be decoded before being displayed.</p>
<p>The <em><a href="#disambiguator">disambiguator</a></em> may or may not be displayed; see recommendations for rules that use <em>identifier</em>.</p>
</blockquote>
<h3 id="punycode-identifiers"><a class="header" href="#punycode-identifiers">Punycode identifiers</a></h3>
<p>Because some environments are restricted to ASCII alphanumerics and <code>_</code>,
Rust’s <a href="../reference/identifiers.html">Unicode identifiers</a> may be encoded using a modified version of <a href="https://tools.ietf.org/html/rfc3492">Punycode</a>.</p>
<p>For example, the function:</p>
<pre><code class="language-rust">mod gödel {
  mod escher {
    fn bach() {}
  }
}</code></pre>
<p>would be mangled as:</p>
<pre><code class="language-text">_RNvNtNtCsgOH4LzxkuMq_7mycrateu8gdel_5qa6escher4bach
                              ││└───┬──┘
                              ││    │
                              ││    └── gdel_5qa translates to gödel
                              │└─────── 8 is the length
                              └──────── `u` indicates it is a Unicode identifier
</code></pre>
<p>Standard Punycode generates strings of the form <code>([[:ascii:]]+-)?[[:alnum:]]+</code>.
This is problematic because the <code>-</code> character
(which is used to separate the ASCII part from the base-36 encoding)
is not in the supported character set for symbols.
For this reason, <code>-</code> characters in the Punycode encoding are replaced with <code>_</code>.</p>
<p>Here are some examples:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Original</th><th>Punycode</th><th>Punycode + Encoding</th></tr>
</thead>
<tbody>
<tr><td>føø</td><td>f-5gaa</td><td>f_5gaa</td></tr>
<tr><td>α_ω</td><td>_-ylb7e</td><td>__ylb7e</td></tr>
<tr><td>铁锈</td><td>n84amf</td><td>n84amf</td></tr>
<tr><td>🤦</td><td>fq9h</td><td>fq9h</td></tr>
<tr><td>ρυστ</td><td>2xaedc</td><td>2xaedc</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p>Note: It is up to the compiler to decide whether or not to encode identifiers using Punycode or not.
Some platforms may have native support for UTF-8 symbols,
and the compiler may decide to use the UTF-8 encoding directly.
Demanglers should be prepared to support either form.</p>
</blockquote>
<h2 id="disambiguator"><a class="header" href="#disambiguator">Disambiguator</a></h2>
<blockquote>
<p>disambiguator → <code>s</code> <em><a href="#base-62-number">base-62-number</a></em></p>
</blockquote>
<p>A <em>disambiguator</em> is used in various parts of a symbol <em><a href="#symbol-path">path</a></em> to uniquely identify path elements that would otherwise be identical but should not be considered the same.
It starts with the character <code>s</code> and is followed by a <em><a href="#base-62-number">base-62-number</a></em>.</p>
<p>If the <em>disambiguator</em> is not specified, then its value can be assumed to be zero.
Otherwise, when demangling, the value 1 should be added to the <em><a href="#base-62-number">base-62-number</a></em>
(thus a <em>base-62-number</em> of zero encoded as <code>_</code> has a value of 1).
This allows disambiguators that are encoded sequentially to use minimal bytes.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>The <em>disambiguator</em> may or may not be displayed; see recommendations for rules that use <em>disambiguator</em>.
Generally, it is recommended that zero disambiguators are never displayed unless their accompanying
identifier is empty (like is the case for unnamed items such as closures).
When rendering a disambiguator, it can be shortened to a length reasonable for the context,
similar to how git commit hashes are rarely displayed in full.</p>
</blockquote>
<h2 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h2>
<blockquote>
<p>lifetime → <code>L</code> <em><a href="#base-62-number">base-62-number</a></em></p>
</blockquote>
<p>A <em>lifetime</em> is used to encode an anonymous (numbered) lifetime, either erased or <a href="#binder">higher-ranked</a>.
It starts with the character <code>L</code> and is followed by a <em><a href="#base-62-number">base-62-number</a></em>.
Index 0 is always erased.
Indices starting from 1 refer (as de Bruijn indices) to a higher-ranked lifetime bound by one of the enclosing <em><a href="#binder">binder</a></em>s.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>lifetime</em> may be displayed like a Rust lifetime using a single quote.</p>
<p>Index 0 should be displayed as <code>'_</code>.
Index 0 should not be displayed for lifetimes in a <em><a href="#ref-type">ref-type</a></em>, <em><a href="#mut-ref-type">mut-ref-type</a></em>, or <em><a href="#dyn-trait-type">dyn-trait-type</a></em>.</p>
<p>A lifetime can be displayed by converting the De Bruijn index to a De Bruijn level
(level = number of bound lifetimes - index) and selecting a unique name for each level.
For example, starting with single lowercase letters such as <code>'a</code> for level 0.
Levels over 25 may consider printing the numeric lifetime as in <code>'_123</code>.
See <em><a href="#binder">binder</a></em> for more on lifetime indexes and ordering.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">fn main() {
    example::&lt;fn(&amp;u8, &amp;u16)&gt;();
}

pub fn example&lt;T&gt;() {}</code></pre>
<p>The symbol for the function <code>example</code> is:</p>
<pre><code class="language-text">_RINvCs7qp2U7fqm6G_7mycrate7exampleFG0_RL1_hRL0_tEuEB2_
                                   │└┬┘│└┬┘││└┬┘││
                                   │ │ │ │ ││ │ │└── end of input types
                                   │ │ │ │ ││ │ └─── type u16
                                   │ │ │ │ ││ └───── lifetime #1 'b
                                   │ │ │ │ │└─────── reference type
                                   │ │ │ │ └──────── type u8
                                   │ │ │ └────────── lifetime #2 'a
                                   │ │ └──────────── reference type
                                   │ └────────────── binder with 2 lifetimes
                                   └──────────────── function type
</code></pre>
<p>Recommended demangling: <code>mycrate::example::&lt;for&lt;'a, 'b&gt; fn(&amp;'a u8, &amp;'b u16)&gt;</code></p>
</blockquote>
<h2 id="const"><a class="header" href="#const">Const</a></h2>
<blockquote>
<p>const → <br>      <em><a href="#type">type</a></em> <em><a href="#const">const-data</a></em> <br>   | <code>p</code> <br>   | <em><a href="#backref">backref</a></em></p>
<p>const-data → <code>n</code><sub>opt</sub> {<em><a href="#const">hex-digit</a></em>} <code>_</code></p>
<p><a href="#const">hex-digit</a> → <em><a href="#common-rules">digit</a></em> | <code>a</code> | <code>b</code> | <code>c</code> | <code>d</code> | <code>e</code> | <code>f</code></p>
</blockquote>
<p>A <em>const</em> is used to encode a const value used in generics and types.
It has the following forms:</p>
<ul>
<li>A constant value encoded as a <em><a href="#type">type</a></em> which represents the type of the constant and <em><a href="#const">const-data</a></em> which is the constant value, followed by <code>_</code> to terminate the <em>const</em>.</li>
<li>The character <code>p</code> which represents a <a href="#placeholders">placeholder</a>.</li>
<li>A <em><a href="#backref">backref</a></em> to a previously encoded <em>const</em> of the same value.</li>
</ul>
<p>The encoding of the <em>const-data</em> depends on the type:</p>
<ul>
<li><code>bool</code> — The value <code>false</code> is encoded as <code>0_</code>, the value true is encoded as <code>1_</code>.</li>
<li><code>char</code> — The Unicode scalar value of the character is encoded in hexadecimal.</li>
<li>Unsigned integers — The value is encoded in hexadecimal.</li>
<li>Signed integers — The character <code>n</code> is a prefix to indicate that it is negative,
followed by the absolute value encoded in hexadecimal.</li>
</ul>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>const</em> may be displayed by the const value depending on the type.</p>
<p>The <code>p</code> placeholder should be displayed as the <code>_</code> character.</p>
<p>For specific types:</p>
<ul>
<li><code>b</code> (bool) — Display as <code>true</code> or <code>false</code>.</li>
<li><code>c</code> (char) — Display the character in as a Rust character (such as <code>'A'</code> or <code>'\n'</code>).</li>
<li>integers — Display the integer (either in decimal or hex).</li>
</ul>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">fn main() {
    example::&lt;0x12345678&gt;();
}

pub fn example&lt;const N: u64&gt;() {}</code></pre>
<p>The symbol for function <code>example</code> is:</p>
<pre><code class="language-text">_RINvCs7qp2U7fqm6G_7mycrate7exampleKy12345678_EB2_
                                   ││└───┬───┘
                                   ││    │
                                   ││    └── const-data 0x12345678
                                   │└─────── const type u64
                                   └──────── const generic arg
</code></pre>
<p>Recommended demangling: <code>mycrate::example::&lt;305419896&gt;</code></p>
</blockquote>
<h3 id="placeholders"><a class="header" href="#placeholders">Placeholders</a></h3>
<p>A <em>placeholder</em> may occur in circumstances where a type or const value is not relevant.</p>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">pub struct Example&lt;T, const N: usize&gt;([T; N]);

impl&lt;T, const N: usize&gt; Example&lt;T, N&gt; {
    pub fn foo() -&gt; &amp;'static () {
        static EXAMPLE_STATIC: () = ();
        &amp;EXAMPLE_STATIC
    }
}</code></pre>
<p>In this example, the static <code>EXAMPLE_STATIC</code> would not be monomorphized by the type or const parameters <code>T</code> and <code>N</code>.
Those will use the placeholder for those generic arguments.
Its symbol is:</p>
<pre><code class="language-text">_RNvNvMCsd9PVOYlP1UU_7mycrateINtB4_7ExamplepKpE3foo14EXAMPLE_STATIC
                             │             │││
                             │             ││└── const placeholder
                             │             │└─── const generic argument
                             │             └──── type placeholder
                             └────────────────── generic-args
</code></pre>
<p>Recommended demangling: <code>&lt;mycrate::Example&lt;_, _&gt;&gt;::foo::EXAMPLE_STATIC</code></p>
</blockquote>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<blockquote>
<p>type → <br>      <em><a href="#basic-type">basic-type</a></em> <br>   | <em><a href="#array-type">array-type</a></em> <br>   | <em><a href="#slice-type">slice-type</a></em> <br>   | <em><a href="#tuple-type">tuple-type</a></em> <br>   | <em><a href="#ref-type">ref-type</a></em> <br>   | <em><a href="#mut-ref-type">mut-ref-type</a></em> <br>   | <em><a href="#const-ptr-type">const-ptr-type</a></em> <br>   | <em><a href="#mut-ptr-type">mut-ptr-type</a></em> <br>   | <em><a href="#fn-type">fn-type</a></em> <br>   | <em><a href="#dyn-trait-type">dyn-trait-type</a></em> <br>   | <em><a href="#pattern-type">pattern-type</a></em> <br>   | <em><a href="#symbol-path">path</a></em> <br>   | <em><a href="#backref">backref</a></em></p>
</blockquote>
<p>A <em>type</em> represents a Rust <a href="../reference/types.html">type</a>.
The initial character can be used to distinguish which type is encoded.
The type encodings based on the initial tag character are:</p>
<ul>
<li>A <span id="basic-type"><em>basic-type</em></span> is encoded as a single character:
<ul>
<li><code>a</code> — <code>i8</code></li>
<li><code>b</code> — <code>bool</code></li>
<li><code>c</code> — <code>char</code></li>
<li><code>d</code> — <code>f64</code></li>
<li><code>e</code> — <code>str</code></li>
<li><code>f</code> — <code>f32</code></li>
<li><code>h</code> — <code>u8</code></li>
<li><code>i</code> — <code>isize</code></li>
<li><code>j</code> — <code>usize</code></li>
<li><code>l</code> — <code>i32</code></li>
<li><code>m</code> — <code>u32</code></li>
<li><code>n</code> — <code>i128</code></li>
<li><code>o</code> — <code>u128</code></li>
<li><code>s</code> — <code>i16</code></li>
<li><code>t</code> — <code>u16</code></li>
<li><code>u</code> — unit <code>()</code></li>
<li><code>v</code> — variadic <code>...</code></li>
<li><code>x</code> — <code>i64</code></li>
<li><code>y</code> — <code>u64</code></li>
<li><code>z</code> — <code>!</code></li>
<li><code>p</code> — <a href="#placeholders">placeholder</a> <code>_</code></li>
</ul>
</li>
</ul>
<p>Remaining primitives are encoded as a crate production, e.g. <code>C4f128</code>.</p>
<ul>
<li>
<p><code>A</code> — An <a href="../reference/types/array.html">array</a> <code>[T; N]</code>.</p>
<blockquote>
<p><span id="array-type">array-type</span> → <code>A</code> <em><a href="#type">type</a></em> <em><a href="#const">const</a></em></p>
</blockquote>
<p>The tag <code>A</code> is followed by the <em><a href="#type">type</a></em> of the array followed by a <em><a href="#const">const</a></em> for the array size.</p>
</li>
<li>
<p><code>S</code> — A <a href="../reference/types/slice.html">slice</a> <code>[T]</code>.</p>
<blockquote>
<p><span id="slice-type">slice-type</span> → <code>S</code> <em><a href="#type">type</a></em></p>
</blockquote>
<p>The tag <code>S</code> is followed by the <em><a href="#type">type</a></em> of the slice.</p>
</li>
<li>
<p><code>T</code> — A <a href="../reference/types/tuple.html">tuple</a> <code>(T1, T2, T3, ...)</code>.</p>
<blockquote>
<p><span id="tuple-type">tuple-type</span> → <code>T</code> {<em><a href="#type">type</a></em>} <code>E</code></p>
</blockquote>
<p>The tag <code>T</code> is followed by one or more <em><a href="#type">type</a></em>s indicating the type of each field, followed by a terminating <code>E</code> character.</p>
<p>Note that a zero-length tuple (unit) is encoded with the <code>u</code> <em><a href="#basic-type">basic-type</a></em>.</p>
</li>
<li>
<p><code>R</code> — A <a href="../reference/types/pointer.html#shared-references-">reference</a> <code>&amp;T</code>.</p>
<blockquote>
<p><span id="ref-type">ref-type</span> →  <code>R</code> <em><a href="#lifetime">lifetime</a></em><sub>opt</sub> <em><a href="#type">type</a></em></p>
</blockquote>
<p>The tag <code>R</code> is followed by an optional <em><a href="#lifetime">lifetime</a></em> followed by the <em><a href="#type">type</a></em> of the reference.
The lifetime is not included if it has been erased.</p>
</li>
<li>
<p><code>Q</code> — A <a href="../reference/types/pointer.html#mutable-references-mut">mutable reference</a> <code>&amp;mut T</code>.</p>
<blockquote>
<p><span id="mut-ref-type">mut-ref-type</span> → <code>Q</code> <em><a href="#lifetime">lifetime</a></em><sub>opt</sub> <em><a href="#type">type</a></em></p>
</blockquote>
<p>The tag <code>Q</code> is followed by an optional <em><a href="#lifetime">lifetime</a></em> followed by the <em><a href="#type">type</a></em> of the mutable reference.
The lifetime is not included if it has been erased.</p>
</li>
<li>
<p><code>P</code> — A <a href="../reference/types/pointer.html#raw-pointers-const-and-mut">constant raw pointer</a> <code>*const T</code>.</p>
<p>The tag <code>P</code> is followed by the <em><a href="#type">type</a></em> of the pointer.</p>
<blockquote>
<p><span id="const-ptr-type">const-ptr-type</span> → <code>P</code> <em><a href="#type">type</a></em></p>
</blockquote>
</li>
<li>
<p><code>O</code> — A <a href="../reference/types/pointer.html#raw-pointers-const-and-mut">mutable raw pointer</a> <code>*mut T</code>.</p>
<blockquote>
<p><span id="mut-ptr-type">mut-ptr-type</span> → <code>O</code> <em><a href="#type">type</a></em></p>
</blockquote>
<p>The tag <code>O</code> is followed by the <em><a href="#type">type</a></em> of the pointer.</p>
</li>
<li>
<p><code>F</code> — A <a href="../reference/types/function-pointer.html">function pointer</a> <code>fn(…) -&gt; …</code>.</p>
<blockquote>
<p><span id="fn-type">fn-type</span> → <code>F</code> <em><a href="#fn-sig">fn-sig</a></em></p>
<p><span id="fn-sig">fn-sig</span> → <em><a href="#binder">binder</a></em><sub>opt</sub> <code>U</code><sub>opt</sub> (<code>K</code> <em><a href="#abi">abi</a></em>)<sub>opt</sub> {<em><a href="#type">type</a></em>} <code>E</code> <em><a href="#type">type</a></em></p>
<p><span id="abi">abi</span> → <br>      <code>C</code> <br>   | <em><a href="#identifier">undisambiguated-identifier</a></em></p>
</blockquote>
<p>The tag <code>F</code> is followed by a <em><a href="#fn-sig">fn-sig</a></em> of the function signature.
A <em>fn-sig</em> is the signature for a function pointer.</p>
<p>It starts with an optional <em><a href="#binder">binder</a></em> which represents the higher-ranked trait bounds (<code>for&lt;…&gt;</code>).</p>
<p>Following that is an optional <code>U</code> character which is present for an <code>unsafe</code> function.</p>
<p>Following that is an optional <code>K</code> character which indicates that an <em><a href="#abi">abi</a></em> is specified.
If the ABI is not specified, it is assumed to be the <code>"Rust"</code> ABI.</p>
<p>The <em><a href="#abi">abi</a></em> can be the letter <code>C</code> to indicate it is the <code>"C"</code> ABI.
Otherwise it is an <em><a href="#identifier">undisambiguated-identifier</a></em> of the ABI string with dashes converted to underscores.</p>
<p>Following that is zero or more <em><a href="#type">type</a></em>s which indicate the input parameters of the function.</p>
<p>Following that is the character <code>E</code> and then the <em><a href="#type">type</a></em> of the return value.</p>
</li>
</ul>
<ul>
<li>
<p><code>W</code> — A [pattern-type][pattern-tpye] <code>u32 is 0..100</code>.</p>
<blockquote>
<p><span id="pattern-type">pattern-type</span> → <code>W</code> <em>[pattern-kind]</em></p>
<p><span id="pattern-kind">pattern-kind</span> → <br>      <em>[range-pattern-kind]</em> <br>   <em>[or-pattern-kind]</em></p>
<p><span id="range-pattern-kind">range-pattern-kind</span> → <code>R</code> <em><a href="#const">const</a></em> <em><a href="#const">const</a></em></p>
<p><span id="or-pattern-kind">or-pattern-kind</span> → <code>O</code> <em>[pattern-kind]</em> <code>E</code></p>
</blockquote>
<p>While or patterns can be nested in theory, in practice this does not happen and they are instead flattened.</p>
<p>Range patterns have a start and end constant that are both included in the range.
The end must be larger than the start (there can be no wraparound). To emulate wraparound,
you need to use an or pattern of the two ranges to the upper limit and from the lower limit.</p>
</li>
<li>
<p><code>D</code> — A <a href="../reference/types/trait-object.html">trait object</a> <code>dyn Trait&lt;Assoc=X&gt; + Send + 'a</code>.</p>
<blockquote>
<p><span id="dyn-trait-type">dyn-trait-type</span> → <code>D</code> <em><a href="#dyn-bounds">dyn-bounds</a></em> <em><a href="#lifetime">lifetime</a></em></p>
<p><span id="dyn-bounds">dyn-bounds</span> → <em><a href="#binder">binder</a></em><sub>opt</sub> {<em><a href="#dyn-trait">dyn-trait</a></em>} <code>E</code></p>
<p><span id="dyn-trait">dyn-trait</span> → <em><a href="#symbol-path">path</a></em> {<em><a href="#dyn-trait-assoc-binding">dyn-trait-assoc-binding</a></em>}</p>
<p><span id="dyn-trait-assoc-binding">dyn-trait-assoc-binding</span> → <code>p</code> <em><a href="#identifier">undisambiguated-identifier</a></em> <em><a href="#type">type</a></em></p>
</blockquote>
<p>The tag <code>D</code> is followed by a <em><a href="#dyn-bounds">dyn-bounds</a></em> which encodes the trait bounds,
followed by a <em><a href="#lifetime">lifetime</a></em> of the trait object lifetime bound.</p>
<p>A <em>dyn-bounds</em> starts with an optional <em><a href="#binder">binder</a></em> which represents the higher-ranked trait bounds (<code>for&lt;…&gt;</code>).
Following that is a sequence of <em><a href="#dyn-trait">dyn-trait</a></em> terminated by the character <code>E</code>.</p>
<p>Each <em><a href="#dyn-trait">dyn-trait</a></em> represents a trait bound, which consists of a <em><a href="#symbol-path">path</a></em> to the trait followed by zero or more <em><a href="#dyn-trait-assoc-binding">dyn-trait-assoc-binding</a></em> which list the associated types.</p>
<p>Each <em><a href="#dyn-trait-assoc-binding">dyn-trait-assoc-binding</a></em> consists of a character <code>p</code> followed a <em><a href="#identifier">undisambiguated-identifier</a></em> representing the associated binding name, and finally a <em><a href="#type">type</a></em>.</p>
</li>
</ul>
<ul>
<li>
<p>A <em><a href="#symbol-path">path</a></em> to a named type.</p>
</li>
<li>
<p>A <em><a href="#backref">backref</a></em> to refer to a previously encoded type.</p>
</li>
</ul>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em><a href="#type">type</a></em> may be displayed as the type it represents, using typical Rust syntax to represent the type.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">fn main() {
    example::&lt;[u16; 8]&gt;();
}

pub fn example&lt;T&gt;() {}</code></pre>
<p>The symbol for function <code>example</code> is:</p>
<pre><code class="language-text">_RINvCs7qp2U7fqm6G_7mycrate7exampleAtj8_EB2_
                                   │││├┘│
                                   ││││ └─── end of generic args
                                   │││└───── const data 8
                                   ││└────── const type usize
                                   │└─────── array element type u16
                                   └──────── array type
</code></pre>
<p>Recommended demangling: <code>mycrate::example::&lt;[u16; 8]&gt;</code></p>
</blockquote>
<h2 id="binder"><a class="header" href="#binder">Binder</a></h2>
<blockquote>
<p>binder → <code>G</code> <em><a href="#base-62-number">base-62-number</a></em></p>
</blockquote>
<p>A <em>binder</em> represents the number of <a href="../reference/trait-bounds.html#higher-ranked-trait-bounds">higher-ranked trait bound</a> lifetimes to bind.
It consists of the character <code>G</code> followed by a <em><a href="#base-62-number">base-62-number</a></em>.
The value 1 should be added to the <em><a href="#base-62-number">base-62-number</a></em> when decoding
(such that the <em>base-62-number</em> encoding of <code>_</code> is interpreted as having 1 binder).</p>
<p>A <em>lifetime</em> rule can then refer to these numbered lifetimes.
The lowest indices represent the innermost lifetimes.
The number of bound lifetimes is the value of <em><a href="#base-62-number">base-62-number</a></em> plus one.</p>
<p>For example, in <code>for&lt;'a, 'b&gt; fn(for&lt;'c&gt; fn (...))</code>, any <em><a href="#lifetime">lifetime</a></em>s in <code>...</code>
(but not inside more binders) will observe the indices 1, 2, and 3 to refer to <code>'c</code>, <code>'b</code>, and <code>'a</code>, respectively.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>binder</em> may be printed using <code>for&lt;…&gt;</code> syntax listing the lifetimes as recommended in <em><a href="#lifetime">lifetime</a></em>.
See <em><a href="#lifetime">lifetime</a></em> for an example.</p>
</blockquote>
<h2 id="backref"><a class="header" href="#backref">Backref</a></h2>
<blockquote>
<p>backref → <code>B</code> <em><a href="#base-62-number">base-62-number</a></em></p>
</blockquote>
<p>A <em>backref</em> is used to refer to a previous part of the mangled symbol.
This provides a simple form of compression to reduce the length of the mangled symbol.
This can help reduce the amount of work and resources needed by the compiler, linker, and loader.</p>
<p>It consists of the character <code>B</code> followed by a <em><a href="#base-62-number">base-62-number</a></em>.
The number indicates the 0-based offset in bytes starting from just after the <code>_R</code> prefix of the symbol.
The <em>backref</em> represents the corresponding element starting at that position.</p>
<p><em>backref</em>s always refer to a position before the <em>backref</em> itself.</p>
<p>The <em>backref</em> compression relies on the fact that all substitutable symbol elements have a self-terminating mangled form.
Given the start position of the encoded node, the grammar guarantees that it is always unambiguous where the node ends.
This is ensured by not allowing optional or repeating elements at the end of substitutable productions.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>A <em>backref</em> should be demangled by rendering the element that it points to.
Care should be considered when handling deeply nested backrefs to avoid using too much stack.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">fn main() {
    example::&lt;Example, Example&gt;();
}

struct Example;

pub fn example&lt;T, U&gt;() {}</code></pre>
<p>The symbol for function <code>example</code> is:</p>
<pre><code class="language-text">_RINvCs7qp2U7fqm6G_7mycrate7exampleNtB2_7ExampleBw_EB2_
                                     │├┘        │├┘ │├┘
                                     ││         ││  ││
                                     ││         ││  │└── backref to offset 3 (crate-root)
                                     ││         ││  └─── backref for instantiating-crate path
                                     ││         │└────── backref to offset 33 (path to Example)
                                     ││         └─────── backref for second generic-arg
                                     │└───────────────── backref to offset 3 (crate-root)
                                     └────────────────── backref for first generic-arg (first segment of Example path)
</code></pre>
<p>Recommended demangling: <code>mycrate::example::&lt;mycrate::Example, mycrate::Example&gt;</code></p>
</blockquote>
<h2 id="instantiating-crate"><a class="header" href="#instantiating-crate">Instantiating crate</a></h2>
<blockquote>
<p>instantiating-crate → <em><a href="#symbol-path">path</a></em></p>
</blockquote>
<p>The <em>instantiating-crate</em> is an optional element of the <em><a href="#symbol-name">symbol-name</a></em> which can be used to indicate which crate is instantiating the symbol.
It consists of a single <em><a href="#symbol-path">path</a></em>.</p>
<p>This helps differentiate symbols that would otherwise be identical,
for example the monomorphization of a function from an external crate may result in a duplicate if another crate is also instantiating the same generic function with the same types.</p>
<p>In practice, the instantiating crate is also often the crate where the symbol is defined,
so it is usually encoded as a <em><a href="#backref">backref</a></em> to the <em><a href="#path-crate-root">crate-root</a></em> encoded elsewhere in the symbol.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>The <em>instantiating-crate</em> usually need not be displayed.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust">std::path::Path::new("example");</code></pre>
<p>The symbol for <code>Path::new::&lt;str&gt;</code> instantiated from the <code>mycrate</code> crate is:</p>
<pre><code class="language-text">_RINvMsY_NtCseXNvpPnDBDp_3std4pathNtB6_4Path3neweECs7qp2U7fqm6G_7mycrate
                                                                └──┬───┘
                                                                   │
                                                                   └── instantiating crate identifier `mycrate`
</code></pre>
<p>Recommended demangling: <code>&lt;std::path::Path&gt;::new::&lt;str&gt;</code></p>
</blockquote>
<h2 id="vendor-specific-suffix"><a class="header" href="#vendor-specific-suffix">Vendor-specific suffix</a></h2>
<blockquote>
<p>vendor-specific-suffix → (<code>.</code> | <code>$</code>) <em><a href="#vendor-specific-suffix">suffix</a></em></p>
<p>suffix → {<em>byte</em>}</p>
</blockquote>
<p>The <em>vendor-specific-suffix</em> is an optional element at the end of the <em><a href="#symbol-name">symbol-name</a></em>.
It consists of either a <code>.</code> or <code>$</code> character followed by zero or more bytes.
There are no restrictions on the characters following the period or dollar sign.</p>
<p>This suffix is added as needed by the implementation.
One example where this can happen is when locally unique names need to become globally unique.
LLVM can append a <code>.llvm.&lt;numbers&gt;</code> suffix during LTO to ensure a unique name,
and <code>$</code> can be used for thread-local data on Mach-O.
In these situations it’s generally fine to ignore the suffix;
the suffixed name has the same semantics as the original.</p>
<blockquote>
<p><strong>Recommended Demangling</strong></p>
<p>The <em>vendor-specific-suffix</em> usually need not be displayed.</p>
</blockquote>
<blockquote>
<p>Example:</p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span>thread_local! {
    pub static EXAMPLE: RefCell&lt;u32&gt; = RefCell::new(1);
}</code></pre>
<p>The symbol for <code>EXAMPLE</code> on macOS may have the following for thread-local data:</p>
<pre><code class="language-text">_RNvNvNvCs7qp2U7fqm6G_7mycrate7EXAMPLE7___getit5___KEY$tlv$init
                                                      └───┬───┘
                                                          │
                                                          └── vendor-specific-suffix
</code></pre>
<p>Recommended demangling: <code>mycrate::EXAMPLE::__getit::__KEY</code></p>
</blockquote>
<h2 id="common-rules"><a class="header" href="#common-rules">Common rules</a></h2>
<blockquote>
<p><a href="#common-rules">decimal-number</a> → <br>      <code>0</code> <br>   | <em><a href="#common-rules">non-zero-digit</a></em> {<em><a href="#common-rules">digit</a></em>}</p>
<p><a href="#common-rules">non-zero-digit</a> → <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code> <br><a href="#common-rules">digit</a> → <code>0</code> | <em><a href="#common-rules">non-zero-digit</a></em></p>
<p><a href="#common-rules">lower</a> → <code>a</code> |<code>b</code> |<code>c</code> |<code>d</code> |<code>e</code> |<code>f</code> |<code>g</code> |<code>h</code> |<code>i</code> |<code>j</code> |<code>k</code> |<code>l</code> |<code>m</code> |<code>n</code> |<code>o</code> |<code>p</code> |<code>q</code> |<code>r</code> |<code>s</code> |<code>t</code> |<code>u</code> |<code>v</code> |<code>w</code> |<code>x</code> |<code>y</code> |<code>z</code></p>
<p><a href="#common-rules">upper</a> → <code>A</code> | <code>B</code> | <code>C</code> | <code>D</code> | <code>E</code> | <code>F</code> | <code>G</code> | <code>H</code> | <code>I</code> | <code>J</code> | <code>K</code> | <code>L</code> | <code>M</code> | <code>N</code> | <code>O</code> | <code>P</code> | <code>Q</code> | <code>R</code> | <code>S</code> | <code>T</code> | <code>U</code> | <code>V</code> | <code>W</code> | <code>X</code> | <code>Y</code> | <code>Z</code></p>
</blockquote>
<p>A <em>decimal-number</em> is encoded as one or more <em><a href="#common-rules">digit</a></em>s indicating a numeric value in decimal.</p>
<p>The value zero is encoded as a single byte <code>0</code>.
Beware that there are situations where <code>0</code> may be followed by another digit that should not be decoded as part of the decimal-number.
For example, a zero-length <em><a href="#identifier">identifier</a></em> within a <em><a href="#path-nested-path">nested-path</a></em> which is in turn inside another <em><a href="#path-nested-path">nested-path</a></em> will result in two identifiers in a row, where the first one only has the encoding of <code>0</code>.</p>
<p>A <em>digit</em> is an ASCII number.</p>
<p>A <em>lower</em> and <em>upper</em> is an ASCII lower and uppercase letter respectively.</p>
<h2 id="base-62-number"><a class="header" href="#base-62-number">base-62-number</a></h2>
<blockquote>
<p><a href="#base-62-number">base-62-number</a> → { <em><a href="#common-rules">digit</a></em> | <em><a href="#common-rules">lower</a></em> | <em><a href="#common-rules">upper</a></em> } <code>_</code></p>
</blockquote>
<p>A <em>base-62-number</em> is an encoding of a numeric value.
It uses ASCII numbers and lowercase and uppercase letters.
The value is terminated with the <code>_</code> character.
If the value is 0, then the encoding is the <code>_</code> character without any digits.
Otherwise, one is subtracted from the value, and it is encoded with the mapping:</p>
<ul>
<li><code>0</code>-<code>9</code> maps to 0-9</li>
<li><code>a</code>-<code>z</code> maps to 10 to 35</li>
<li><code>A</code>-<code>Z</code> maps to 36 to 61</li>
</ul>
<p>The number is repeatedly divided by 62 (with integer division round towards zero)
to choose the next character in the sequence.
The remainder of each division is used in the mapping to choose the next character.
This is repeated until the number is 0.
The final sequence of characters is then reversed.</p>
<p>Decoding is a similar process in reverse.</p>
<p>Examples:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Encoding</th></tr>
</thead>
<tbody>
<tr><td>0</td><td><code>_</code></td></tr>
<tr><td>1</td><td><code>0_</code></td></tr>
<tr><td>11</td><td><code>a_</code></td></tr>
<tr><td>62</td><td><code>Z_</code></td></tr>
<tr><td>63</td><td><code>10_</code></td></tr>
<tr><td>1000</td><td><code>g7_</code></td></tr>
</tbody>
</table>
</div>
<h2 id="symbol-grammar-summary"><a class="header" href="#symbol-grammar-summary">Symbol grammar summary</a></h2>
<p>The following is a summary of all of the productions of the symbol grammar.</p>
<blockquote>
<p><a href="#symbol-name">symbol-name</a> → <code>_R</code> <em><a href="#common-rules">decimal-number</a></em><sub>opt</sub> <em><a href="#symbol-path">path</a></em> <em><a href="#instantiating-crate">instantiating-crate</a></em><sub>opt</sub> <em><a href="#vendor-specific-suffix">vendor-specific-suffix</a></em><sub>opt</sub></p>
<p><a href="#symbol-path">path</a> → <br>      <em><a href="#path-crate-root">crate-root</a></em> <br>   | <em><a href="#path-inherent-impl">inherent-impl</a></em> <br>   | <em><a href="#path-trait-impl">trait-impl</a></em> <br>   | <em><a href="#path-trait-definition">trait-definition</a></em> <br>   | <em><a href="#path-nested-path">nested-path</a></em> <br>   | <em><a href="#path-generic-arguments">generic-args</a></em> <br>   | <em><a href="#backref">backref</a></em></p>
<p><a href="#path-crate-root">crate-root</a> → <code>C</code> <em><a href="#identifier">identifier</a></em> <br><a href="#path-inherent-impl">inherent-impl</a> → <code>M</code> <em><a href="#path-impl">impl-path</a></em> <em><a href="#type">type</a></em> <br><a href="#path-trait-impl">trait-impl</a> → <code>X</code> <em><a href="#path-impl">impl-path</a></em> <em><a href="#type">type</a></em> <em><a href="#symbol-path">path</a></em> <br><a href="#path-trait-definition">trait-definition</a> → <code>Y</code> <em><a href="#type">type</a></em> <em><a href="#symbol-path">path</a></em> <br><a href="#path-nested-path">nested-path</a> → <code>N</code> <em><a href="#namespace">namespace</a></em> <em><a href="#symbol-path">path</a></em> <em><a href="#identifier">identifier</a></em> <br><a href="#path-generic-arguments">generic-args</a> → <code>I</code> <em><a href="#symbol-path">path</a></em> {<em><a href="#path-generic-arguments">generic-arg</a></em>} <code>E</code></p>
<p><a href="#identifier">identifier</a> → <em><a href="#disambiguator">disambiguator</a></em><sub>opt</sub> <em><a href="#identifier">undisambiguated-identifier</a></em> <br><a href="#identifier">undisambiguated-identifier</a> → <code>u</code><sub>opt</sub> <em><a href="#common-rules">decimal-number</a></em> <code>_</code><sub>opt</sub> <em><a href="#identifier">bytes</a></em> <br><a href="#identifier">bytes</a> → {<em>UTF-8 bytes</em>}</p>
<p><a href="#disambiguator">disambiguator</a> → <code>s</code> <em><a href="#base-62-number">base-62-number</a></em></p>
<p><a href="#path-impl">impl-path</a> → <em><a href="#disambiguator">disambiguator</a></em><sub>opt</sub> <em><a href="#symbol-path">path</a></em></p>
<p><a href="#type">type</a> → <br>      <em><a href="#basic-type">basic-type</a></em> <br>   | <em><a href="#array-type">array-type</a></em> <br>   | <em><a href="#slice-type">slice-type</a></em> <br>   | <em><a href="#tuple-type">tuple-type</a></em> <br>   | <em><a href="#ref-type">ref-type</a></em> <br>   | <em><a href="#mut-ref-type">mut-ref-type</a></em> <br>   | <em><a href="#const-ptr-type">const-ptr-type</a></em> <br>   | <em><a href="#mut-ptr-type">mut-ptr-type</a></em> <br>   | <em><a href="#fn-type">fn-type</a></em> <br>   | <em><a href="#dyn-trait-type">dyn-trait-type</a></em> <br>   | <em><a href="#pattern-type">pattern-type</a></em> <br>   | <em><a href="#symbol-path">path</a></em> <br>   | <em><a href="#backref">backref</a></em></p>
<p><a href="#basic-type">basic-type</a> → <em><a href="#common-rules">lower</a></em> <br><a href="#array-type">array-type</a> → <code>A</code> <em><a href="#type">type</a></em> <em><a href="#const">const</a></em> <br><a href="#slice-type">slice-type</a> → <code>S</code> <em><a href="#type">type</a></em> <br><a href="#tuple-type">tuple-type</a> → <code>T</code> {<em><a href="#type">type</a></em>} <code>E</code> <br><a href="#ref-type">ref-type</a> →  <code>R</code> <em><a href="#lifetime">lifetime</a></em><sub>opt</sub> <em><a href="#type">type</a></em> <br><a href="#mut-ref-type">mut-ref-type</a> → <code>Q</code> <em><a href="#lifetime">lifetime</a></em><sub>opt</sub> <em><a href="#type">type</a></em> <br><a href="#const-ptr-type">const-ptr-type</a> → <code>P</code> <em><a href="#type">type</a></em> <br><a href="#mut-ptr-type">mut-ptr-type</a> → <code>O</code> <em><a href="#type">type</a></em> <br><a href="#fn-type">fn-type</a> → <code>F</code> <em><a href="#fn-sig">fn-sig</a></em> <br><a href="#dyn-trait-type">dyn-trait-type</a> → <code>D</code> <em><a href="#dyn-bounds">dyn-bounds</a></em> <em><a href="#lifetime">lifetime</a></em>
<a href="#pattern-type">pattern-type</a> → <code>W</code> <em>[pattern-kind]</em></p>
<p>[pattern-kind] → <br>      <em>[range-pattern-kind]</em> <br>   <em>[or-pattern-kind]</em></p>
<p>[range-pattern-kind] -&gt; <code>R</code> <em><a href="#const">const</a></em> <em><a href="#const">const</a></em> <br>[or-pattern-kind] -&gt; <code>O</code> <em>[pattern-kind]</em> <code>E</code> \</p>
<p><a href="#namespace">namespace</a> → <em><a href="#common-rules">lower</a></em> | <em><a href="#common-rules">upper</a></em></p>
<p><a href="#path-generic-arguments">generic-arg</a> → <br>      <em><a href="#lifetime">lifetime</a></em> <br>   | <em><a href="#type">type</a></em> <br>   | <code>K</code> <em><a href="#const">const</a></em></p>
<p><a href="#lifetime">lifetime</a> → <code>L</code> <em><a href="#base-62-number">base-62-number</a></em></p>
<p><a href="#const">const</a> → <br>      <em><a href="#type">type</a></em> <em><a href="#const">const-data</a></em> <br>   | <code>p</code> <br>   | <em><a href="#backref">backref</a></em></p>
<p><a href="#const">const-data</a> → <code>n</code><sub>opt</sub> {<em><a href="#const">hex-digit</a></em>} <code>_</code></p>
<p><a href="#const">hex-digit</a> → <em><a href="#common-rules">digit</a></em> | <code>a</code> | <code>b</code> | <code>c</code> | <code>d</code> | <code>e</code> | <code>f</code></p>
<p><a href="#fn-sig">fn-sig</a> → <em><a href="#binder">binder</a></em><sub>opt</sub> <code>U</code><sub>opt</sub> (<code>K</code> <em><a href="#abi">abi</a></em>)<sub>opt</sub> {<em><a href="#type">type</a></em>} <code>E</code> <em><a href="#type">type</a></em></p>
<p><a href="#abi">abi</a> → <br>      <code>C</code> <br>   | <em><a href="#identifier">undisambiguated-identifier</a></em></p>
<p><a href="#dyn-bounds">dyn-bounds</a> → <em><a href="#binder">binder</a></em><sub>opt</sub> {<em><a href="#dyn-trait">dyn-trait</a></em>} <code>E</code> <br><a href="#dyn-trait">dyn-trait</a> → <em><a href="#symbol-path">path</a></em> {<em><a href="#dyn-trait-assoc-binding">dyn-trait-assoc-binding</a></em>} <br><a href="#dyn-trait-assoc-binding">dyn-trait-assoc-binding</a> → <code>p</code> <em><a href="#identifier">undisambiguated-identifier</a></em> <em><a href="#type">type</a></em></p>
<p><a href="#binder">binder</a> → <code>G</code> <em><a href="#base-62-number">base-62-number</a></em></p>
<p><a href="#backref">backref</a> → <code>B</code> <em><a href="#base-62-number">base-62-number</a></em></p>
<p><a href="#instantiating-crate">instantiating-crate</a> → <em><a href="#symbol-path">path</a></em></p>
<p><a href="#vendor-specific-suffix">vendor-specific-suffix</a> → (<code>.</code> | <code>$</code>) <em><a href="#vendor-specific-suffix">suffix</a></em> <br><a href="#vendor-specific-suffix">suffix</a> → {<em>byte</em>}</p>
<p><a href="#common-rules">decimal-number</a> → <br>      <code>0</code> <br>   | <em><a href="#common-rules">non-zero-digit</a></em> {<em><a href="#common-rules">digit</a></em>}</p>
<p><a href="#base-62-number">base-62-number</a> → { <em><a href="#common-rules">digit</a></em> | <em><a href="#common-rules">lower</a></em> | <em><a href="#common-rules">upper</a></em> } <code>_</code></p>
<p><a href="#common-rules">non-zero-digit</a> → <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code> <br><a href="#common-rules">digit</a> → <code>0</code> | <em><a href="#common-rules">non-zero-digit</a></em> <br><a href="#common-rules">lower</a> → <code>a</code> |<code>b</code> |<code>c</code> |<code>d</code> |<code>e</code> |<code>f</code> |<code>g</code> |<code>h</code> |<code>i</code> |<code>j</code> |<code>k</code> |<code>l</code> |<code>m</code> |<code>n</code> |<code>o</code> |<code>p</code> |<code>q</code> |<code>r</code> |<code>s</code> |<code>t</code> |<code>u</code> |<code>v</code> |<code>w</code> |<code>x</code> |<code>y</code> |<code>z</code> <br><a href="#common-rules">upper</a> → <code>A</code> | <code>B</code> | <code>C</code> | <code>D</code> | <code>E</code> | <code>F</code> | <code>G</code> | <code>H</code> | <code>I</code> | <code>J</code> | <code>K</code> | <code>L</code> | <code>M</code> | <code>N</code> | <code>O</code> | <code>P</code> | <code>Q</code> | <code>R</code> | <code>S</code> | <code>T</code> | <code>U</code> | <code>V</code> | <code>W</code> | <code>X</code> | <code>Y</code> | <code>Z</code></p>
</blockquote>
<h2 id="encoding-of-rust-entities"><a class="header" href="#encoding-of-rust-entities">Encoding of Rust entities</a></h2>
<p>The following are guidelines for how Rust entities are encoded in a symbol.
The compiler has some latitude in how an entity is encoded as long as the symbol is unambiguous.</p>
<ul>
<li>
<p>Named functions, methods, and statics shall be represented by a <em><a href="#symbol-path">path</a></em> production.</p>
</li>
<li>
<p>Paths should be rooted at the innermost entity that can act as a path root.
Roots can be crate-ids, inherent impls, trait impls, and (for items within default methods) trait definitions.</p>
</li>
<li>
<p>The compiler is free to choose disambiguation indices and namespace tags from
the reserved ranges as long as it ascertains identifier unambiguity.</p>
</li>
<li>
<p>Generic arguments that are equal to the default should not be encoded in order to save space.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributing-to-rustc"><a class="header" href="#contributing-to-rustc">Contributing to rustc</a></h1>
<p>We’d love to have your help improving <code>rustc</code>! To that end, we’ve written <a href="https://rustc-dev-guide.rust-lang.org/">a
whole book</a> on its
internals, how it works, and how to get started working on it. To learn
more, you’ll want to check that out.</p>
<p>If you would like to contribute to <em>this</em> book, you can find its source in the
rustc source at <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/rustc">src/doc/rustc</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<style type="text/css">
    td code {
        white-space: nowrap;
    }
</style>
<p>Support for different platforms (“targets”) are organized into three tiers,
each with a different set of guarantees. For more information on the policies
for targets at each tier, see the <a href="#target-tier-policy">Target Tier Policy</a>.</p>
<p>Targets are identified by their “target triple” which is the string to inform
the compiler what kind of output should be produced.</p>
<p>Component availability is tracked <a href="https://rust-lang.github.io/rustup-components-history/">here</a>.</p>
<h2 id="tier-1-with-host-tools"><a class="header" href="#tier-1-with-host-tools">Tier 1 with Host Tools</a></h2>
<p>Tier 1 targets can be thought of as “guaranteed to work”. The Rust project
builds official binary releases for each tier 1 target, and automated testing
ensures that each tier 1 target builds and passes tests after each change.</p>
<p>Tier 1 targets with host tools additionally support running tools like <code>rustc</code>
and <code>cargo</code> natively on the target, and automated testing ensures that tests
pass for the host tools as well. This allows the target to be used as a
development platform, not just a compilation target. For the full requirements,
see <a href="#tier-1-with-host-tools-1">Tier 1 with Host Tools</a> in
the Target Tier Policy.</p>
<p>All tier 1 targets with host tools support the full standard library.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>target</th><th>notes</th></tr>
</thead>
<tbody>
<tr><td><a href="#-apple-darwin"><code>aarch64-apple-darwin</code></a></td><td>ARM64 macOS (11.0+, Big Sur+)</td></tr>
<tr><td><a href="#-pc-windows-msvc"><code>aarch64-pc-windows-msvc</code></a></td><td>ARM64 Windows MSVC</td></tr>
<tr><td><a href="#aarch64-unknown-linux-gnu"><code>aarch64-unknown-linux-gnu</code></a></td><td>ARM64 Linux (kernel 4.1+, glibc 2.17+)</td></tr>
<tr><td><a href="#-pc-windows-msvc"><code>i686-pc-windows-msvc</code></a></td><td>32-bit MSVC (Windows 10+, Windows Server 2016+, Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-1"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup> <sup class="footnote-reference" id="fr-win32-msvc-alignment-1"><a href="#footnote-win32-msvc-alignment">2</a></sup></td></tr>
<tr><td><code>i686-unknown-linux-gnu</code></td><td>32-bit Linux (kernel 3.2+, glibc 2.17+, Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-2"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-windows-gnu"><code>x86_64-pc-windows-gnu</code></a></td><td>64-bit MinGW (Windows 10+, Windows Server 2016+)</td></tr>
<tr><td><a href="#-pc-windows-msvc"><code>x86_64-pc-windows-msvc</code></a></td><td>64-bit MSVC (Windows 10+, Windows Server 2016+)</td></tr>
<tr><td><code>x86_64-unknown-linux-gnu</code></td><td>64-bit Linux (kernel 3.2+, glibc 2.17+)</td></tr>
</tbody>
</table>
</div>
<h2 id="tier-1"><a class="header" href="#tier-1">Tier 1</a></h2>
<p>Tier 1 targets can be thought of as “guaranteed to work”. The Rust project
builds official binary releases for each tier 1 target, and automated testing
ensures that each tier 1 target builds and passes tests after each change. For
the full requirements, see <a href="#tier-1-target-policy">Tier 1 target
policy</a> in the Target Tier Policy.</p>
<p>At this time, all Tier 1 targets are <a href="#tier-1-with-host-tools">Tier 1 with Host
Tools</a>.</p>
<h2 id="tier-2-with-host-tools"><a class="header" href="#tier-2-with-host-tools">Tier 2 with Host Tools</a></h2>
<p>Tier 2 targets can be thought of as “guaranteed to build”. The Rust project
builds official binary releases of the standard library (or, in some cases,
only the <code>core</code> library) for each tier 2 target, and automated builds
ensure that each tier 2 target can be used as build target after each change. Automated tests are
not always run so it’s not guaranteed to produce a working build, but tier 2
targets often work to quite a good degree and patches are always welcome!</p>
<p>Tier 2 target-specific code is not closely scrutinized by Rust team(s) when
modifications are made. Bugs are possible in all code, but the level of quality
control for these targets is likely to be lower. See <a href="https://std-dev-guide.rust-lang.org/policy/target-code.html">library team
policy</a> for
details on the review practices for standard library code.</p>
<p>Tier 2 targets with host tools additionally support running tools like <code>rustc</code>
and <code>cargo</code> natively on the target, and automated builds ensure that the host
tools build as well. This allows the target to be used as a development
platform, not just a compilation target. For the full requirements, see <a href="#tier-2-with-host-tools-1">Tier 2
with Host Tools</a> in the Target
Tier Policy.</p>
<p>All tier 2 targets with host tools support the full standard library.</p>
<p><strong>NOTE:</strong> The <code>rust-docs</code> component is not usually built for tier 2 targets,
so Rustup may install the documentation for a similar tier 1 target instead.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>target</th><th>notes</th></tr>
</thead>
<tbody>
<tr><td><a href="#-windows-gnullvm"><code>aarch64-pc-windows-gnullvm</code></a></td><td>ARM64 MinGW (Windows 10+), LLVM ABI</td></tr>
<tr><td><a href="#aarch64-unknown-linux-musl"><code>aarch64-unknown-linux-musl</code></a></td><td>ARM64 Linux with musl 1.2.5</td></tr>
<tr><td><a href="#-unknown-linux-ohos"><code>aarch64-unknown-linux-ohos</code></a></td><td>ARM64 OpenHarmony</td></tr>
<tr><td><code>arm-unknown-linux-gnueabi</code></td><td>Armv6 Linux (kernel 3.2+, glibc 2.17)</td></tr>
<tr><td><code>arm-unknown-linux-gnueabihf</code></td><td>Armv6 Linux, hardfloat (kernel 3.2+, glibc 2.17)</td></tr>
<tr><td><a href="#armv7-unknown-linux-gnueabi-and-armv7-unknown-linux-gnueabihf"><code>armv7-unknown-linux-gnueabihf</code></a></td><td>Armv7-A Linux, hardfloat (kernel 3.2+, glibc 2.17)</td></tr>
<tr><td><a href="#-unknown-linux-ohos"><code>armv7-unknown-linux-ohos</code></a></td><td>Armv7-A OpenHarmony</td></tr>
<tr><td><a href="#loongarch-unknown-linux-"><code>loongarch64-unknown-linux-gnu</code></a></td><td>LoongArch64 Linux, LP64D ABI (kernel 5.19+, glibc 2.36), LSX required</td></tr>
<tr><td><a href="#loongarch-unknown-linux-"><code>loongarch64-unknown-linux-musl</code></a></td><td>LoongArch64 Linux, LP64D ABI (kernel 5.19+, musl 1.2.5), LSX required</td></tr>
<tr><td><a href="#-windows-gnu"><code>i686-pc-windows-gnu</code></a></td><td>32-bit MinGW (Windows 10+, Windows Server 2016+, Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-3"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup> <sup class="footnote-reference" id="fr-win32-msvc-alignment-2"><a href="#footnote-win32-msvc-alignment">2</a></sup></td></tr>
<tr><td><code>powerpc-unknown-linux-gnu</code></td><td>PowerPC Linux (kernel 3.2+, glibc 2.17)</td></tr>
<tr><td><code>powerpc64-unknown-linux-gnu</code></td><td>PPC64 Linux (kernel 3.2+, glibc 2.17)</td></tr>
<tr><td><a href="#powerpc64le-unknown-linux-gnu"><code>powerpc64le-unknown-linux-gnu</code></a></td><td>PPC64LE Linux (kernel 3.10+, glibc 2.17)</td></tr>
<tr><td><a href="#powerpc64le-unknown-linux-musl"><code>powerpc64le-unknown-linux-musl</code></a></td><td>PPC64LE Linux (kernel 4.19+, musl 1.2.5)</td></tr>
<tr><td><a href="#riscv64gc-unknown-linux-gnu"><code>riscv64gc-unknown-linux-gnu</code></a></td><td>RISC-V Linux (kernel 4.20+, glibc 2.29)</td></tr>
<tr><td><a href="#s390x-unknown-linux-gnu"><code>s390x-unknown-linux-gnu</code></a></td><td>S390x Linux (kernel 3.2+, glibc 2.17)</td></tr>
<tr><td><a href="#-apple-darwin"><code>x86_64-apple-darwin</code></a></td><td>64-bit macOS (10.12+, Sierra+)</td></tr>
<tr><td><a href="#-windows-gnullvm"><code>x86_64-pc-windows-gnullvm</code></a></td><td>64-bit x86 MinGW (Windows 10+), LLVM ABI</td></tr>
<tr><td><a href="#-unknown-freebsd"><code>x86_64-unknown-freebsd</code></a></td><td>64-bit x86 FreeBSD</td></tr>
<tr><td><a href="#aarch64-unknown-illumos-and-x86_64-unknown-illumos"><code>x86_64-unknown-illumos</code></a></td><td>illumos</td></tr>
<tr><td><code>x86_64-unknown-linux-musl</code></td><td>64-bit Linux with musl 1.2.5</td></tr>
<tr><td><a href="#-unknown-linux-ohos"><code>x86_64-unknown-linux-ohos</code></a></td><td>x86_64 OpenHarmony</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>x86_64-unknown-netbsd</code></a></td><td>NetBSD/amd64</td></tr>
<tr><td><a href="#sparcv9-sun-solaris"><code>x86_64-pc-solaris</code></a></td><td>64-bit x86 Solaris 11.4</td></tr>
<tr><td><a href="#sparcv9-sun-solaris"><code>sparcv9-sun-solaris</code></a></td><td>SPARC V9 Solaris 11.4</td></tr>
</tbody>
</table>
</div>
<h2 id="tier-2-without-host-tools"><a class="header" href="#tier-2-without-host-tools">Tier 2 without Host Tools</a></h2>
<p>Tier 2 targets can be thought of as “guaranteed to build”. The Rust project
builds official binary releases of the standard library (or, in some cases,
only the <code>core</code> library) for each tier 2 target, and automated builds
ensure that each tier 2 target can be used as build target after each change. Automated tests are
not always run so it’s not guaranteed to produce a working build, but tier 2
targets often work to quite a good degree and patches are always welcome! For
the full requirements, see <a href="#tier-2-target-policy">Tier 2 target
policy</a> in the Target Tier Policy.</p>
<p>The <code>std</code> column in the table below has the following meanings:</p>
<ul>
<li>✓ indicates the full standard library is available.</li>
<li>* indicates the target only supports <a href="https://rust-embedded.github.io/book/intro/no-std.html"><code>no_std</code></a> development.</li>
<li>? indicates the standard library support is a work-in-progress.</li>
</ul>
<p>Tier 2 target-specific code is not closely scrutinized by Rust team(s) when
modifications are made. Bugs are possible in all code, but the level of quality
control for these targets is likely to be lower. See <a href="https://std-dev-guide.rust-lang.org/policy/target-code.html">library team
policy</a> for
details on the review practices for standard library code.</p>
<p><strong>NOTE:</strong> The <code>rust-docs</code> component is not usually built for tier 2 targets,
so Rustup may install the documentation for a similar tier 1 target instead.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>target</th><th style="text-align: center">std</th><th>notes</th></tr>
</thead>
<tbody>
<tr><td><a href="#-apple-ios"><code>aarch64-apple-ios</code></a></td><td style="text-align: center">✓</td><td>ARM64 iOS</td></tr>
<tr><td><a href="#-apple-ios-macabi"><code>aarch64-apple-ios-macabi</code></a></td><td style="text-align: center">✓</td><td>Mac Catalyst on ARM64</td></tr>
<tr><td><a href="#-apple-ios"><code>aarch64-apple-ios-sim</code></a></td><td style="text-align: center">✓</td><td>Apple iOS Simulator on ARM64</td></tr>
<tr><td><a href="#-linux-android-and--linux-androideabi"><code>aarch64-linux-android</code></a></td><td style="text-align: center">✓</td><td>ARM64 Android</td></tr>
<tr><td><a href="#aarch64-unknown-fuchsia-and-x86_64-unknown-fuchsia"><code>aarch64-unknown-fuchsia</code></a></td><td style="text-align: center">✓</td><td>ARM64 Fuchsia</td></tr>
<tr><td><a href="#aarch64-unknown-none-and-aarch64-unknown-none-softfloat"><code>aarch64-unknown-none</code></a></td><td style="text-align: center">*</td><td>Bare ARM64, hardfloat</td></tr>
<tr><td><a href="#aarch64-unknown-none-and-aarch64-unknown-none-softfloat"><code>aarch64-unknown-none-softfloat</code></a></td><td style="text-align: center">*</td><td>Bare ARM64, softfloat</td></tr>
<tr><td><a href="#-unknown-uefi"><code>aarch64-unknown-uefi</code></a></td><td style="text-align: center">?</td><td>ARM64 UEFI</td></tr>
<tr><td><a href="#-linux-android-and--linux-androideabi"><code>arm-linux-androideabi</code></a></td><td style="text-align: center">✓</td><td>Armv6 Android</td></tr>
<tr><td><code>arm-unknown-linux-musleabi</code></td><td style="text-align: center">✓</td><td>Armv6 Linux with musl 1.2.5</td></tr>
<tr><td><code>arm-unknown-linux-musleabihf</code></td><td style="text-align: center">✓</td><td>Armv6 Linux with musl 1.2.5, hardfloat</td></tr>
<tr><td><a href="#arm64ec-pc-windows-msvc"><code>arm64ec-pc-windows-msvc</code></a></td><td style="text-align: center">✓</td><td>Arm64EC Windows MSVC</td></tr>
<tr><td><a href="#armv5te-unknown-linux-gnueabi"><code>armv5te-unknown-linux-gnueabi</code></a></td><td style="text-align: center">✓</td><td>Armv5TE Linux (kernel 4.4+, glibc 2.23)</td></tr>
<tr><td><code>armv5te-unknown-linux-musleabi</code></td><td style="text-align: center">✓</td><td>Armv5TE Linux with musl 1.2.5</td></tr>
<tr><td><a href="#-linux-android-and--linux-androideabi"><code>armv7-linux-androideabi</code></a></td><td style="text-align: center">✓</td><td>Armv7-A Android</td></tr>
<tr><td><a href="#armv7-unknown-linux-gnueabi-and-armv7-unknown-linux-gnueabihf"><code>armv7-unknown-linux-gnueabi</code></a></td><td style="text-align: center">✓</td><td>Armv7-A Linux (kernel 4.15+, glibc 2.27)</td></tr>
<tr><td><code>armv7-unknown-linux-musleabi</code></td><td style="text-align: center">✓</td><td>Armv7-A Linux with musl 1.2.5</td></tr>
<tr><td><code>armv7-unknown-linux-musleabihf</code></td><td style="text-align: center">✓</td><td>Armv7-A Linux with musl 1.2.5, hardfloat</td></tr>
<tr><td><a href="#armv7a-none-eabi-and-armv7a-none-eabihf"><code>armv7a-none-eabi</code></a></td><td style="text-align: center">*</td><td>Bare Armv7-A</td></tr>
<tr><td><a href="#armv7a-none-eabi-and-armv7a-none-eabihf"><code>armv7a-none-eabihf</code></a></td><td style="text-align: center">*</td><td>Bare Armv7-A, hardfloat</td></tr>
<tr><td><a href="#armv7r-none-eabi-and-armv7r-none-eabihf"><code>armv7r-none-eabi</code></a></td><td style="text-align: center">*</td><td>Bare Armv7-R</td></tr>
<tr><td><a href="#armv7r-none-eabi-and-armv7r-none-eabihf"><code>armv7r-none-eabihf</code></a></td><td style="text-align: center">*</td><td>Bare Armv7-R, hardfloat</td></tr>
<tr><td><a href="#armv8r-none-eabihf"><code>armv8r-none-eabihf</code></a></td><td style="text-align: center">*</td><td>Bare Armv8-R, hardfloat</td></tr>
<tr><td><code>i586-unknown-linux-gnu</code></td><td style="text-align: center">✓</td><td>32-bit Linux (kernel 3.2+, glibc 2.17, original Pentium) <sup class="footnote-reference" id="fr-x86_32-floats-x87-1"><a href="#footnote-x86_32-floats-x87">3</a></sup></td></tr>
<tr><td><code>i586-unknown-linux-musl</code></td><td style="text-align: center">✓</td><td>32-bit Linux (musl 1.2.5, original Pentium) <sup class="footnote-reference" id="fr-x86_32-floats-x87-2"><a href="#footnote-x86_32-floats-x87">3</a></sup></td></tr>
<tr><td><a href="#-linux-android-and--linux-androideabi"><code>i686-linux-android</code></a></td><td style="text-align: center">✓</td><td>32-bit x86 Android (<a href="https://developer.android.com/ndk/guides/abis.html#x86">Pentium 4 plus various extensions</a>) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-4"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-windows-gnullvm"><code>i686-pc-windows-gnullvm</code></a></td><td style="text-align: center">✓</td><td>32-bit x86 MinGW (Windows 10+, Pentium 4), LLVM ABI <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-5"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-unknown-freebsd"><code>i686-unknown-freebsd</code></a></td><td style="text-align: center">✓</td><td>32-bit x86 FreeBSD (Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-6"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><code>i686-unknown-linux-musl</code></td><td style="text-align: center">✓</td><td>32-bit Linux with musl 1.2.5 (Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-7"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-unknown-uefi"><code>i686-unknown-uefi</code></a></td><td style="text-align: center">?</td><td>32-bit UEFI (Pentium 4, softfloat) <sup class="footnote-reference" id="fr-win32-msvc-alignment-3"><a href="#footnote-win32-msvc-alignment">2</a></sup></td></tr>
<tr><td><a href="#loongarch-unknown-none"><code>loongarch64-unknown-none</code></a></td><td style="text-align: center">*</td><td>LoongArch64 Bare-metal (LP64D ABI)</td></tr>
<tr><td><a href="#loongarch-unknown-none"><code>loongarch64-unknown-none-softfloat</code></a></td><td style="text-align: center">*</td><td>LoongArch64 Bare-metal (LP64S ABI)</td></tr>
<tr><td><a href="#nvptx64-nvidia-cuda"><code>nvptx64-nvidia-cuda</code></a></td><td style="text-align: center">*</td><td>–emit=asm generates PTX code that <a href="https://github.com/japaric-archived/nvptx#targets">runs on NVIDIA GPUs</a></td></tr>
<tr><td><a href="#riscv32iimimaimcimacimafc-unknown-none-elf"><code>riscv32i-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td>Bare RISC-V (RV32I ISA)</td></tr>
<tr><td><a href="#riscv32iimimaimcimacimafc-unknown-none-elf"><code>riscv32im-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td>Bare RISC-V (RV32IM ISA)</td></tr>
<tr><td><a href="#riscv32iimimaimcimacimafc-unknown-none-elf"><code>riscv32imac-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td>Bare RISC-V (RV32IMAC ISA)</td></tr>
<tr><td><a href="#riscv32iimimaimcimacimafc-unknown-none-elf"><code>riscv32imafc-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td>Bare RISC-V (RV32IMAFC ISA)</td></tr>
<tr><td><a href="#riscv32iimimaimcimacimafc-unknown-none-elf"><code>riscv32imc-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td>Bare RISC-V (RV32IMC ISA)</td></tr>
<tr><td><a href="#riscv64gc-unknown-linux-musl"><code>riscv64gc-unknown-linux-musl</code></a></td><td style="text-align: center">✓</td><td>RISC-V Linux (kernel 4.20+, musl 1.2.5)</td></tr>
<tr><td><code>riscv64gc-unknown-none-elf</code></td><td style="text-align: center">*</td><td>Bare RISC-V (RV64IMAFDC ISA)</td></tr>
<tr><td><a href="#riscv64im-unknown-none-elf"><code>riscv64im-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td>Bare RISC-V (RV64IM ISA)</td></tr>
<tr><td><code>riscv64imac-unknown-none-elf</code></td><td style="text-align: center">*</td><td>Bare RISC-V (RV64IMAC ISA)</td></tr>
<tr><td><code>sparc64-unknown-linux-gnu</code></td><td style="text-align: center">✓</td><td>SPARC Linux (kernel 4.4+, glibc 2.23)</td></tr>
<tr><td><a href="#thumbv6m-none-eabi"><code>thumbv6m-none-eabi</code></a></td><td style="text-align: center">*</td><td>Bare Armv6-M</td></tr>
<tr><td><a href="#thumbv7em-none-eabi-and-thumbv7em-none-eabihf"><code>thumbv7em-none-eabi</code></a></td><td style="text-align: center">*</td><td>Bare Armv7E-M</td></tr>
<tr><td><a href="#thumbv7em-none-eabi-and-thumbv7em-none-eabihf"><code>thumbv7em-none-eabihf</code></a></td><td style="text-align: center">*</td><td>Bare Armv7E-M, hardfloat</td></tr>
<tr><td><a href="#thumbv7m-none-eabi"><code>thumbv7m-none-eabi</code></a></td><td style="text-align: center">*</td><td>Bare Armv7-M</td></tr>
<tr><td><a href="#-linux-android-and--linux-androideabi"><code>thumbv7neon-linux-androideabi</code></a></td><td style="text-align: center">✓</td><td>Thumb2-mode Armv7-A Android with NEON</td></tr>
<tr><td><code>thumbv7neon-unknown-linux-gnueabihf</code></td><td style="text-align: center">✓</td><td>Thumb2-mode Armv7-A Linux with NEON (kernel 4.4+, glibc 2.23)</td></tr>
<tr><td><a href="#thumbv8mbase-none-eabi"><code>thumbv8m.base-none-eabi</code></a></td><td style="text-align: center">*</td><td>Bare Armv8-M Baseline</td></tr>
<tr><td><a href="#thumbv8mmain-none-eabi-and-thumbv8mmain-none-eabihf"><code>thumbv8m.main-none-eabi</code></a></td><td style="text-align: center">*</td><td>Bare Armv8-M Mainline</td></tr>
<tr><td><a href="#thumbv8mmain-none-eabi-and-thumbv8mmain-none-eabihf"><code>thumbv8m.main-none-eabihf</code></a></td><td style="text-align: center">*</td><td>Bare Armv8-M Mainline, hardfloat</td></tr>
<tr><td><a href="#wasm32-unknown-emscripten"><code>wasm32-unknown-emscripten</code></a></td><td style="text-align: center">✓</td><td>WebAssembly via Emscripten</td></tr>
<tr><td><a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a></td><td style="text-align: center">✓</td><td>WebAssembly</td></tr>
<tr><td><a href="#wasm32-wasip1"><code>wasm32-wasip1</code></a></td><td style="text-align: center">✓</td><td>WebAssembly with WASIp1</td></tr>
<tr><td><a href="#wasm32-wasip1-threads"><code>wasm32-wasip1-threads</code></a></td><td style="text-align: center">✓</td><td>WebAssembly with WASI Preview 1 and threads</td></tr>
<tr><td><a href="#wasm32-wasip2"><code>wasm32-wasip2</code></a></td><td style="text-align: center">✓</td><td>WebAssembly with WASIp2</td></tr>
<tr><td><a href="#wasm32v1-none"><code>wasm32v1-none</code></a></td><td style="text-align: center">*</td><td>WebAssembly limited to 1.0 features and no imports</td></tr>
<tr><td><a href="#-apple-ios"><code>x86_64-apple-ios</code></a></td><td style="text-align: center">✓</td><td>64-bit x86 iOS</td></tr>
<tr><td><a href="#-apple-ios-macabi"><code>x86_64-apple-ios-macabi</code></a></td><td style="text-align: center">✓</td><td>Mac Catalyst on x86_64</td></tr>
<tr><td><a href="#x86_64-fortanix-unknown-sgx"><code>x86_64-fortanix-unknown-sgx</code></a></td><td style="text-align: center">✓</td><td><a href="https://edp.fortanix.com/">Fortanix ABI</a> for 64-bit Intel SGX</td></tr>
<tr><td><a href="#-linux-android-and--linux-androideabi"><code>x86_64-linux-android</code></a></td><td style="text-align: center">✓</td><td>64-bit x86 Android</td></tr>
<tr><td><a href="#x86_64-unknown-linux-gnuasan"><code>x86_64-unknown-linux-gnuasan</code></a></td><td style="text-align: center">✓</td><td>64-bit Linux (kernel 3.2+, glibc 2.17+) with ASAN enabled by default</td></tr>
<tr><td><a href="#aarch64-unknown-fuchsia-and-x86_64-unknown-fuchsia"><code>x86_64-unknown-fuchsia</code></a></td><td style="text-align: center">✓</td><td>64-bit x86 Fuchsia</td></tr>
<tr><td><code>x86_64-unknown-linux-gnux32</code></td><td style="text-align: center">✓</td><td>64-bit Linux (x32 ABI) (kernel 4.15+, glibc 2.27)</td></tr>
<tr><td><a href="#x86_64-unknown-none"><code>x86_64-unknown-none</code></a></td><td style="text-align: center">*</td><td>Freestanding/bare-metal x86_64, softfloat</td></tr>
<tr><td><a href="#-unknown-redox"><code>x86_64-unknown-redox</code></a></td><td style="text-align: center">✓</td><td>Redox OS</td></tr>
<tr><td><a href="#-unknown-uefi"><code>x86_64-unknown-uefi</code></a></td><td style="text-align: center">?</td><td>64-bit UEFI</td></tr>
</tbody>
</table>
</div>
<h2 id="tier-3"><a class="header" href="#tier-3">Tier 3</a></h2>
<p>Tier 3 targets are those which the Rust codebase has support for, but which the
Rust project does not build or test automatically, so they may or may not work.
Official builds are not available. For the full requirements, see <a href="#tier-3-target-policy">Tier 3
target policy</a> in the Target Tier
Policy.</p>
<p>The <code>std</code> column in the table below has the following meanings:</p>
<ul>
<li>✓ indicates the full standard library is available.</li>
<li>* indicates the target only supports <a href="https://rust-embedded.github.io/book/intro/no-std.html"><code>no_std</code></a> development.</li>
<li>? indicates the standard library support is unknown or a work-in-progress.</li>
</ul>
<p>Tier 3 target-specific code is not closely scrutinized by Rust team(s) when
modifications are made. Bugs are possible in all code, but the level of quality
control for these targets is likely to be lower. See <a href="https://std-dev-guide.rust-lang.org/policy/target-code.html">library team
policy</a> for
details on the review practices for standard library code.</p>
<p>The <code>host</code> column indicates whether the codebase includes support for building
host tools.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>target</th><th style="text-align: center">std</th><th style="text-align: center">host</th><th>notes</th></tr>
</thead>
<tbody>
<tr><td><a href="#-apple-tvos"><code>aarch64-apple-tvos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 tvOS</td></tr>
<tr><td><a href="#-apple-tvos"><code>aarch64-apple-tvos-sim</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 tvOS Simulator</td></tr>
<tr><td><a href="#-apple-visionos"><code>aarch64-apple-visionos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 Apple visionOS</td></tr>
<tr><td><a href="#-apple-visionos"><code>aarch64-apple-visionos-sim</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 Apple visionOS Simulator</td></tr>
<tr><td><a href="#-apple-watchos"><code>aarch64-apple-watchos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 Apple WatchOS</td></tr>
<tr><td><a href="#-apple-watchos"><code>aarch64-apple-watchos-sim</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 Apple WatchOS Simulator</td></tr>
<tr><td><a href="#-kmc-solid_"><code>aarch64-kmc-solid_asp3</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 SOLID with TOPPERS/ASP3</td></tr>
<tr><td><a href="#aarch64-nintendo-switch-freestanding"><code>aarch64-nintendo-switch-freestanding</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>ARM64 Nintendo Switch, Horizon</td></tr>
<tr><td><a href="#-unknown-freebsd"><code>aarch64-unknown-freebsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 FreeBSD</td></tr>
<tr><td><a href="#-unknown-helenos"><code>aarch64-unknown-helenos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 HelenOS</td></tr>
<tr><td><a href="#-unknown-hermit"><code>aarch64-unknown-hermit</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 Hermit</td></tr>
<tr><td><a href="#aarch64-unknown-illumos-and-x86_64-unknown-illumos"><code>aarch64-unknown-illumos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 illumos</td></tr>
<tr><td><code>aarch64-unknown-linux-gnu_ilp32</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 Linux (ILP32 ABI)</td></tr>
<tr><td><a href="#-unknown-managarm-mlibc"><code>aarch64-unknown-managarm-mlibc</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>ARM64 Managarm</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>aarch64-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 NetBSD</td></tr>
<tr><td><a href="#nto-qnx"><code>aarch64-unknown-nto-qnx700</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>ARM64 QNX Neutrino 7.0 RTOS</td></tr>
<tr><td><a href="#nto-qnx"><code>aarch64-unknown-nto-qnx710</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 QNX Neutrino 7.1 RTOS with default network stack (io-pkt)</td></tr>
<tr><td><a href="#nto-qnx"><code>aarch64-unknown-nto-qnx710_iosock</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 QNX Neutrino 7.1 RTOS with new network stack (io-sock)</td></tr>
<tr><td><a href="#nto-qnx"><code>aarch64-unknown-nto-qnx800</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 QNX Neutrino 8.0 RTOS</td></tr>
<tr><td><a href="#-nuttx-elf"><code>aarch64-unknown-nuttx</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 with NuttX</td></tr>
<tr><td><a href="#-unknown-openbsd"><code>aarch64-unknown-openbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 OpenBSD</td></tr>
<tr><td><a href="#-unknown-redox"><code>aarch64-unknown-redox</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 Redox OS</td></tr>
<tr><td><a href="#aarch64-unknown-teeos"><code>aarch64-unknown-teeos</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>ARM64 TEEOS</td></tr>
<tr><td><a href="#aarch64-unknown-trusty-and-armv7-unknown-trusty"><code>aarch64-unknown-trusty</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#x86_64-uwp-windows-msvc-i686-uwp-windows-msvc-thumbv7a-uwp-windows-msvc-and-aarch64-uwp-windows-msvc"><code>aarch64-uwp-windows-msvc</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#-wrs-vxworks"><code>aarch64-wrs-vxworks</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 VxWorks OS</td></tr>
<tr><td><a href="#-unknown-hermit"><code>aarch64_be-unknown-hermit</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64 Hermit (big-endian)</td></tr>
<tr><td><code>aarch64_be-unknown-linux-gnu</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 Linux (big-endian)</td></tr>
<tr><td><code>aarch64_be-unknown-linux-gnu_ilp32</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 Linux (big-endian, ILP32 ABI)</td></tr>
<tr><td><a href="#aarch64_be-unknown-linux-musl"><code>aarch64_be-unknown-linux-musl</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 Linux (big-endian) with musl-libc 1.2.5</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>aarch64_be-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64 NetBSD (big-endian)</td></tr>
<tr><td><a href="#aarch64_be-unknown-none-softfloat"><code>aarch64_be-unknown-none-softfloat</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare big-endian ARM64, softfloat</td></tr>
<tr><td><a href="#amdgcn-amd-amdhsa"><code>amdgcn-amd-amdhsa</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td><code>-Ctarget-cpu=gfx...</code> to specify <a href="https://llvm.org/docs/AMDGPUUsage.html#processors">the AMD GPU</a> to compile for</td></tr>
<tr><td><a href="#-apple-watchos"><code>arm64_32-apple-watchos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Arm Apple WatchOS 64-bit with 32-bit pointers</td></tr>
<tr><td><a href="#arm64e-apple-darwin"><code>arm64e-apple-darwin</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>ARM64e Apple Darwin</td></tr>
<tr><td><a href="#arm64e-apple-ios"><code>arm64e-apple-ios</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64e Apple iOS</td></tr>
<tr><td><a href="#arm64e-apple-tvos"><code>arm64e-apple-tvos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM64e Apple tvOS</td></tr>
<tr><td><a href="#armeb-unknown-linux-gnueabi"><code>armeb-unknown-linux-gnueabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">?</td><td>Arm BE8 the default Arm big-endian architecture since <a href="https://developer.arm.com/documentation/101754/0616/armlink-Reference/armlink-Command-line-Options/--be8?lang=en">Armv6</a>.</td></tr>
<tr><td><a href="#armebv7r-none-eabi-and-armebv7r-none-eabihf"><code>armebv7r-none-eabi</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare Armv7-R, Big Endian</td></tr>
<tr><td><a href="#armebv7r-none-eabi-and-armebv7r-none-eabihf"><code>armebv7r-none-eabihf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare Armv7-R, Big Endian, hardfloat</td></tr>
<tr><td><a href="#armv4t-none-eabi--thumbv4t-none-eabi"><code>armv4t-none-eabi</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare Armv4T</td></tr>
<tr><td><code>armv4t-unknown-linux-gnueabi</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>Armv4T Linux</td></tr>
<tr><td><a href="#armv5te-none-eabi"><code>armv5te-none-eabi</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare Armv5TE</td></tr>
<tr><td><code>armv5te-unknown-linux-uclibceabi</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>Armv5TE Linux with uClibc</td></tr>
<tr><td><a href="#-unknown-freebsd"><code>armv6-unknown-freebsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>Armv6 FreeBSD</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>armv6-unknown-netbsd-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>Armv6 NetBSD w/hard-float</td></tr>
<tr><td><a href="#armv6k-nintendo-3ds"><code>armv6k-nintendo-3ds</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>Armv6k Nintendo 3DS, Horizon (Requires devkitARM toolchain)</td></tr>
<tr><td><a href="#armv7-rtems-eabihf"><code>armv7-rtems-eabihf</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RTEMS OS for ARM BSPs</td></tr>
<tr><td><a href="#armv7-sony-vita-newlibeabihf"><code>armv7-sony-vita-newlibeabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Armv7-A Cortex-A9 Sony PlayStation Vita (requires VITASDK toolchain)</td></tr>
<tr><td><a href="#-unknown-freebsd"><code>armv7-unknown-freebsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>Armv7-A FreeBSD</td></tr>
<tr><td><a href="#armv7-unknown-linux-uclibceabi"><code>armv7-unknown-linux-uclibceabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>Armv7-A Linux with uClibc, softfloat</td></tr>
<tr><td><a href="#armv7-unknown-linux-uclibceabihf"><code>armv7-unknown-linux-uclibceabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">?</td><td>Armv7-A Linux with uClibc, hardfloat</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>armv7-unknown-netbsd-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>Armv7-A NetBSD w/hard-float</td></tr>
<tr><td><a href="#aarch64-unknown-trusty-and-armv7-unknown-trusty"><code>armv7-unknown-trusty</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#-wrs-vxworks"><code>armv7-wrs-vxworks-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Armv7-A for VxWorks</td></tr>
<tr><td><a href="#-kmc-solid_"><code>armv7a-kmc-solid_asp3-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM SOLID with TOPPERS/ASP3</td></tr>
<tr><td><a href="#-kmc-solid_"><code>armv7a-kmc-solid_asp3-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARM SOLID with TOPPERS/ASP3, hardfloat</td></tr>
<tr><td><a href="#armv7a-vex-v5"><code>armv7a-vex-v5</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>Armv7-A Cortex-A9 VEX V5 Brain, VEXos</td></tr>
<tr><td><a href="#-apple-watchos"><code>armv7k-apple-watchos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Armv7-A Apple WatchOS</td></tr>
<tr><td><a href="#-apple-ios"><code>armv7s-apple-ios</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Armv7-A Apple-A6 Apple iOS</td></tr>
<tr><td><a href="#-nuttx-elf"><code>armv7a-nuttx-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv7-A with NuttX</td></tr>
<tr><td><a href="#-nuttx-elf"><code>armv7a-nuttx-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv7-A with NuttX, hardfloat</td></tr>
<tr><td><a href="#avr-none"><code>avr-none</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>AVR; requires <code>-Zbuild-std=core</code> and <code>-Ctarget-cpu=...</code></td></tr>
<tr><td><code>bpfeb-unknown-none</code></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>BPF (big endian)</td></tr>
<tr><td><code>bpfel-unknown-none</code></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>BPF (little endian)</td></tr>
<tr><td><code>csky-unknown-linux-gnuabiv2</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>C-SKY abiv2 Linux (little endian)</td></tr>
<tr><td><code>csky-unknown-linux-gnuabiv2hf</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>C-SKY abiv2 Linux, hardfloat (little endian)</td></tr>
<tr><td><a href="#hexagon-unknown-linux-musl"><code>hexagon-unknown-linux-musl</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Hexagon Linux with musl 1.2.5</td></tr>
<tr><td><a href="#hexagon-unknown-none-elf"><code>hexagon-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare Hexagon (v60+, HVX)</td></tr>
<tr><td><a href="#hexagon-unknown-qurt"><code>hexagon-unknown-qurt</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Hexagon QuRT</td></tr>
<tr><td><a href="#-apple-ios"><code>i386-apple-ios</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>32-bit x86 iOS (Penryn) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-8"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-unknown-netbsd"><code>i586-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>32-bit x86 (original Pentium) <sup class="footnote-reference" id="fr-x86_32-floats-x87-3"><a href="#footnote-x86_32-floats-x87">3</a></sup></td></tr>
<tr><td><a href="#-unknown-redox"><code>i586-unknown-redox</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>32-bit x86 Redox OS (PentiumPro) <sup class="footnote-reference" id="fr-x86_32-floats-x87-4"><a href="#footnote-x86_32-floats-x87">3</a></sup></td></tr>
<tr><td><a href="#-apple-darwin"><code>i686-apple-darwin</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>32-bit macOS (10.12+, Sierra+, Penryn) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-9"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#nto-qnx"><code>i686-pc-nto-qnx700</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>32-bit x86 QNX Neutrino 7.0 RTOS (Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-10"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><code>i686-unknown-haiku</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>32-bit Haiku (Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-11"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-unknown-helenos"><code>i686-unknown-helenos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>HelenOS IA-32 (see docs for pending issues)</td></tr>
<tr><td><a href="#i686-unknown-hurd-gnu-and-x86_64-unknown-hurd-gnu"><code>i686-unknown-hurd-gnu</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>32-bit GNU/Hurd (Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-12"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-unknown-netbsd"><code>i686-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>NetBSD/i386 (Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-13"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-unknown-openbsd"><code>i686-unknown-openbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>32-bit OpenBSD (Pentium 4) <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-14"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><code>i686-uwp-windows-gnu</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td><sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-15"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#x86_64-uwp-windows-msvc-i686-uwp-windows-msvc-thumbv7a-uwp-windows-msvc-and-aarch64-uwp-windows-msvc"><code>i686-uwp-windows-msvc</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td><sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-16"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup> <sup class="footnote-reference" id="fr-win32-msvc-alignment-4"><a href="#footnote-win32-msvc-alignment">2</a></sup></td></tr>
<tr><td><a href="#-win7-windows-gnu"><code>i686-win7-windows-gnu</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>32-bit Windows 7 support <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-17"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-win7-windows-msvc"><code>i686-win7-windows-msvc</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>32-bit Windows 7 support <sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-18"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup> <sup class="footnote-reference" id="fr-win32-msvc-alignment-5"><a href="#footnote-win32-msvc-alignment">2</a></sup></td></tr>
<tr><td><a href="#-wrs-vxworks"><code>i686-wrs-vxworks</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td><sup class="footnote-reference" id="fr-x86_32-floats-return-ABI-19"><a href="#footnote-x86_32-floats-return-ABI">1</a></sup></td></tr>
<tr><td><a href="#-unknown-linux-ohos"><code>loongarch64-unknown-linux-ohos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>LoongArch64 OpenHarmony</td></tr>
<tr><td><a href="#loongarch-unknown-none"><code>loongarch32-unknown-none</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>LoongArch32 Bare-metal (ILP32D ABI)</td></tr>
<tr><td><a href="#loongarch-unknown-none"><code>loongarch32-unknown-none-softfloat</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>LoongArch32 Bare-metal (ILP32S ABI)</td></tr>
<tr><td><a href="#m68k-unknown-linux-gnu"><code>m68k-unknown-linux-gnu</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>Motorola 680x0 Linux</td></tr>
<tr><td><a href="#m68k-unknown-none-elf"><code>m68k-unknown-none-elf</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td>Motorola 680x0</td></tr>
<tr><td><code>mips-unknown-linux-gnu</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>MIPS Linux (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>mips-unknown-linux-musl</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>MIPS Linux with musl 1.2.5</td></tr>
<tr><td><code>mips-unknown-linux-uclibc</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>MIPS Linux with uClibc</td></tr>
<tr><td><a href="#mips64-openwrt-linux-musl"><code>mips64-openwrt-linux-musl</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>MIPS64 for OpenWrt Linux musl 1.2.5</td></tr>
<tr><td><code>mips64-unknown-linux-gnuabi64</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>MIPS64 Linux, N64 ABI (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><a href="#mips64-unknown-linux-muslabi64"><code>mips64-unknown-linux-muslabi64</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>MIPS64 Linux, N64 ABI, musl 1.2.5</td></tr>
<tr><td><code>mips64el-unknown-linux-gnuabi64</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>MIPS64 (little endian) Linux, N64 ABI (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>mips64el-unknown-linux-muslabi64</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>MIPS64 (little endian) Linux, N64 ABI, musl 1.2.5</td></tr>
<tr><td><code>mipsel-sony-psp</code></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>MIPS (LE) Sony PlayStation Portable (PSP)</td></tr>
<tr><td><a href="#mipsel-sony-psx"><code>mipsel-sony-psx</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>MIPS (LE) Sony PlayStation 1 (PSX)</td></tr>
<tr><td><a href="#mipsel-unknown-linux-gnu"><code>mipsel-unknown-linux-gnu</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>MIPS (little endian) Linux (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>mipsel-unknown-linux-musl</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>MIPS (little endian) Linux with musl 1.2.5</td></tr>
<tr><td><code>mipsel-unknown-linux-uclibc</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>MIPS (LE) Linux with uClibc</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>mipsel-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>32-bit MIPS (LE), requires mips32 cpu support</td></tr>
<tr><td><code>mipsel-unknown-none</code></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare MIPS (LE) softfloat</td></tr>
<tr><td><a href="#mips-mti-none-elf"><code>mips-mti-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare MIPS32r2 (BE) softfloat</td></tr>
<tr><td><a href="#mips-mti-none-elf"><code>mipsel-mti-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare MIPS32r2 (LE) softfloat</td></tr>
<tr><td><a href="#mipsisar6-unknown-linux-gnu"><code>mipsisa32r6-unknown-linux-gnu</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>32-bit MIPS Release 6 Big Endian</td></tr>
<tr><td><a href="#mipsisar6-unknown-linux-gnu"><code>mipsisa32r6el-unknown-linux-gnu</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>32-bit MIPS Release 6 Little Endian</td></tr>
<tr><td><a href="#mipsisar6-unknown-linux-gnu"><code>mipsisa64r6-unknown-linux-gnuabi64</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>64-bit MIPS Release 6 Big Endian</td></tr>
<tr><td><a href="#mipsisar6-unknown-linux-gnu"><code>mipsisa64r6el-unknown-linux-gnuabi64</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>64-bit MIPS Release 6 Little Endian</td></tr>
<tr><td><code>msp430-none-elf</code></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>16-bit MSP430 microcontrollers</td></tr>
<tr><td><a href="#-unknown-freebsd"><code>powerpc-unknown-freebsd</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>PowerPC FreeBSD</td></tr>
<tr><td><a href="#-unknown-helenos"><code>powerpc-unknown-helenos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>PowerPC HelenOS</td></tr>
<tr><td><a href="#powerpc-unknown-linux-gnuspe"><code>powerpc-unknown-linux-gnuspe</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>PowerPC SPE Linux</td></tr>
<tr><td><code>powerpc-unknown-linux-musl</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>PowerPC Linux with musl 1.2.5</td></tr>
<tr><td><a href="#powerpc-unknown-linux-muslspe"><code>powerpc-unknown-linux-muslspe</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>PowerPC SPE Linux with musl 1.2.5</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>powerpc-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>NetBSD 32-bit powerpc systems</td></tr>
<tr><td><a href="#powerpc-unknown-openbsd"><code>powerpc-unknown-openbsd</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#-wrs-vxworks"><code>powerpc-wrs-vxworks</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#-wrs-vxworks"><code>powerpc-wrs-vxworks-spe</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#powerpc64-ibm-aix"><code>powerpc64-ibm-aix</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>64-bit AIX (7.2 and newer)</td></tr>
<tr><td><a href="#-unknown-freebsd"><code>powerpc64-unknown-freebsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>PPC64 FreeBSD (ELFv2)</td></tr>
<tr><td><a href="#powerpc64-unknown-linux-musl"><code>powerpc64-unknown-linux-musl</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>PPC64 Linux (kernel 4.19, musl 1.2.5)</td></tr>
<tr><td><a href="#-unknown-openbsd"><code>powerpc64-unknown-openbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>OpenBSD/powerpc64</td></tr>
<tr><td><a href="#-wrs-vxworks"><code>powerpc64-wrs-vxworks</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#-unknown-freebsd"><code>powerpc64le-unknown-freebsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>PPC64LE FreeBSD</td></tr>
<tr><td><a href="#-wrs-vxworks"><code>riscv32-wrs-vxworks</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#riscv32eememc-unknown-none-elf"><code>riscv32e-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare RISC-V (RV32E ISA)</td></tr>
<tr><td><a href="#riscv32eememc-unknown-none-elf"><code>riscv32em-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare RISC-V (RV32EM ISA)</td></tr>
<tr><td><a href="#riscv32eememc-unknown-none-elf"><code>riscv32emc-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare RISC-V (RV32EMC ISA)</td></tr>
<tr><td><code>riscv32gc-unknown-linux-gnu</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V Linux (kernel 5.4, glibc 2.33)</td></tr>
<tr><td><code>riscv32gc-unknown-linux-musl</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RISC-V Linux (kernel 5.4, musl 1.2.5)</td></tr>
<tr><td><a href="#riscv32im-risc0-zkvm-elf"><code>riscv32im-risc0-zkvm-elf</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RISC Zero’s zero-knowledge Virtual Machine (RV32IM ISA)</td></tr>
<tr><td><a href="#riscv32iimimaimcimacimafc-unknown-none-elf"><code>riscv32ima-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare RISC-V (RV32IMA ISA)</td></tr>
<tr><td><a href="#-espidf"><code>riscv32imac-esp-espidf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V ESP-IDF</td></tr>
<tr><td><a href="#-nuttx-elf"><code>riscv32imac-unknown-nuttx-elf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V 32bit with NuttX</td></tr>
<tr><td><a href="#riscv32imac-unknown-xous-elf"><code>riscv32imac-unknown-xous-elf</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RISC-V Xous (RV32IMAC ISA)</td></tr>
<tr><td><a href="#-espidf"><code>riscv32imafc-esp-espidf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V ESP-IDF</td></tr>
<tr><td><a href="#-nuttx-elf"><code>riscv32imafc-unknown-nuttx-elf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V 32bit with NuttX</td></tr>
<tr><td><a href="#-espidf"><code>riscv32imc-esp-espidf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V ESP-IDF</td></tr>
<tr><td><a href="#-nuttx-elf"><code>riscv32imc-unknown-nuttx-elf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V 32bit with NuttX</td></tr>
<tr><td><a href="#-linux-android-and--linux-androideabi"><code>riscv64-linux-android</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RISC-V 64-bit Android</td></tr>
<tr><td><a href="#-wrs-vxworks"><code>riscv64-wrs-vxworks</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><code>riscv64gc-unknown-freebsd</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RISC-V FreeBSD</td></tr>
<tr><td><code>riscv64gc-unknown-fuchsia</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RISC-V Fuchsia</td></tr>
<tr><td><a href="#-unknown-hermit"><code>riscv64gc-unknown-hermit</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V Hermit</td></tr>
<tr><td><a href="#-unknown-managarm-mlibc"><code>riscv64gc-unknown-managarm-mlibc</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>RISC-V Managarm</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>riscv64gc-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>RISC-V NetBSD</td></tr>
<tr><td><a href="#-nuttx-elf"><code>riscv64gc-unknown-nuttx-elf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V 64bit with NuttX</td></tr>
<tr><td><a href="#-unknown-openbsd"><code>riscv64gc-unknown-openbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>OpenBSD/riscv64</td></tr>
<tr><td><a href="#-unknown-redox"><code>riscv64gc-unknown-redox</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V 64bit Redox OS</td></tr>
<tr><td><a href="#-nuttx-elf"><code>riscv64imac-unknown-nuttx-elf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>RISC-V 64bit with NuttX</td></tr>
<tr><td><a href="#riscv64a23-unknown-linux-gnu"><code>riscv64a23-unknown-linux-gnu</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>RISC-V Linux (kernel 6.8.0+, glibc 2.39)</td></tr>
<tr><td><a href="#s390x-unknown-linux-musl"><code>s390x-unknown-linux-musl</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>S390x Linux (kernel 3.2, musl 1.2.5)</td></tr>
<tr><td><code>sparc-unknown-linux-gnu</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>32-bit SPARC Linux</td></tr>
<tr><td><a href="#sparc-unknown-none-elf"><code>sparc-unknown-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Bare 32-bit SPARC V7+</td></tr>
<tr><td><a href="#-unknown-helenos"><code>sparc64-unknown-helenos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>sparc64 HelenOS</td></tr>
<tr><td><a href="#-unknown-netbsd"><code>sparc64-unknown-netbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>NetBSD/sparc64</td></tr>
<tr><td><a href="#-unknown-openbsd"><code>sparc64-unknown-openbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>OpenBSD/sparc64</td></tr>
<tr><td><a href="#armv4t-none-eabi--thumbv4t-none-eabi"><code>thumbv4t-none-eabi</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Thumb-mode Bare Armv4T</td></tr>
<tr><td><a href="#armv5te-none-eabi"><code>thumbv5te-none-eabi</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Thumb-mode Bare Armv5TE</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv6m-nuttx-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv6M with NuttX</td></tr>
<tr><td><code>thumbv7a-pc-windows-msvc</code></td><td style="text-align: center"></td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#x86_64-uwp-windows-msvc-i686-uwp-windows-msvc-thumbv7a-uwp-windows-msvc-and-aarch64-uwp-windows-msvc"><code>thumbv7a-uwp-windows-msvc</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv7a-nuttx-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv7-A with NuttX</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv7a-nuttx-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv7-A with NuttX, hardfloat</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv7em-nuttx-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv7EM with NuttX</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv7em-nuttx-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv7EM with NuttX, hardfloat</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv7m-nuttx-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv7M with NuttX</td></tr>
<tr><td><code>thumbv7neon-unknown-linux-musleabihf</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>Thumb2-mode Armv7-A Linux with NEON, musl 1.2.5</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv8m.base-nuttx-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv8M Baseline with NuttX</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv8m.main-nuttx-eabi</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv8M Mainline with NuttX</td></tr>
<tr><td><a href="#-nuttx-elf"><code>thumbv8m.main-nuttx-eabihf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>ARMv8M Mainline with NuttX, hardfloat</td></tr>
<tr><td><a href="#wasm64-unknown-unknown"><code>wasm64-unknown-unknown</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>WebAssembly</td></tr>
<tr><td><a href="#wasm32-wali-linux-"><code>wasm32-wali-linux-musl</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>WebAssembly with <a href="https://github.com/arjunr2/WALI">WALI</a></td></tr>
<tr><td><a href="#wasm32-wasip3"><code>wasm32-wasip3</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>WebAssembly with WASIp3</td></tr>
<tr><td><a href="#-apple-tvos"><code>x86_64-apple-tvos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86 64-bit tvOS</td></tr>
<tr><td><a href="#-apple-watchos"><code>x86_64-apple-watchos-sim</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86 64-bit Apple WatchOS simulator</td></tr>
<tr><td><a href="#-lynxos178-"><code>x86_64-lynx-lynxos178</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td>x86_64 LynxOS-178</td></tr>
<tr><td><a href="#x86_64-pc-cygwin"><code>x86_64-pc-cygwin</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>64-bit x86 Cygwin</td></tr>
<tr><td><a href="#nto-qnx"><code>x86_64-pc-nto-qnx710</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86 64-bit QNX Neutrino 7.1 RTOS with default network stack (io-pkt)</td></tr>
<tr><td><a href="#nto-qnx"><code>x86_64-pc-nto-qnx710_iosock</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86 64-bit QNX Neutrino 7.1 RTOS with new network stack (io-sock)</td></tr>
<tr><td><a href="#nto-qnx"><code>x86_64-pc-nto-qnx800</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86 64-bit QNX Neutrino 8.0 RTOS</td></tr>
<tr><td><a href="#-unikraft-linux-musl"><code>x86_64-unikraft-linux-musl</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>64-bit Unikraft with musl 1.2.5</td></tr>
<tr><td><code>x86_64-unknown-dragonfly</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>64-bit DragonFlyBSD</td></tr>
<tr><td><code>x86_64-unknown-haiku</code></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>64-bit Haiku</td></tr>
<tr><td><a href="#-unknown-hermit"><code>x86_64-unknown-hermit</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86_64 Hermit</td></tr>
<tr><td><a href="#-unknown-helenos"><code>x86_64-unknown-helenos</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86_64 (amd64) HelenOS</td></tr>
<tr><td><a href="#i686-unknown-hurd-gnu-and-x86_64-unknown-hurd-gnu"><code>x86_64-unknown-hurd-gnu</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>64-bit GNU/Hurd</td></tr>
<tr><td><code>x86_64-unknown-l4re-uclibc</code></td><td style="text-align: center">?</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#x86_64-unknown-linux-none"><code>x86_64-unknown-linux-none</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>64-bit Linux with no libc</td></tr>
<tr><td><a href="#-unknown-managarm-mlibc"><code>x86_64-unknown-managarm-mlibc</code></a></td><td style="text-align: center">?</td><td style="text-align: center"></td><td>x86_64 Managarm</td></tr>
<tr><td><a href="#x86_64-unknown-motor"><code>x86_64-unknown-motor</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>x86_64 Motor OS</td></tr>
<tr><td><a href="#-unknown-openbsd"><code>x86_64-unknown-openbsd</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>64-bit OpenBSD</td></tr>
<tr><td><a href="#aarch64-unknown-trusty-and-armv7-unknown-trusty"><code>x86_64-unknown-trusty</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><code>x86_64-uwp-windows-gnu</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#x86_64-uwp-windows-msvc-i686-uwp-windows-msvc-thumbv7a-uwp-windows-msvc-and-aarch64-uwp-windows-msvc"><code>x86_64-uwp-windows-msvc</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#-win7-windows-gnu"><code>x86_64-win7-windows-gnu</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>64-bit Windows 7 support</td></tr>
<tr><td><a href="#-win7-windows-msvc"><code>x86_64-win7-windows-msvc</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>64-bit Windows 7 support</td></tr>
<tr><td><a href="#-wrs-vxworks"><code>x86_64-wrs-vxworks</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td></td></tr>
<tr><td><a href="#x86_64h-apple-darwin"><code>x86_64h-apple-darwin</code></a></td><td style="text-align: center">✓</td><td style="text-align: center">✓</td><td>macOS with late-gen Intel (at least Haswell)</td></tr>
<tr><td><a href="#-espidf"><code>xtensa-esp32-espidf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Xtensa ESP32</td></tr>
<tr><td><a href="#xtensa--none-elf"><code>xtensa-esp32-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Xtensa ESP32</td></tr>
<tr><td><a href="#-espidf"><code>xtensa-esp32s2-espidf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Xtensa ESP32-S2</td></tr>
<tr><td><a href="#xtensa--none-elf"><code>xtensa-esp32s2-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Xtensa ESP32-S2</td></tr>
<tr><td><a href="#-espidf"><code>xtensa-esp32s3-espidf</code></a></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>Xtensa ESP32-S3</td></tr>
<tr><td><a href="#xtensa--none-elf"><code>xtensa-esp32s3-none-elf</code></a></td><td style="text-align: center">*</td><td style="text-align: center"></td><td>Xtensa ESP32-S3</td></tr>
</tbody>
</table>
</div>
<hr>
<ol class="footnote-definition">
<li id="footnote-x86_32-floats-return-ABI">
<p>Due to limitations of the C ABI, floating-point support on <code>i686</code> targets is non-compliant: floating-point return values are passed via an x87 register, so NaN payload bits can be lost. Functions with the default Rust ABI are not affected. See <a href="https://github.com/rust-lang/rust/issues/115567">issue #115567</a>. <a href="#fr-x86_32-floats-return-ABI-1">↩</a> <a href="#fr-x86_32-floats-return-ABI-2">↩2</a> <a href="#fr-x86_32-floats-return-ABI-3">↩3</a> <a href="#fr-x86_32-floats-return-ABI-4">↩4</a> <a href="#fr-x86_32-floats-return-ABI-5">↩5</a> <a href="#fr-x86_32-floats-return-ABI-6">↩6</a> <a href="#fr-x86_32-floats-return-ABI-7">↩7</a> <a href="#fr-x86_32-floats-return-ABI-8">↩8</a> <a href="#fr-x86_32-floats-return-ABI-9">↩9</a> <a href="#fr-x86_32-floats-return-ABI-10">↩10</a> <a href="#fr-x86_32-floats-return-ABI-11">↩11</a> <a href="#fr-x86_32-floats-return-ABI-12">↩12</a> <a href="#fr-x86_32-floats-return-ABI-13">↩13</a> <a href="#fr-x86_32-floats-return-ABI-14">↩14</a> <a href="#fr-x86_32-floats-return-ABI-15">↩15</a> <a href="#fr-x86_32-floats-return-ABI-16">↩16</a> <a href="#fr-x86_32-floats-return-ABI-17">↩17</a> <a href="#fr-x86_32-floats-return-ABI-18">↩18</a> <a href="#fr-x86_32-floats-return-ABI-19">↩19</a></p>
</li>
<li id="footnote-win32-msvc-alignment">
<p>Due to non-standard behavior of MSVC, native C code on this target can cause types with an alignment of more than 4 bytes to be incorrectly aligned to only 4 bytes (this affects, e.g., <code>u64</code> and <code>i64</code>). Rust applies some mitigations to reduce the impact of this issue, but this can still cause unsoundness due to unsafe code that (correctly) assumes that references are always properly aligned. See <a href="https://github.com/rust-lang/rust/issues/112480">issue #112480</a>. <a href="#fr-win32-msvc-alignment-1">↩</a> <a href="#fr-win32-msvc-alignment-2">↩2</a> <a href="#fr-win32-msvc-alignment-3">↩3</a> <a href="#fr-win32-msvc-alignment-4">↩4</a> <a href="#fr-win32-msvc-alignment-5">↩5</a></p>
</li>
<li id="footnote-x86_32-floats-x87">
<p>Floating-point support on <code>i586</code> targets is non-compliant: the <code>x87</code> registers and instructions used for these targets do not provide IEEE-754-compliant behavior, in particular when it comes to rounding and NaN payload bits. See <a href="https://github.com/rust-lang/rust/issues/114479">issue #114479</a>. <a href="#fr-x86_32-floats-x87-1">↩</a> <a href="#fr-x86_32-floats-x87-2">↩2</a> <a href="#fr-x86_32-floats-x87-3">↩3</a> <a href="#fr-x86_32-floats-x87-4">↩4</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="target-tier-policy"><a class="header" href="#target-tier-policy">Target Tier Policy</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#general">General</a></li>
<li><a href="#adding-a-new-target">Adding a new target</a></li>
<li><a href="#tier-3-target-policy">Tier 3 target policy</a></li>
<li><a href="#tier-2-target-policy">Tier 2 target policy</a>
<ul>
<li><a href="#tier-2-with-host-tools-1">Tier 2 with host tools</a></li>
</ul>
</li>
<li><a href="#tier-1-target-policy">Tier 1 target policy</a>
<ul>
<li><a href="#tier-1-with-host-tools-1">Tier 1 with host tools</a></li>
</ul>
</li>
</ul>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<p>Rust provides three tiers of target support:</p>
<ul>
<li>Rust provides no guarantees about tier 3 targets; they exist in the codebase,
but may or may not build.</li>
<li>Rust’s continuous integration checks that tier 2 targets will always build,
but they may or may not pass tests.</li>
<li>Rust’s continuous integration checks that tier 1 targets will always build
and pass tests.</li>
</ul>
<p>Adding a new tier 3 target imposes minimal requirements; we focus primarily on
avoiding disruption to other ongoing Rust development.</p>
<p>Tier 2 and tier 1 targets place work on Rust project developers as a whole, to
avoid breaking the target. The broader Rust community may also feel more
inclined to support higher-tier targets in their crates (though they are not
obligated to do so). Thus, these tiers require commensurate and ongoing efforts
from the maintainers of the target, to demonstrate value and to minimize any
disruptions to ongoing Rust development.</p>
<p>This policy defines the requirements for accepting a proposed target at a given
level of support.</p>
<p>Each tier builds on all the requirements from the previous tier, unless
overridden by a stronger requirement. Targets at tier 2 and tier 1 may also
provide <em>host tools</em> (such as <code>rustc</code> and <code>cargo</code>); each of those tiers
includes a set of supplementary requirements that must be met if supplying host
tools for the target. A target at tier 2 or tier 1 is not required to supply
host tools, but if it does, it must meet the corresponding additional
requirements for host tools.</p>
<p>The policy for each tier also documents the Rust governance teams that must
approve the addition of any target at that tier. Those teams are responsible
for reviewing and evaluating the target, based on these requirements and their
own judgment. Those teams may apply additional requirements, including
subjective requirements, such as to deal with issues not foreseen by this
policy. (Such requirements may subsequently motivate additions to this policy.)</p>
<p>While these criteria attempt to document the policy, that policy still involves
human judgment. Targets must fulfill the spirit of the requirements as well, as
determined by the judgment of the approving teams. Reviewers and team members
evaluating targets and target-specific patches should always use their own best
judgment regarding the quality of work, and the suitability of a target for the
Rust project. Neither this policy nor any decisions made regarding targets
shall create any binding agreement or estoppel by any party.</p>
<p>Before filing an issue or pull request (PR) to introduce or promote a target,
the target should already meet the corresponding tier requirements. This does
not preclude an existing target’s maintainers using issues (on the Rust
repository or otherwise) to track requirements that have not yet been met, as
appropriate; however, before officially proposing the introduction or promotion
of a target, it should meet all of the necessary requirements. A target
proposal must quote the corresponding requirements verbatim and respond to them
as part of explaining how the target meets those requirements. (For the
requirements that simply state that the target or the target developers must
not do something, it suffices to acknowledge the requirement.)</p>
<p>For a list of all supported targets and their corresponding tiers (“tier 3”,
“tier 2”, “tier 2 with host tools”, “tier 1”, or “tier 1 with host tools”), see
<a href="#platform-support">platform support</a>.</p>
<p>Several parts of this policy require providing target-specific documentation.
Such documentation should typically appear in a subdirectory of the
platform-support section of this rustc manual, with a link from the target’s
entry in <a href="#platform-support">platform support</a>. Use
<a href="#target-name-here">TEMPLATE.md</a> as a base, and see other
documentation in that directory for examples.</p>
<p>Note that a target must have already received approval for the next lower tier,
and spent a reasonable amount of time at that tier, before making a proposal
for promotion to the next higher tier; this is true even if a target meets the
requirements for several tiers at once. This policy leaves the precise
interpretation of “reasonable amount of time” up to the approving teams; those
teams may scale the amount of time required based on their confidence in the
target and its demonstrated track record at its current tier. At a minimum,
multiple stable releases of Rust should typically occur between promotions of a
target.</p>
<p>The availability or tier of a target in stable Rust is not a hard stability
guarantee about the future availability or tier of that target. Higher-level
target tiers are an increasing commitment to the support of a target, and we
will take that commitment and potential disruptions into account when
evaluating the potential demotion or removal of a target that has been part of
a stable release. The promotion or demotion of a target will not generally
affect existing stable releases, only current development and future releases.</p>
<p>In this policy, the words “must” and “must not” specify absolute requirements
that a target must meet to qualify for a tier. The words “should” and “should
not” specify requirements that apply in almost all cases, but for which the
approving teams may grant an exception for good reason. The word “may”
indicates something entirely optional, and does not indicate guidance or
recommendations. This language is based on <a href="https://tools.ietf.org/html/rfc2119">IETF RFC
2119</a>.</p>
<h2 id="adding-a-new-target"><a class="header" href="#adding-a-new-target">Adding a new target</a></h2>
<p>New targets typically start as Tier 3 and then can be promoted later.
To propose addition of a new target, open a pull request on <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a>:</p>
<ul>
<li>Copy the <a href="#tier-3-target-policy">Tier 3 target policy</a> to the description
and fill it out, see <a href="https://github.com/rust-lang/rust/pull/94872">example</a>.</li>
<li>Add a new description for the target in <code>src/doc/rustc/src/platform-support</code>
using the <a href="https://github.com/rust-lang/rust/blob/HEAD/src/doc/rustc/src/platform-support/TEMPLATE.md">template</a>.</li>
<li>Add the target to the <a href="https://github.com/rust-lang/rust/blob/HEAD/src/doc/rustc/src/SUMMARY.md">SUMMARY.md</a> (allows wildcards) and
<a href="https://github.com/rust-lang/rust/blob/HEAD/src/doc/rustc/src/platform-support.md">platform-support.md</a> (must name all targets verbatim).
Link to the created description page.</li>
<li>Ensure the pull request is assigned to a member of the <a href="https://www.rust-lang.org/governance/teams/compiler">Rust compiler team</a> by commenting:
<pre><code class="language-text">r? compiler
</code></pre>
</li>
</ul>
<p>See also the documentation in the <code>rustc-dev-guide</code> on <a href="https://rustc-dev-guide.rust-lang.org/building/new-target.html">adding a new target to
<code>rustc</code></a>.</p>
<p>Note that adding a new target that wants to support <code>std</code> would transitively
require <code>cc</code> and <code>libc</code> support. However, these would like to know about the
target from <code>rustc</code> as well. To break this cycle, you are strongly encouraged
to add a <em>minimal</em> <code>#![no_core]</code> target spec first to teach <code>rustc</code> about the
target’s existence, and add <code>std</code> support as a follow-up once you’ve added
support for the target in <code>cc</code> and <code>libc</code>.</p>
<h2 id="tier-3-target-policy"><a class="header" href="#tier-3-target-policy">Tier 3 target policy</a></h2>
<p>At this tier, the Rust project provides no official support for a target, so we
place minimal requirements on the introduction of targets.</p>
<p>A proposed new tier 3 target must be reviewed and approved by a member of the
compiler team based on these requirements. The reviewer may choose to gauge
broader compiler team consensus via a <a href="https://forge.rust-lang.org/compiler/proposals-and-stabilization.html#how-do-i-submit-an-mcp">Major Change Proposal (MCP)</a>.</p>
<p>A proposed target or target-specific patch that substantially changes code
shared with other targets (not just target-specific code) must be reviewed and
approved by the appropriate team for that shared code before acceptance.</p>
<ul>
<li>A tier 3 target must have a designated developer or developers (the “target
maintainers”) on record to be CCed when issues arise regarding the target.
(The mechanism to track and CC such developers may evolve over time.)</li>
<li>Targets must use naming consistent with any existing targets; for instance, a
target for the same CPU or OS as an existing Rust target should use the same
name for that CPU or OS. Targets should normally use the same names and
naming conventions as used elsewhere in the broader ecosystem beyond Rust
(such as in other toolchains), unless they have a very good reason to
diverge. Changing the name of a target can be highly disruptive, especially
once the target reaches a higher tier, so getting the name right is important
even for a tier 3 target.
<ul>
<li>Target names should not introduce undue confusion or ambiguity unless
absolutely necessary to maintain ecosystem compatibility. For example, if
the name of the target makes people extremely likely to form incorrect
beliefs about what it targets, the name should be changed or augmented to
disambiguate it.</li>
<li>If possible, use only letters, numbers, dashes and underscores for the name.
Periods (<code>.</code>) are known to cause issues in Cargo.</li>
</ul>
</li>
<li>Tier 3 targets may have unusual requirements to build or use, but must not
create legal issues or impose onerous legal terms for the Rust project or for
Rust developers or users.
<ul>
<li>The target must not introduce license incompatibilities.</li>
<li>Anything added to the Rust repository must be under the standard Rust
license (<code>MIT OR Apache-2.0</code>).</li>
<li>The target must not cause the Rust tools or libraries built for any other
host (even when supporting cross-compilation to the target) to depend
on any new dependency less permissive than the Rust licensing policy. This
applies whether the dependency is a Rust crate that would require adding
new license exceptions (as specified by the <code>tidy</code> tool in the
rust-lang/rust repository), or whether the dependency is a native library
or binary. In other words, the introduction of the target must not cause a
user installing or running a version of Rust or the Rust tools to be
subject to any new license requirements.</li>
<li>Compiling, linking, and emitting functional binaries, libraries, or other
code for the target (whether hosted on the target itself or cross-compiling
from another target) must not depend on proprietary (non-FOSS) libraries.
Host tools built for the target itself may depend on the ordinary runtime
libraries supplied by the platform and commonly used by other applications
built for the target, but those libraries must not be required for code
generation for the target; cross-compilation to the target must not require
such libraries at all. For instance, <code>rustc</code> built for the target may
depend on a common proprietary C runtime library or console output library,
but must not depend on a proprietary code generation library or code
optimization library. Rust’s license permits such combinations, but the
Rust project has no interest in maintaining such combinations within the
scope of Rust itself, even at tier 3.</li>
<li>“onerous” here is an intentionally subjective term. At a minimum, “onerous”
legal/licensing terms include but are <em>not</em> limited to: non-disclosure
requirements, non-compete requirements, contributor license agreements
(CLAs) or equivalent, “non-commercial”/“research-only”/etc terms,
requirements conditional on the employer or employment of any particular
Rust developers, revocable terms, any requirements that create liability
for the Rust project or its developers or users, or any requirements that
adversely affect the livelihood or prospects of the Rust project or its
developers or users.</li>
</ul>
</li>
<li>Neither this policy nor any decisions made regarding targets shall create any
binding agreement or estoppel by any party. If any member of an approving
Rust team serves as one of the maintainers of a target, or has any legal or
employment requirement (explicit or implicit) that might affect their
decisions regarding a target, they must recuse themselves from any approval
decisions regarding the target’s tier status, though they may otherwise
participate in discussions.
<ul>
<li>This requirement does not prevent part or all of this policy from being
cited in an explicit contract or work agreement (e.g. to implement or
maintain support for a target). This requirement exists to ensure that a
developer or team responsible for reviewing and approving a target does not
face any legal threats or obligations that would prevent them from freely
exercising their judgment in such approval, even if such judgment involves
subjective matters or goes beyond the letter of these requirements.</li>
</ul>
</li>
<li>Tier 3 targets should attempt to implement as much of the standard libraries
as possible and appropriate (<code>core</code> for most targets, <code>alloc</code> for targets
that can support dynamic memory allocation, <code>std</code> for targets with an
operating system or equivalent layer of system-provided functionality), but
may leave some code unimplemented (either unavailable or stubbed out as
appropriate), whether because the target makes it impossible to implement or
challenging to implement. The authors of pull requests are not obligated to
avoid calling any portions of the standard library on the basis of a tier 3
target not implementing those portions.</li>
<li>The target must provide documentation for the Rust community explaining how
to build for the target, using cross-compilation if possible. If the target
supports running binaries, or running tests (even if they do not pass), the
documentation must explain how to run such binaries or tests for the target,
using emulation if possible or dedicated hardware if necessary.</li>
<li>Tier 3 targets must not impose burden on the authors of pull requests, or
other developers in the community, to maintain the target. In particular,
do not post comments (automated or manual) on a PR that derail or suggest a
block on the PR based on a tier 3 target. Do not send automated messages or
notifications (via any medium, including via <code>@</code>) to a PR author or others
involved with a PR regarding a tier 3 target, unless they have opted into
such messages.
<ul>
<li>Backlinks such as those generated by the issue/PR tracker when linking to
an issue or PR are not considered a violation of this policy, within
reason. However, such messages (even on a separate repository) must not
generate notifications to anyone involved with a PR who has not requested
such notifications.</li>
</ul>
</li>
<li>Patches adding or updating tier 3 targets must not break any existing tier 2
or tier 1 target, and must not knowingly break another tier 3 target without
approval of either the compiler team or the maintainers of the other tier 3
target.
<ul>
<li>In particular, this may come up when working on closely related targets,
such as variations of the same architecture with different features. Avoid
introducing unconditional uses of features that another variation of the
target may not have; use conditional compilation or runtime detection, as
appropriate, to let each target run code supported by that target.</li>
</ul>
</li>
<li>Tier 3 targets must be able to produce assembly using at least one of
rustc’s supported backends from any host target. (Having support in a fork
of the backend is not sufficient, it must be upstream.)</li>
</ul>
<p>If a tier 3 target stops meeting these requirements, or the target maintainers
no longer have interest or time, or the target shows no signs of activity and
has not built for some time, or removing the target would improve the quality
of the Rust codebase, we may post a PR to remove it; any such PR will be CCed
to the target maintainers (and potentially other people who have previously
worked on the target), to check potential interest in improving the situation.</p>
<h2 id="tier-2-target-policy"><a class="header" href="#tier-2-target-policy">Tier 2 target policy</a></h2>
<p>At this tier, the Rust project guarantees that a target builds, and will reject
patches that fail to build on a target. Thus, we place requirements that ensure
the target will not block forward progress of the Rust project.</p>
<p>A proposed new tier 2 target must be reviewed and approved by the compiler team
based on these requirements. Such review and approval may occur via a <a href="https://forge.rust-lang.org/compiler/proposals-and-stabilization.html#how-do-i-submit-an-mcp">Major
Change Proposal (MCP)</a>.</p>
<p>In addition, the infrastructure team must approve the integration of the target
into Continuous Integration (CI), and the tier 2 CI-related requirements. This
review and approval may take place in a PR adding the target to CI, or simply
by an infrastructure team member reporting the outcome of a team discussion.</p>
<ul>
<li>A tier 2 target must have value to people other than its maintainers. (It may
still be a niche target, but it must not be exclusively useful for an
inherently closed group.)</li>
<li>A tier 2 target must have a designated team of developers (the “target
maintainers”) available to consult on target-specific build-breaking issues,
or if necessary to develop target-specific language or library implementation
details. This team must have at least 2 developers.
<ul>
<li>The target maintainers should not only fix target-specific issues, but
should use any such issue as an opportunity to educate the Rust community
about portability to their target, and enhance documentation of the target.</li>
</ul>
</li>
<li>The target must not place undue burden on Rust developers not specifically
concerned with that target. Rust developers are expected to not gratuitously
break a tier 2 target, but are not expected to become experts in every tier 2
target, and are not expected to provide target-specific implementations for
every tier 2 target.</li>
<li>The target must provide documentation for the Rust community explaining how
to build for the target using cross-compilation, and explaining how to run
tests for the target. If at all possible, this documentation should show how
to run Rust programs and tests for the target using emulation, to allow
anyone to do so. If the target cannot be feasibly emulated, the documentation
should explain how to obtain and work with physical hardware, cloud systems,
or equivalent.</li>
<li>The target must document its baseline expectations for the features or
versions of CPUs, operating systems, libraries, runtime environments, and
similar.</li>
<li>If introducing a new tier 2 or higher target that is identical to an existing
Rust target except for the baseline expectations for the features or versions
of CPUs, operating systems, libraries, runtime environments, and similar,
then the proposed target must document to the satisfaction of the approving
teams why the specific difference in baseline expectations provides
sufficient value to justify a separate target.
<ul>
<li>Note that in some cases, based on the usage of existing targets within the
Rust community, Rust developers or a target’s maintainers may wish to
modify the baseline expectations of a target, or split an existing target
into multiple targets with different baseline expectations. A proposal to
do so will be treated similarly to the analogous promotion, demotion, or
removal of a target, according to this policy, with the same team approvals
required.
<ul>
<li>For instance, if an OS version has become obsolete and unsupported, a
target for that OS may raise its baseline expectations for OS version
(treated as though removing a target corresponding to the older
versions), or a target for that OS may split out support for older OS
versions into a lower-tier target (treated as though demoting a target
corresponding to the older versions, and requiring justification for a
new target at a lower tier for the older OS versions).</li>
</ul>
</li>
</ul>
</li>
<li>Tier 2 targets must not leave any significant portions of <code>core</code> or the
standard library unimplemented or stubbed out, unless they cannot possibly be
supported on the target.
<ul>
<li>The right approach to handling a missing feature from a target may depend
on whether the target seems likely to develop the feature in the future. In
some cases, a target may be co-developed along with Rust support, and Rust
may gain new features on the target as that target gains the capabilities
to support those features.</li>
<li>As an exception, a target identical to an existing tier 1 target except for
lower baseline expectations for the OS, CPU, or similar, may propose to
qualify as tier 2 (but not higher) without support for <code>std</code> if the target
will primarily be used in <code>no_std</code> applications, to reduce the support
burden for the standard library. In this case, evaluation of the proposed
target’s value will take this limitation into account.</li>
</ul>
</li>
<li>The code generation backend for the target should not have deficiencies that
invalidate Rust safety properties, as evaluated by the Rust compiler team.
(This requirement does not apply to arbitrary security enhancements or
mitigations provided by code generation backends, only to those properties
needed to ensure safe Rust code cannot cause undefined behavior or other
unsoundness.) If this requirement does not hold, the target must clearly and
prominently document any such limitations as part of the target’s entry in
the target tier list, and ideally also via a failing test in the testsuite.
The Rust compiler team must be satisfied with the balance between these
limitations and the difficulty of implementing the necessary features.
<ul>
<li>For example, if Rust relies on a specific code generation feature to ensure
that safe code cannot overflow the stack, the code generation for the
target should support that feature.</li>
<li>If the Rust compiler introduces new safety properties (such as via new
capabilities of a compiler backend), the Rust compiler team will determine
if they consider those new safety properties a best-effort improvement for
specific targets, or a required property for all Rust targets. In the
latter case, the compiler team may require the maintainers of existing
targets to either implement and confirm support for the property or update
the target tier list with documentation of the missing property.</li>
</ul>
</li>
<li>If the target supports C code, and the target has an interoperable calling
convention for C code, the Rust target must support that C calling convention
for the platform via <code>extern "C"</code>. The C calling convention does not need to
be the default Rust calling convention for the target, however.</li>
<li>The target must build reliably in CI, for all components that Rust’s CI
considers mandatory.</li>
<li>The approving teams may additionally require that a subset of tests pass in
CI, such as enough to build a functional “hello world” program, <code>./x.py test --no-run</code>, or equivalent “smoke tests”. In particular, this requirement may
apply if the target builds host tools, or if the tests in question provide
substantial value via early detection of critical problems.</li>
<li>Building the target in CI must not take substantially longer than the current
slowest target in CI, and should not substantially raise the maintenance
burden of the CI infrastructure. This requirement is subjective, to be
evaluated by the infrastructure team, and will take the community importance
of the target into account.</li>
<li>Tier 2 targets should, if at all possible, support cross-compiling. Tier 2
targets should not require using the target as the host for builds, even if
the target supports host tools.</li>
<li>In addition to the legal requirements for all targets (specified in the tier
3 requirements), because a tier 2 target typically involves the Rust project
building and supplying various compiled binaries, incorporating the target
and redistributing any resulting compiled binaries (e.g. built libraries,
host tools if any) must not impose any onerous license requirements on any
members of the Rust project, including infrastructure team members and those
operating CI systems. This is a subjective requirement, to be evaluated by
the approving teams.
<ul>
<li>As an exception to this, if the target’s primary purpose is to build
components for a Free and Open Source Software (FOSS) project licensed
under “copyleft” terms (terms which require licensing other code under
compatible FOSS terms), such as kernel modules or plugins, then the
standard libraries for the target may potentially be subject to copyleft
terms, as long as such terms are satisfied by Rust’s existing practices of
providing full corresponding source code. Note that anything added to the
Rust repository itself must still use Rust’s standard license terms.</li>
</ul>
</li>
<li>Tier 2 targets must not impose burden on the authors of pull requests, or
other developers in the community, to ensure that tests pass for the target.
In particular, do not post comments (automated or manual) on a PR that derail
or suggest a block on the PR based on tests failing for the target. Do not
send automated messages or notifications (via any medium, including via <code>@</code>)
to a PR author or others involved with a PR regarding the PR breaking tests
on a tier 2 target, unless they have opted into such messages.
<ul>
<li>Backlinks such as those generated by the issue/PR tracker when linking to
an issue or PR are not considered a violation of this policy, within
reason. However, such messages (even on a separate repository) must not
generate notifications to anyone involved with a PR who has not requested
such notifications.</li>
</ul>
</li>
<li>The target maintainers should regularly run the testsuite for the target, and
should fix any test failures in a reasonably timely fashion.</li>
<li>All requirements for tier 3 apply.</li>
</ul>
<p>A tier 2 target may be demoted or removed if it no longer meets these
requirements. Any proposal for demotion or removal will be CCed to the target
maintainers, and will be communicated widely to the Rust community before being
dropped from a stable release. (The amount of time between such communication
and the next stable release may depend on the nature and severity of the failed
requirement, the timing of its discovery, whether the target has been part of a
stable release yet, and whether the demotion or removal can be a planned and
scheduled action.)</p>
<p>In some circumstances, especially if the target maintainers do not respond in a
timely fashion, Rust teams may land pull requests that temporarily disable some
targets in the nightly compiler, in order to implement a feature not yet
supported by those targets. (As an example, this happened when introducing the
128-bit types <code>u128</code> and <code>i128</code>.) Such a pull request will include notification
and coordination with the maintainers of such targets, and will ideally happen
towards the beginning of a new development cycle to give maintainers time to
update their targets. The maintainers of such targets will then be expected to
implement the corresponding target-specific support in order to re-enable the
target. If the maintainers of such targets cannot provide such support in time
for the next stable release, this may result in demoting or removing the
targets.</p>
<h3 id="tier-2-with-host-tools-1"><a class="header" href="#tier-2-with-host-tools-1">Tier 2 with host tools</a></h3>
<p>Some tier 2 targets may additionally have binaries built to run on them as a
host (such as <code>rustc</code> and <code>cargo</code>). This allows the target to be used as a
development platform, not just a compilation target.</p>
<p>A proposed new tier 2 target with host tools must be reviewed and approved by
the compiler team based on these requirements. Such review and approval may
occur via a <a href="https://forge.rust-lang.org/compiler/proposals-and-stabilization.html#how-do-i-submit-an-mcp">Major Change Proposal (MCP)</a>.</p>
<p>In addition, the infrastructure team must approve the integration of the
target’s host tools into Continuous Integration (CI), and the CI-related
requirements for host tools. This review and approval may take place in a PR
adding the target’s host tools to CI, or simply by an infrastructure team
member reporting the outcome of a team discussion.</p>
<ul>
<li>Depending on the target, its capabilities, its performance, and the
likelihood of use for any given tool, the host tools provided for a tier 2
target may include only <code>rustc</code> and <code>cargo</code>, or may include additional tools
such as <code>clippy</code> and <code>rustfmt</code>.</li>
<li>Approval of host tools will take into account the additional time required to
build the host tools, and the substantial additional storage required for the
host tools.</li>
<li>The host tools must have direct value to people other than the target’s
maintainers. (It may still be a niche target, but the host tools must not be
exclusively useful for an inherently closed group.) This requirement will be
evaluated independently from the corresponding tier 2 requirement.
<ul>
<li>The requirement to provide “direct value” means that it does not suffice to
argue that having host tools will help the target’s maintainers more easily
provide the target to others. The tools themselves must provide value to
others.</li>
</ul>
</li>
<li>There must be a reasonable expectation that the host tools will be used, for
purposes other than to prove that they can be used.</li>
<li>The host tools must build and run reliably in CI (for all components that
Rust’s CI considers mandatory), though they may or may not pass tests.</li>
<li>Building host tools for the target must not take substantially longer than
building host tools for other targets, and should not substantially raise the
maintenance burden of the CI infrastructure.</li>
<li>The host tools must provide a substantively similar experience as on other
targets, subject to reasonable target limitations.
<ul>
<li>Adding a substantively different interface to an existing tool, or a
target-specific interface to the functionality of an existing tool,
requires design and implementation approval (e.g. RFC/MCP) from the
appropriate approving teams for that tool.
<ul>
<li>Such an interface should have a design that could potentially work for
other targets with similar properties.</li>
<li>This should happen separately from the review and approval of the target,
to simplify the target review and approval processes, and to simplify the
review and approval processes for the proposed new interface.</li>
</ul>
</li>
<li>By way of example, a target that runs within a sandbox may need to modify
the handling of files, tool invocation, and similar to meet the
expectations and conventions of the sandbox, but must not introduce a
separate “sandboxed compilation” interface separate from the CLI interface
without going through the normal approval process for such an interface.
Such an interface should take into account potential other targets with
similar sandboxes.</li>
</ul>
</li>
<li>If the host tools for the platform would normally be expected to be signed or
equivalent (e.g. if running unsigned binaries or similar involves a
“developer mode” or an additional prompt), it must be possible for the Rust
project’s automated builds to apply the appropriate signature process,
without any manual intervention by either Rust developers, target
maintainers, or a third party. This process must meet the approval of the
infrastructure team.
<ul>
<li>This process may require one-time or semi-regular manual steps by the
infrastructure team, such as registration or renewal of a signing key. Any
such manual process must meet the approval of the infrastructure team.</li>
<li>This process may require the execution of a legal agreement with the
signature provider. Such a legal agreement may be revocable, and may
potentially require a nominal fee, but must not be otherwise onerous. Any
such legal agreement must meet the approval of the infrastructure team.
(The infrastructure team is not expected or required to sign binding legal
agreements on behalf of the Rust project; this review and approval exists
to ensure no terms are onerous or cause problems for infrastructure,
especially if such terms may impose requirements or obligations on people
who have access to target-specific infrastructure.)</li>
<li>Changes to this process, or to any legal agreements involved, may
cause a target to stop meeting this requirement.</li>
<li>This process involved must be available under substantially similar
non-onerous terms to the general public. Making it available exclusively to
the Rust project does not suffice.</li>
<li>This requirement exists to ensure that Rust builds, including nightly
builds, can meet the necessary requirements to allow users to smoothly run
the host tools.</li>
</ul>
</li>
<li>Providing host tools does not exempt a target from requirements to support
cross-compilation if at all possible.</li>
<li>All requirements for tier 2 apply.</li>
</ul>
<p>A target may be promoted directly from tier 3 to tier 2 with host tools if it
meets all the necessary requirements, but doing so may introduce substantial
additional complexity. If in doubt, the target should qualify for tier 2
without host tools first.</p>
<h2 id="tier-1-target-policy"><a class="header" href="#tier-1-target-policy">Tier 1 target policy</a></h2>
<p>At this tier, the Rust project guarantees that a target builds and passes all
tests, and will reject patches that fail to build or pass the testsuite on a
target. We hold tier 1 targets to our highest standard of requirements.</p>
<p>A proposed new tier 1 target must be reviewed and approved by the compiler team
based on these requirements. In addition, the infra team must approve the
viability of supporting the target. For a tier 1 target, this will
typically take place via a full RFC proposing the target, to be jointly
reviewed and approved by the compiler team and infra team.</p>
<p>In addition, the infrastructure team must approve the integration of the target
into Continuous Integration (CI), and the tier 1 CI-related requirements. This
review and approval may take place in a PR adding the target to CI, by an
infrastructure team member reporting the outcome of a team discussion, or by
including the infrastructure team in the RFC proposing the target.</p>
<ul>
<li>Tier 1 targets must have substantial, widespread interest within the
developer community, and must serve the ongoing needs of multiple production
users of Rust across multiple organizations or projects. These requirements
are subjective, and determined by consensus of the approving teams. A tier 1
target may be demoted or removed if it becomes obsolete or no longer meets
this requirement.</li>
<li>The target maintainer team must include at least 3 developers.</li>
<li>The target must build and pass tests reliably in CI, for all components that
Rust’s CI considers mandatory.
<ul>
<li>The target must not disable an excessive number of tests or pieces of tests
in the testsuite in order to do so. This is a subjective requirement.</li>
<li>If the target does not have host tools support, or if the target has low
performance, the infrastructure team may choose to have CI cross-compile
the testsuite from another platform, and then run the compiled tests
either natively or via accurate emulation. However, the approving teams may
take such performance considerations into account when determining the
viability of the target or of its host tools.</li>
</ul>
</li>
<li>The target must provide as much of the Rust standard library as is feasible
and appropriate to provide. For instance, if the target can support dynamic
memory allocation, it must provide an implementation of <code>alloc</code> and the
associated data structures.</li>
<li>Building the target and running the testsuite for the target must not take
substantially longer than other targets, and should not substantially raise
the maintenance burden of the CI infrastructure.
<ul>
<li>In particular, if building the target takes a reasonable amount of time,
but the target cannot run the testsuite in a timely fashion due to low
performance of either native code or accurate emulation, that alone may
prevent the target from qualifying as tier 1.</li>
</ul>
</li>
<li>If running the testsuite requires additional infrastructure (such as physical
systems running the target), the target maintainers must arrange to provide
such resources to the Rust project, to the satisfaction and approval of the
Rust infrastructure team.
<ul>
<li>Such resources may be provided via cloud systems, via emulation, or via
physical hardware.</li>
<li>If the target requires the use of emulation to meet any of the tier
requirements, the approving teams for those requirements must have high
confidence in the accuracy of the emulation, such that discrepancies
between emulation and native operation that affect test results will
constitute a high-priority bug in either the emulation or the
implementation of the target.</li>
<li>If it is not possible to run the target via emulation, these resources must
additionally be sufficient for the Rust infrastructure team to make them
available for access by Rust team members, for the purposes of development
and testing. (Note that the responsibility for doing target-specific
development to keep the target well maintained remains with the target
maintainers. This requirement ensures that it is possible for other
Rust developers to test the target, but does not obligate other Rust
developers to make target-specific fixes.)</li>
<li>Resources provided for CI and similar infrastructure must be available for
continuous exclusive use by the Rust project. Resources provided
for access by Rust team members for development and testing must be
available on an exclusive basis when in use, but need not be available on a
continuous basis when not in use.</li>
</ul>
</li>
<li>Tier 1 targets must not have a hard requirement for signed, verified, or
otherwise “approved” binaries. Developers must be able to build, run, and
test binaries for the target on systems they control, or provide such
binaries for others to run. (Doing so may require enabling some appropriate
“developer mode” on such systems, but must not require the payment of any
additional fee or other consideration, or agreement to any onerous legal
agreements.)
<ul>
<li>The Rust project may decide to supply appropriately signed binaries if
doing so provides a smoother experience for developers using the target,
and a tier 2 target with host tools already requires providing appropriate
mechanisms that enable our infrastructure to provide such signed binaries.
However, this additional tier 1 requirement ensures that Rust developers
can develop and test Rust software for the target (including Rust itself),
and that development or testing for the target is not limited.</li>
</ul>
</li>
<li>All requirements for tier 2 apply.</li>
</ul>
<p>A tier 1 target may be demoted if it no longer meets these requirements but
still meets the requirements for a lower tier. Any proposal for demotion of a
tier 1 target requires a full RFC process, with approval by the compiler and
infra teams. Any such proposal will be communicated widely to the Rust
community, both when initially proposed and before being dropped from a stable
release. A tier 1 target is highly unlikely to be directly removed without
first being demoted to tier 2 or tier 3. (The amount of time between such
communication and the next stable release may depend on the nature and severity
of the failed requirement, the timing of its discovery, whether the target has
been part of a stable release yet, and whether the demotion or removal can be a
planned and scheduled action.)</p>
<p>Raising the baseline expectations of a tier 1 target (such as the minimum CPU
features or OS version required) requires the approval of the compiler and
infra teams, and should be widely communicated as well, but does not
necessarily require a full RFC.</p>
<h3 id="tier-1-with-host-tools-1"><a class="header" href="#tier-1-with-host-tools-1">Tier 1 with host tools</a></h3>
<p>Some tier 1 targets may additionally have binaries built to run on them as a
host (such as <code>rustc</code> and <code>cargo</code>). This allows the target to be used as a
development platform, not just a compilation target.</p>
<p>A proposed new tier 1 target with host tools must be reviewed and approved by
the compiler team based on these requirements. In addition, the infra team
must approve the viability of supporting host tools for the target.
For a tier 1 target, this will typically take place via a full RFC proposing
the target, to be jointly reviewed and approved by the compiler team and
infra team.</p>
<p>In addition, the infrastructure team must approve the integration of the
target’s host tools into Continuous Integration (CI), and the CI-related
requirements for host tools. This review and approval may take place in a PR
adding the target’s host tools to CI, by an infrastructure team member
reporting the outcome of a team discussion, or by including the infrastructure
team in the RFC proposing the target.</p>
<ul>
<li>Tier 1 targets with host tools should typically include all of the additional
tools such as <code>clippy</code> and <code>rustfmt</code>, unless there is a target-specific
reason why a tool cannot possibly make sense for the target.
<ul>
<li>Unlike with tier 2, for tier 1 we will not exclude specific tools on the
sole basis of them being less likely to be used; rather, we’ll take that
into account when considering whether the target should be at tier 1 with
host tools. In general, on any tier 1 target with host tools, people
should be able to expect to find and install all the same components that
they would for any other tier 1 target with host tools.</li>
</ul>
</li>
<li>Approval of host tools will take into account the additional time required to
build the host tools, and the substantial additional storage required for the
host tools.</li>
<li>Host tools for the target must have substantial, widespread interest within
the developer community, and must serve the ongoing needs of multiple
production users of Rust across multiple organizations or projects. These
requirements are subjective, and determined by consensus of the approving
teams. This requirement will be evaluated independently from the
corresponding tier 1 requirement; it is possible for a target to have
sufficient interest for cross-compilation, but not have sufficient interest
for native compilation. The host tools may be dropped if they no longer meet
this requirement, even if the target otherwise qualifies as tier 1.</li>
<li>The host tools must build, run, and pass tests reliably in CI, for all
components that Rust’s CI considers mandatory.
<ul>
<li>The target must not disable an excessive number of tests or pieces of tests
in the testsuite in order to do so. This is a subjective requirement.</li>
</ul>
</li>
<li>Building the host tools and running the testsuite for the host tools must not
take substantially longer than other targets, and should not substantially raise
the maintenance burden of the CI infrastructure.
<ul>
<li>In particular, if building the target’s host tools takes a reasonable
amount of time, but the target cannot run the testsuite in a timely fashion
due to low performance of either native code or accurate emulation, that
alone may prevent the target from qualifying as tier 1 with host tools.</li>
</ul>
</li>
<li>Providing host tools does not exempt a target from requirements to support
cross-compilation if at all possible.</li>
<li>All requirements for tier 2 targets with host tools apply.</li>
<li>All requirements for tier 1 apply.</li>
</ul>
<p>A target seeking promotion to tier 1 with host tools should typically either be
tier 2 with host tools or tier 1 without host tools, to reduce the number of
requirements to simultaneously review and approve.</p>
<p>In addition to the general process for demoting a tier 1 target, a tier 1
target with host tools may be demoted (including having its host tools dropped,
or being demoted to tier 2 with host tools) if it no longer meets these
requirements but still meets the requirements for a lower tier. Any proposal
for demotion of a tier 1 target (with or without host tools) requires a full
RFC process, with approval by the compiler and infra teams. Any such proposal
will be communicated widely to the Rust community, both when initially proposed
and before being dropped from a stable release.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="target-name-here"><a class="header" href="#target-name-here"><code>target-name-here</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>One-sentence description of the target (e.g. CPU, OS)</p>
<h2 id="target-maintainers"><a class="header" href="#target-maintainers">Target maintainers</a></h2>
<p><a href="https://github.com/Ghost">@Ghost</a>
<a href="https://github.com/octocat">@octocat</a></p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Does the target support host tools, or only cross-compilation? Does the target
support std, or alloc (either with a default allocator, or if the user supplies
an allocator)?</p>
<p>Document the expectations of binaries built for the target. Do they assume
specific minimum features beyond the baseline of the CPU/environment/etc? What
version of the OS or environment do they expect?</p>
<p>Are there notable <code>#[target_feature(...)]</code> or <code>-C target-feature=</code> values that
programs may wish to use?</p>
<p>What calling convention does <code>extern "C"</code> use on the target?</p>
<p>What format do binaries use by default? ELF, PE, something else?</p>
<h2 id="building-the-target"><a class="header" href="#building-the-target">Building the target</a></h2>
<p>If Rust doesn’t build the target by default, how can users build it? Can users
just add it to the <code>target</code> list in <code>bootstrap.toml</code>?</p>
<h2 id="building-rust-programs"><a class="header" href="#building-rust-programs">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Does the target support running binaries, or do binaries have varying
expectations that prevent having a standard way to run them? If users can run
binaries, can they do so in some common emulator, or do they need native
hardware? Does the target support running the Rust testsuite?</p>
<h2 id="cross-compilation-toolchains-and-c-code"><a class="header" href="#cross-compilation-toolchains-and-c-code">Cross-compilation toolchains and C code</a></h2>
<p>Does the target support C code? If so, what toolchain target should users use
to build compatible C code? (This may match the target triple, or it may be a
toolchain for a different target triple, potentially with specific options or
caveats.)</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm64ec-pc-windows-msvc"><a class="header" href="#arm64ec-pc-windows-msvc"><code>arm64ec-pc-windows-msvc</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>Arm64EC (“Emulation Compatible”) for mixed architecture (AArch64 and x86_64)
applications on AArch64 Windows 11. See <a href="https://learn.microsoft.com/en-us/windows/arm/arm64ec">https://learn.microsoft.com/en-us/windows/arm/arm64ec</a>.</p>
<h2 id="target-maintainers-1"><a class="header" href="#target-maintainers-1">Target maintainers</a></h2>
<p><a href="https://github.com/dpaoliello">@dpaoliello</a></p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<p>Builds Arm64EC static and dynamic libraries and executables which can be run on
AArch64 Windows 11 devices. Arm64EC static libraries can also be linked into
Arm64X dynamic libraries and executables.</p>
<p>Only supported backend is LLVM 18 or above:</p>
<ul>
<li>18.1.0 added initial support for Arm64EC.</li>
<li>18.1.2 fixed import library generation (required for <code>raw-dylib</code> support).</li>
<li>18.1.4 fixed linking issue for some intrinsics implemented in
<code>compiler_builtins</code>.</li>
</ul>
<p>Visual Studio 2022 (or above) with the “ARM64/ARM64EC built tools” component and
the Windows 11 SDK are required.</p>
<h3 id="reusing-code-from-other-architectures---x86_64-or-aarch64"><a class="header" href="#reusing-code-from-other-architectures---x86_64-or-aarch64">Reusing code from other architectures - x86_64 or AArch64?</a></h3>
<p>Arm64EC uses <code>arm64ec</code> as its <code>target_arch</code>, but it is possible to reuse
existing architecture-specific code in most cases. The best mental model for
deciding which architecture to reuse is to is to think of Arm64EC as an x86_64
process that happens to use the AArch64 instruction set (with some caveats) and
has a completely custom ABI.</p>
<p>To put this in practice:</p>
<ul>
<li>Arm64EC interacts with the operating system, other processes and other DLLs as
x86_64.
<ul>
<li>For example, <a href="https://github.com/rust-lang/backtrace-rs/commit/ef39a7d7da58b4cae8c8f3fc67a8300fd8d2d0d9">in <code>backtrace</code></a>
we use the x86_64 versions of <code>CONTEXT</code> and <code>RtlVirtualUnwind</code>.</li>
<li>If you are configuring a search path to find DLLs (e.g., to load plugins or
addons into your application), you should use the same path as the x86_64
version of your application, not the AArch64 path (since Arm64EC (i.e.,
x86_64) processes cannot load native AArch64 DLLs).</li>
</ul>
</li>
<li>Arm64EC uses AArch64 intrinsics.
<ul>
<li>For example, <a href="https://github.com/rust-lang/portable-simd/commit/ca4033f49b1f6019561b8b161b4097b4a07f2e1b">https://github.com/rust-lang/portable-simd/commit/ca4033f49b1f6019561b8b161b4097b4a07f2e1b</a>
and <a href="https://github.com/rust-lang/stdarch/commit/166ef7ba22b6a1d908d4b29a36e68ceca324808a">https://github.com/rust-lang/stdarch/commit/166ef7ba22b6a1d908d4b29a36e68ceca324808a</a>.</li>
</ul>
</li>
<li>Assembly for AArch64 might be reusable for Arm64EC, but there are many
caveats. For full details see <a href="https://learn.microsoft.com/en-us/windows/arm/arm64ec-abi">Microsoft’s documentation on the Arm64EC ABI</a>
but in brief:
<ul>
<li>Arm64EC uses a subset of AArch64 registers.</li>
<li>Arm64EC uses a different name mangling scheme than AArch64.</li>
<li>Arm64EC requires entry and exit thunks be generated for some functions.</li>
<li>Indirect calls must be done via a call checker.</li>
<li>Control Flow Guard and stack checks use different functions than AArch64.</li>
</ul>
</li>
</ul>
<h2 id="building-the-target-1"><a class="header" href="#building-the-target-1">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code>
list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["arm64ec-pc-windows-msvc"]
</code></pre>
<h2 id="building-rust-programs-1"><a class="header" href="#building-rust-programs-1">Building Rust programs</a></h2>
<p>These targets are distributed through <code>rustup</code>, and otherwise require no
special configuration.</p>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>Tests can be run on AArch64 Windows 11 devices.</p>
<h2 id="cross-compilation-toolchains-and-c-code-1"><a class="header" href="#cross-compilation-toolchains-and-c-code-1">Cross-compilation toolchains and C code</a></h2>
<p>C code can be built using the Arm64-targeting MSVC or Clang toolchain.</p>
<p>To compile:</p>
<pre><code class="language-bash">cl /arm64EC /c ...
</code></pre>
<p>To link:</p>
<pre><code class="language-bash">link /MACHINE:ARM64EC ...
</code></pre>
<p>Further reading: <a href="https://learn.microsoft.com/en-us/windows/arm/arm64ec-build">https://learn.microsoft.com/en-us/windows/arm/arm64ec-build</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-apple-darwin"><a class="header" href="#-apple-darwin"><code>*-apple-darwin</code></a></h1>
<p>Apple macOS targets.</p>
<p><strong>Tier: 1</strong></p>
<ul>
<li><code>aarch64-apple-darwin</code>: macOS on ARM64 (M1-family or later Apple Silicon CPUs).</li>
</ul>
<p><strong>Tier: 2</strong></p>
<ul>
<li><code>x86_64-apple-darwin</code>: macOS on 64-bit x86.</li>
</ul>
<h2 id="target-maintainers-2"><a class="header" href="#target-maintainers-2">Target maintainers</a></h2>
<p><a href="https://github.com/thomcc">@thomcc</a>
<a href="https://github.com/madsmtm">@madsmtm</a></p>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<h3 id="os-version"><a class="header" href="#os-version">OS version</a></h3>
<p>The minimum supported version is macOS 10.12 Sierra on x86, and macOS 11.0 Big
Sur on ARM64.</p>
<p>This version can be raised per-binary by changing the <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/cross_development/Configuring/configuring.html">deployment target</a>,
which might yield more performance optimizations. <code>rustc</code> respects the common
environment variables used by Xcode to do so, in this case
<code>MACOSX_DEPLOYMENT_TARGET</code>.</p>
<p>The current default deployment target for <code>rustc</code> can be retrieved with
<a href="#option-print"><code>rustc --print=deployment-target</code></a>.</p>
<h3 id="host-tooling"><a class="header" href="#host-tooling">Host tooling</a></h3>
<p>The minimum supported OS versions for the host tooling (<code>rustc</code>, <code>cargo</code>,
etc.) are currently the same as for applications, namely 10.12 on x86 and 11.0
on ARM64.
The minimum supported Xcode version is 9.2.</p>
<p>Building from source likely requires that you can build LLVM from source too,
which <a href="https://releases.llvm.org/19.1.0/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library">currently</a> requires Xcode 10.0 and macOS 10.13 (for LLVM 19).</p>
<h3 id="binary-format"><a class="header" href="#binary-format">Binary format</a></h3>
<p>The default binary format is Mach-O, the executable format used on Apple’s
platforms.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>These targets are distributed through <code>rustup</code>, and otherwise require no
special configuration.</p>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<p>There are no special requirements for testing and running this target.</p>
<p>x86 binaries can be run on Apple Silicon by using Rosetta.</p>
<h2 id="cross-compilation-toolchains-and-c-code-2"><a class="header" href="#cross-compilation-toolchains-and-c-code-2">Cross-compilation toolchains and C code</a></h2>
<p>Cross-compilation of these targets are supported using Clang, but may require
Xcode or the macOS SDK (<code>MacOSX.sdk</code>) to be available to compile C code and
to link.</p>
<p>The Clang target is suffixed with <code>-macosx</code>. Clang’s <code>-darwin</code> target refers
to Darwin platforms in general (macOS/iOS/tvOS/watchOS/visionOS), and requires
the <code>-mmacosx-version-min=...</code>, <code>-miphoneos-version-min=...</code> or similar flags
to disambiguate.</p>
<p>The path to the SDK can be passed to <code>rustc</code> using the common <code>SDKROOT</code>
environment variable, or will be inferred when compiling on host macOS using
roughly the same logic as <code>xcrun --sdk macosx --show-sdk-path</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="i686-apple-darwin"><a class="header" href="#i686-apple-darwin"><code>i686-apple-darwin</code></a></h1>
<p>Apple macOS on 32-bit x86.</p>
<h2 id="target-maintainers-3"><a class="header" href="#target-maintainers-3">Target maintainers</a></h2>
<p><a href="https://github.com/thomcc">@thomcc</a>
<a href="https://github.com/madsmtm">@madsmtm</a></p>
<h2 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h2>
<p>See the docs on <a href="#-apple-darwin"><code>*-apple-darwin</code></a> for general macOS requirements.</p>
<h2 id="building-the-target-2"><a class="header" href="#building-the-target-2">Building the target</a></h2>
<p>You’ll need the macOS 10.13 SDK shipped with Xcode 9. The location of the SDK
can be passed to <code>rustc</code> using the common <code>SDKROOT</code> environment variable.</p>
<p>Once you have that, you can build Rust with support for the target by adding
it to the <code>target</code> list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["i686-apple-darwin"]
</code></pre>
<p>Using the unstable <code>-Zbuild-std</code> with a nightly Cargo may also work.</p>
<h2 id="building-rust-programs-2"><a class="header" href="#building-rust-programs-2">Building Rust programs</a></h2>
<p>Rust <a href="https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html">no longer</a> ships pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy using <code>build-std</code> or
similar.</p>
<h2 id="testing-3"><a class="header" href="#testing-3">Testing</a></h2>
<p>Running this target requires an Intel Macbook running macOS 10.14 or earlier,
as later versions removed support for running 32-bit binaries.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64h-apple-darwin"><a class="header" href="#x86_64h-apple-darwin"><code>x86_64h-apple-darwin</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Target for macOS on late-generation <code>x86_64</code> Apple chips, usable as the
<code>x86_64h</code> entry in universal binaries, and equivalent to LLVM’s
<code>x86_64h-apple-macosx*</code> targets.</p>
<h2 id="target-maintainers-4"><a class="header" href="#target-maintainers-4">Target maintainers</a></h2>
<p><a href="https://github.com/thomcc">@thomcc</a></p>
<h2 id="requirements-4"><a class="header" href="#requirements-4">Requirements</a></h2>
<p>This target is an <code>x86_64</code> target that only supports Apple’s late-gen
(Haswell-compatible) Intel chips. It enables a set of target features available
on these chips (AVX2 and similar), and MachO binaries built with this target may
be used as the <code>x86_64h</code> entry in universal binaries (“fat” MachO binaries), and
will fail to load on machines that do not support this.</p>
<p>It should support the full standard library (<code>std</code> and <code>alloc</code> either with
default or user-defined allocators). This target is probably most useful when
targeted via cross-compilation (including from <code>x86_64-apple-darwin</code>), but if
built manually, the host tools work.</p>
<p>It is similar to <a href="#-apple-darwin"><code>x86_64-apple-darwin</code></a> in nearly all
respects.</p>
<h2 id="building-the-target-3"><a class="header" href="#building-the-target-3">Building the target</a></h2>
<p>Users on Apple targets can build this by adding it to the <code>target</code> list in
<code>bootstrap.toml</code>, or with <code>-Zbuild-std</code>.</p>
<h2 id="building-rust-programs-3"><a class="header" href="#building-rust-programs-3">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing-4"><a class="header" href="#testing-4">Testing</a></h2>
<p>Code built with this target can be run on the set of Intel macOS machines that
support running <code>x86_64h</code> binaries (relatively recent Intel macs). The Rust test
suite seems to work.</p>
<h2 id="cross-compilation-toolchains-and-c-code-3"><a class="header" href="#cross-compilation-toolchains-and-c-code-3">Cross-compilation toolchains and C code</a></h2>
<p>Cross-compilation to this target from Apple hosts should generally work without
much configuration, so long as XCode and the CommandLineTools are installed.
Targeting it from non-Apple hosts is difficult, but no more so than targeting
<code>x86_64-apple-darwin</code>.</p>
<p>When compiling C code for this target, either the “<code>x86_64h-apple-macosx*</code>” LLVM
targets should be used, or an argument like <code>-arch x86_64h</code> should be passed to
the C compiler.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm64e-apple-darwin"><a class="header" href="#arm64e-apple-darwin"><code>arm64e-apple-darwin</code></a></h1>
<p><strong>Tier: 3 (with Host Tools)</strong></p>
<p>ARM64e macOS (11.0+, Big Sur+)</p>
<h2 id="target-maintainers-5"><a class="header" href="#target-maintainers-5">Target maintainers</a></h2>
<p><a href="https://github.com/arttet">@arttet</a></p>
<h2 id="requirements-5"><a class="header" href="#requirements-5">Requirements</a></h2>
<p>Target for <code>macOS</code> on late-generation <code>M</code> series Apple chips.</p>
<p>See the docs on <a href="#-apple-darwin"><code>*-apple-darwin</code></a> for general macOS requirements.</p>
<h2 id="building-the-target-4"><a class="header" href="#building-the-target-4">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code> list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["arm64e-apple-darwin"]
</code></pre>
<h2 id="building-rust-programs-4"><a class="header" href="#building-rust-programs-4">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target.
To compile for this target, you will need to build Rust with the target enabled (see <a href="#building-the-target-4">Building the target</a> above).</p>
<h2 id="testing-5"><a class="header" href="#testing-5">Testing</a></h2>
<p>The target does support running binaries on macOS platforms with <code>arm64e</code> architecture.</p>
<h2 id="cross-compilation-toolchains-and-c-code-4"><a class="header" href="#cross-compilation-toolchains-and-c-code-4">Cross-compilation toolchains and C code</a></h2>
<p>The targets do support <code>C</code> code.
To build compatible <code>C</code> code, you have to use XCode with the same compiler and flags.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-apple-ios"><a class="header" href="#-apple-ios"><code>*-apple-ios</code></a></h1>
<p>Apple iOS / iPadOS targets.</p>
<p><strong>Tier: 2 (without Host Tools)</strong></p>
<ul>
<li><code>aarch64-apple-ios</code>: Apple iOS on ARM64.</li>
<li><code>aarch64-apple-ios-sim</code>: Apple iOS Simulator on ARM64.</li>
<li><code>x86_64-apple-ios</code>: Apple iOS Simulator on 64-bit x86.</li>
</ul>
<p><strong>Tier: 3</strong></p>
<ul>
<li><code>armv7s-apple-ios</code>: Apple iOS on Armv7-A.</li>
<li><code>i386-apple-ios</code>: Apple iOS Simulator on 32-bit x86.</li>
</ul>
<h2 id="target-maintainers-6"><a class="header" href="#target-maintainers-6">Target maintainers</a></h2>
<p><a href="https://github.com/badboy">@badboy</a>
<a href="https://github.com/deg4uss3r">@deg4uss3r</a>
<a href="https://github.com/madsmtm">@madsmtm</a></p>
<h2 id="requirements-6"><a class="header" href="#requirements-6">Requirements</a></h2>
<p>These targets are cross-compiled, and require the corresponding iOS SDK
(<code>iPhoneOS.sdk</code> or <code>iPhoneSimulator.sdk</code>), as provided by Xcode. To build the
ARM64 targets, Xcode 12 or higher is required.</p>
<p>The path to the SDK can be passed to <code>rustc</code> using the common <code>SDKROOT</code>
environment variable, or will be inferred when compiling on host macOS using
roughly the same logic as <code>xcrun --sdk iphoneos --show-sdk-path</code>.</p>
<h3 id="os-version-1"><a class="header" href="#os-version-1">OS version</a></h3>
<p>The minimum supported version is iOS 10.0.</p>
<p>This can be raised per-binary by changing the deployment target. <code>rustc</code>
respects the common environment variables used by Xcode to do so, in this
case <code>IPHONEOS_DEPLOYMENT_TARGET</code>.</p>
<h2 id="building-the-target-5"><a class="header" href="#building-the-target-5">Building the target</a></h2>
<p>The tier 2 targets are distributed through <code>rustup</code>, and can be installed
using one of:</p>
<pre><code class="language-console">$ rustup target add aarch64-apple-ios
$ rustup target add aarch64-apple-ios-sim
$ rustup target add x86_64-apple-ios
</code></pre>
<p>The tier 3 targets can be built by enabling them for a <code>rustc</code> build in
<code>bootstrap.toml</code>, by adding, for example:</p>
<pre><code class="language-toml">[build]
target = ["armv7s-apple-ios", "i386-apple-ios"]
</code></pre>
<p>Using the unstable <code>-Zbuild-std</code> with a nightly Cargo may also work.</p>
<h2 id="building-rust-programs-5"><a class="header" href="#building-rust-programs-5">Building Rust programs</a></h2>
<p>Rust programs can be built for these targets by specifying <code>--target</code>, if
<code>rustc</code> has been built with support for them. For example:</p>
<pre><code class="language-console">$ rustc --target aarch64-apple-ios your-code.rs
</code></pre>
<p>Or if using Cargo and <code>-Zbuild-std</code>:</p>
<pre><code class="language-console">$ cargo +nightly build -Zbuild-std --target armv7s-apple-ios
</code></pre>
<p>The simulator variants can be differentiated from the variants running
on-device with the <code>target_env = "sim"</code> cfg (or <code>target_abi = "sim"</code> before
Rust 1.91.0).</p>
<pre><code class="language-rust">if cfg!(all(target_vendor = "apple", target_env = "sim")) {
    // Do something on the iOS/tvOS/visionOS/watchOS Simulator.
} else {
    // Everything else, like Windows and non-Simulator iOS.
}</code></pre>
<p>This is similar to the <code>TARGET_OS_SIMULATOR</code> define in C code.</p>
<h2 id="testing-6"><a class="header" href="#testing-6">Testing</a></h2>
<p>Running and testing your code naturally requires either an actual device
running iOS, or the equivalent Xcode simulator environment. There exists
several tools in the ecosystem for running a Cargo project on one of these.
One of these tools is <a href="https://github.com/sonos/dinghy"><code>cargo-dinghy</code></a>. <a href="https://github.com/madsmtm/objc2/issues/459">madsmtm/objc2#459</a> contains a more
exhaustive list.</p>
<p>See also <a href="https://rustc-dev-guide.rust-lang.org/tests/running.html#testing-on-emulators">testing on emulators in the <code>rustc-dev-guide</code></a> for
instructions on running the standard library’s test suite.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-apple-ios-macabi"><a class="header" href="#-apple-ios-macabi"><code>*-apple-ios-macabi</code></a></h1>
<p>Apple Mac Catalyst targets.</p>
<p><strong>Tier: 2 (without Host Tools)</strong></p>
<ul>
<li><code>aarch64-apple-ios-macabi</code>: Mac Catalyst on ARM64.</li>
<li><code>x86_64-apple-ios-macabi</code>: Mac Catalyst on 64-bit x86.</li>
</ul>
<h2 id="target-maintainers-7"><a class="header" href="#target-maintainers-7">Target maintainers</a></h2>
<p><a href="https://github.com/badboy">@badboy</a>
<a href="https://github.com/BlackHoleFox">@BlackHoleFox</a>
<a href="https://github.com/madsmtm">@madsmtm</a></p>
<h2 id="requirements-7"><a class="header" href="#requirements-7">Requirements</a></h2>
<p>These targets are cross-compiled, and require the corresponding macOS SDK
(<code>MacOSX.sdk</code>) which contain <code>./System/iOSSupport</code> headers to allow linking to
iOS-specific headers, as provided by Xcode 11 or higher.</p>
<p>The path to the SDK can be passed to <code>rustc</code> using the common <code>SDKROOT</code>
environment variable, or will be inferred when compiling on host macOS using
roughly the same logic as <code>xcrun --sdk macosx --show-sdk-path</code>.</p>
<h3 id="os-version-2"><a class="header" href="#os-version-2">OS version</a></h3>
<p>The minimum supported version is iOS 13.1 on x86 and 14.0 on Aarch64.</p>
<p>This can be raised per-binary by changing the deployment target. <code>rustc</code>
respects the common environment variables used by Xcode to do so, in this
case <code>IPHONEOS_DEPLOYMENT_TARGET</code>.</p>
<h2 id="building-the-target-6"><a class="header" href="#building-the-target-6">Building the target</a></h2>
<p>The targets are distributed through <code>rustup</code>, and can be installed using one
of:</p>
<pre><code class="language-console">$ rustup target add aarch64-apple-ios-macabi
$ rustup target add x86_64-apple-ios-macabi
</code></pre>
<h3 id="sanitizers"><a class="header" href="#sanitizers">Sanitizers</a></h3>
<p>Due to CMake having poor support for Mac Catalyst, sanitizer runtimes are not
currently available, see <a href="https://github.com/rust-lang/rust/issues/129069">#129069</a>.</p>
<h2 id="building-rust-programs-6"><a class="header" href="#building-rust-programs-6">Building Rust programs</a></h2>
<p>Rust programs can be built for these targets by specifying <code>--target</code>, if
<code>rustc</code> has been built with support for them. For example:</p>
<pre><code class="language-console">$ rustc --target aarch64-apple-ios-macabi your-code.rs
</code></pre>
<p>The target can be differentiated from the iOS targets with the
<code>target_env = "macabi"</code> cfg (or <code>target_abi = "macabi"</code> before Rust 1.91.0).</p>
<pre><code class="language-rust">if cfg!(target_env = "macabi") {
    // Do something only on Mac Catalyst.
}</code></pre>
<p>This is similar to the <code>TARGET_OS_MACCATALYST</code> define in C code.</p>
<h2 id="testing-7"><a class="header" href="#testing-7">Testing</a></h2>
<p>Mac Catalyst binaries can be run directly on macOS 10.15 Catalina or newer.</p>
<p>x86 binaries can be run on Apple Silicon by using Rosetta.</p>
<p>Note that using certain UIKit functionality requires the binary to be bundled.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm64e-apple-ios"><a class="header" href="#arm64e-apple-ios"><code>arm64e-apple-ios</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>ARM64e iOS (14.0+)</p>
<h2 id="target-maintainers-8"><a class="header" href="#target-maintainers-8">Target maintainers</a></h2>
<p><a href="https://github.com/arttet">@arttet</a></p>
<h2 id="requirements-8"><a class="header" href="#requirements-8">Requirements</a></h2>
<p>See the docs on <a href="#-apple-ios"><code>*-apple-ios</code></a> for general iOS requirements.</p>
<h2 id="building-the-target-7"><a class="header" href="#building-the-target-7">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code> list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["arm64e-apple-ios"]
</code></pre>
<h2 id="building-rust-programs-7"><a class="header" href="#building-rust-programs-7">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target.
To compile for this target, you will need to build Rust with the target enabled (see <a href="#building-the-target-7">Building the target</a> above).</p>
<h2 id="testing-8"><a class="header" href="#testing-8">Testing</a></h2>
<p>The target does support running binaries on iOS platforms with <code>arm64e</code> architecture.</p>
<h2 id="cross-compilation-toolchains-and-c-code-5"><a class="header" href="#cross-compilation-toolchains-and-c-code-5">Cross-compilation toolchains and C code</a></h2>
<p>The targets do support <code>C</code> code.
To build compatible <code>C</code> code, you have to use XCode with the same compiler and flags.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-apple-tvos"><a class="header" href="#-apple-tvos"><code>*-apple-tvos</code></a></h1>
<p>Apple tvOS targets.</p>
<p><strong>Tier: 3</strong></p>
<ul>
<li><code>aarch64-apple-tvos</code>: Apple tvOS on ARM64.</li>
<li><code>aarch64-apple-tvos-sim</code>: Apple tvOS Simulator on ARM64.</li>
<li><code>x86_64-apple-tvos</code>: Apple tvOS Simulator on x86_64.</li>
</ul>
<h2 id="target-maintainers-9"><a class="header" href="#target-maintainers-9">Target maintainers</a></h2>
<p><a href="https://github.com/thomcc">@thomcc</a>
<a href="https://github.com/madsmtm">@madsmtm</a></p>
<h2 id="requirements-9"><a class="header" href="#requirements-9">Requirements</a></h2>
<p>These targets are cross-compiled, and require the corresponding tvOS SDK
(<code>AppleTVOS.sdk</code> or <code>AppleTVSimulator.sdk</code>), as provided by Xcode. To build the
ARM64 targets, Xcode 12 or higher is required.</p>
<p>The path to the SDK can be passed to <code>rustc</code> using the common <code>SDKROOT</code>
environment variable, or will be inferred when compiling on host macOS using
roughly the same logic as <code>xcrun --sdk appletvos --show-sdk-path</code>.</p>
<h3 id="os-version-3"><a class="header" href="#os-version-3">OS version</a></h3>
<p>The minimum supported version is tvOS 10.0, although the actual minimum version
you can target may be newer than this, for example due to the versions of Xcode
and your SDKs.</p>
<p>The version can be raised per-binary by changing the deployment target. <code>rustc</code>
respects the common environment variables used by Xcode to do so, in this
case <code>TVOS_DEPLOYMENT_TARGET</code>.</p>
<h3 id="incompletely-supported-library-functionality"><a class="header" href="#incompletely-supported-library-functionality">Incompletely supported library functionality</a></h3>
<p>The targets support most of the standard library including the allocator to the
best of my knowledge, however they are very new, not yet well-tested, and it is
possible that there are various bugs.</p>
<p>The following APIs are currently known to have missing or incomplete support:</p>
<ul>
<li><code>std::process::Command</code>’s API will return an error if it is configured in a
manner which cannot be performed using <code>posix_spawn</code> – this is because the
more flexible <code>fork</code>/<code>exec</code>-based approach is prohibited on these platforms in
favor of <code>posix_spawn{,p}</code> (which still probably will get you rejected from
app stores, so is likely sideloading-only). A concrete set of cases where this
will occur is difficult to enumerate (and would quickly become stale), but in
some cases it may be worked around by tweaking the manner in which <code>Command</code>
is invoked.</li>
</ul>
<h2 id="building-the-target-8"><a class="header" href="#building-the-target-8">Building the target</a></h2>
<p>The targets can be built by enabling them for a <code>rustc</code> build in
<code>bootstrap.toml</code>, by adding, for example:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["aarch64-apple-tvos", "aarch64-apple-tvos-sim"]
</code></pre>
<p>Using the unstable <code>-Zbuild-std</code> with a nightly Cargo may also work.</p>
<h2 id="building-rust-programs-8"><a class="header" href="#building-rust-programs-8">Building Rust programs</a></h2>
<p>See <a href="#building-rust-programs-5">the instructions for iOS</a>.</p>
<h2 id="testing-9"><a class="header" href="#testing-9">Testing</a></h2>
<p>See <a href="#testing-6">the instructions for iOS</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm64e-apple-tvos"><a class="header" href="#arm64e-apple-tvos"><code>arm64e-apple-tvos</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>ARM64e tvOS (10.0+)</p>
<h2 id="target-maintainers-10"><a class="header" href="#target-maintainers-10">Target maintainers</a></h2>
<p><a href="https://github.com/arttet">@arttet</a></p>
<h2 id="requirements-10"><a class="header" href="#requirements-10">Requirements</a></h2>
<p>This target is cross-compiled and supports <code>std</code>.
To build this target Xcode 12 or higher on macOS is required.</p>
<h2 id="building-the-target-9"><a class="header" href="#building-the-target-9">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code> list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["arm64e-apple-tvos"]
</code></pre>
<h2 id="building-rust-programs-9"><a class="header" href="#building-rust-programs-9">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target.
To compile for this target, you will need to build Rust with the target enabled (see <a href="#building-the-target-9">Building the target</a> above).</p>
<h2 id="testing-10"><a class="header" href="#testing-10">Testing</a></h2>
<p>The target does support running binaries on tvOS platforms with <code>arm64e</code> architecture.</p>
<h2 id="cross-compilation-toolchains-and-c-code-6"><a class="header" href="#cross-compilation-toolchains-and-c-code-6">Cross-compilation toolchains and C code</a></h2>
<p>The targets do support <code>C</code> code.
To build compatible <code>C</code> code, you have to use XCode with the same compiler and flags.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-apple-watchos"><a class="header" href="#-apple-watchos"><code>*-apple-watchos</code></a></h1>
<p>Apple watchOS targets.</p>
<p><strong>Tier: 3</strong></p>
<ul>
<li><code>aarch64-apple-watchos</code>: Apple WatchOS on ARM64.</li>
<li><code>aarch64-apple-watchos-sim</code>: Apple WatchOS Simulator on ARM64.</li>
<li><code>x86_64-apple-watchos-sim</code>: Apple WatchOS Simulator on 64-bit x86.</li>
<li><code>arm64_32-apple-watchos</code>: Apple WatchOS on Arm 64_32.</li>
<li><code>armv7k-apple-watchos</code>: Apple WatchOS on Armv7k.</li>
</ul>
<h2 id="target-maintainers-11"><a class="header" href="#target-maintainers-11">Target maintainers</a></h2>
<p><a href="https://github.com/deg4uss3r">@deg4uss3r</a>
<a href="https://github.com/vladimir-ea">@vladimir-ea</a>
<a href="https://github.com/leohowell">@leohowell</a>
<a href="https://github.com/madsmtm">@madsmtm</a></p>
<h2 id="requirements-11"><a class="header" href="#requirements-11">Requirements</a></h2>
<p>These targets are cross-compiled, and require the corresponding watchOS SDK
(<code>WatchOS.sdk</code> or <code>WatchSimulator.sdk</code>), as provided by Xcode. To build the
ARM64 targets, Xcode 12 or higher is required.</p>
<p>The path to the SDK can be passed to <code>rustc</code> using the common <code>SDKROOT</code>
environment variable, or will be inferred when compiling on host macOS using
roughly the same logic as <code>xcrun --sdk watchos --show-sdk-path</code>.</p>
<h3 id="os-version-4"><a class="header" href="#os-version-4">OS version</a></h3>
<p>The minimum supported version is watchOS 5.0.</p>
<p>This can be raised per-binary by changing the deployment target. <code>rustc</code>
respects the common environment variables used by Xcode to do so, in this
case <code>WATCHOS_DEPLOYMENT_TARGET</code>.</p>
<h2 id="building-the-target-10"><a class="header" href="#building-the-target-10">Building the target</a></h2>
<p>The targets can be built by enabling them for a <code>rustc</code> build in
<code>bootstrap.toml</code>, by adding, for example:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["aarch64-apple-watchos", "aarch64-apple-watchos-sim"]
</code></pre>
<p>Using the unstable <code>-Zbuild-std</code> with a nightly Cargo may also work.</p>
<h2 id="building-rust-programs-10"><a class="header" href="#building-rust-programs-10">Building Rust programs</a></h2>
<p>See <a href="#building-rust-programs-5">the instructions for iOS</a>.</p>
<h2 id="testing-11"><a class="header" href="#testing-11">Testing</a></h2>
<p>See <a href="#testing-6">the instructions for iOS</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-apple-visionos"><a class="header" href="#-apple-visionos"><code>*-apple-visionos</code></a></h1>
<p>Apple visionOS / xrOS targets.</p>
<p><strong>Tier: 3</strong></p>
<ul>
<li><code>aarch64-apple-visionos</code>: Apple visionOS on arm64.</li>
<li><code>aarch64-apple-visionos-sim</code>: Apple visionOS Simulator on arm64.</li>
</ul>
<h2 id="target-maintainers-12"><a class="header" href="#target-maintainers-12">Target maintainers</a></h2>
<p><a href="https://github.com/agg23">@agg23</a>
<a href="https://github.com/madsmtm">@madsmtm</a></p>
<h2 id="requirements-12"><a class="header" href="#requirements-12">Requirements</a></h2>
<p>These targets are cross-compiled, and require the corresponding visionOS SDK
(<code>XROS.sdk</code> or <code>XRSimulator.sdk</code>), as provided by Xcode 15 or newer.</p>
<p>The path to the SDK can be passed to <code>rustc</code> using the common <code>SDKROOT</code>
environment variable, or will be inferred when compiling on host macOS using
roughly the same logic as <code>xcrun --sdk xros --show-sdk-path</code>.</p>
<h3 id="os-version-5"><a class="header" href="#os-version-5">OS version</a></h3>
<p>The minimum supported version is visionOS 1.0.</p>
<p>This can be raised per-binary by changing the deployment target. <code>rustc</code>
respects the common environment variables used by Xcode to do so, in this
case <code>XROS_DEPLOYMENT_TARGET</code>.</p>
<h2 id="building-the-target-11"><a class="header" href="#building-the-target-11">Building the target</a></h2>
<p>The targets can be built by enabling them for a <code>rustc</code> build in
<code>bootstrap.toml</code>, by adding, for example:</p>
<pre><code class="language-toml">[build]
target = ["aarch64-apple-visionos", "aarch64-apple-visionos-sim"]
</code></pre>
<p>Using the unstable <code>-Zbuild-std</code> with a nightly Cargo may also work.</p>
<p>Note: Currently, a newer version of <code>libc</code> and <code>cc</code> may be required, this will
be fixed in <a href="https://github.com/rust-lang/rust/pull/124560">#124560</a>.</p>
<h2 id="building-rust-programs-11"><a class="header" href="#building-rust-programs-11">Building Rust programs</a></h2>
<p>See <a href="#building-rust-programs-5">the instructions for iOS</a>.</p>
<h2 id="testing-12"><a class="header" href="#testing-12">Testing</a></h2>
<p>See <a href="#testing-6">the instructions for iOS</a>.</p>
<h2 id="cross-compilation-toolchains-and-c-code-7"><a class="header" href="#cross-compilation-toolchains-and-c-code-7">Cross-compilation toolchains and C code</a></h2>
<p>The Clang target is suffixed with <code>-xros</code> for historical reasons.</p>
<p>LLVM 18 or newer is required to build this target.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-nintendo-switch-freestanding"><a class="header" href="#aarch64-nintendo-switch-freestanding">aarch64-nintendo-switch-freestanding</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Nintendo Switch with pure-Rust toolchain.</p>
<h2 id="target-maintainers-13"><a class="header" href="#target-maintainers-13">Target Maintainers</a></h2>
<p><a href="https://github.com/leo60228">@leo60228</a>
<a href="https://github.com/jam1garner">@jam1garner</a></p>
<h2 id="requirements-13"><a class="header" href="#requirements-13">Requirements</a></h2>
<p>This target is cross-compiled.
It has no special requirements for the host.</p>
<h2 id="building-1"><a class="header" href="#building-1">Building</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["aarch64-nintendo-switch-freestanding"]
</code></pre>
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-13"><a class="header" href="#testing-13">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-12"><a class="header" href="#building-rust-programs-12">Building Rust programs</a></h2>
<p>If <code>rustc</code> has support for that target and the library artifacts are available,
then Rust programs can be built for that target:</p>
<pre><code class="language-text">rustc --target aarch64-nintendo-switch-freestanding your-code.rs
</code></pre>
<p>To generate binaries in the NRO format that can be easily run on-device, you
can use <a href="https://github.com/aarch64-switch-rs/cargo-nx">cargo-nx</a>:</p>
<pre><code class="language-text">cargo nx --triple=aarch64-nintendo-switch-freestanding
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-unknown-linux-gnu"><a class="header" href="#aarch64-unknown-linux-gnu"><code>aarch64-unknown-linux-gnu</code></a></h1>
<p><strong>Tier: 1 (with Host Tools)</strong></p>
<p>Target for 64-bit little endian ARMv8-A Linux 4.1+ programs using glibc 2.17+.</p>
<h2 id="target-maintainers-14"><a class="header" href="#target-maintainers-14">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="requirements-14"><a class="header" href="#requirements-14">Requirements</a></h2>
<p>Building the target itself requires a 64-bit little endian ARMv8-A compiler that is supported by
<code>cc-rs</code>.</p>
<h2 id="building-the-target-12"><a class="header" href="#building-the-target-12">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build:</p>
<pre><code class="language-toml">[build]
target = ["aarch64-unknown-linux-gnu"]
</code></pre>
<p>If cross-compiling, make sure your C compiler is included in <code>$PATH</code>, then add it to the
<code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-musl]
cc = "aarch64-linux-gnu-gcc"
cxx = "aarch64-linux-gnu-g++"
ar = "aarch64-linux-gnu-ar"
linker = "aarch64-linux-gnu-gcc"
</code></pre>
<h2 id="building-rust-programs-13"><a class="header" href="#building-rust-programs-13">Building Rust programs</a></h2>
<p>This target is distributed through <code>rustup</code>, and otherwise requires no special configuration.</p>
<h2 id="cross-compilation-1"><a class="header" href="#cross-compilation-1">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-14"><a class="header" href="#testing-14">Testing</a></h2>
<p>This target can be tested as normal with <code>x.py</code> on a 64-bit little endian ARMv8-A host or via QEMU
emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-unknown-linux-musl"><a class="header" href="#aarch64-unknown-linux-musl">aarch64-unknown-linux-musl</a></h1>
<p><strong>Tier: 2</strong></p>
<p>Target for 64-bit little endian ARMv8-A Linux programs using musl libc.</p>
<h2 id="target-maintainers-15"><a class="header" href="#target-maintainers-15">Target maintainers</a></h2>
<p><a href="https://github.com/Gelbpunkt">@Gelbpunkt</a>
<a href="https://github.com/famfo">@famfo</a></p>
<h2 id="requirements-15"><a class="header" href="#requirements-15">Requirements</a></h2>
<p>Building the target itself requires a 64-bit little endian ARMv8-A compiler
that is supported by <code>cc-rs</code>.</p>
<h2 id="building-the-target-13"><a class="header" href="#building-the-target-13">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["aarch64-unknown-linux-musl"]
</code></pre>
<p>Make sure your C compiler is included in <code>$PATH</code>, then add it to the
<code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-musl]
cc = "aarch64-linux-musl-gcc"
cxx = "aarch64-linux-musl-g++"
ar = "aarch64-linux-musl-ar"
linker = "aarch64-linux-musl-gcc"
</code></pre>
<h2 id="building-rust-programs-14"><a class="header" href="#building-rust-programs-14">Building Rust programs</a></h2>
<p>This target is distributed through <code>rustup</code>, and otherwise requires no
special configuration.</p>
<h2 id="cross-compilation-2"><a class="header" href="#cross-compilation-2">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-15"><a class="header" href="#testing-15">Testing</a></h2>
<p>This target can be tested as normal with <code>x.py</code> on a 64-bit little endian
ARMv8-A host or via QEMU emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-unknown-none-and-aarch64-unknown-none-softfloat"><a class="header" href="#aarch64-unknown-none-and-aarch64-unknown-none-softfloat"><code>aarch64-unknown-none</code> and <code>aarch64-unknown-none-softfloat</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal targets for CPUs in the Armv8-A architecture family, running in AArch64 mode.</p>
<p>For the AArch32 mode carried over from Armv7-A, see
<a href="#armv7a-none-eabi-and-armv7a-none-eabihf"><code>armv7a-none-eabi</code></a> instead.</p>
<p>Processors in this family include the <a href="https://en.wikipedia.org/wiki/Comparison_of_ARM_processors#ARMv8-A">Arm Cortex-A35, 53, 76, etc</a>.</p>
<h2 id="target-maintainers-16"><a class="header" href="#target-maintainers-16">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="target-cpu-and-target-feature-options"><a class="header" href="#target-cpu-and-target-feature-options">Target CPU and Target Feature options</a></h2>
<p>All AArch64 processors include an FPU. The difference between the <code>-none</code> and
<code>-none-softfloat</code> targets is whether the FPU is used for passing function arguments.
You may prefer the <code>-softfloat</code> target when writing a kernel or interfacing with
pre-compiled binaries that use the soft-float ABI.</p>
<p>When using the hardfloat targets, the minimum floating-point features assumed
are <a href="https://developer.arm.com/documentation/109697/2025_12/Feature-descriptions/The-Armv8-0-architecture-extension?lang=en"><code>FEAT_AdvSIMD</code></a>, which means NEON SIMD support. If your
processor supports a different set of floating-point features than the default
expectations of <code>FEAT_AdvSIMD</code>, then these should also be enabled or disabled
as needed with <code>-C target-feature=(+/-)</code>. It is also possible to tell Rust (or
LLVM) that you have a specific model of Arm processor, using the
<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu"><code>-Ctarget-cpu</code></a> option. Doing so may change the default set of
target-features enabled.</p>
<h2 id="requirements-16"><a class="header" href="#requirements-16">Requirements</a></h2>
<p>These targets are cross-compiled and use static linking.</p>
<p>By default, the <code>lld</code> linker included with Rust will be used; however, you may
want to use the GNU linker instead. This can be obtained for Windows/Mac/Linux
from the <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">Arm Developer Website</a>, or possibly from your OS’s
package manager. To use it, add the following to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.aarch64-unknown-none]
linker = "aarch64-none-elf-ld"
</code></pre>
<p>The GNU linker can also be used by specifying <code>aarch64-none-elf-gcc</code> as the
linker. This is needed when using GCC’s link time optimization.</p>
<p>These targets don’t provide a linker script, so you’ll need to bring your own
according to the specific device you are using. Pass
<code>-Clink-arg=-Tyour_script.ld</code> as a rustc argument to make the linker use
<code>your_script.ld</code> during linking.</p>
<h2 id="cross-compilation-toolchains-and-c-code-8"><a class="header" href="#cross-compilation-toolchains-and-c-code-8">Cross-compilation toolchains and C code</a></h2>
<p>This target supports C code compiled with the <code>aarch64-none-elf</code> target
triple and a suitable <code>-march</code> or <code>-mcpu</code> flag.</p>
<h2 id="start-up-and-low-level-code"><a class="header" href="#start-up-and-low-level-code">Start-up and Low-Level Code</a></h2>
<p>The <a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a> maintain the
<a href="https://docs.rs/aarch64-cpu"><code>aarch64-cpu</code></a> crate, which may be useful for writing bare-metal code using
this target.</p>
<p>The <em>TrustedFirmware</em> group also maintain <a href="https://github.com/ArmFirmwareCrates">Rust crates for this
target</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64_be-unknown-none-softfloat"><a class="header" href="#aarch64_be-unknown-none-softfloat">aarch64_be-unknown-none-softfloat</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Target for freestanding/bare-metal big-endian ARM64 binaries in ELF format:
firmware, kernels, etc.</p>
<h2 id="target-maintainers-17"><a class="header" href="#target-maintainers-17">Target maintainers</a></h2>
<p><a href="https://github.com/Gelbpunkt">@Gelbpunkt</a></p>
<h2 id="requirements-17"><a class="header" href="#requirements-17">Requirements</a></h2>
<p>This target is cross-compiled. There is no support for <code>std</code>. There is no
default allocator, but it’s possible to use <code>alloc</code> by supplying an allocator.</p>
<p>The target does not assume existence of a FPU and does not make use of any
non-GPR register. This allows the generated code to run in environments, such
as kernels, which may need to avoid the use of such registers or which may have
special considerations about the use of such registers (e.g. saving and
restoring them to avoid breaking userspace code using the same registers). You
can change code generation to use additional CPU features via the
<code>-C target-feature=</code> codegen options to rustc, or via the <code>#[target_feature]</code>
mechanism within Rust code.</p>
<p>By default, code generated with the soft-float target should run on any
big-endian ARM64 hardware, enabling additional target features may raise this
baseline.</p>
<p><code>extern "C"</code> uses the <a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst">architecture’s standard calling convention</a>.</p>
<p>The targets generate binaries in the ELF format. Any alternate formats or
special considerations for binary layout will require linker options or linker
scripts.</p>
<h2 id="building-the-target-14"><a class="header" href="#building-the-target-14">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["aarch64_be-unknown-none-softfloat"]
</code></pre>
<h2 id="building-rust-programs-15"><a class="header" href="#building-rust-programs-15">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will first need to build Rust with the target enabled (see
“Building the target” above).</p>
<h2 id="cross-compilation-3"><a class="header" href="#cross-compilation-3">Cross-compilation</a></h2>
<p>For cross builds, you will need an appropriate ARM64 C/C++ toolchain for
linking, or if you want to compile C code along with Rust (such as for Rust
crates with C dependencies).</p>
<p>Rust <em>may</em> be able to use an <code>aarch64_be-unknown-linux-{gnu,musl}-</code> toolchain
with appropriate standalone flags to build for this target (depending on the
assumptions of that toolchain, see below), or you may wish to use a separate
<code>aarch64_be-unknown-none-softfloat</code> toolchain.</p>
<p>On some ARM64 hosts that use ELF binaries, you <em>may</em> be able to use the host C
toolchain, if it does not introduce assumptions about the host environment that
don’t match the expectations of a standalone environment. Otherwise, you may
need a separate toolchain for standalone/freestanding development, just as when
cross-compiling from a non-ARM64 platform.</p>
<h2 id="testing-16"><a class="header" href="#testing-16">Testing</a></h2>
<p>As the target supports a variety of different environments and does not support
<code>std</code>, it does not support running the Rust test suite.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64_be-unknown-linux-musl"><a class="header" href="#aarch64_be-unknown-linux-musl">aarch64_be-unknown-linux-musl</a></h1>
<p><strong>Tier: 3</strong></p>
<p>ARM64 Linux (big-endian) with musl-libc.</p>
<h2 id="target-maintainers-18"><a class="header" href="#target-maintainers-18">Target maintainers</a></h2>
<p><a href="https://github.com/neuschaefer">@neuschaefer</a>
<a href="https://github.com/Gelbpunkt">@Gelbpunkt</a></p>
<h2 id="requirements-18"><a class="header" href="#requirements-18">Requirements</a></h2>
<p>The target requires a <code>aarch64_be-*-linux-musl</code> toolchain, which likely has to
be built from source because this is a rare combination.  <a href="https://buildroot.org/">Buildroot</a> provides
a way of doing so:</p>
<ul>
<li>select <em>Target options</em> → <em>Target Architecture</em> → <em>AArch64 (big endian)</em></li>
<li>select <em>Toolchain</em> → <em>C library</em> → <em>musl</em></li>
<li>select <em>Toolchain</em> → <em>Enable C++ support</em></li>
</ul>
<p>Host tools are supported.</p>
<h2 id="building-the-target-15"><a class="header" href="#building-the-target-15">Building the target</a></h2>
<p>The target can be enabled in bootstrap.toml:</p>
<pre><code class="language-toml">[build]
target = ["aarch64_be-unknown-linux-musl"]

[target.aarch64_be-unknown-linux-musl]
cc          = "/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-cc"
cxx         = "/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-c++"
linker      = "/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-cc"
ar          = "/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-ar"
ranlib      = "/path/to/buildroot/host/bin/aarch64_be-buildroot-linux-musl-ranlib"
musl-root   = "/path/to/buildroot/staging"
runner      = "qemu-aarch64_be -L /path/to/buildroot/target"
crt-static  = "/path/to/buildroot/target"
</code></pre>
<h2 id="testing-17"><a class="header" href="#testing-17">Testing</a></h2>
<p>Binaries can be run under <code>qemu-aarch64_be</code> or under a big-endian Linux kernel.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="amdgcn-amd-amdhsa"><a class="header" href="#amdgcn-amd-amdhsa"><code>amdgcn-amd-amdhsa</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>AMD GPU target for compute/HSA (Heterogeneous System Architecture).</p>
<h2 id="target-maintainers-19"><a class="header" href="#target-maintainers-19">Target maintainers</a></h2>
<p><a href="https://github.com/Flakebi">@Flakebi</a></p>
<h2 id="requirements-19"><a class="header" href="#requirements-19">Requirements</a></h2>
<p>AMD GPUs can be targeted via cross-compilation.
Supported GPUs depend on the LLVM version that is used by Rust.
In general, most GPUs starting from gfx7 (Sea Islands/CI) are supported as compilation targets, though older GPUs are not supported by the latest host runtime.
Details about supported GPUs can be found in <a href="https://llvm.org/docs/AMDGPUUsage.html#processors">LLVM’s documentation</a> and <a href="https://rocmdocs.amd.com">ROCm documentation</a>.</p>
<p>Binaries can be loaded by <a href="https://rocm.docs.amd.com/projects/HIP/">HIP</a> or by the HSA runtime implemented in <a href="https://github.com/ROCm/ROCR-Runtime">ROCR-Runtime</a>.
The format of binaries is a linked ELF.</p>
<p>Binaries must be built with no-std.
They can use <code>core</code> and <code>alloc</code> (<code>alloc</code> only if an allocator is supplied).
At least one function should use the <code>"gpu-kernel"</code> calling convention and should be marked with <code>no_mangle</code> or <code>export_name</code>.
Functions using the <code>"gpu-kernel"</code> calling convention are kernel entrypoints and can be launched from the host runtime.</p>
<h2 id="building-the-target-16"><a class="header" href="#building-the-target-16">Building the target</a></h2>
<p>The target is included in rustc.</p>
<h2 id="building-rust-programs-16"><a class="header" href="#building-rust-programs-16">Building Rust programs</a></h2>
<p>The amdgpu target supports many hardware generations, which need different binaries.
The generations are exposed as different target-cpus in the backend.
As there are many, Rust does not ship pre-compiled libraries for this target.
Therefore, you have to build your own copy of <code>core</code> by using <code>cargo -Zbuild-std=core</code> or similar.</p>
<p>An allocator and <code>println!()</code> support is provided by the <a href="https://crates.io/crates/amdgpu-device-libs"><code>amdgpu-device-libs</code></a> crate.
Both features rely on the <a href="https://rocm.docs.amd.com/projects/HIP/">HIP</a> runtime.</p>
<p>To build a binary, create a no-std library:</p>
<pre><code class="language-rust ignore (platform-specific)">// src/lib.rs
#![feature(abi_gpu_kernel)]
#![no_std]

#[panic_handler]
fn panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}

#[no_mangle]
pub extern "gpu-kernel" fn kernel(/* Arguments */) {
    // Code
}</code></pre>
<p>Build the library as <code>cdylib</code>:</p>
<pre><code class="language-toml"># Cargo.toml
[lib]
crate-type = ["cdylib"]

[profile.dev]
lto = true # LTO must be explicitly enabled for now
[profile.release]
lto = true
</code></pre>
<p>The target-cpu must be from the list <a href="https://llvm.org/docs/AMDGPUUsage.html#processors">supported by LLVM</a> (or printed with <code>rustc --target amdgcn-amd-amdhsa --print target-cpus</code>).
The GPU version on the current system can be found e.g. with <a href="https://github.com/ROCm/rocminfo"><code>rocminfo</code></a>.
For a GPU series that has xnack support but the target GPU has not, the <code>-xnack-support</code> target-feature needs to be enabled.
I.e. if the ISA info as printed with <a href="https://github.com/ROCm/rocminfo"><code>rocminfo</code></a> says something about <code>xnack-</code>, e.g. <code>gfx1010:xnack-</code>, add <code>-Ctarget-feature=-xnack-support</code> to the rustflags.</p>
<p>Example <code>.cargo/config.toml</code> file to set the target and GPU generation:</p>
<pre><code class="language-toml"># .cargo/config.toml
[build]
target = "amdgcn-amd-amdhsa"
rustflags = ["-Ctarget-cpu=gfx1100"]
# Add "-Ctarget-feature=-xnack-support" for xnack- GPUs (see above)

[unstable]
build-std = ["core"] # Optional: "alloc"
</code></pre>
<h2 id="running-rust-programs"><a class="header" href="#running-rust-programs">Running Rust programs</a></h2>
<p>To run a binary on an AMD GPU, a host runtime is needed.
On Linux and Windows, <a href="https://rocm.docs.amd.com/projects/HIP/">HIP</a> can be used to load and run binaries.
Example code on how to load a compiled binary and run it is available in <a href="https://github.com/ROCm/rocm-examples/tree/ca8ef5b6f1390176616cd1c18fbc98785cbc73f6/HIP-Basic/module_api">ROCm examples</a>.</p>
<p>On Linux, binaries can also run through the HSA runtime as implemented in <a href="https://github.com/ROCm/ROCR-Runtime">ROCR-Runtime</a>.</p>
<!--
## Testing

Does the target support running binaries, or do binaries have varying
expectations that prevent having a standard way to run them? If users can run
binaries, can they do so in some common emulator, or do they need native
hardware? Does the target support running the Rust testsuite?

-->
<h2 id="additional-information"><a class="header" href="#additional-information">Additional information</a></h2>
<p>More information can be found on the <a href="https://llvm.org/docs/AMDGPUUsage.html">LLVM page for amdgpu</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armthumb-none-eabihf"><a class="header" href="#armthumb-none-eabihf"><code>{arm,thumb}*-none-eabi(hf)?</code></a></h1>
<h2 id="common-target-details"><a class="header" href="#common-target-details">Common Target Details</a></h2>
<p>This documentation covers details that apply to a range of bare-metal targets
for 32-bit Arm CPUs. The <code>arm-none-eabi</code> flavor of the GNU compiler toolchain is
often used to assist compilation to these targets.</p>
<p>Details that apply only to only a specific target in this group are covered in
their own document.</p>
<h3 id="tier-2-target-list"><a class="header" href="#tier-2-target-list">Tier 2 Target List</a></h3>
<ul>
<li>Arm A-Profile Architectures
<ul>
<li><a href="#armv7a-none-eabi-and-armv7a-none-eabihf"><code>armv7a-none-eabi</code></a></li>
</ul>
</li>
<li>Arm R-Profile Architectures
<ul>
<li><a href="#armv7r-none-eabi-and-armv7r-none-eabihf"><code>armv7r-none-eabi</code> and <code>armv7r-none-eabihf</code></a></li>
<li><a href="#armebv7r-none-eabi-and-armebv7r-none-eabihf"><code>armebv7r-none-eabi</code> and <code>armebv7r-none-eabihf</code></a></li>
<li><a href="#armv8r-none-eabihf"><code>armv8r-none-eabihf</code></a></li>
</ul>
</li>
<li>Arm M-Profile Architectures
<ul>
<li><a href="#thumbv6m-none-eabi"><code>thumbv6m-none-eabi</code></a></li>
<li><a href="#thumbv7m-none-eabi"><code>thumbv7m-none-eabi</code></a></li>
<li><a href="#thumbv7em-none-eabi-and-thumbv7em-none-eabihf"><code>thumbv7em-none-eabi</code> and <code>thumbv7em-none-eabihf</code></a></li>
<li><a href="#thumbv8mbase-none-eabi"><code>thumbv8m.base-none-eabi</code></a></li>
<li><a href="#thumbv8mmain-none-eabi-and-thumbv8mmain-none-eabihf"><code>thumbv8m.main-none-eabi</code> and <code>thumbv8m.main-none-eabihf</code></a></li>
</ul>
</li>
<li><em>Legacy</em> Arm Architectures
<ul>
<li>None</li>
</ul>
</li>
</ul>
<h3 id="tier-3-target-list"><a class="header" href="#tier-3-target-list">Tier 3 Target List</a></h3>
<ul>
<li>Arm A-Profile Architectures
<ul>
<li><a href="#armv7a-none-eabi-and-armv7a-none-eabihf"><code>armv7a-none-eabihf</code></a></li>
</ul>
</li>
<li>Arm R-Profile Architectures
<ul>
<li>None</li>
</ul>
</li>
<li>Arm M-Profile Architectures
<ul>
<li>None</li>
</ul>
</li>
<li><em>Legacy</em> Arm Architectures
<ul>
<li><a href="#armv4t-none-eabi--thumbv4t-none-eabi"><code>armv4t-none-eabi</code> and <code>thumbv4t-none-eabi</code></a></li>
<li><a href="#armv5te-none-eabi"><code>armv5te-none-eabi</code> and <code>thumbv5te-none-eabi</code></a></li>
</ul>
</li>
</ul>
<h2 id="instruction-sets"><a class="header" href="#instruction-sets">Instruction Sets</a></h2>
<p>There are two 32-bit instruction set architectures (ISAs) defined by Arm:</p>
<ul>
<li>The <a href="https://developer.arm.com/Architectures/A32%20Instruction%20Set%20Architecture"><em>A32 ISA</em></a>, with fixed-width 32-bit instructions. Previously
known as the <em>Arm</em> ISA, this originated with the original ARM1 of 1985 and has
been updated by various revisions to the architecture specifications ever
since.</li>
<li>The <a href="https://developer.arm.com/Architectures/T32%20Instruction%20Set%20Architecture"><em>T32 ISA</em></a>, with a mix of 16-bit and 32-bit width instructions.
Note that this term includes both the original 16-bit width <em>Thumb</em> ISA
introduced with the Armv4T architecture in 1994, and the later 16/32-bit sized
<em>Thumb-2</em> ISA introduced with the Armv6T2 architecture in 2003. Again, these
ISAs have been revised by subsequent revisions to the relevant Arm
architecture specifications.</li>
</ul>
<p>There is also a 64-bit ISA with fixed-width 32-bit instructions called the <em>A64
ISA</em>, but targets which implement that instruction set generally start with
<code>aarch64*</code> and are discussed elsewhere.</p>
<p>Rust targets starting with <code>arm*</code> generate Arm (A32) code by default, whilst
targets named <code>thumb*</code> generate Thumb (T32) code by default. Most Arm chips
support both Thumb mode and Arm mode, with the notable exception that M-profile
processors (<code>thumbv*m*-none-eabi*</code> targets) <em>only</em> support Thumb-mode.</p>
<p>Rust targets ending with <code>eabi</code> use the so-called <em>soft-float ABI</em>: functions
which take <code>f32</code> or <code>f64</code> as arguments will have those values packed into
integer registers. This means that an FPU is not required from an ABI
perspective, but within a function floating-point instructions may still be used
if the code is compiled with a <code>target-cpu</code> or <code>target-feature</code> option that
enables FPU support.</p>
<p>Rust targets ending in <code>eabihf</code> use the so-called <em>hard-float ABI</em>: functions
which take <code>f32</code> or <code>f64</code> as arguments will have them passed via FPU registers.
These targets therefore require the availability of an FPU and will assume some
baseline level of floating-point support is available (which can vary depending
on the target). More advanced floating-point instructions may be generated if
the code is compiled with a <code>target-cpu</code> or <code>target-feature</code> option that enables
such additional FPU support. For example, if a given hard-float target has
baseline <em>single-precision</em> (<code>f32</code>) support in hardware, there may be
<code>target-cpu</code> or <code>target-feature</code> options that tell LLVM to assume your processor
in fact also has <em>double-precision</em> (<code>f64</code>) support.</p>
<p>You may of course use the <code>f32</code> and <code>f64</code> types in your code, regardless of the
ABI being used, or the level of support your processor has for performing such
operations in hardware. Any floating-point operations that LLVM assumes your
processor cannot support will be lowered to library calls (like <code>__aeabi_dadd</code>)
which perform the floating-point operation in software using integer
instructions.</p>
<h2 id="target-cpu-and-target-feature-options-1"><a class="header" href="#target-cpu-and-target-feature-options-1">Target CPU and Target Feature options</a></h2>
<p>It is possible to tell Rust (or LLVM) that you have a specific model of Arm
processor, using the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#target-cpu"><code>-C target-cpu</code></a> option. You can also control
whether Rust (or LLVM) will include instructions that target optional hardware
features, e.g. hardware floating-point, or Advanced SIMD operations, using <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#target-feature"><code>-C target-feature</code></a>.</p>
<p>It is important to note that selecting a <em>target-cpu</em> will typically enable
<em>all</em> the optional features available from Arm on that model of CPU and your
particular implementation of that CPU may not have those features available. In
that case, you can use <code>-C target-feature=-option</code> to turn off the specific CPU
features you do not have available, leaving you with the optimized instruction
scheduling and support for the features you do have. More details are available
in the detailed target-specific documentation.</p>
<div class="warning">
<p>Many target-features are currently unstable and subject to change, and
if you use them you should disassemble the compiler output and manually inspect
it to ensure only appropriate instructions for your CPU have been generated.</p>
</div>

<p>If you wish to use the <em>target-cpu</em> and <em>target-feature</em> options, you can add
them to your <code>.cargo/config.toml</code> file alongside any other flags your project
uses (likely linker related ones):</p>
<pre><code class="language-toml">rustflags = [
  # Usual Arm bare-metal linker setup
  "-Clink-arg=-Tlink.x",
  "-Clink-arg=--nmagic",
  # tell Rust we have a Cortex-M55
  "-Ctarget-cpu=cortex-m55",
  # tell Rust our Cortex-M55 doesn't have Floating-Point M-Profile Vector
  # Extensions (but it does have everything else a Cortex-M55 could have).
  "-Ctarget-feature=-mve.fp"
]

[build]
target = "thumbv8m.main-none-eabihf"
</code></pre>
<h2 id="requirements-20"><a class="header" href="#requirements-20">Requirements</a></h2>
<p>These targets are cross-compiled and use static linking.</p>
<p>By default, the <code>lld</code> linker included with Rust will be used; however, you may
want to use the GNU linker instead. This can be obtained for Windows/Mac/Linux
from the <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">Arm Developer Website</a>, or possibly from your OS’s
package manager. To use it, add the following to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.&lt;your-target&gt;]
linker = "arm-none-eabi-ld"
</code></pre>
<p>The GNU linker can also be used by specifying <code>arm-none-eabi-gcc</code> as the
linker. This is needed when using GCC’s link time optimization.</p>
<p>These targets don’t provide a linker script, so you’ll need to bring your own
according to the specific device you are using. Pass
<code>-Clink-arg=-Tyour_script.ld</code> as a rustc argument to make the linker use
<code>your_script.ld</code> during linking.</p>
<p>For the <code>arm*</code> targets, Thumb-mode code generation can be enabled by using <code>-C target-feature=+thumb-mode</code>. Using the unstable
<code>#![feature(arm_target_feature)]</code>, the attribute <code>#[target_feature(enable = "thumb-mode")]</code> can be applied to individual <code>unsafe</code> functions to cause those
functions to be compiled to Thumb-mode code.</p>
<h2 id="building-rust-programs-17"><a class="header" href="#building-rust-programs-17">Building Rust Programs</a></h2>
<p>For the Tier 3 targets in this family, rust does not ship pre-compiled
artifacts.</p>
<p>Just use the <code>build-std</code> nightly cargo feature to build the <code>core</code> library. You
can pass this as a command line argument to cargo, or your <code>.cargo/config.toml</code>
file might include the following lines:</p>
<pre><code class="language-toml">[unstable]
build-std = ["core"]
</code></pre>
<p>Most of <code>core</code> should work as expected, with the following notes:</p>
<ul>
<li>Floating-point operations are emulated in software unless LLVM is told to
enable FPU support (either by using an <code>eabihf</code> target, specifying a
<code>target-cpu</code> with FPU support, or using a <code>target-feature</code> to support for a
specific kind of FPU)</li>
<li>Integer division is also emulated in software on some targets, depending on
the target, <code>target-cpu</code> and <code>target-feature</code>s.</li>
<li>Older Arm architectures (e.g. Armv4, Armv5TE and Armv6-M) are limited to basic
<a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicU32.html#method.load"><code>load</code></a> and <a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicU32.html#method.store"><code>store</code></a> operations, and not more
advanced operations like <a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicU32.html#method.fetch_add"><code>fetch_add</code></a> or
<a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicU32.html#method.compare_exchange"><code>compare_exchange</code></a>.</li>
</ul>
<p><code>alloc</code> is also supported, as long as you provide your own global allocator.</p>
<p>Rust programs are output as ELF files.</p>
<h2 id="testing-18"><a class="header" href="#testing-18">Testing</a></h2>
<p>This is a cross-compiled target that you will need to emulate during testing.</p>
<p>The exact emulator that you’ll need depends on the specific device you want to
run your code on.</p>
<h2 id="cross-compilation-toolchains-and-c-code-9"><a class="header" href="#cross-compilation-toolchains-and-c-code-9">Cross-compilation toolchains and C code</a></h2>
<p>The target supports C code compiled with the <code>arm-none-eabi</code> target triple and
a suitable <code>-march</code> or <code>-mcpu</code> flag.</p>
<p><code>gcc</code> or <code>clang</code> can be used, but note that <code>gcc</code> uses <code>-fshort-enums</code> by
default for <code>arm-none*</code> targets, while <code>clang</code> does not. <code>rustc</code> matches the
<code>gcc</code> behavior, i.e., the size of a <code>#[repr(C)] enum</code> in Rust can be as little
as 1 byte, rather than 4, as they are on <code>arm-linux</code> targets.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv4t-none-eabi--thumbv4t-none-eabi"><a class="header" href="#armv4t-none-eabi--thumbv4t-none-eabi">armv4t-none-eabi / thumbv4t-none-eabi</a></h1>
<ul>
<li><strong>Tier:  3</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>These two targets are part of the <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> target
group, and all the information there applies.</p>
<p>Both of these targets can be used on the Game Boy Advance (GBA), among other
things. On the GBA, one should usually use the <code>thumb</code> target to get the best
overall performance.  Note that this architecture only supports the old
Thumb-1 instruction set, not the later Thumb-2 instruction set.</p>
<h2 id="target-maintainers-20"><a class="header" href="#target-maintainers-20">Target Maintainers</a></h2>
<p><a href="https://github.com/lokathor">@Lokathor</a>
<a href="https://github.com/corwinkuiper">@corwinkuiper</a></p>
<h2 id="testing-19"><a class="header" href="#testing-19">Testing</a></h2>
<p>This is a cross-compiled target that you will need to emulate during testing.</p>
<p>Because this is a device-agnostic target, and the exact emulator that you’ll
need depends on the specific device you want to run your code on.</p>
<ul>
<li>When building for the GBA, <a href="https://github.com/agbrs/agb">mgba-test-runner</a>
can be used to make a normal set of rust tests be run within the <code>mgba</code>
emulator.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv5te-none-eabi"><a class="header" href="#armv5te-none-eabi"><code>armv5te-none-eabi</code></a></h1>
<ul>
<li><strong>Tier: 3</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for any cpu in the Armv5TE architecture family, supporting
ARM/Thumb code interworking (aka <code>Arm</code>/<code>Thumb</code>), with <code>Arm</code> code as the
default code generation.</p>
<p>The <code>thumbv5te-none-eabi</code> target is the same as this one, but the instruction
set defaults to <code>Thumb</code>. Note that this architecture only supports the old
Thumb-1 instruction set, not the later Thumb-2 instruction set.</p>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<h2 id="target-maintainers-21"><a class="header" href="#target-maintainers-21">Target Maintainers</a></h2>
<p><a href="https://github.com/QuinnPainter">@QuinnPainter</a></p>
<h2 id="testing-20"><a class="header" href="#testing-20">Testing</a></h2>
<p>This is a cross-compiled target that you will need to emulate during testing.</p>
<p>Because this is a device-agnostic target, and the exact emulator that you’ll
need depends on the specific device you want to run your code on.</p>
<p>For example, when programming for the DS, you can use one of the several
available DS emulators, such as <a href="https://melonds.kuribo64.net/">melonDS</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7a-none-eabi-and-armv7a-none-eabihf"><a class="header" href="#armv7a-none-eabi-and-armv7a-none-eabihf"><code>armv7a-none-eabi</code> and <code>armv7a-none-eabihf</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the Armv7-A architecture family, supporting
dual ARM/Thumb mode, with ARM mode as the default.</p>
<p>Note, this is for processors running in AArch32 mode. For the AArch64 mode
added in Armv8-A, see <a href="#aarch64-unknown-none-and-aarch64-unknown-none-softfloat"><code>aarch64-unknown-none</code></a> instead.</p>
<p>Processors in this family include the <a href="https://en.wikipedia.org/wiki/ARM_Cortex-A">Arm Cortex-A5, 8, 32, etc</a>.</p>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<h2 id="target-maintainers-22"><a class="header" href="#target-maintainers-22">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="requirements-21"><a class="header" href="#requirements-21">Requirements</a></h2>
<p>Almost all Armv7-A processors include an FPU (a VFPv3 or a VFPv4). The
difference between the <code>-eabi</code> and <code>-eabihf</code> targets is whether the FPU is
used for passing function arguments. You may prefer the <code>-eabi</code> soft-float
target when the processor does not have a floating point unit or the compiled
code should not use the floating point unit.</p>
<p>When using the hardfloat targets, the minimum floating-point features assumed
are those of the VFPv3-D16, which includes single- and double-precision, with
16 double-precision registers. This floating-point unit appears in Cortex-A8
and Cortex-A9 processors. See <a href="https://developer.arm.com/documentation/den0013/0400/Floating-Point/Floating-point-basics-and-the-IEEE-754-standard/ARM-VFP">VFP in the Cortex-A processors</a> for more
details on the possible FPU variants.</p>
<p>If your processor supports a different set of floating-point features than the
default expectations of VFPv3-D16, then these should also be enabled or
disabled as needed with <code>-C target-feature=(+/-)</code>.</p>
<p>In general, the following four combinations are possible:</p>
<ul>
<li>VFPv3-D16, target feature <code>+vfp3</code> and <code>-d32</code></li>
<li>VFPv3-D32, target feature <code>+vfp3</code> and <code>+d32</code></li>
<li>VFPv4-D16, target feature <code>+vfp4</code> and <code>-d32</code></li>
<li>VFPv4-D32, target feature <code>+vfp4</code> and <code>+d32</code></li>
</ul>
<p>An Armv7-A processor may optionally include a NEON hardware unit which
provides Single Instruction Multiple Data (SIMD) operations. The
implementation of this unit implies VFPv3-D32. The target feature <code>+neon</code> may
be added to inform the compiler about the availability of NEON.</p>
<p>You can refer to the <a href="#armthumb-none-eabihf">arm-none-eabi</a> documentation for a
generic guide on target feature and target CPU specification and how to enable
and disable them via <code>.cargo/config.toml</code> file.</p>
<h2 id="start-up-and-low-level-code-1"><a class="header" href="#start-up-and-low-level-code-1">Start-up and Low-Level Code</a></h2>
<p>The <a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a> maintain the <a href="https://docs.rs/aarch32-cpu"><code>aarch32-cpu</code></a>
and <a href="https://docs.rs/aarch32-rt"><code>aarch32-rt</code></a> crates, which may be useful for writing bare-metal code
using this target. Those crates include several examples which run in QEMU and
build using these targets.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7r-none-eabi-and-armv7r-none-eabihf"><a class="header" href="#armv7r-none-eabi-and-armv7r-none-eabihf"><code>armv7r-none-eabi</code> and <code>armv7r-none-eabihf</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the Armv7-R architecture family, supporting
dual ARM/Thumb mode, with ARM mode as the default.</p>
<p>Processors in this family include the <a href="https://en.wikipedia.org/wiki/ARM_Cortex-R">Arm Cortex-R4, 5, 7, and 8</a>.</p>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<h2 id="target-maintainers-23"><a class="header" href="#target-maintainers-23">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/chrisnc">@chrisnc</a></li>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="requirements-22"><a class="header" href="#requirements-22">Requirements</a></h2>
<p>When using the hardfloat targets, the minimum floating-point features assumed
are those of the <code>vfpv3-d16</code>, which includes single- and double-precision, with
16 double-precision registers. This floating-point unit appears in Cortex-R4F
and Cortex-R5F processors. See <a href="https://developer.arm.com/documentation/den0042/a/Floating-Point/Floating-point-basics-and-the-IEEE-754-standard/VFP-in-the-Cortex-R-processors">VFP in the Cortex-R processors</a>
for more details on the possible FPU variants.</p>
<p>If your processor supports a different set of floating-point features than the
default expectations of <code>vfpv3-d16</code>, then these should also be enabled or
disabled as needed with <code>-C target-feature=(+/-)</code>.</p>
<h2 id="start-up-and-low-level-code-2"><a class="header" href="#start-up-and-low-level-code-2">Start-up and Low-Level Code</a></h2>
<p>The <a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a> maintain the <a href="https://docs.rs/aarch32-cpu"><code>aarch32-cpu</code></a>
and <a href="https://docs.rs/aarch32-rt"><code>aarch32-rt</code></a> crates, which may be useful for writing bare-metal code
using this target. Those crates include several examples which run in QEMU and
build using these targets.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armebv7r-none-eabi-and-armebv7r-none-eabihf"><a class="header" href="#armebv7r-none-eabi-and-armebv7r-none-eabihf"><code>armebv7r-none-eabi</code> and <code>armebv7r-none-eabihf</code></a></h1>
<ul>
<li><strong>Tier: 3</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the Armv7-R architecture family running in Big
Endian mode. These processors support dual ARM/Thumb mode, with ARM mode as
the default.</p>
<p><strong>NOTE:</strong> You should almost always prefer the <a href="#armv7r-none-eabi-and-armv7r-none-eabihf">little-endian
versions</a> of these target. Big Endian Arm systems are
highly unusual.</p>
<p>Processors in this family include the <a href="https://en.wikipedia.org/wiki/ARM_Cortex-R">Arm Cortex-R4, 5, 7, and 8</a>.</p>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<h2 id="target-maintainers-24"><a class="header" href="#target-maintainers-24">Target maintainers</a></h2>
<p><a href="https://github.com/chrisnc">@chrisnc</a></p>
<h2 id="requirements-23"><a class="header" href="#requirements-23">Requirements</a></h2>
<p>Note that some variants of the Cortex-R have both big-endian instructions and
data. This configuration is known as BE-32, while data-only big-endianness is
known as BE-8. To build programs for BE-32 processors, the GNU linker must be
used with the <code>-mbe32</code> option. See <a href="https://developer.arm.com/documentation/den0042/a/Coding-for-Cortex-R-Processors/Endianness">ARM Cortex-R Series Programmer’s Guide:
Endianness</a> for more details about different endian modes.</p>
<p>When using the hardfloat targets, the minimum floating-point features assumed
are those of the <code>vfpv3-d16</code>, which includes single- and double-precision, with
16 double-precision registers. This floating-point unit appears in Cortex-R4F
and Cortex-R5F processors. See <a href="https://developer.arm.com/documentation/den0042/a/Floating-Point/Floating-point-basics-and-the-IEEE-754-standard/VFP-in-the-Cortex-R-processors">VFP in the Cortex-R processors</a>
for more details on the possible FPU variants.</p>
<p>If your processor supports a different set of floating-point features than the
default expectations of <code>vfpv3-d16</code>, then these should also be enabled or
disabled as needed with <code>-C target-feature=(+/-)</code>.</p>
<h2 id="start-up-and-low-level-code-3"><a class="header" href="#start-up-and-low-level-code-3">Start-up and Low-Level Code</a></h2>
<p>The [Rust Embedded Devices Working Group Arm Team] maintain the <a href="https://docs.rs/aarch32-cpu"><code>aarch32-cpu</code></a>
and <a href="https://docs.rs/aarch32-rt"><code>aarch32-rt</code></a> crates, which may be useful for writing bare-metal code
using this target. Those crates include several examples which run in QEMU and
build using these targets.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv8r-none-eabihf"><a class="header" href="#armv8r-none-eabihf"><code>armv8r-none-eabihf</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the Armv8-R architecture family, supporting
dual ARM/Thumb mode, with ARM mode as the default.</p>
<p>Processors in this family include the Arm <a href="https://www.arm.com/products/silicon-ip-cpu/cortex-r/cortex-r52">Cortex-R52</a>
and <a href="https://www.arm.com/products/silicon-ip-cpu/cortex-r/cortex-r52-plus">Cortex-R52+</a>.</p>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<h2 id="target-maintainers-25"><a class="header" href="#target-maintainers-25">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/chrisnc">@chrisnc</a></li>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="requirements-24"><a class="header" href="#requirements-24">Requirements</a></h2>
<p>The Cortex-R52 family always includes a floating-point unit, so there is no
non-<code>hf</code> version of this target. The floating-point features assumed by this
target are those of the single-precision-only config of the Cortex-R52, which
has 16 double-precision registers, accessible as 32 single-precision registers.
The other variant of Cortex-R52 includes double-precision, 32 double-precision
registers, and Advanced SIMD (Neon).</p>
<p>The manual refers to this as the “Full Advanced SIMD config”. To compile code
for this variant, use: <code>-C target-feature=+fp64,+d32,+neon</code>. See the <a href="https://developer.arm.com/documentation/100026/0104/Advanced-SIMD-and-floating-point-support/About-the-Advanced-SIMD-and-floating-point-support">Advanced
SIMD and floating-point support</a> section of the Cortex-R52 Processor
Technical Reference Manual for more details.</p>
<h3 id="table-of-supported-cpus-for-armv8r-none-eabihf"><a class="header" href="#table-of-supported-cpus-for-armv8r-none-eabihf">Table of supported CPUs for <code>armv8r-none-eabihf</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">CPU</th><th>FPU</th><th style="text-align: left">Neon</th><th style="text-align: left">Target CPU</th><th style="text-align: left">Target Features</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left">Any</td><td>SP</td><td style="text-align: left">No</td><td style="text-align: left">None</td><td style="text-align: left">None</td></tr>
<tr><td style="text-align: left">Cortex-R52</td><td>SP</td><td style="text-align: left">No</td><td style="text-align: left"><code>cortex-r52</code></td><td style="text-align: left"><code>-fp64,-d32,-neon</code></td></tr>
<tr><td style="text-align: left">Cortex-R52</td><td>DP</td><td style="text-align: left">No</td><td style="text-align: left"><code>cortex-r52</code></td><td style="text-align: left"><code>-neon</code></td></tr>
<tr><td style="text-align: left">Cortex-R52</td><td>DP</td><td style="text-align: left">Yes</td><td style="text-align: left"><code>cortex-r52</code></td><td style="text-align: left">None</td></tr>
<tr><td style="text-align: left">Cortex-R52+</td><td>SP</td><td style="text-align: left">No</td><td style="text-align: left"><code>cortex-r52plus</code></td><td style="text-align: left"><code>-fp64,-d32,-neon</code></td></tr>
<tr><td style="text-align: left">Cortex-R52+</td><td>DP</td><td style="text-align: left">No</td><td style="text-align: left"><code>cortex-r52plus</code></td><td style="text-align: left"><code>-neon</code></td></tr>
<tr><td style="text-align: left">Cortex-R52+</td><td>DP</td><td style="text-align: left">Yes</td><td style="text-align: left"><code>cortex-r52plus</code></td><td style="text-align: left">None</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="thumbv6m-none-eabi"><a class="header" href="#thumbv6m-none-eabi"><code>thumbv6m-none-eabi</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the <a href="https://developer.arm.com/documentation/ddi0419/latest/">Armv6-M</a> architecture family, supporting a
subset of the <a href="https://developer.arm.com/Architectures/T32%20Instruction%20Set%20Architecture">T32 ISA</a>.</p>
<p>Processors in this family include the:</p>
<ul>
<li><a href="https://developer.arm.com/Processors/Cortex-M0">Arm Cortex-M0</a></li>
<li><a href="https://developer.arm.com/Processors/Cortex-M0+">Arm Cortex-M0+</a></li>
<li><a href="https://developer.arm.com/Processors/Cortex-M1">Arm Cortex-M1</a></li>
</ul>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<p>This target uses the soft-float ABI: functions which take <code>f32</code> or <code>f64</code> as
arguments will have those values packed into integer registers. This is the
only option because there is no FPU support in <a href="https://developer.arm.com/documentation/ddi0419/latest/">Armv6-M</a>.</p>
<h2 id="target-maintainers-26"><a class="header" href="#target-maintainers-26">Target maintainers</a></h2>
<p><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></p>
<h2 id="target-cpu-and-target-feature-options-2"><a class="header" href="#target-cpu-and-target-feature-options-2">Target CPU and Target Feature options</a></h2>
<p>See <a href="#target-cpu-and-target-feature-options-1">the bare-metal Arm
docs</a> for details on how
to use these flags.</p>
<h3 id="table-of-supported-cpus"><a class="header" href="#table-of-supported-cpus">Table of supported CPUs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CPU</th><th>FPU</th><th>Target CPU</th><th>Target Features</th></tr>
</thead>
<tbody>
<tr><td>Cortex-M0</td><td>No</td><td><code>cortex-m0</code></td><td>None</td></tr>
<tr><td>Cortex-M0+</td><td>No</td><td><code>cortex-m0plus</code></td><td>None</td></tr>
<tr><td>Cortex-M1</td><td>No</td><td><code>cortex-m1</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<h3 id="arm-cortex-m0"><a class="header" href="#arm-cortex-m0">Arm Cortex-M0</a></h3>
<p>The target CPU option is <code>cortex-m0</code>.</p>
<p>There are no relevant feature flags, and the FPU is not available.</p>
<h3 id="arm-cortex-m0-1"><a class="header" href="#arm-cortex-m0-1">Arm Cortex-M0+</a></h3>
<p>The target CPU option is <code>cortex-m0plus</code>.</p>
<p>There are no relevant feature flags, and the FPU is not available.</p>
<h3 id="arm-cortex-m1"><a class="header" href="#arm-cortex-m1">Arm Cortex-M1</a></h3>
<p>The target CPU option is <code>cortex-m1</code>.</p>
<p>There are no relevant feature flags, and the FPU is not available.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="thumbv7em-none-eabi-and-thumbv7em-none-eabihf"><a class="header" href="#thumbv7em-none-eabi-and-thumbv7em-none-eabihf"><code>thumbv7em-none-eabi</code> and <code>thumbv7em-none-eabihf</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the <a href="https://developer.arm.com/documentation/ddi0403/latest/">Armv7E-M</a> architecture family, supporting a
subset of the <a href="https://developer.arm.com/Architectures/T32%20Instruction%20Set%20Architecture">T32 ISA</a>.</p>
<p>Processors in this family include the:</p>
<ul>
<li><a href="https://developer.arm.com/Processors/Cortex-M4">Arm Cortex-M4</a> and Arm Cortex-M4F</li>
<li><a href="https://developer.arm.com/Processors/Cortex-M7">Arm Cortex-M7</a> and Arm Cortex-M7F</li>
</ul>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets, in particular the difference between the <code>eabi</code> and
<code>eabihf</code> ABI.</p>
<h2 id="target-maintainers-27"><a class="header" href="#target-maintainers-27">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="target-cpu-and-target-feature-options-3"><a class="header" href="#target-cpu-and-target-feature-options-3">Target CPU and Target Feature options</a></h2>
<p>See <a href="#target-cpu-and-target-feature-options-1">the bare-metal Arm
docs</a> for details on how
to use these flags.</p>
<h3 id="table-of-supported-cpus-for-thumbv7em-none-eabi"><a class="header" href="#table-of-supported-cpus-for-thumbv7em-none-eabi">Table of supported CPUs for <code>thumbv7em-none-eabi</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CPU</th><th>FPU</th><th>DSP</th><th>Target CPU</th><th>Target Features</th></tr>
</thead>
<tbody>
<tr><td>Any</td><td>No</td><td>Yes</td><td>None</td><td>None</td></tr>
<tr><td>Cortex-M4</td><td>No</td><td>Yes</td><td><code>cortex-m4</code></td><td><code>-fpregs</code></td></tr>
<tr><td>Cortex-M4F</td><td>SP</td><td>Yes</td><td><code>cortex-m4</code></td><td>None</td></tr>
<tr><td>Cortex-M7</td><td>No</td><td>Yes</td><td><code>cortex-m7</code></td><td><code>-fpregs</code></td></tr>
<tr><td>Cortex-M7F</td><td>SP</td><td>Yes</td><td><code>cortex-m7</code></td><td><code>-fp64</code></td></tr>
<tr><td>Cortex-M7F</td><td>DP</td><td>Yes</td><td><code>cortex-m7</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<h3 id="table-of-supported-cpus-for-thumbv7em-none-eabihf"><a class="header" href="#table-of-supported-cpus-for-thumbv7em-none-eabihf">Table of supported CPUs for <code>thumbv7em-none-eabihf</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CPU</th><th>FPU</th><th>DSP</th><th>Target CPU</th><th>Target Features</th></tr>
</thead>
<tbody>
<tr><td>Any</td><td>SP</td><td>Yes</td><td>None</td><td>None</td></tr>
<tr><td>Cortex-M4F</td><td>SP</td><td>Yes</td><td><code>cortex-m4</code></td><td>None</td></tr>
<tr><td>Cortex-M7F</td><td>SP</td><td>Yes</td><td><code>cortex-m7</code></td><td><code>-fp64</code></td></tr>
<tr><td>Cortex-M7F</td><td>DP</td><td>Yes</td><td><code>cortex-m7</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<div class="warning">
<p>Never use the <code>-fpregs</code> <em>target-feature</em> with the <code>thumbv7em-none-eabihf</code> target
as it will cause compilation units to have different ABIs, which is unsound.</p>
</div>

<h3 id="arm-cortex-m4-and-arm-cortex-m4f"><a class="header" href="#arm-cortex-m4-and-arm-cortex-m4f">Arm Cortex-M4 and Arm Cortex-M4F</a></h3>
<p>The target CPU is <code>cortex-m4</code>.</p>
<ul>
<li>All Cortex-M4 have DSP extensions
<ul>
<li>support is controlled by the <code>dsp</code> <em>target-feature</em></li>
<li>enabled by default with this <em>target</em></li>
</ul>
</li>
<li>Cortex-M4F has a single precision FPU
<ul>
<li>support is enabled by default with this <em>target-cpu</em></li>
<li>disable support using the <code>-fpregs</code> <em>target-feature</em> (<code>eabi</code> only)</li>
</ul>
</li>
</ul>
<h3 id="arm-cortex-m7-and-arm-cortex-m7f"><a class="header" href="#arm-cortex-m7-and-arm-cortex-m7f">Arm Cortex-M7 and Arm Cortex-M7F</a></h3>
<p>The target CPU is <code>cortex-m7</code>.</p>
<ul>
<li>All Cortex-M7 have DSP extensions
<ul>
<li>support is controlled by the <code>dsp</code> <em>target-feature</em></li>
<li>enabled by default with this <em>target</em></li>
</ul>
</li>
<li>Cortex-M7F have either a single-precision or double-precision FPU
<ul>
<li>double-precision support is enabled by default with this <em>target-cpu</em>
<ul>
<li>opt-out by using the <code>-f64</code> <em>target-feature</em></li>
</ul>
</li>
<li>disable support entirely using the <code>-fpregs</code> <em>target-feature</em> (<code>eabi</code> only)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="thumbv7m-none-eabi"><a class="header" href="#thumbv7m-none-eabi"><code>thumbv7m-none-eabi</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the <a href="https://developer.arm.com/documentation/ddi0403/latest/">Armv7-M</a> architecture family, supporting a
subset of the <a href="https://developer.arm.com/Architectures/T32%20Instruction%20Set%20Architecture">T32 ISA</a>.</p>
<p>Processors in this family include the:</p>
<ul>
<li><a href="https://developer.arm.com/Processors/Cortex-M3">Arm Cortex-M3</a></li>
</ul>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<p>This target uses the soft-float ABI: functions which take <code>f32</code> or <code>f64</code> as
arguments will have those values packed into integer registers. This is the
only option because there is no FPU support in <a href="https://developer.arm.com/documentation/ddi0403/latest/">Armv7-M</a>.</p>
<h2 id="target-maintainers-28"><a class="header" href="#target-maintainers-28">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="target-cpu-and-target-feature-options-4"><a class="header" href="#target-cpu-and-target-feature-options-4">Target CPU and Target Feature options</a></h2>
<p>See <a href="#target-cpu-and-target-feature-options-1">the bare-metal Arm
docs</a> for details on how
to use these flags.</p>
<h3 id="table-of-supported-cpus-1"><a class="header" href="#table-of-supported-cpus-1">Table of supported CPUs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CPU</th><th>FPU</th><th>Target CPU</th><th>Target Features</th></tr>
</thead>
<tbody>
<tr><td>Cortex-M3</td><td>No</td><td><code>cortex-m3</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<h3 id="arm-cortex-m3"><a class="header" href="#arm-cortex-m3">Arm Cortex-M3</a></h3>
<p>The target CPU option is <code>cortex-m3</code>.</p>
<p>There are no relevant feature flags, and the FPU is not available.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="thumbv8mbase-none-eabi"><a class="header" href="#thumbv8mbase-none-eabi"><code>thumbv8m.base-none-eabi</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the Baseline <a href="https://developer.arm.com/documentation/ddi0553/latest/">Armv8-M</a> architecture family,
supporting a subset of the <a href="https://developer.arm.com/Architectures/T32%20Instruction%20Set%20Architecture">T32 ISA</a>.</p>
<p>Processors in this family include the:</p>
<ul>
<li><a href="https://developer.arm.com/Processors/Cortex-M23">Arm Cortex-M23</a></li>
</ul>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets.</p>
<p>This target uses the soft-float ABI: functions which take <code>f32</code> or <code>f64</code> as
arguments will have those values packed into integer registers. This is the
only option because there is no FPU support in <a href="https://developer.arm.com/documentation/ddi0553/latest/">Armv8-M</a> Baseline.</p>
<h2 id="target-maintainers-29"><a class="header" href="#target-maintainers-29">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="target-cpu-and-target-feature-options-5"><a class="header" href="#target-cpu-and-target-feature-options-5">Target CPU and Target Feature options</a></h2>
<p>See <a href="#target-cpu-and-target-feature-options-1">the bare-metal Arm
docs</a> for details on how
to use these flags.</p>
<h3 id="table-of-supported-cpus-2"><a class="header" href="#table-of-supported-cpus-2">Table of supported CPUs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CPU</th><th>FPU</th><th>Target CPU</th><th>Target Features</th></tr>
</thead>
<tbody>
<tr><td>Cortex-M23</td><td>No</td><td><code>cortex-m23</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<h3 id="arm-cortex-m23"><a class="header" href="#arm-cortex-m23">Arm Cortex-M23</a></h3>
<p>The target CPU option is <code>cortex-m23</code>.</p>
<p>There are no relevant feature flags, and the FPU is not available.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="thumbv8mmain-none-eabi-and-thumbv8mmain-none-eabihf"><a class="header" href="#thumbv8mmain-none-eabi-and-thumbv8mmain-none-eabihf"><code>thumbv8m.main-none-eabi</code> and <code>thumbv8m.main-none-eabihf</code></a></h1>
<ul>
<li><strong>Tier: 2</strong></li>
<li><strong>Library Support:</strong> core and alloc (bare-metal, <code>#![no_std]</code>)</li>
</ul>
<p>Bare-metal target for CPUs in the Mainline <a href="https://developer.arm.com/documentation/ddi0553/latest/">Armv8-M</a> architecture family,
supporting a subset of the <a href="https://developer.arm.com/Architectures/T32%20Instruction%20Set%20Architecture">T32 ISA</a>.</p>
<p>Processors in this family include the:</p>
<ul>
<li><a href="https://developer.arm.com/Processors/Cortex-M33">Arm Cortex-M33</a></li>
<li><a href="https://developer.arm.com/Processors/Cortex-M35P">Arm Cortex-M35P</a></li>
<li><a href="https://developer.arm.com/Processors/Cortex-M55">Arm Cortex-M55</a></li>
<li><a href="https://developer.arm.com/Processors/Cortex-M85">Arm Cortex-M85</a></li>
</ul>
<p>See <a href="#armthumb-none-eabihf"><code>arm-none-eabi</code></a> for information applicable to all
<code>arm-none-eabi</code> targets, in particular the difference between the <code>eabi</code> and
<code>eabihf</code> ABI.</p>
<h2 id="target-maintainers-30"><a class="header" href="#target-maintainers-30">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-embedded/wg?tab=readme-ov-file#the-arm-team">Rust Embedded Devices Working Group Arm Team</a></li>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="target-cpu-and-target-feature-options-6"><a class="header" href="#target-cpu-and-target-feature-options-6">Target CPU and Target Feature options</a></h2>
<p>See <a href="#target-cpu-and-target-feature-options-1">the bare-metal Arm
docs</a> for details on how
to use these flags.</p>
<h3 id="table-of-supported-cpus-for-thumbv8mmain-none-eabi"><a class="header" href="#table-of-supported-cpus-for-thumbv8mmain-none-eabi">Table of supported CPUs for <code>thumbv8m.main-none-eabi</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CPU</th><th>FPU</th><th>DSP</th><th>MVE</th><th>Target CPU</th><th>Target Features</th></tr>
</thead>
<tbody>
<tr><td>Unspecified</td><td>No</td><td>No</td><td>No</td><td>None</td><td>None</td></tr>
<tr><td>Cortex-M33</td><td>No</td><td>No</td><td>No</td><td><code>cortex-m33</code></td><td><code>-fpregs,-dsp</code></td></tr>
<tr><td>Cortex-M33</td><td>No</td><td>Yes</td><td>No</td><td><code>cortex-m33</code></td><td><code>-fpregs</code></td></tr>
<tr><td>Cortex-M33</td><td>SP</td><td>No</td><td>No</td><td><code>cortex-m33</code></td><td><code>-dsp</code></td></tr>
<tr><td>Cortex-M33</td><td>SP</td><td>Yes</td><td>No</td><td><code>cortex-m33</code></td><td>None</td></tr>
<tr><td>Cortex-M35P</td><td>No</td><td>No</td><td>No</td><td><code>cortex-m35p</code></td><td><code>-fpregs,-dsp</code></td></tr>
<tr><td>Cortex-M35P</td><td>No</td><td>Yes</td><td>No</td><td><code>cortex-m35p</code></td><td><code>-fpregs</code></td></tr>
<tr><td>Cortex-M35P</td><td>SP</td><td>No</td><td>No</td><td><code>cortex-m35p</code></td><td><code>-dsp</code></td></tr>
<tr><td>Cortex-M35P</td><td>SP</td><td>Yes</td><td>No</td><td><code>cortex-m35p</code></td><td>None</td></tr>
<tr><td>Cortex-M55</td><td>No</td><td>Yes</td><td>No</td><td><code>cortex-m55</code></td><td><code>-fpregs,-mve</code></td></tr>
<tr><td>Cortex-M55</td><td>DP</td><td>Yes</td><td>No</td><td><code>cortex-m55</code></td><td><code>-mve</code></td></tr>
<tr><td>Cortex-M55</td><td>No</td><td>Yes</td><td>Int</td><td><code>cortex-m55</code></td><td><code>-fpregs,-mve.fp,+mve</code></td></tr>
<tr><td>Cortex-M55</td><td>DP</td><td>Yes</td><td>Int</td><td><code>cortex-m55</code></td><td><code>-mve.fp</code></td></tr>
<tr><td>Cortex-M55</td><td>DP</td><td>Yes</td><td>Int+Float</td><td><code>cortex-m55</code></td><td>None</td></tr>
<tr><td>Cortex-M85</td><td>No</td><td>Yes</td><td>No</td><td><code>cortex-m85</code></td><td><code>-fpregs,-mve</code></td></tr>
<tr><td>Cortex-M85</td><td>DP</td><td>Yes</td><td>No</td><td><code>cortex-m85</code></td><td><code>-mve</code></td></tr>
<tr><td>Cortex-M85</td><td>No</td><td>Yes</td><td>Int</td><td><code>cortex-m85</code></td><td><code>-fpregs,-mve.fp,+mve</code></td></tr>
<tr><td>Cortex-M85</td><td>DP</td><td>Yes</td><td>Int</td><td><code>cortex-m85</code></td><td><code>-mve.fp</code></td></tr>
<tr><td>Cortex-M85</td><td>DP</td><td>Yes</td><td>Int+Float</td><td><code>cortex-m85</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<h3 id="table-of-supported-cpus-for-thumbv8mmain-none-eabihf"><a class="header" href="#table-of-supported-cpus-for-thumbv8mmain-none-eabihf">Table of supported CPUs for <code>thumbv8m.main-none-eabihf</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>CPU</th><th>FPU</th><th>DSP</th><th>MVE</th><th>Target CPU</th><th>Target Features</th></tr>
</thead>
<tbody>
<tr><td>Unspecified</td><td>SP</td><td>No</td><td>No</td><td>None</td><td>None</td></tr>
<tr><td>Cortex-M33</td><td>SP</td><td>No</td><td>No</td><td><code>cortex-m33</code></td><td><code>-dsp</code></td></tr>
<tr><td>Cortex-M33</td><td>SP</td><td>Yes</td><td>No</td><td><code>cortex-m33</code></td><td>None</td></tr>
<tr><td>Cortex-M33P</td><td>SP</td><td>No</td><td>No</td><td><code>cortex-m35p</code></td><td><code>-dsp</code></td></tr>
<tr><td>Cortex-M33P</td><td>SP</td><td>Yes</td><td>No</td><td><code>cortex-m35p</code></td><td>None</td></tr>
<tr><td>Cortex-M55</td><td>DP</td><td>Yes</td><td>No</td><td><code>cortex-m55</code></td><td><code>-mve</code></td></tr>
<tr><td>Cortex-M55</td><td>DP</td><td>Yes</td><td>Int</td><td><code>cortex-m55</code></td><td><code>-mve.fp</code></td></tr>
<tr><td>Cortex-M55</td><td>DP</td><td>Yes</td><td>Int+Float</td><td><code>cortex-m55</code></td><td>None</td></tr>
<tr><td>Cortex-M85</td><td>DP</td><td>Yes</td><td>No</td><td><code>cortex-m85</code></td><td><code>-mve</code></td></tr>
<tr><td>Cortex-M85</td><td>DP</td><td>Yes</td><td>Int</td><td><code>cortex-m85</code></td><td><code>-mve.fp</code></td></tr>
<tr><td>Cortex-M85</td><td>DP</td><td>Yes</td><td>Int+Float</td><td><code>cortex-m85</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<p><em>Technically</em> you can use this hard-float ABI on a CPU which has no FPU but does
have Integer MVE, because MVE provides the same set of registers as the FPU
(including <code>s0</code> and <code>d0</code>). The particular set of flags that might enable this
unusual scenario are currently not recorded here.</p>
<div class="warning">
<p>Never use the <code>-fpregs</code> <em>target-feature</em> with the <code>thumbv8m.main-none-eabihf</code>
target as it will cause compilation units to have different ABIs, which is
unsound.</p>
</div>

<h3 id="arm-cortex-m33"><a class="header" href="#arm-cortex-m33">Arm Cortex-M33</a></h3>
<p>The target CPU is <code>cortex-m33</code>.</p>
<ul>
<li>Has optional DSP extensions
<ul>
<li>support is controlled by the <code>dsp</code> <em>target-feature</em></li>
<li>enabled by default with this <em>target-cpu</em></li>
</ul>
</li>
<li>Has an optional single precision FPU
<ul>
<li>support is enabled by default with this <em>target-cpu</em></li>
<li>disable support using the <code>-fpregs</code> <em>target-feature</em> (<code>eabi</code> only)</li>
</ul>
</li>
</ul>
<h3 id="arm-cortex-m35p"><a class="header" href="#arm-cortex-m35p">Arm Cortex-M35P</a></h3>
<p>The target CPU is <code>cortex-m35p</code>.</p>
<ul>
<li>Has optional DSP extensions
<ul>
<li>support is controlled by the <code>dsp</code> <em>target-feature</em></li>
<li>enabled by default with this <em>target-cpu</em></li>
</ul>
</li>
<li>Has an optional single precision FPU
<ul>
<li>support is enabled by default with this <em>target-cpu</em></li>
<li>disable support using the <code>-fpregs</code> <em>target-feature</em> (<code>eabi</code> only)</li>
</ul>
</li>
</ul>
<h3 id="arm-cortex-m55"><a class="header" href="#arm-cortex-m55">Arm Cortex-M55</a></h3>
<p>The target CPU is <code>cortex-m55</code>.</p>
<ul>
<li>Has DSP extensions
<ul>
<li>support is controlled by the <code>dsp</code> <em>target-feature</em></li>
<li>enabled by default with this <em>target-cpu</em></li>
</ul>
</li>
<li>Has an optional double-precision FPU that also supports half-precision FP16
values
<ul>
<li>support is enabled by default with this <em>target-cpu</em></li>
<li>disable support using the <code>-fpregs</code> <em>target-feature</em> (<code>eabi</code> only)</li>
</ul>
</li>
<li>Has optional support for M-Profile Vector Extensions
<ul>
<li>Also known as <em>Helium Technology</em></li>
<li>Available with only integer support, or both integer/float support</li>
<li>The appropriate feature for the MVE is either <code>mve</code> (integer) or <code>mve.fp</code>
(float)</li>
<li><code>mve.fp</code> is enabled by default on this target CPU</li>
<li>disable using <code>-mve.fp</code> (disable float MVE) or <code>-mve</code> (disable all MVE)</li>
</ul>
</li>
</ul>
<h3 id="arm-cortex-m85"><a class="header" href="#arm-cortex-m85">Arm Cortex-M85</a></h3>
<p>The target CPU is <code>cortex-m85</code>.</p>
<ul>
<li>Has DSP extensions
<ul>
<li>support is controlled by the <code>dsp</code> <em>target-feature</em></li>
<li>enabled by default with this <em>target-cpu</em></li>
</ul>
</li>
<li>Has an optional double-precision FPU that also supports half-precision FP16
values
<ul>
<li>support is enabled by default with this <em>target-cpu</em></li>
<li>disable support using the <code>-fpregs</code> <em>target-feature</em> (<code>eabi</code> only)</li>
</ul>
</li>
<li>Has optional support for M-Profile Vector Extensions
<ul>
<li>Also known as <em>Helium Technology</em></li>
<li>Available with only integer support, or both integer/float support</li>
<li>The appropriate feature for the MVE is either <code>mve</code> (integer) or <code>mve.fp</code>
(float)</li>
<li><code>mve.fp</code> is enabled by default on this target CPU</li>
<li>disable using <code>-mve.fp</code> (disable float MVE) or <code>-mve</code> (disable all MVE)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm-linux-support-in-rust"><a class="header" href="#arm-linux-support-in-rust">Arm Linux support in Rust</a></h1>
<p>The Arm Architecture has been around since the mid-1980s, going through nine
major revisions, many minor revisions, and spanning both 32-bit and 64-bit
architectures. This page covers 32-bit Arm platforms that run some form of
Linux (but not Android). Those targets are:</p>
<ul>
<li><code>arm-unknown-linux-gnueabi</code></li>
<li><code>arm-unknown-linux-gnueabihf</code></li>
<li><code>arm-unknown-linux-musleabi</code></li>
<li><code>arm-unknown-linux-musleabihf</code></li>
<li><a href="#armeb-unknown-linux-gnueabi"><code>armeb-unknown-linux-gnueabi</code></a></li>
<li><code>armv4t-unknown-linux-gnueabi</code></li>
<li><a href="#armv5te-unknown-linux-gnueabi"><code>armv5te-unknown-linux-gnueabi</code></a></li>
<li><code>armv5te-unknown-linux-musleabi</code></li>
<li><code>armv5te-unknown-linux-uclibceabi</code></li>
<li><a href="#armv7-unknown-linux-gnueabi-and-armv7-unknown-linux-gnueabihf"><code>armv7-unknown-linux-gnueabi</code></a></li>
<li><a href="#armv7-unknown-linux-gnueabi-and-armv7-unknown-linux-gnueabihf"><code>armv7-unknown-linux-gnueabihf</code></a></li>
<li><code>armv7-unknown-linux-musleabi</code></li>
<li><code>armv7-unknown-linux-musleabihf</code></li>
<li><code>armv7-unknown-linux-ohos</code></li>
<li><a href="#armv7-unknown-linux-uclibceabi"><code>armv7-unknown-linux-uclibceabi</code></a></li>
<li><a href="#armv7-unknown-linux-uclibceabihf"><code>armv7-unknown-linux-uclibceabihf</code></a></li>
<li><code>thumbv7neon-unknown-linux-gnueabihf</code></li>
<li><code>thumbv7neon-unknown-linux-musleabihf</code></li>
</ul>
<p>Some of these targets have dedicated pages and some do not. This is largely
due to historical accident, or the enthusiasm of the maintainers. This
document attempts to cover all the targets, but only in broad terms.</p>
<p>To make sense of this list, the architecture and ABI component of the
<code>&lt;architecture&gt;-unknown-linux-&lt;abi&gt;</code> tuple will be discussed separately.</p>
<p>The second part of the tuple is <code>unknown</code> because these systems don’t come
from any one specific vendor (like <code>powerpc-ibm-aix</code> or
<code>aarch64-apple-darwin</code>). The third part is <code>linux</code>, because this page only
discusses Linux targets.</p>
<h2 id="architecture-component"><a class="header" href="#architecture-component">Architecture Component</a></h2>
<ul>
<li><code>arm</code></li>
<li><code>armeb</code></li>
<li><code>armv4t</code></li>
<li><code>armv5te</code></li>
<li><code>armv7</code></li>
<li><code>thumbv7neon</code></li>
</ul>
<p>The architecture component simply called <code>arm</code> corresponds to the Armv6
architecture - that is, version 6 of the Arm Architecture as defined in
version 6 of the Arm Architecture Reference Manual (the Arm ARM). This was the
last ‘legacy’ release of the Arm architecture, before they split into
Application, Real-Time, and Microcontroller profiles (leading to Armv7-A,
Armv7-R and Armv7-M). Processors that implement the Armv6 architecture include
the ARM1176JZF-S, as found in BCM2835 SoC that powers the Raspberry Pi Zero.
Arm processors are generally fairly backwards compatible, especially for
user-mode code, so code compiled for the <code>arm</code> architecture should also work
on newer ARMv7-A systems, or even 64/32-bit Armv8-A systems.</p>
<p>The <code>armeb</code> architecture component specifies an Armv6 processor running in Big
Endian mode (<code>eb</code> is for big-endian - the letters are backwards because
engineers used to little-endian systems perceive big-endian numbers to be
written into memory backwards, and they thought it was funny like that).
Most Arm processors can operate in either little-endian or big-endian mode and
little-endian mode is by far the most common. However, if for whatever reason
you wish to store your Most Significant Bytes first, these targets are
available. They just aren’t terribly well tested, or compatible with most
existing pre-compiled Arm libraries.</p>
<p>Targets that start with <code>armv4t</code> are for processors implementing the Armv4T
architecture from 1994. These include the ARM7TDMI, as found in the Nokia 6110
brick-phone and the Game Boy Advance. The ‘T’ stands for <em>Thumb</em> and indicate
that the processors can execute smaller 16-bit versions of some of the 32-bit
Arm instructions. This is because a Thumb is like a small version of an Arm.</p>
<p>Targets that start with <code>armv5te</code> are for processors implementing the Armv5TE
architecture. These are mostly from the ARM9 family, like the ARM946E-S found
in the Nintendo DS. If you are programming an Arm machine from the early
2000s, this might be what you need.</p>
<p>The <code>armv7</code> is arguably a misnomer, and it should be <code>armv7a</code>. This is because
it corresponds to the Application profile of Armv7 (i.e. Armv7-A), as opposed
to the Real-Time or Microcontroller profile. Processors implementing this
architecture include the Cortex-A7 and Cortex-A8.</p>
<p>The <code>thumbv7neon</code> component indicates support for a processor that implements
ARMv7-A (the same as <code>armv7</code>), it generates Thumb instructions (technically
Thumb-2, also known as the T32 ISA) as opposed to Arm instructions (also known
as the A32 ISA). These instructions are smaller, giving more code per KB of
RAM, but may have a performance penalty if they take two instructions to do
something Arm instructions could do in one. It’s a complex trade-off and you
should be doing benchmarks to work out which is better for you, if you
strongly care about code size and/or performance. This component also enables
support for Arm’s SIMD extensions, known as Neon. These extensions will
improve performance for certain kinds of repetitive operations.</p>
<h2 id="abi-component"><a class="header" href="#abi-component">ABI Component</a></h2>
<ul>
<li><code>gnueabi</code></li>
<li><code>gnueabihf</code></li>
<li><code>musleabi</code></li>
<li><code>musleabihf</code></li>
<li><code>ohos</code></li>
<li><code>uclibceabi</code></li>
<li><code>uclibceabihf</code></li>
</ul>
<p>You will need to select the appropriate ABI to match the system you want to be
running this code on. For example, running <code>eabihf</code> code on an <code>eabi</code> system
will not work correctly.</p>
<p>The <code>gnueabi</code> ABI component indicates support for using the GNU C Library
(glibc), and the Arm Embedded ABI (EABI). The EABI is a replacement for the
original ABI (now called the Old ABI or OABI), and it is the standard ABI for
32-bit Arm systems. With this ABI, function parameters that are <code>f32</code> or <code>f64</code>
are passed as if they were integers, instead of being passed in FPU
registers. Generally, these targets also disable the use of the FPU entirely,
although that isn’t always true.</p>
<p>The <code>gnueabihf</code> ABI component is like <code>gnueabi</code>, except that it supports the
‘hard-float’ of the EABI. That is, function parameters that are <code>f32</code> or <code>f64</code>
are passed in FPU registers. Naturally, this makes the FPU mandatory.</p>
<p>Most ‘desktop’ Linux distributions (Debian, Ubuntu, Fedora, etc) use the GNU C
Library and so you should probably select either <code>gnueabi</code> or <code>gnueabihf</code>,
depending on whether your distribution is using ‘soft-float’ (EABI) or
‘hard-float’ (EABIHF). Debian happens to offer
<a href="https://wiki.debian.org/ArmEabiPort">both</a>
<a href="https://wiki.debian.org/ArmHardFloatPort">kinds</a>.</p>
<p>The <code>musleabi</code> and <code>musleabihf</code> ABI components offer support for the <a href="https://musl.libc.org/">musl C
library</a>. This C library can be used to create ‘static
binaries’ that have no run-time library requirements (a feature that glibc
does not support). There are soft-float (<code>eabi</code>) and hard-float (<code>eabihf</code>)
variants, as per the <code>gnu*</code> targets above.</p>
<p>The <code>uclibceabi</code> and <code>uclibceabihf</code> ABI components are for the <a href="https://uclibc-ng.org/">uClibc-ng C
library</a>. This is sometimes used in light-weight
embedded Linux distributions, like those created with
<a href="https://www.buildroot.org/">buildroot</a>.</p>
<h2 id="cross-compilation-4"><a class="header" href="#cross-compilation-4">Cross Compilation</a></h2>
<p>Unfortunately, 32-bit Arm machines are generally not the fastest around, and
they don’t have much RAM. This means you are likely to be cross-compiling.</p>
<p>To do this, you need to give Rust a suitable linker to use - one that knows
the Arm architecture, and more importantly, knows where to find a suitable C
Library to link against.</p>
<p>To do that, you can add the <code>linker</code> property to your <code>.cargo/config.toml</code>.
Typically, you would refer to a suitable copy of GCC that was built as a
cross-compiler, alongside a C library.</p>
<pre><code class="language-toml">[target.arm-unknown-linux-gnueabi]
linker = "arm-linux-gnueabi-gcc"
</code></pre>
<p>On Debian, you could install such a cross-compilation toolchain with
<code>apt install gcc-arm-linux-gnueabi</code>. For more exotic combinations, you might
need to build a bespoke version of GCC using <a href="https://github.com/crosstool-ng/crosstool-ng">crosstool-ng</a>.</p>
<p>Note that for GCC, all 32-bit Arm architectures are handled in the same build</p>
<ul>
<li>there are no separate Armv4T or Armv6 builds of GCC. The architecture is
selected with flags, like <code>-march=armv6</code>, but they aren’t required for the
linker.</li>
</ul>
<p>Let’s assume we are on some Debian machine, and we want to build a basic Arm
Linux binary for a distribution using the GNU C Library, targeting Armv6 with
a hard-float ABI. Such a binary should work on a Raspberry Pi, for example.
The commands are:</p>
<pre><code class="language-bash">sudo apt install -y gcc-arm-linux-gnueabihf
rustup target add arm-unknown-linux-gnueabihf
cargo new --bin armdemo
cd armdemo
mkdir .cargo
cat &gt; .cargo/config.toml &lt;&lt; EOF
[target.arm-unknown-linux-gnueabihf]
linker = "arm-linux-gnueabihf-gcc"
EOF
cargo build --target=arm-unknown-linux-gnueabihf
</code></pre>
<p>This will give us our ARM Linux binary for the GNU C Library with a soft-float ABI:</p>
<pre><code class="language-console">$ file ./target/arm-unknown-linux-gnueabi/debug/armdemo
./target/arm-unknown-linux-gnueabi/debug/armdemo: ELF 32-bit LSB pie
  executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter
  /lib/ld-linux.so.3, BuildID[sha1]=dd0b9aa5ae876330fd4e2fcf393850f083ec7fcd,
  for GNU/Linux 3.2.0, with debug_info, not stripped
</code></pre>
<p>If you are building C code as part of your Rust project, you may want to
direct <code>cc-rs</code> to use an appropriate cross-compiler with the <code>CROSS_COMPILE</code>
environment variable. You may also want to set the CFLAGS environment variable
for the target. For example:</p>
<pre><code class="language-bash">export CROSS_COMPILE=arm-linux-gnueabi
export CFLAGS_arm_unknown_linux_gnueabi="-march=armv6"
</code></pre>
<p>(Note that the dashes (<code>-</code>) turn to underscores (<code>_</code>) to form the name of the
CFLAGS environment variable)</p>
<p>If you are building for a Tier 3 target using <code>-Zbuild-std</code> (on Nightly Rust),
you need to set these variables as well:</p>
<pre><code class="language-bash">export CXX_arm_unknown_linux_gnueabi=arm-linux-gnueabi-g++
export CC_arm_unknown_linux_gnueabi=arm-linux-gnueabi-gcc
cargo +nightly build -Zbuild-std --target=arm-unknown-linux-gnueabi
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armeb-unknown-linux-gnueabi"><a class="header" href="#armeb-unknown-linux-gnueabi">armeb-unknown-linux-gnueabi</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Target for cross-compiling Linux user-mode applications targeting the Arm BE8 architecture.</p>
<p>See <a href="#arm-linux-support-in-rust"><code>arm-linux</code></a> for information applicable to all Arm Linux
targets.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>BE8 architecture retains the same little-endian ordered code-stream used by conventional little endian Arm systems, however the data accesses are in big-endian. BE8 is used primarily in high-performance networking applications where the ability to read packets in their native “Network Byte Order” is important (many network protocols transmit data in big-endian byte order for their wire formats).</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>BE8 architecture is the default big-endian architecture for Arm since <a href="https://developer.arm.com/documentation/101754/0616/armlink-Reference/armlink-Command-line-Options/--be8?lang=en">Armv6</a>. It’s predecessor, used for Armv4 and Armv5 devices was <a href="https://developer.arm.com/documentation/dui0474/j/linker-command-line-options/--be32">BE32</a>. On Armv6 architecture, endianness can be configured via <a href="https://developer.arm.com/documentation/ddi0290/g/unaligned-and-mixed-endian-data-access-support/mixed-endian-access-support/interaction-between-the-bus-protocol-and-the-core-endianness">system registers</a>. However, BE32 was withdrawn for <a href="https://developer.arm.com/documentation/ddi0406/cb/Appendixes/Deprecated-and-Obsolete-Features/Obsolete-features/Support-for-BE-32-endianness-model">Armv7</a> onwards.</p>
<h2 id="target-maintainers-31"><a class="header" href="#target-maintainers-31">Target Maintainers</a></h2>
<p><a href="https://github.com/WorksButNotTested">@WorksButNotTested</a></p>
<h2 id="requirements-25"><a class="header" href="#requirements-25">Requirements</a></h2>
<p>The target is cross-compiled. This target supports <code>std</code> in the normal way (indeed only nominal changes are required from the standard Arm configuration).</p>
<h2 id="target-definition"><a class="header" href="#target-definition">Target definition</a></h2>
<p>The target definition can be seen <a href="https://github.com/rust-lang/rust/blob/HEAD/compiler/rustc_target/src/spec/targets/armeb_unknown_linux_gnueabi.rs">here</a>. In particular, it should be noted that the <code>features</code> specify that this target is built for the Armv8 core. Though this can likely be modified as required.</p>
<h2 id="building-the-target-17"><a class="header" href="#building-the-target-17">Building the target</a></h2>
<p>Because it is Tier 3, rust does not yet ship pre-compiled artifacts for this target.</p>
<p>Therefore, you can build Rust with support for the target by adding it to the target list in bootstrap.toml, a sample configuration is shown below. It is expected that the user already have a working GNU compiler toolchain and update the paths accordingly.</p>
<pre><code class="language-toml">[llvm]
download-ci-llvm = false
optimize = true
ninja = true
targets = "ARM;X86"
clang = false

[build]
target = ["x86_64-unknown-linux-gnu", "armeb-unknown-linux-gnueabi"]
docs = false
docs-minification = false
compiler-docs = false
[install]
prefix = "/home/user/x-tools/rust/"

[rust]
debug-logging=true
backtrace = true
incremental = true

[target.x86_64-unknown-linux-gnu]

[dist]

[target.armeb-unknown-linux-gnueabi]
cc = "/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-gcc"
cxx = "/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-g++"
ar = "/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-ar"
ranlib = "/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-ranlib"
linker = "/home/user/x-tools/armeb-unknown-linux-gnueabi/bin/armeb-unknown-linux-gnueabi-gcc"
llvm-config = "/home/user/x-tools/clang/bin/llvm-config"
llvm-filecheck = "/home/user/x-tools/clang/bin/FileCheck"
</code></pre>
<h2 id="building-rust-programs-18"><a class="header" href="#building-rust-programs-18">Building Rust programs</a></h2>
<p>The following <code>.cargo/config</code> is needed inside any project directory to build for the BE8 target:</p>
<pre><code class="language-toml">[build]
target = "armeb-unknown-linux-gnueabi"

[target.armeb-unknown-linux-gnueabi]
linker = "armeb-unknown-linux-gnueabi-gcc"
</code></pre>
<p>Note that it is expected that the user has a suitable linker from the GNU toolchain.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv5te-unknown-linux-gnueabi"><a class="header" href="#armv5te-unknown-linux-gnueabi"><code>armv5te-unknown-linux-gnueabi</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>This target supports Linux programs with glibc on ARMv5TE CPUs without
floating-point units.</p>
<p>See <a href="#arm-linux-support-in-rust"><code>arm-linux</code></a> for information applicable to all Arm Linux
targets.</p>
<h2 id="target-maintainers-32"><a class="header" href="#target-maintainers-32">Target maintainers</a></h2>
<p>There are currently no formally documented target maintainers.</p>
<h2 id="requirements-26"><a class="header" href="#requirements-26">Requirements</a></h2>
<p>The target is for cross-compilation only. Host tools are not supported.
std is fully supported.</p>
<h2 id="building-the-target-18"><a class="header" href="#building-the-target-18">Building the target</a></h2>
<p>Because this target is tier 2, artifacts are available from rustup.</p>
<h2 id="building-rust-programs-19"><a class="header" href="#building-rust-programs-19">Building Rust programs</a></h2>
<p>For building rust programs, you might want to specify GCC as linker in
<code>.cargo/config.toml</code> as follows:</p>
<pre><code class="language-toml">[target.armv5te-unknown-linux-gnueabi]
linker = "arm-linux-gnueabi-gcc"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7-unknown-linux-gnueabi-and-armv7-unknown-linux-gnueabihf"><a class="header" href="#armv7-unknown-linux-gnueabi-and-armv7-unknown-linux-gnueabihf"><code>armv7-unknown-linux-gnueabi</code> and <code>armv7-unknown-linux-gnueabihf</code></a></h1>
<ul>
<li><strong>Tier: 2 (with Host Tools)</strong> for <code>armv7-unknown-linux-gnueabihf</code></li>
<li><strong>Tier: 2</strong> for <code>armv7-unknown-linux-gnueabi</code></li>
</ul>
<p>Target for 32-bit little endian ARMv7-A Linux 3.2+ programs using glibc 2.17+.</p>
<h2 id="target-maintainers-33"><a class="header" href="#target-maintainers-33">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="requirements-27"><a class="header" href="#requirements-27">Requirements</a></h2>
<p>Building the targets themselves requires a 32-bit little endian ARMv7-A compiler that is supported
by <code>cc-rs</code>.</p>
<h2 id="building-the-target-19"><a class="header" href="#building-the-target-19">Building the target</a></h2>
<p>These targets can be built by enabling it for a <code>rustc</code> build:</p>
<pre><code class="language-toml">[build]
target = ["armv7-unknown-linux-gnueabihf", "armv7-unknown-linux-gnueabi"]
</code></pre>
<p>If cross-compiling, make sure your C compiler is included in <code>$PATH</code>, then add it to the
<code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-musl]
cc = "arm-linux-gnu-gcc"
cxx = "arm-linux-gnu-g++"
ar = "arm-linux-gnu-ar"
linker = "arm-linux-gnu-gcc"
</code></pre>
<h2 id="building-rust-programs-20"><a class="header" href="#building-rust-programs-20">Building Rust programs</a></h2>
<p>These targets is distributed through <code>rustup</code>, and otherwise requires no special configuration.</p>
<h2 id="cross-compilation-5"><a class="header" href="#cross-compilation-5">Cross-compilation</a></h2>
<p>These targets can be cross-compiled from any host.</p>
<h2 id="testing-21"><a class="header" href="#testing-21">Testing</a></h2>
<p>These targets can be tested as normal with <code>x.py</code> on a 32-bit little endian ARMv7-A host or via
QEMU emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7-unknown-linux-uclibceabi"><a class="header" href="#armv7-unknown-linux-uclibceabi"><code>armv7-unknown-linux-uclibceabi</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>This target supports Armv7-A softfloat CPUs and uses the uclibc-ng standard library. This is a common configuration on many consumer routers (e.g., Netgear R7000, Asus RT-AC68U).</p>
<p>See <a href="#arm-linux-support-in-rust"><code>arm-linux</code></a> for information applicable to all Arm Linux
targets.</p>
<h2 id="target-maintainers-34"><a class="header" href="#target-maintainers-34">Target maintainers</a></h2>
<p><a href="https://github.com/lancethepants">@lancethepants</a></p>
<h2 id="requirements-28"><a class="header" href="#requirements-28">Requirements</a></h2>
<p>This target is cross compiled, and requires a cross toolchain.</p>
<p>This target supports host tools and std.</p>
<h2 id="building-the-target-20"><a class="header" href="#building-the-target-20">Building the target</a></h2>
<p>You will need to download or build a <code>'C'</code> cross toolchain that targets Armv7-A softfloat and that uses the uclibc-ng standard library. If your target hardware is something like a router or an embedded device, keep in mind that manufacturer supplied SDKs for this class of CPU could be outdated and potentially unsuitable for bootstrapping rust.</p>
<p><a href="https://github.com/lancethepants/tomatoware-toolchain">Here</a> is a sample toolchain that is built using <a href="https://buildroot.org/">buildroot</a>. It uses modern toolchain components, older thus universal kernel headers (2.6.36.4), and is used for a project called <a href="https://github.com/lancethepants/tomatoware">Tomatoware</a>. This toolchain is patched so that its sysroot is located at /mmc (e.g., /mmc/bin, /mmc/lib, /mmc/include). This is useful in scenarios where the root filesystem is read-only but you are able attach external storage loaded with user applications. Tomatoware is an example of this that even allows you to run various compilers and developer tools natively on the target device.</p>
<p>Utilizing the Tomatoware toolchain this target can be built for cross compilation and native compilation (host tools) with project</p>
<p><a href="https://github.com/lancethepants/rust-bootstrap-armv7-unknown-linux-uclibceabi">rust-bootstrap-armv7-unknown-linux-uclibceabi</a>.</p>
<p>Here is a sample config if using your own toolchain.</p>
<pre><code class="language-toml">[build]
build-stage = 2
target = ["armv7-unknown-linux-uclibceabi"]

[target.armv7-unknown-linux-uclibceabi]
cc = "/path/to/arm-unknown-linux-uclibcgnueabi-gcc"
cxx = "/path/to/arm-unknown-linux-uclibcgnueabi-g++"
ar = "path/to/arm-unknown-linux-uclibcgnueabi-ar"
ranlib = "path/to/arm-unknown-linux-uclibcgnueabi-ranlib"
linker = "/path/to/arm-unknown-linux-uclibcgnueabi-gcc"
</code></pre>
<h2 id="building-rust-programs-21"><a class="header" href="#building-rust-programs-21">Building Rust programs</a></h2>
<p>The following assumes you are using the Tomatoware toolchain and environment. Adapt if you are using your own toolchain.</p>
<h3 id="native-compilation"><a class="header" href="#native-compilation">Native compilation</a></h3>
<p>Since this target supports host tools, you can natively build rust applications directly on your target device. This can be convenient because it removes the complexities of cross compiling and you can immediately test and deploy your binaries. One downside is that compiling on your Armv7-A CPU will probably be much slower than cross compilation on your x86 machine.</p>
<p>To setup native compilation:</p>
<ul>
<li>Download Tomatoware to your device using the latest nightly release found <a href="https://files.lancethepants.com/Tomatoware/Nightly/">here</a>.</li>
<li>Extract <code>tar zxvf arm-soft-mmc.tgz -C /mmc</code></li>
<li>Add <code>/mmc/bin:/mmc:sbin/</code> to your PATH, or <code>source /mmc/etc/profile</code></li>
<li><code>apt update &amp;&amp; apt install rust</code></li>
</ul>
<p>If you bootstrap rust on your own using the project above, it will create a .deb file that you then can install with</p>
<pre><code class="language-text">dpkg -i rust_1.xx.x-x_arm.deb
</code></pre>
<p>After completing these steps you can use rust normally in a native environment.</p>
<h3 id="cross-compilation-6"><a class="header" href="#cross-compilation-6">Cross Compilation</a></h3>
<p>To cross compile, you’ll need to:</p>
<ul>
<li>
<p>Build the rust cross toolchain using  <a href="https://github.com/lancethepants/rust-bootstrap-armv7-unknown-linux-uclibceabi">rust-bootstrap-armv7-unknown-linux-uclibceabi</a> or your own built toolchain.</p>
</li>
<li>
<p>Link your built toolchain with</p>
<pre><code class="language-text">rustup toolchain link stage2 \
${HOME}/rust-bootstrap-armv7-unknown-linux-uclibceabi/src/rust/rust/build/x86_64-unknown-linux-gnu/stage2
</code></pre>
</li>
<li>
<p>Build with:</p>
<pre><code class="language-text">CC_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \
CXX_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-g++ \
AR_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-ar \
CFLAGS_armv7_unknown_linux_uclibceabi="-march=armv7-a -mtune=cortex-a9" \
CXXFLAGS_armv7_unknown_linux_uclibceabi="-march=armv7-a -mtune=cortex-a9" \
CARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_LINKER=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \
CARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_RUSTFLAGS='-Clink-arg=-s -Clink-arg=-Wl,--dynamic-linker=/mmc/lib/ld-uClibc.so.1 -Clink-arg=-Wl,-rpath,/mmc/lib' \
cargo +stage2 \
build \
--target armv7-unknown-linux-uclibceabi \
--release
</code></pre>
</li>
<li>
<p>Copy the binary to your target device and run.</p>
</li>
</ul>
<p>We specify <code>CC</code>, <code>CXX</code>, <code>AR</code>, <code>CFLAGS</code>, and <code>CXXFLAGS</code> environment variables because sometimes a project or a subproject requires the use of your <code>'C'</code> cross toolchain. Since Tomatoware has a modified sysroot we also pass via RUSTFLAGS the location of the dynamic-linker and rpath.</p>
<h3 id="test-with-qemu"><a class="header" href="#test-with-qemu">Test with QEMU</a></h3>
<p>To test a cross-compiled binary on your build system follow the instructions for <code>Cross Compilation</code>, install <code>qemu-arm-static</code>, and run with the following.</p>
<pre><code class="language-text">CC_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \
CXX_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-g++ \
AR_armv7_unknown_linux_uclibceabi=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-ar \
CFLAGS_armv7_unknown_linux_uclibceabi="-march=armv7-a -mtune=cortex-a9" \
CXXFLAGS_armv7_unknown_linux_uclibceabi="-march=armv7-a -mtune=cortex-a9" \
CARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_LINKER=/opt/tomatoware/arm-soft-mmc/bin/arm-linux-gcc \
CARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABI_RUNNER="qemu-arm-static -L /opt/tomatoware/arm-soft-mmc/arm-tomatoware-linux-uclibcgnueabi/sysroot/" \
cargo +stage2 \
run \
--target armv7-unknown-linux-uclibceabi \
--release
</code></pre>
<h3 id="run-in-a-chroot"><a class="header" href="#run-in-a-chroot">Run in a chroot</a></h3>
<p>It’s also possible to build in a chroot environment. This is a convenient way to work without needing to access the target hardware.</p>
<p>To build the chroot:</p>
<ul>
<li><code>sudo debootstrap --arch armel bullseye $HOME/debian</code></li>
<li><code>sudo chroot $HOME/debian/ /bin/bash</code></li>
<li><code>mount proc /proc -t proc</code></li>
<li><code>mount -t sysfs /sys sys/</code></li>
<li><code>export PATH=/mmc/bin:/mmc/sbin:$PATH</code></li>
</ul>
<p>From here you can setup your environment (e.g., add user, install wget).</p>
<ul>
<li>Download Tomatoware to the chroot environment using the latest nightly release found <a href="https://files.lancethepants.com/Tomatoware/Nightly/">here</a>.</li>
<li>Extract <code>tar zxvf arm-soft-mmc.tgz -C /mmc</code></li>
<li>Add <code>/mmc/bin:/mmc:sbin/</code> to your PATH, or <code>source /mmc/etc/profile</code></li>
<li><code>sudo /mmc/bin/apt update &amp;&amp; sudo /mmc/bin/apt install rust</code></li>
</ul>
<p>After completing these steps you can use rust normally in a chroot environment.</p>
<p>Remember when using <code>sudo</code> the root user’s PATH could differ from your user’s PATH.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7-unknown-linux-uclibceabihf"><a class="header" href="#armv7-unknown-linux-uclibceabihf">armv7-unknown-linux-uclibceabihf</a></h1>
<p><strong>Tier: 3</strong></p>
<p>This tier supports the Armv7-A processor running a Linux kernel and uClibc-ng standard library.  It provides full support for rust and the rust standard library.</p>
<p>See <a href="#arm-linux-support-in-rust"><code>arm-linux</code></a> for information applicable to all Arm Linux
targets.</p>
<h2 id="target-maintainers-35"><a class="header" href="#target-maintainers-35">Target Maintainers</a></h2>
<p><a href="https://github.com/skrap">@skrap</a></p>
<h2 id="requirements-29"><a class="header" href="#requirements-29">Requirements</a></h2>
<p>This target is cross compiled, and requires a cross toolchain.  You can find suitable pre-built toolchains at <a href="https://toolchains.bootlin.com/">bootlin</a> or build one yourself via <a href="https://buildroot.org">buildroot</a>.</p>
<h2 id="building-2"><a class="header" href="#building-2">Building</a></h2>
<h3 id="get-a-c-toolchain"><a class="header" href="#get-a-c-toolchain">Get a C toolchain</a></h3>
<p>Compiling rust for this target has been tested on <code>x86_64</code> linux hosts.  Other host types have not been tested, but may work, if you can find a suitable cross compilation toolchain for them.</p>
<p>If you don’t already have a suitable toolchain, download one <a href="https://toolchains.bootlin.com/downloads/releases/toolchains/armv7-eabihf/tarballs/armv7-eabihf--uclibc--bleeding-edge-2025.08-1.tar.xz">here</a>, and unpack it into a directory.</p>
<h3 id="configure-rust"><a class="header" href="#configure-rust">Configure rust</a></h3>
<p>The target can be built by enabling it for a <code>rustc</code> build, by placing the following in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["armv7-unknown-linux-uclibceabihf"]
build-stage = 2

[target.armv7-unknown-linux-uclibceabihf]
# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN
cc = "/TOOLCHAIN_PATH/bin/arm-buildroot-linux-uclibcgnueabihf-gcc"
</code></pre>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<pre><code class="language-sh"># in rust dir
./x.py build --stage 2
</code></pre>
<h2 id="building-and-running-rust-programs"><a class="header" href="#building-and-running-rust-programs">Building and Running Rust Programs</a></h2>
<p>To test cross-compiled binaries on a <code>x86_64</code> system, you can use the <code>qemu-arm</code> <a href="https://qemu-project.gitlab.io/qemu/user/main.html">userspace emulation</a> program.  This avoids having a full emulated ARM system by doing dynamic binary translation and dynamic system call translation.  It lets you run ARM programs directly on your <code>x86_64</code> kernel.  It’s very convenient!</p>
<p>To use:</p>
<ul>
<li>Install <code>qemu-arm</code> according to your distro.</li>
<li>Link your built toolchain via:
<ul>
<li><code>rustup toolchain link stage2 ${RUST}/build/x86_64-unknown-linux-gnu/stage2</code></li>
</ul>
</li>
<li>Create a test program</li>
</ul>
<pre><code class="language-sh">cargo new hello_world
cd hello_world
</code></pre>
<ul>
<li>Build and run</li>
</ul>
<pre><code class="language-sh">CARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABIHF_RUNNER="qemu-arm -L ${TOOLCHAIN}/arm-buildroot-linux-uclibcgnueabihf/sysroot/" \
CARGO_TARGET_ARMV7_UNKNOWN_LINUX_UCLIBCEABIHF_LINKER=${TOOLCHAIN}/bin/arm-buildroot-linux-uclibcgnueabihf-gcc \
cargo +stage2 run --target armv7-unknown-linux-uclibceabihf
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv6k-nintendo-3ds"><a class="header" href="#armv6k-nintendo-3ds"><code>armv6k-nintendo-3ds</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>The Nintendo 3DS platform, which has an Armv6k processor, and its associated
operating system (<code>horizon</code>).</p>
<p>Rust support for this target is not affiliated with Nintendo, and is not derived
from nor used with any official Nintendo SDK.</p>
<h2 id="target-maintainers-36"><a class="header" href="#target-maintainers-36">Target maintainers</a></h2>
<p>This target is maintained by members of the <a href="https://github.com/rust3ds">@rust3ds</a>
organization:</p>
<p><a href="https://github.com/Meziu">@Meziu</a>
<a href="https://github.com/AzureMarker">@AzureMarker</a>
<a href="https://github.com/ian-h-chamberlain">@ian-h-chamberlain</a></p>
<h2 id="requirements-30"><a class="header" href="#requirements-30">Requirements</a></h2>
<p>This target is cross-compiled. Dynamic linking is not supported.</p>
<p><code>#![no_std]</code> crates can be built using <code>build-std</code> to build <code>core</code> and optionally
<code>alloc</code>, and either <code>panic_abort</code> or <code>panic_unwind</code>.</p>
<p><code>std</code> is partially supported, but mostly works. Some APIs are unimplemented
and will simply return an error, such as <code>std::process</code>. An allocator is provided
by default.</p>
<p>In order to support some APIs, binaries must be linked against <code>libc</code> written
for the target, using a linker for the target. These are provided by the
devkitARM toolchain. See
<a href="#cross-compilation-toolchains-and-c-code-10">Cross-compilation toolchains and C code</a>
for more details.</p>
<p>Additionally, some helper crates provide implementations of some <code>libc</code> functions
use by <code>std</code> that may otherwise be missing. These, or an alternate implementation
of the relevant functions, are required to use <code>std</code>:</p>
<ul>
<li><a href="https://github.com/rust3ds/pthread-3ds"><code>pthread-3ds</code></a> provides pthread APIs for <code>std::thread</code>.</li>
<li><a href="https://github.com/rust3ds/shim-3ds"><code>shim-3ds</code></a> fulfills some other missing libc APIs (e.g. <code>getrandom</code>).</li>
</ul>
<p>Binaries built for this target should be compatible with all variants of the
3DS (and 2DS) hardware and firmware, but testing is limited and some versions may
not work correctly.</p>
<p>This target generates binaries in the ELF format.</p>
<h2 id="building-the-target-21"><a class="header" href="#building-the-target-21">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>bootstrap.toml</code> and providing paths to the devkitARM toolchain.</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["armv6k-nintendo-3ds"]

[target.armv6k-nintendo-3ds]
cc = "/opt/devkitpro/devkitARM/bin/arm-none-eabi-gcc"
cxx = "/opt/devkitpro/devkitARM/bin/arm-none-eabi-g++"
ar = "/opt/devkitpro/devkitARM/bin/arm-none-eabi-ar"
ranlib = "/opt/devkitpro/devkitARM/bin/arm-none-eabi-ranlib"
linker = "/opt/devkitpro/devkitARM/bin/arm-none-eabi-gcc"
</code></pre>
<p>Also, to build <code>compiler_builtins</code> for the target, export these flags before
building the Rust toolchain:</p>
<pre><code class="language-sh">export CFLAGS_armv6k_nintendo_3ds="-mfloat-abi=hard -mtune=mpcore -mtp=soft -march=armv6k"
</code></pre>
<h2 id="building-rust-programs-22"><a class="header" href="#building-rust-programs-22">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target.</p>
<p>The recommended way to build binaries is by using the
<a href="https://github.com/rust3ds/cargo-3ds">cargo-3ds</a> tool, which uses <code>build-std</code>
and provides commands that work like the usual <code>cargo run</code>, <code>cargo build</code>, etc.
The <code>cargo 3ds new</code> will automatically set up a new project with the dependencies
needed to build a simple binary.</p>
<p>You can also build Rust with the target enabled (see
<a href="#building-the-target-21">Building the target</a> above).</p>
<p>As mentioned in <a href="#requirements-30">Requirements</a>, programs that use <code>std</code> must link
against both the devkitARM toolchain and libraries providing the <code>libc</code> APIs used
in <code>std</code>.  There is a general-purpose utility crate for working with nonstandard
APIs provided by the OS: <a href="https://github.com/rust3ds/ctru-rs"><code>ctru-rs</code></a>.
Add it to Cargo.toml to use it in your program:</p>
<pre><code class="language-toml">[dependencies]
ctru-rs = { git = "https://github.com/rust3ds/ctru-rs.git" }
</code></pre>
<p>Depending on <code>ctru-rs</code> ensures that all the necessary symbols are available at
link time.</p>
<h2 id="testing-22"><a class="header" href="#testing-22">Testing</a></h2>
<p>Binaries built for this target can be run in an emulator (most commonly
<a href="https://citra-emu.org/">Citra</a>), or sent to a device through
the use of a tool like devkitARM’s <code>3dslink</code>. They may also simply be copied
to an SD card to be inserted in the device.</p>
<p>The <code>cargo-3ds</code> tool mentioned in <a href="#building-rust-programs-22">Building Rust programs</a>
supports the use of <code>3dslink</code> with <code>cargo 3ds run</code>. The default Rust test runner
is not supported, but
<a href="../unstable-book/language-features/custom-test-frameworks.html">custom test frameworks</a>
can be used with <code>cargo 3ds test</code> to run unit tests on a device.</p>
<p>The Rust test suite for <code>library/std</code> is not yet supported.</p>
<h2 id="cross-compilation-toolchains-and-c-code-10"><a class="header" href="#cross-compilation-toolchains-and-c-code-10">Cross-compilation toolchains and C code</a></h2>
<p>C code can be built for this target using the
<a href="https://devkitpro.org/wiki/Getting_Started">devkitARM toolchain</a>.
This toolchain provides <code>arm-none-eabi-gcc</code> as the linker used to link Rust
programs as well.</p>
<p>The toolchain also provides a <code>libc</code> implementation, which is required by <code>std</code>
for many of its APIs, and a helper library <code>libctru</code> which is used by several
of the helper crates listed in <a href="#requirements-30">Requirements</a>.
This toolchain does not, however, include all of the APIs expected by <code>std</code>,
and the remaining APIs are implemented by <code>pthread-3ds</code> and <code>linker-fix-3ds</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7-rtems-eabihf"><a class="header" href="#armv7-rtems-eabihf"><code>armv7-rtems-eabihf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>ARM targets for the <a href="https://www.rtems.org">RTEMS realtime operating system</a>  using the RTEMS gcc cross-compiler for linking against the libraries of a specified Board Support Package (BSP).</p>
<h2 id="target-maintainers-37"><a class="header" href="#target-maintainers-37">Target maintainers</a></h2>
<p><a href="https://github.com/thesummer">@thesummer</a></p>
<h2 id="requirements-31"><a class="header" href="#requirements-31">Requirements</a></h2>
<p>The target does not support host tools. Only cross-compilation is possible.
The cross-compiler toolchain can be obtained by following the installation instructions
of the <a href="https://docs.rtems.org/docs/main/user/index.html">RTEMS Documentation</a>. Additionally to the cross-compiler also a compiled BSP
for a board fitting the architecture needs to be available on the host.
Currently tested has been the BSP <code>xilinx_zynq_a9_qemu</code> of RTEMS 6.</p>
<p><code>std</code> support is available, but not yet fully tested. Do NOT use in flight software!</p>
<p>The target follows the EABI calling convention for <code>extern "C"</code>.</p>
<p>The resulting binaries are in ELF format.</p>
<h2 id="building-the-target-22"><a class="header" href="#building-the-target-22">Building the target</a></h2>
<p>The target can be built by the standard compiler of Rust.</p>
<h2 id="building-rust-programs-23"><a class="header" href="#building-rust-programs-23">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<p>In order to build an RTEMS executable it is also necessary to have a basic RTEMS configuration (in C) compiled to link against as this configures the operating system.
An example can be found at this <a href="https://github.com/thesummer/rtems-sys"><code>rtems-sys</code></a> crate which could be added as an dependency to your application.</p>
<h2 id="testing-23"><a class="header" href="#testing-23">Testing</a></h2>
<p>The resulting binaries run fine on an emulated target (possibly also on a real Zedboard or similar).
For example, on qemu the following command can execute the binary:</p>
<pre><code class="language-sh">qemu-system-arm -no-reboot -serial null -serial mon:stdio -net none -nographic -M xilinx-zynq-a9 -m 512M -kernel &lt;binary file&gt;
</code></pre>
<p>While basic execution of the unit test harness seems to work. However, running the Rust testsuite on the (emulated) hardware has not yet been tested.</p>
<h2 id="cross-compilation-toolchains-and-c-code-11"><a class="header" href="#cross-compilation-toolchains-and-c-code-11">Cross-compilation toolchains and C code</a></h2>
<p>Compatible C-code can be built with the RTEMS cross-compiler toolchain <code>arm-rtems6-gcc</code>.
For more information how to build the toolchain, RTEMS itself and RTEMS applications please have a look at the <a href="https://docs.rtems.org/docs/main/user/index.html">RTEMS Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7-sony-vita-newlibeabihf"><a class="header" href="#armv7-sony-vita-newlibeabihf">armv7-sony-vita-newlibeabihf</a></h1>
<p><strong>Tier: 3</strong></p>
<p>This tier supports the ARM Cortex A9 processor running on a PlayStation Vita console.</p>
<p>Rust support for this target is not affiliated with Sony, and is not derived
from nor used with any official Sony SDK.</p>
<h2 id="target-maintainers-38"><a class="header" href="#target-maintainers-38">Target maintainers</a></h2>
<p><a href="https://github.com/nikarh">@nikarh</a>
<a href="https://github.com/pheki">@pheki</a>
<a href="https://github.com/zetanumbers">@zetanumbers</a></p>
<h2 id="requirements-32"><a class="header" href="#requirements-32">Requirements</a></h2>
<p>This target is cross-compiled, and requires installing <a href="https://vitasdk.org/">VITASDK</a> toolchain on your system. Dynamic linking is not supported.</p>
<p><code>#![no_std]</code> crates can be built using <code>build-std</code> to build <code>core</code>, and optionally
<code>alloc</code>, and <code>panic_abort</code>.</p>
<p><code>std</code> is partially supported, but mostly works. Some APIs are unimplemented
and will simply return an error, such as <code>std::process</code>.</p>
<p>This target generates binaries in the ELF format with thumb ISA by default.</p>
<p>Binaries are linked with <code>arm-vita-eabi-gcc</code> provided by VITASDK toolchain.</p>
<h2 id="building-the-target-23"><a class="header" href="#building-the-target-23">Building the target</a></h2>
<p>Rust does not ship pre-compiled artifacts for this target. You can use <code>build-std</code> flag to build ELF binaries with <code>std</code>:</p>
<pre><code class="language-sh">cargo build -Z build-std=std,panic_abort --target=armv7-sony-vita-newlibeabihf --release
</code></pre>
<h2 id="building-rust-programs-24"><a class="header" href="#building-rust-programs-24">Building Rust programs</a></h2>
<p>The recommended way to build artifacts that can be installed and run on PlayStation Vita is by using the <a href="https://github.com/vita-rust/cargo-vita">cargo-vita</a> tool. This tool uses <code>build-std</code> and VITASDK toolchain to build artifacts runnable on Vita.</p>
<p>To install the tool run:</p>
<pre><code class="language-sh">cargo install cargo-vita
</code></pre>
<p><a href="https://vitasdk.org/">VITASDK</a> toolchain must be installed, and the <code>VITASDK</code> environment variable must be set to its location, e.g.:</p>
<pre><code class="language-sh">export VITASDK=/opt/vitasdk
</code></pre>
<p>Add the following section to your project’s <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.vita]
# A unique 9 character alphanumeric identifier of the app.
title_id = "RUSTAPP01"
# A title that will be used for the app. Optional, name will be used if not defined
title_name = "My application"
</code></pre>
<p>To build a VPK with ELF in the release profile, run:</p>
<pre><code class="language-sh">cargo vita build vpk --release
</code></pre>
<p>After building a *.vpk file it can be uploaded to a PlayStation Vita and installed, or used with a <a href="https://vita3k.org/">Vita3K</a> emulator.</p>
<h2 id="testing-24"><a class="header" href="#testing-24">Testing</a></h2>
<p>The default Rust test runner is supported, and tests can be compiled to an elf and packed to a *.vpk file using <code>cargo-vita</code> tool. Filtering tests is not currently supported since passing command-line arguments to the executable is not supported on Vita, so the runner will always execute all tests.</p>
<p>The Rust test suite for <code>library/std</code> is not yet supported.</p>
<h2 id="cross-compilation-7"><a class="header" href="#cross-compilation-7">Cross-compilation</a></h2>
<p>This target can be cross-compiled from <code>x86_64</code> on Windows, MacOS or Linux systems. Other hosts are not supported for cross-compilation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="armv7a-vex-v5"><a class="header" href="#armv7a-vex-v5"><code>armv7a-vex-v5</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Allows compiling user programs for the <a href="https://www.vexrobotics.com/276-4810.html">VEX V5 Brain</a>, a microcontroller for educational and competitive robotics.</p>
<p>Rust support for this target is not affiliated with VEX Robotics or IFI, and does not link to any official VEX SDK.</p>
<h2 id="target-maintainers-39"><a class="header" href="#target-maintainers-39">Target maintainers</a></h2>
<p>This target is maintained by members of the <a href="https://github.com/vexide">vexide</a> organization:</p>
<ul>
<li><a href="https://github.com/lewisfm">@lewisfm</a></li>
<li><a href="https://github.com/Tropix126">@Tropix126</a></li>
<li><a href="https://github.com/Gavin-Niederman">@Gavin-Niederman</a></li>
<li><a href="https://github.com/max-niederman">@max-niederman</a></li>
</ul>
<h2 id="requirements-33"><a class="header" href="#requirements-33">Requirements</a></h2>
<p>This target is cross-compiled. Dynamic linking is unsupported.</p>
<p><code>#![no_std]</code> crates can be built using <code>build-std</code> to build <code>core</code> and <code>panic_abort</code> and optionally <code>alloc</code>. Unwinding panics are not yet supported on this target.</p>
<p><code>std</code> has only partial support due to platform limitations. Notably:</p>
<ul>
<li><code>std::process</code> and <code>std::net</code> are unimplemented. <code>std::thread</code> only supports sleeping and yielding, as this is a single-threaded environment.</li>
<li><code>std::time</code> has full support for <code>Instant</code>, but no support for <code>SystemTime</code>.</li>
<li><code>std::io</code> has full support for <code>stdin</code>/<code>stdout</code>/<code>stderr</code>. <code>stdout</code> and <code>stderr</code> both write to to USB channel 1 on this platform and are not differentiated.</li>
<li><code>std::fs</code> has limited support for reading or writing to files. Directory operations, file deletion, and some file opening features are unsupported and will return errors.</li>
<li>A global allocator implemented on top of <code>dlmalloc</code> is provided.</li>
<li>Modules that do not need to interact with the OS beyond allocation such as <code>std::collections</code>, <code>std::hash</code>, <code>std::future</code>, <code>std::sync</code>, etc are fully supported.</li>
<li>Random number generation and hashing is insecure, as there is no reliable source of entropy on this platform.</li>
</ul>
<p>In order to support some APIs, users are expected to provide a supporting runtime SDK for <code>libstd</code> to link against. This library may be provided either by <a href="https://github.com/vexide/vex-sdk/tree/main/packages/vex-sdk-build"><code>vex-sdk-build</code></a> (which will download an official SDK from VEX) or through an open-source implementation such as <a href="https://crates.io/crates/vex-sdk-jumptable"><code>vex-sdk-jumptable</code></a>.</p>
<p>When compiling for this target, the “C” calling convention maps to AAPCS with VFP registers (hard float ABI) and the “system” calling convention maps to AAPCS without VFP registers (softfp ABI).</p>
<p>This target generates binaries in the ELF format that may be uploaded to the brain with external tools.</p>
<h2 id="building-the-target-24"><a class="header" href="#building-the-target-24">Building the target</a></h2>
<p>You can build Rust with support for this target by adding it to the <code>target</code> list in <code>bootstrap.toml</code>, and then running <code>./x build --target armv7a-vex-v5 compiler</code>.</p>
<h2 id="building-rust-programs-25"><a class="header" href="#building-rust-programs-25">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see “Building the target” above), or build your own copy of <code>core</code> by using <code>build-std</code> or similar.</p>
<p>When the compiler builds a binary, an ELF build artifact will be produced. Additional tools are required for this artifact to be recognizable to VEXos as a user program.</p>
<p>The <a href="https://github.com/vexide/cargo-v5">cargo-v5</a> tool is capable of creating binaries that can be uploaded to the V5 brain. This tool wraps the <code>cargo build</code> command by supplying arguments necessary to build the target and produce an artifact recognizable to VEXos, while also providing functionality for uploading over USB to a V5 Controller or Brain.</p>
<p>To install the tool, run:</p>
<pre><code class="language-sh">cargo install cargo-v5
</code></pre>
<p>The following fields in your project’s <code>Cargo.toml</code> are read by <code>cargo-v5</code> to configure upload behavior:</p>
<pre><code class="language-toml">[package.metadata.v5]
# Slot number to upload the user program to. This should be from 1-8.
slot = 1
# Program icon/thumbnail that will be displayed on the dashboard.
icon = "cool-x"
# Use gzip compression when uploading binaries.
compress = true
</code></pre>
<p>To build an uploadable BIN file using the release profile, run:</p>
<pre><code class="language-sh">cargo v5 build --release
</code></pre>
<p>Programs can also be directly uploaded to the brain over a USB connection immediately after building:</p>
<pre><code class="language-sh">cargo v5 upload --release
</code></pre>
<h2 id="testing-25"><a class="header" href="#testing-25">Testing</a></h2>
<p>Binaries built for this target can be run in an emulator (such as <a href="https://github.com/vexide/vex-v5-qemu">vex-v5-qemu</a>), or uploaded to a physical device over a serial (USB) connection.</p>
<p>The default Rust test runner is not supported.</p>
<p>The Rust test suite for <code>library/std</code> is not yet supported.</p>
<h2 id="cross-compilation-toolchains-and-c-code-12"><a class="header" href="#cross-compilation-toolchains-and-c-code-12">Cross-compilation toolchains and C code</a></h2>
<p>This target can be cross-compiled from any host.</p>
<p>Linking to C libraries is not supported.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-linux-android-and--linux-androideabi"><a class="header" href="#-linux-android-and--linux-androideabi">*-linux-android and *-linux-androideabi</a></h1>
<p><strong>Tier: 2</strong></p>
<p><a href="https://source.android.com/">Android</a> is a mobile operating system built on top of the Linux kernel.</p>
<h2 id="target-maintainers-40"><a class="header" href="#target-maintainers-40">Target maintainers</a></h2>
<p><a href="https://github.com/chriswailes">@chriswailes</a>
<a href="https://github.com/jfgoog">@jfgoog</a>
<a href="https://github.com/maurer">@maurer</a>
<a href="https://github.com/pirama-arumuga-nainar">@pirama-arumuga-nainar</a></p>
<h2 id="requirements-34"><a class="header" href="#requirements-34">Requirements</a></h2>
<p>This target is cross-compiled from a host environment. Development may be done
from the <a href="https://source.android.com/docs/setup/build/downloading">source tree</a> or using the Android NDK.</p>
<p>Android targets support std. Generated binaries use the ELF file format.</p>
<h2 id="ndkapi-update-policy"><a class="header" href="#ndkapi-update-policy">NDK/API Update Policy</a></h2>
<p>Rust will support the most recent Long Term Support (LTS) Android Native
Development Kit (NDK).  By default Rust will support all API levels supported
by the NDK, but a higher minimum API level may be required if deemed necessary.</p>
<h2 id="building-the-target-25"><a class="header" href="#building-the-target-25">Building the target</a></h2>
<p>To build Rust binaries for Android you’ll need a copy of the most recent LTS
edition of the <a href="https://developer.android.com/ndk/downloads">Android NDK</a>.  Supported Android targets are:</p>
<ul>
<li>aarch64-linux-android</li>
<li>arm-linux-androideabi</li>
<li>armv7-linux-androideabi</li>
<li>i686-linux-android</li>
<li>thumbv7neon-linux-androideabi</li>
<li>x86_64-linux-android</li>
</ul>
<p>The riscv64-linux-android target is supported as a Tier 3 target.</p>
<p>A list of all supported targets can be found
<a href="#platform-support">here</a></p>
<h2 id="architecture-notes"><a class="header" href="#architecture-notes">Architecture Notes</a></h2>
<h3 id="riscv64-linux-android"><a class="header" href="#riscv64-linux-android">riscv64-linux-android</a></h3>
<p>Currently the <code>riscv64-linux-android</code> target requires the following architecture features/extensions:</p>
<ul>
<li><code>a</code> (atomics)</li>
<li><code>d</code> (double-precision floating-point)</li>
<li><code>c</code> (compressed instruction set)</li>
<li><code>f</code> (single-precision floating-point)</li>
<li><code>m</code> (multiplication and division)</li>
<li><code>v</code> (vector)</li>
<li><code>Zba</code> (address calculation instructions)</li>
<li><code>Zbb</code> (base instructions)</li>
<li><code>Zbs</code> (single-bit instructions)</li>
</ul>
<h3 id="aarch64-linux-android-on-nightly-compilers"><a class="header" href="#aarch64-linux-android-on-nightly-compilers">aarch64-linux-android on Nightly compilers</a></h3>
<p>As soon as <code>-Zfixed-x18</code> compiler flag is supplied, the <a href="https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html"><code>ShadowCallStack</code> sanitizer</a>
instrumentation is also made available by supplying the second compiler flag <code>-Zsanitizer=shadow-call-stack</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-linux-ohos"><a class="header" href="#-unknown-linux-ohos"><code>*-unknown-linux-ohos</code></a></h1>
<p><strong>Tier: 2 (with Host Tools)</strong></p>
<ul>
<li>aarch64-unknown-linux-ohos</li>
<li>armv7-unknown-linux-ohos</li>
<li>x86_64-unknown-linux-ohos</li>
</ul>
<p><strong>Tier: 3</strong></p>
<ul>
<li>loongarch64-unknown-linux-ohos</li>
</ul>
<p>Targets for the <a href="https://gitee.com/openharmony/docs/">OpenHarmony</a> operating
system.</p>
<h2 id="target-maintainers-41"><a class="header" href="#target-maintainers-41">Target maintainers</a></h2>
<p><a href="https://github.com/Amanieu">@Amanieu</a>
<a href="https://github.com/cceerczw">@cceerczw</a></p>
<h2 id="requirements-35"><a class="header" href="#requirements-35">Requirements</a></h2>
<p>All the ohos targets of Tier 2 with host tools support all extended rust tools.
(exclude <code>miri</code>, the support of <code>miri</code> will be added soon)</p>
<h3 id="host-toolchain"><a class="header" href="#host-toolchain">Host toolchain</a></h3>
<p>The targets require a reasonably up-to-date OpenHarmony SDK on the host.</p>
<p>The targets support <code>cargo</code>, which require <a href="https://github.com/ohos-rs/ohos-openssl">ohos-openssl</a>.</p>
<p><code>miri</code> isn’t supported yet, since its dependencies (<code>libffi</code> and <code>tikv-jemalloc-sys</code>) don’t support
compiling for the OHOS targets.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>The OpenHarmony SDK doesn’t currently support Rust compilation directly, so
some setup is required.</p>
<p>First, you must obtain the OpenHarmony SDK from <a href="https://gitee.com/openharmony/docs/tree/master/en/release-notes">this page</a>.
Select the version of OpenHarmony you are developing for and download the “Public SDK package for the standard system”.</p>
<p>Create the following shell scripts that wrap Clang from the OpenHarmony SDK:</p>
<p><code>aarch64-unknown-linux-ohos-clang.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang \
  -target aarch64-linux-ohos \
  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \
  -D__MUSL__ \
  "$@"
</code></pre>
<p><code>aarch64-unknown-linux-ohos-clang++.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \
  -target aarch64-linux-ohos \
  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \
  -D__MUSL__ \
  "$@"
</code></pre>
<p><code>armv7-unknown-linux-ohos-clang.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang \
  -target arm-linux-ohos \
  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \
  -D__MUSL__ \
  -march=armv7-a \
  -mfloat-abi=softfp \
  -mtune=generic-armv7-a \
  -mthumb \
  "$@"
</code></pre>
<p><code>armv7-unknown-linux-ohos-clang++.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \
  -target arm-linux-ohos \
  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \
  -D__MUSL__ \
  -march=armv7-a \
  -mfloat-abi=softfp \
  -mtune=generic-armv7-a \
  -mthumb \
  "$@"
</code></pre>
<p><code>x86_64-unknown-linux-ohos-clang.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang \
  -target x86_64-linux-ohos \
  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \
  -D__MUSL__ \
  "$@"
</code></pre>
<p><code>x86_64-unknown-linux-ohos-clang++.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \
  -target x86_64-linux-ohos \
  --sysroot=/path/to/ohos-sdk/linux/native/sysroot \
  -D__MUSL__ \
  "$@"
</code></pre>
<p>Future versions of the OpenHarmony SDK will avoid the need for this process.</p>
<h2 id="building-rust-programs-26"><a class="header" href="#building-rust-programs-26">Building Rust programs</a></h2>
<p>Rustup ships pre-compiled artifacts for this target, which you can install with:</p>
<pre><code class="language-sh">rustup target add aarch64-unknown-linux-ohos
rustup target add armv7-unknown-linux-ohos
rustup target add x86_64-unknown-linux-ohos
</code></pre>
<p>You will need to configure the linker to use in <code>~/.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-ohos]
ar = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar"
linker = "/path/to/aarch64-unknown-linux-ohos-clang.sh"

[target.armv7-unknown-linux-ohos]
ar = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar"
linker = "/path/to/armv7-unknown-linux-ohos-clang.sh"

[target.x86_64-unknown-linux-ohos]
ar = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar"
linker = "/path/to/x86_64-unknown-linux-ohos-clang.sh"
</code></pre>
<h2 id="building-the-target-from-source"><a class="header" href="#building-the-target-from-source">Building the target from source</a></h2>
<p>Instead of using <code>rustup</code>, you can instead build a rust toolchain from source.
Create a <code>bootstrap.toml</code> with the following contents:</p>
<pre><code class="language-toml">profile = "compiler"
change-id = 115898

[build]
sanitizers = true
profiler = true

[target.aarch64-unknown-linux-ohos]
cc = "/path/to/aarch64-unknown-linux-ohos-clang.sh"
cxx = "/path/to/aarch64-unknown-linux-ohos-clang++.sh"
ar = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar"
ranlib = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib"
linker  = "/path/to/aarch64-unknown-linux-ohos-clang.sh"

[target.armv7-unknown-linux-ohos]
cc = "/path/to/armv7-unknown-linux-ohos-clang.sh"
cxx = "/path/to/armv7-unknown-linux-ohos-clang++.sh"
ar = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar"
ranlib = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib"
linker  = "/path/to/armv7-unknown-linux-ohos-clang.sh"

[target.x86_64-unknown-linux-ohos]
cc = "/path/to/x86_64-unknown-linux-ohos-clang.sh"
cxx = "/path/to/x86_64-unknown-linux-ohos-clang++.sh"
ar = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar"
ranlib = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib"
linker  = "/path/to/x86_64-unknown-linux-ohos-clang.sh"
</code></pre>
<h2 id="testing-26"><a class="header" href="#testing-26">Testing</a></h2>
<p>Running the Rust testsuite is possible, but currently difficult due to the way
the OpenHarmony emulator is set up (no networking).</p>
<h2 id="cross-compilation-toolchains-and-c-code-13"><a class="header" href="#cross-compilation-toolchains-and-c-code-13">Cross-compilation toolchains and C code</a></h2>
<p>You can use the shell scripts above to compile C code for the target.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="i686-unknown-hurd-gnu-and-x86_64-unknown-hurd-gnu"><a class="header" href="#i686-unknown-hurd-gnu-and-x86_64-unknown-hurd-gnu"><code>i686-unknown-hurd-gnu</code> and <code>x86_64-unknown-hurd-gnu</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>[GNU/Hurd] is the GNU Hurd is the GNU project’s replacement for the Unix kernel.</p>
<h2 id="target-maintainers-42"><a class="header" href="#target-maintainers-42">Target maintainers</a></h2>
<p><a href="https://github.com/sthibaul">@sthibaul</a></p>
<h2 id="requirements-36"><a class="header" href="#requirements-36">Requirements</a></h2>
<p>The target supports host tools.</p>
<p>The GNU/Hurd target supports <code>std</code> and uses the standard ELF file format.</p>
<h2 id="building-the-target-26"><a class="header" href="#building-the-target-26">Building the target</a></h2>
<p>This target can be built by adding <code>i686-unknown-hurd-gnu</code> and
<code>x86_64-unknown-hurd-gnu</code> as targets in the rustc list.</p>
<h2 id="building-rust-programs-27"><a class="header" href="#building-rust-programs-27">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing-27"><a class="header" href="#testing-27">Testing</a></h2>
<p>Tests can be run in the same way as a regular binary.</p>
<h2 id="cross-compilation-toolchains-and-c-code-14"><a class="header" href="#cross-compilation-toolchains-and-c-code-14">Cross-compilation toolchains and C code</a></h2>
<p>The target supports C code, the GNU toolchain calls the target
<code>i686-unknown-gnu</code> and <code>x86_64-unknown-gnu</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-unknown-teeos"><a class="header" href="#aarch64-unknown-teeos"><code>aarch64-unknown-teeos</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Target for the TEEOS operating system.</p>
<p>TEEOS is a mini os run in TrustZone, for trusted/security apps. The kernel of TEEOS is HongMeng/ChCore micro kernel. The libc for TEEOS is a part of musl.
It’s very small that there is no network, no stdin, and no file system for apps in TEEOS.</p>
<p>Some abbreviation:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Abbreviation</th><th>The full text</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>TEE</td><td>Trusted Execution Environment</td><td>ARM TrustZone divides the system into two worlds/modes – the secure world/mode and the normal world/mode. TEE is in the secure world/mode.</td></tr>
<tr><td>REE</td><td>Rich Execution Environment</td><td>The normal world. for example, Linux for Android phone is in REE side.</td></tr>
<tr><td>TA</td><td>Trusted Application</td><td>The app run in TEE side system.</td></tr>
<tr><td>CA</td><td>Client Application</td><td>The progress run in REE side system.</td></tr>
</tbody>
</table>
</div>
<p>TEEOS is open source in progress. <a href="https://gitee.com/opentrustee-group">MORE about</a></p>
<h2 id="target-maintainers-43"><a class="header" href="#target-maintainers-43">Target maintainers</a></h2>
<p><a href="https://github.com/petrochenkov">@petrochenkov</a>
<a href="https://github.com/Sword-Destiny">@Sword-Destiny</a></p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>We use OpenHarmony SDK for TEEOS.</p>
<p>The OpenHarmony SDK doesn’t currently support Rust compilation directly, so
some setup is required.</p>
<p>First, you must obtain the OpenHarmony SDK from <a href="https://gitee.com/openharmony/docs/tree/master/en/release-notes">this page</a>.
Select the version of OpenHarmony you are developing for and download the “Public SDK package for the standard system”.</p>
<p>Create the following shell scripts that wrap Clang from the OpenHarmony SDK:</p>
<p><code>aarch64-unknown-teeos-clang.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang \
  -target aarch64-linux-gnu \
  "$@"
</code></pre>
<p><code>aarch64-unknown-teeos-clang++.sh</code></p>
<pre><code class="language-sh">#!/bin/sh
exec /path/to/ohos-sdk/linux/native/llvm/bin/clang++ \
  -target aarch64-linux-gnu \
  "$@"
</code></pre>
<h2 id="building-the-target-27"><a class="header" href="#building-the-target-27">Building the target</a></h2>
<p>To build a rust toolchain, create a <code>bootstrap.toml</code> with the following contents:</p>
<pre><code class="language-toml">profile = "compiler"
change-id = 115898

[build]
sanitizers = true
profiler = true
target = ["x86_64-unknown-linux-gnu", "aarch64-unknown-teeos"]
submodules = false
compiler-docs = false
extended = true

[install]
bindir = "bin"
libdir = "lib"

[target.aarch64-unknown-teeos]
cc = "/path/to/scripts/aarch64-unknown-teeos-clang.sh"
cxx = "/path/to/scripts/aarch64-unknown-teeos-clang.sh"
linker = "/path/to/scripts/aarch64-unknown-teeos-clang.sh"
ar = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ar"
ranlib = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-ranlib"
llvm-config = "/path/to/ohos-sdk/linux/native/llvm/bin/llvm-config"
</code></pre>
<pre><code class="language-text">note: You need to insert "/usr/include/x86_64-linux-gnu/" into environment variable: $C_INCLUDE_PATH
 if some header files like bits/xxx.h not found.
note: You can install gcc-aarch64-linux-gnu,g++-aarch64-linux-gnu if some files like crti.o not found.
note: You may need to install libc6-dev-i386 libc6-dev if "gnu/stubs-32.h" not found.
</code></pre>
<h2 id="building-rust-programs-28"><a class="header" href="#building-rust-programs-28">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<p>You will need to configure the linker to use in <code>~/.cargo/config</code>:</p>
<pre><code class="language-toml">[target.aarch64-unknown-teeos]
linker = "/path/to/aarch64-unknown-teeos-clang.sh" # or aarch64-linux-gnu-ld
</code></pre>
<h2 id="testing-28"><a class="header" href="#testing-28">Testing</a></h2>
<p>Running the Rust testsuite is not possible now.</p>
<p>More information about how to test CA/TA. <a href="https://gitee.com/openharmony-sig/tee_tee_dev_kit/tree/master/docs">See here</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="avr-none"><a class="header" href="#avr-none"><code>avr-none</code></a></h1>
<p>Series of microcontrollers from Atmel: ATmega8, ATmega328p etc.</p>
<p><strong>Tier: 3</strong></p>
<h2 id="target-maintainers-44"><a class="header" href="#target-maintainers-44">Target maintainers</a></h2>
<p><a href="https://github.com/Patryk27">@Patryk27</a></p>
<h2 id="requirements-37"><a class="header" href="#requirements-37">Requirements</a></h2>
<p>This target is only cross-compiled; x86-64 Linux, x86-64 macOS and aarch64 macOS
hosts are confirmed to work, but in principle any machine able to run rustc and
avr-gcc should be good.</p>
<p>Compiling for this target requires <code>avr-gcc</code> installed, because a couple of
intrinsics (like 32-bit multiplication) rely on <a href="https://github.com/gcc-mirror/gcc/blob/3269a722b7a03613e9c4e2862bc5088c4a17cc11/libgcc/config/avr/lib1funcs.S"><code>libgcc</code></a>
and can’t be provided through <code>compiler-builtins</code> yet. This is a limitation that
<a href="https://github.com/rust-lang/compiler-builtins/issues/711">we hope to lift in the future</a>.</p>
<p>You’ll also need to setup the <code>.cargo/config</code> file - see below for details.</p>
<h2 id="building-the-target-28"><a class="header" href="#building-the-target-28">Building the target</a></h2>
<p>Rust comes with AVR support enabled, you don’t have to rebuild the compiler.</p>
<h2 id="building-rust-programs-29"><a class="header" href="#building-rust-programs-29">Building Rust programs</a></h2>
<p>Install <code>avr-gcc</code>:</p>
<pre><code class="language-console"># Ubuntu:
$ sudo apt-get install gcc-avr

# Mac:
$ brew tap osx-cross/avr &amp;&amp; brew install avr-gcc

# NixOS (takes a couple of minutes, since it's not provided through Hydra):
$ nix shell nixpkgs#pkgsCross.avr.buildPackages.gcc11
</code></pre>
<p>… setup <code>.cargo/config</code> for your project:</p>
<pre><code class="language-toml">[build]
target = "avr-none"
rustflags = ["-C", "target-cpu=atmega328p"]

[unstable]
build-std = ["core"]
</code></pre>
<p>… and then simply run:</p>
<pre><code class="language-console">$ cargo build --release
</code></pre>
<p>The final binary will be placed into
<code>./target/avr-none/release/your-project.elf</code>.</p>
<p>Note that since AVRs have rather small amounts of registers, ROM and RAM, it’s
recommended to always use <code>--release</code> to avoid running out of space.</p>
<p>Also, please note that specifying <code>-C target-cpu</code> is required - here’s a list of
the possible variants:</p>
<p>https://github.com/llvm/llvm-project/blob/093d4db2f3c874d4683fb01194b00dbb20e5c713/clang/lib/Basic/Targets/AVR.cpp#L32</p>
<h2 id="testing-29"><a class="header" href="#testing-29">Testing</a></h2>
<p>You can use <a href="https://github.com/buserror/simavr"><code>simavr</code></a> to emulate the
resulting firmware on your machine:</p>
<pre><code class="language-console">$ simavr -m atmega328p ./target/avr-none/release/your-project.elf
</code></pre>
<p>Alternatively, if you want to write a couple of actual <code>#[test]</code>s, you can use
<a href="https://github.com/Patryk27/avr-tester"><code>avr-tester</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-espidf"><a class="header" href="#-espidf"><code>*-espidf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Targets for the <a href="https://github.com/espressif/esp-idf">ESP-IDF</a> development framework running on RISC-V and Xtensa CPUs.</p>
<h2 id="target-maintainers-45"><a class="header" href="#target-maintainers-45">Target maintainers</a></h2>
<p><a href="https://github.com/ivmarkov">@ivmarkov</a>
<a href="https://github.com/MabezDev">@MabezDev</a>
<a href="https://github.com/SergioGasquez">@SergioGasquez</a></p>
<h2 id="requirements-38"><a class="header" href="#requirements-38">Requirements</a></h2>
<p>The target names follow this format: <code>$ARCH-esp-espidf</code>, where <code>$ARCH</code> specifies the target processor architecture. The following targets are currently defined:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target name</th><th>Target CPU(s)</th><th>Minimum ESP-IDF version</th></tr>
</thead>
<tbody>
<tr><td><code>riscv32imc-esp-espidf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-c2">ESP32-C2</a></td><td><code>v5.0</code></td></tr>
<tr><td><code>riscv32imc-esp-espidf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-c3">ESP32-C3</a></td><td><code>v4.4</code></td></tr>
<tr><td><code>riscv32imac-esp-espidf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-c6">ESP32-C6</a></td><td><code>v5.1</code></td></tr>
<tr><td><code>riscv32imac-esp-espidf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-h2">ESP32-H2</a></td><td><code>v5.1</code></td></tr>
<tr><td><code>riscv32imafc-esp-espidf</code></td><td><a href="https://www.espressif.com/en/news/ESP32-P4">ESP32-P4</a></td><td><code>v5.2</code></td></tr>
<tr><td><code>xtensa-esp32-espidf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32">ESP32</a></td><td><code>v4.4</code></td></tr>
<tr><td><code>xtensa-esp32s2-espidf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-s2">ESP32-S2</a></td><td><code>v4.4</code></td></tr>
<tr><td><code>xtensa-esp32s3-espidf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-s3">ESP32-S3</a></td><td><code>v4.4</code></td></tr>
</tbody>
</table>
</div>
<p>It is recommended to use the latest ESP-IDF stable release if possible.</p>
<h2 id="building-the-target-29"><a class="header" href="#building-the-target-29">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build. The <code>build-std</code> feature is required to build the standard library for ESP-IDF. <code>ldproxy</code> is also required for linking, it can be installed from crates.io.</p>
<pre><code class="language-toml">[build]
target = ["$ARCH-esp-espidf"]

[target.$ARCH-esp-espidf]
linker = "ldproxy"

[unstable]
build-std = ["std", "panic_abort"]
</code></pre>
<p>The <code>esp-idf-sys</code> crate will handle the compilation of ESP-IDF, including downloading the relevant toolchains for the build.</p>
<h2 id="cross-compilation-toolchains-and-c-code-15"><a class="header" href="#cross-compilation-toolchains-and-c-code-15">Cross-compilation toolchains and C code</a></h2>
<p><code>esp-idf-sys</code> exposes the toolchain used in the compilation of ESP-IDF, see the crate <a href="https://github.com/esp-rs/esp-idf-sys#conditional-compilation">documentation for build output propagation</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-unknown-fuchsia-and-x86_64-unknown-fuchsia"><a class="header" href="#aarch64-unknown-fuchsia-and-x86_64-unknown-fuchsia"><code>aarch64-unknown-fuchsia</code> and <code>x86_64-unknown-fuchsia</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p><a href="https://fuchsia.dev/">Fuchsia</a> is a modern open source operating system that’s simple, secure,
updatable, and performant.</p>
<h2 id="target-maintainers-46"><a class="header" href="#target-maintainers-46">Target maintainers</a></h2>
<p><a href="https://github.com/erickt">@erickt</a>
<a href="https://github.com/Nashenas88">@Nashenas88</a></p>
<p>The up-to-date list can be also found via the
<a href="https://github.com/rust-lang/team/blob/master/teams/fuchsia.toml">fuchsia marker team</a>.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ol>
<li><a href="#requirements-39">Requirements</a></li>
<li><a href="#walkthrough-structure">Walkthrough structure</a></li>
<li><a href="#compiling-a-rust-binary-targeting-fuchsia">Compiling a Rust binary targeting Fuchsia</a>
<ol>
<li><a href="#targeting-fuchsia-with-rustup-and-cargo">Targeting Fuchsia with rustup and cargo</a></li>
<li><a href="#targeting-fuchsia-with-a-compiler-built-from-source">Targeting Fuchsia with a compiler built from source</a></li>
</ol>
</li>
<li><a href="#creating-a-fuchsia-package">Creating a Fuchsia package</a>
<ol>
<li><a href="#creating-a-fuchsia-component">Creating a Fuchsia component</a></li>
<li><a href="#building-a-fuchsia-package">Building a Fuchsia package</a></li>
</ol>
</li>
<li><a href="#publishing-a-fuchsia-package">Publishing a Fuchsia package</a>
<ol>
<li><a href="#creating-a-fuchsia-package-repository">Creating a Fuchsia package repository</a></li>
<li><a href="#publishing-fuchsia-package-to-repository">Publishing Fuchsia package to repository</a></li>
</ol>
</li>
<li><a href="#running-a-fuchsia-component-on-an-emulator">Running a Fuchsia component on an emulator</a>
<ol>
<li><a href="#starting-the-fuchsia-emulator">Starting the Fuchsia emulator</a></li>
<li><a href="#watching-emulator-logs">Watching emulator logs</a></li>
<li><a href="#serving-a-fuchsia-package">Serving a Fuchsia package</a></li>
<li><a href="#running-a-fuchsia-component">Running a Fuchsia component</a></li>
</ol>
</li>
<li><a href="#gitignore-extensions"><code>.gitignore</code> extensions</a></li>
<li><a href="#testing-30">Testing</a>
<ol>
<li><a href="#running-unit-tests">Running unit tests</a></li>
<li><a href="#running-the-compiler-test-suite">Running the compiler test suite</a></li>
</ol>
</li>
<li><a href="#debugging">Debugging</a>
<ol>
<li><a href="#zxdb"><code>zxdb</code></a></li>
<li><a href="#attaching-zxdb">Attaching <code>zxdb</code></a></li>
<li><a href="#using-zxdb">Using <code>zxdb</code></a></li>
<li><a href="#displaying-source-code-in-zxdb">Displaying source code in <code>zxdb</code></a></li>
</ol>
</li>
</ol>
<h2 id="requirements-39"><a class="header" href="#requirements-39">Requirements</a></h2>
<p>This target is cross-compiled from a host environment. You will need a recent
copy of the <a href="https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core">Fuchsia SDK</a>, which provides the tools, libraries, and binaries
required to build and link programs for Fuchsia.</p>
<p>Development may also be done from the <a href="https://fuchsia.dev/fuchsia-src/get-started/learn/build">source tree</a>.</p>
<p>Fuchsia targets support <code>std</code> and follow the <code>sysv64</code> calling convention on
x86_64. Fuchsia binaries use the ELF file format.</p>
<h2 id="walkthrough-structure"><a class="header" href="#walkthrough-structure">Walkthrough structure</a></h2>
<p>This walkthrough will cover:</p>
<ol>
<li>Compiling a Rust binary targeting Fuchsia.</li>
<li>Building a Fuchsia package.</li>
<li>Publishing and running a Fuchsia package to a Fuchsia emulator.</li>
</ol>
<p>For the purposes of this walkthrough, we will only target <code>x86_64-unknown-fuchsia</code>.</p>
<h2 id="compiling-a-rust-binary-targeting-fuchsia"><a class="header" href="#compiling-a-rust-binary-targeting-fuchsia">Compiling a Rust binary targeting Fuchsia</a></h2>
<p>Today, there are two main ways to build a Rust binary targeting Fuchsia
using the Fuchsia SDK:</p>
<ol>
<li>Allow <a href="https://rustup.rs/">rustup</a> to handle the installation of Fuchsia targets for you.</li>
<li>Build a toolchain locally that can target Fuchsia.</li>
</ol>
<h3 id="targeting-fuchsia-with-rustup-and-cargo"><a class="header" href="#targeting-fuchsia-with-rustup-and-cargo">Targeting Fuchsia with rustup and cargo</a></h3>
<p>The easiest way to build a Rust binary targeting Fuchsia is by allowing <a href="https://rustup.rs/">rustup</a>
to handle the installation of Fuchsia targets for you. This can be done by issuing
the following commands:</p>
<pre><code class="language-sh">rustup target add x86_64-unknown-fuchsia
rustup target add aarch64-unknown-fuchsia
</code></pre>
<p>After installing our Fuchsia targets, we can now compile a Rust binary that targets
Fuchsia.</p>
<p>To create our Rust project, we can use <a href="../cargo/index.html"><code>cargo</code></a> as follows:</p>
<p><strong>From base working directory</strong></p>
<pre><code class="language-sh">cargo new hello_fuchsia
</code></pre>
<p>The rest of this walkthrough will take place from <code>hello_fuchsia</code>, so we can
change into that directory now:</p>
<pre><code class="language-sh">cd hello_fuchsia
</code></pre>
<p><em>Note: From this point onwards, all commands will be issued from the <code>hello_fuchsia/</code>
directory, and all <code>hello_fuchsia/</code> prefixes will be removed from references for sake of brevity.</em></p>
<p>We can edit our <code>src/main.rs</code> to include a test as follows:</p>
<p><strong><code>src/main.rs</code></strong></p>
<pre><code class="language-rust">fn main() {
    println!("Hello Fuchsia!");
}

#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}</code></pre>
<p>In addition to the standard workspace created, we will want to create a
<code>.cargo/config.toml</code> file to link necessary libraries
during compilation:</p>
<p><strong><code>.cargo/config.toml</code></strong></p>
<pre><code class="language-txt">[target.x86_64-unknown-fuchsia]

rustflags = [
    "-Lnative=&lt;SDK_PATH&gt;/arch/x64/lib",
    "-Lnative=&lt;SDK_PATH&gt;/arch/x64/sysroot/lib"
]
</code></pre>
<p><em>Note: Make sure to fill out <code>&lt;SDK_PATH&gt;</code> with the path to the downloaded <a href="https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core">Fuchsia SDK</a>.</em></p>
<p>These options configure the following:</p>
<ul>
<li><code>-Lnative=${SDK_PATH}/arch/${ARCH}/lib</code>: Link against Fuchsia libraries from
the SDK</li>
<li><code>-Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib</code>: Link against Fuchsia sysroot
libraries from the SDK</li>
</ul>
<p>In total, our new project will look like:</p>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┣━ src/
┃  ┗━ main.rs
┣━ Cargo.toml
┗━ .cargo/
   ┗━ config.toml
</code></pre>
<p>Finally, we can build our rust binary as:</p>
<pre><code class="language-sh">cargo build --target x86_64-unknown-fuchsia
</code></pre>
<p>Now we have a Rust binary at <code>target/x86_64-unknown-fuchsia/debug/hello_fuchsia</code>,
targeting our desired Fuchsia target.</p>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┣━ src/
┃  ┗━ main.rs
┣━ target/
┃  ┗━ x86_64-unknown-fuchsia/
┃     ┗━ debug/
┃        ┗━ hello_fuchsia
┣━ Cargo.toml
┗━ .cargo/
   ┗━ config.toml
</code></pre>
<h3 id="targeting-fuchsia-with-a-compiler-built-from-source"><a class="header" href="#targeting-fuchsia-with-a-compiler-built-from-source">Targeting Fuchsia with a compiler built from source</a></h3>
<p>An alternative to the first workflow is to target Fuchsia by using
<code>rustc</code> built from source.</p>
<p>Before building Rust for Fuchsia, you’ll need a clang toolchain that supports
Fuchsia as well. A recent version (14+) of clang should be sufficient to compile
Rust for Fuchsia.</p>
<p>x86-64 and AArch64 Fuchsia targets can be enabled using the following
configuration in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["&lt;host_platform&gt;", "aarch64-unknown-fuchsia", "x86_64-unknown-fuchsia"]

[rust]
lld = true

[llvm]
download-ci-llvm = false

[target.x86_64-unknown-fuchsia]
cc = "clang"
cxx = "clang++"

[target.aarch64-unknown-fuchsia]
cc = "clang"
cxx = "clang++"
</code></pre>
<p>Though not strictly required, you may also want to use <code>clang</code> for your host
target as well:</p>
<pre><code class="language-toml">[target.&lt;host_platform&gt;]
cc = "clang"
cxx = "clang++"
</code></pre>
<p>By default, the Rust compiler installs itself to <code>/usr/local</code> on most UNIX
systems. You may want to install it to another location (e.g. a local <code>install</code>
directory) by setting a custom prefix in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[install]
# Make sure to use the absolute path to your install directory
prefix = "&lt;RUST_SRC_PATH&gt;/install"
</code></pre>
<p>Next, the following environment variables must be configured. For example, using
a script we name <code>config-env.sh</code>:</p>
<pre><code class="language-sh"># Configure this environment variable to be the path to the downloaded SDK
export SDK_PATH="&lt;SDK path goes here&gt;"

export CFLAGS_aarch64_unknown_fuchsia="--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include"
export CXXFLAGS_aarch64_unknown_fuchsia="--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include"
export LDFLAGS_aarch64_unknown_fuchsia="--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -L${SDK_PATH}/arch/arm64/lib"
export CARGO_TARGET_AARCH64_UNKNOWN_FUCHSIA_RUSTFLAGS="-C link-arg=--sysroot=${SDK_PATH}/arch/arm64/sysroot -Lnative=${SDK_PATH}/arch/arm64/sysroot/lib -Lnative=${SDK_PATH}/arch/arm64/lib"
export CFLAGS_x86_64_unknown_fuchsia="--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include"
export CXXFLAGS_x86_64_unknown_fuchsia="--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include"
export LDFLAGS_x86_64_unknown_fuchsia="--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -L${SDK_PATH}/arch/x64/lib"
export CARGO_TARGET_X86_64_UNKNOWN_FUCHSIA_RUSTFLAGS="-C link-arg=--sysroot=${SDK_PATH}/arch/x64/sysroot -Lnative=${SDK_PATH}/arch/x64/sysroot/lib -Lnative=${SDK_PATH}/arch/x64/lib"
</code></pre>
<p>Finally, the Rust compiler can be built and installed:</p>
<pre><code class="language-sh">(source config-env.sh &amp;&amp; ./x.py install)
</code></pre>
<p>Once <code>rustc</code> is installed, we can create a new working directory to work from,
<code>hello_fuchsia</code> along with <code>hello_fuchsia/src</code>:</p>
<pre><code class="language-sh">mkdir hello_fuchsia
cd hello_fuchsia
mkdir src
</code></pre>
<p><em>Note: From this point onwards, all commands will be issued from the <code>hello_fuchsia/</code>
directory, and all <code>hello_fuchsia/</code> prefixes will be removed from references for sake of brevity.</em></p>
<p>There, we can create a new file named <code>src/hello_fuchsia.rs</code>:</p>
<p><strong><code>src/hello_fuchsia.rs</code></strong></p>
<pre><code class="language-rust">fn main() {
    println!("Hello Fuchsia!");
}

#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}</code></pre>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┗━ src/
    ┗━ hello_fuchsia.rs
</code></pre>
<p>Using your freshly installed <code>rustc</code>, you can compile a binary for Fuchsia using
the following options:</p>
<ul>
<li><code>--target x86_64-unknown-fuchsia</code>/<code>--target aarch64-unknown-fuchsia</code>: Targets the Fuchsia
platform of your choice</li>
<li><code>-Lnative ${SDK_PATH}/arch/${ARCH}/lib</code>: Link against Fuchsia libraries from
the SDK</li>
<li><code>-Lnative ${SDK_PATH}/arch/${ARCH}/sysroot/lib</code>: Link against Fuchsia sysroot
libraries from the SDK</li>
</ul>
<p>Putting it all together:</p>
<pre><code class="language-sh"># Configure these for the Fuchsia target of your choice
TARGET_ARCH="&lt;x86_64-unknown-fuchsia|aarch64-unknown-fuchsia&gt;"
ARCH="&lt;x64|aarch64&gt;"

rustc \
    --target ${TARGET_ARCH} \
    -Lnative=${SDK_PATH}/arch/${ARCH}/lib \
    -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib \
    --out-dir bin src/hello_fuchsia.rs
</code></pre>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┣━ src/
┃   ┗━ hello_fuchsia.rs
┗━ bin/
   ┗━ hello_fuchsia
</code></pre>
<h2 id="creating-a-fuchsia-package"><a class="header" href="#creating-a-fuchsia-package">Creating a Fuchsia package</a></h2>
<p>Before moving on, double check your directory structure:</p>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┣━ src/                         (if using rustc)
┃   ┗━ hello_fuchsia.rs         ...
┣━ bin/                         ...
┃  ┗━ hello_fuchsia             ...
┣━ src/                         (if using cargo)
┃  ┗━ main.rs                   ...
┗━ target/                      ...
   ┗━ x86_64-unknown-fuchsia/   ...
      ┗━ debug/                 ...
         ┗━ hello_fuchsia       ...
</code></pre>
<p>With our Rust binary built, we can move to creating a Fuchsia package.
On Fuchsia, a package is the unit of distribution for software. We’ll need to
create a new package directory where we will place files like our finished
binary and any data it may need.</p>
<p>To start, make the <code>pkg</code>, and <code>pkg/meta</code> directories:</p>
<pre><code class="language-sh">mkdir pkg
mkdir pkg/meta
</code></pre>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┗━ pkg/
   ┗━ meta/
</code></pre>
<p>Now, create the following files inside:</p>
<p><strong><code>pkg/meta/package</code></strong></p>
<pre><code class="language-json">{
  "name": "hello_fuchsia",
  "version": "0"
}
</code></pre>
<p>The <code>package</code> file describes our package’s name and version number. Every
package must contain one.</p>
<p><strong><code>pkg/hello_fuchsia.manifest</code> if using cargo</strong></p>
<pre><code class="language-txt">bin/hello_fuchsia=target/x86_64-unknown-fuchsia/debug/hello_fuchsia
lib/ld.so.1=&lt;SDK_PATH&gt;/arch/x64/sysroot/dist/lib/ld.so.1
lib/libfdio.so=&lt;SDK_PATH&gt;/arch/x64/dist/libfdio.so
meta/package=pkg/meta/package
meta/hello_fuchsia.cm=pkg/meta/hello_fuchsia.cm
</code></pre>
<p><strong><code>pkg/hello_fuchsia.manifest</code> if using rustc</strong></p>
<pre><code class="language-txt">bin/hello_fuchsia=bin/hello_fuchsia
lib/ld.so.1=&lt;SDK_PATH&gt;/arch/x64/sysroot/dist/lib/ld.so.1
lib/libfdio.so=&lt;SDK_PATH&gt;/arch/x64/dist/libfdio.so
meta/package=pkg/meta/package
meta/hello_fuchsia.cm=pkg/meta/hello_fuchsia.cm
</code></pre>
<p><em>Note: Relative manifest paths are resolved starting from the working directory
of <code>ffx</code>. Make sure to fill out <code>&lt;SDK_PATH&gt;</code> with the path to the downloaded
SDK.</em></p>
<p>The <code>.manifest</code> file will be used to describe the contents of the package by
relating their location when installed to their location on the file system. The
<code>bin/hello_fuchsia=</code> entry will be different depending on how your Rust binary
was built, so choose accordingly.</p>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┗━ pkg/
   ┣━ meta/
   ┃  ┗━ package
   ┗━ hello_fuchsia.manifest
</code></pre>
<h3 id="creating-a-fuchsia-component"><a class="header" href="#creating-a-fuchsia-component">Creating a Fuchsia component</a></h3>
<p>On Fuchsia, components require a component manifest written in Fuchsia’s markup
language called CML. The Fuchsia devsite contains an <a href="https://fuchsia.dev/fuchsia-src/concepts/components/v2/component_manifests">overview of CML</a> and a
<a href="https://fuchsia.dev/reference/cml">reference for the file format</a>. Here’s a basic one that can run our single binary:</p>
<p><strong><code>pkg/hello_fuchsia.cml</code></strong></p>
<pre><code class="language-txt">{
    include: [ "syslog/client.shard.cml" ],
    program: {
        runner: "elf",
        binary: "bin/hello_fuchsia",
    },
}
</code></pre>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┗━ pkg/
   ┣━ meta/
   ┃  ┗━ package
   ┣━ hello_fuchsia.manifest
   ┗━ hello_fuchsia.cml
</code></pre>
<p>Now we can compile that CML into a component manifest:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/cmc compile \
    pkg/hello_fuchsia.cml \
    --includepath ${SDK_PATH}/pkg \
    -o pkg/meta/hello_fuchsia.cm
</code></pre>
<p><em>Note: <code>--includepath</code> tells the compiler where to look for <code>include</code>s from our CML.
In our case, we’re only using <code>syslog/client.shard.cml</code>.</em></p>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┗━ pkg/
   ┣━ meta/
   ┃  ┣━ package
   ┃  ┗━ hello_fuchsia.cm
   ┣━ hello_fuchsia.manifest
   ┗━ hello_fuchsia.cml
</code></pre>
<h3 id="building-a-fuchsia-package"><a class="header" href="#building-a-fuchsia-package">Building a Fuchsia package</a></h3>
<p>Next, we’ll build a package manifest as defined by our manifest:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx package build \
    --api-level $(${SDK_PATH}/tools/${ARCH}/ffx --machine json version | jq .tool_version.api_level) \
    --out pkg/hello_fuchsia_manifest \
    pkg/hello_fuchsia.manifest
</code></pre>
<p>This will produce <code>pkg/hello_fuchsia_manifest/</code> which is a package manifest we can
publish directly to a repository.</p>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┗━ pkg/
   ┣━ meta/
   ┃  ┣━ package
   ┃  ┗━ hello_fuchsia.cm
   ┣━ hello_fuchsia_manifest/
   ┃  ┗━ ...
   ┣━ hello_fuchsia.manifest
   ┣━ hello_fuchsia.cml
   ┗━ hello_fuchsia_package_manifest
</code></pre>
<p>We are now ready to publish the package.</p>
<h2 id="publishing-a-fuchsia-package"><a class="header" href="#publishing-a-fuchsia-package">Publishing a Fuchsia package</a></h2>
<p>With our package and component manifests setup,
we can now publish our package. The first step will
be to create a Fuchsia package repository to publish
to.</p>
<h3 id="creating-a-fuchsia-package-repository"><a class="header" href="#creating-a-fuchsia-package-repository">Creating a Fuchsia package repository</a></h3>
<p>We can set up our repository with:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx repository create pkg/repo
</code></pre>
<p><strong>Current directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┗━ pkg/
   ┣━ meta/
   ┃  ┣━ package
   ┃  ┗━ hello_fuchsia.cm
   ┣━ hello_fuchsia_manifest/
   ┃  ┗━ ...
   ┣━ repo/
   ┃  ┗━ ...
   ┣━ hello_fuchsia.manifest
   ┣━ hello_fuchsia.cml
   ┗━ hello_fuchsia_package_manifest
</code></pre>
<h2 id="publishing-fuchsia-package-to-repository"><a class="header" href="#publishing-fuchsia-package-to-repository">Publishing Fuchsia package to repository</a></h2>
<p>We can publish our new package to that repository with:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx repository publish \
    --package pkg/hello_fuchsia_package_manifest \
    pkg/repo
</code></pre>
<h2 id="running-a-fuchsia-component-on-an-emulator"><a class="header" href="#running-a-fuchsia-component-on-an-emulator">Running a Fuchsia component on an emulator</a></h2>
<p>At this point, we are ready to run our Fuchsia
component. For reference, our final directory
structure will look like:</p>
<p><strong>Final directory structure</strong></p>
<pre><code class="language-txt">hello_fuchsia/
┣━ src/                         (if using rustc)
┃   ┗━ hello_fuchsia.rs         ...
┣━ bin/                         ...
┃  ┗━ hello_fuchsia             ...
┣━ src/                         (if using cargo)
┃  ┗━ main.rs                   ...
┣━ target/                      ...
┃  ┗━ x86_64-unknown-fuchsia/   ...
┃     ┗━ debug/                 ...
┃        ┗━ hello_fuchsia       ...
┗━ pkg/
   ┣━ meta/
   ┃  ┣━ package
   ┃  ┗━ hello_fuchsia.cm
   ┣━ hello_fuchsia_manifest/
   ┃  ┗━ ...
   ┣━ repo/
   ┃  ┗━ ...
   ┣━ hello_fuchsia.manifest
   ┣━ hello_fuchsia.cml
   ┗━ hello_fuchsia_package_manifest
</code></pre>
<h3 id="starting-the-fuchsia-emulator"><a class="header" href="#starting-the-fuchsia-emulator">Starting the Fuchsia emulator</a></h3>
<p>Start a Fuchsia emulator in a new terminal using:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx product-bundle get workstation_eng.qemu-${ARCH}
${SDK_PATH}/tools/${ARCH}/ffx emu start workstation_eng.qemu-${ARCH} --headless
</code></pre>
<h3 id="watching-emulator-logs"><a class="header" href="#watching-emulator-logs">Watching emulator logs</a></h3>
<p>Once the emulator is running, open a separate terminal to watch the emulator logs:</p>
<p><strong>In separate terminal</strong></p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx log \
    --since now
</code></pre>
<h3 id="serving-a-fuchsia-package"><a class="header" href="#serving-a-fuchsia-package">Serving a Fuchsia package</a></h3>
<p>Now, start a package repository server to serve our
package to the emulator:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx repository server start \
    --background --repository hello-fuchsia --repo-path pkg-repo
</code></pre>
<p>Once the repository server is up and running, register it with the target Fuchsia system running in the emulator:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx target repository register \
    --repository hello-fuchsia
</code></pre>
<h3 id="running-a-fuchsia-component"><a class="header" href="#running-a-fuchsia-component">Running a Fuchsia component</a></h3>
<p>Finally, run the component:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx component run \
    /core/ffx-laboratory:hello_fuchsia \
    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm
</code></pre>
<p>On reruns of the component, the <code>--recreate</code> argument may also need to be
passed.</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx component run \
    --recreate \
    /core/ffx-laboratory:hello_fuchsia \
    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm
</code></pre>
<h2 id="gitignore-extensions"><a class="header" href="#gitignore-extensions"><code>.gitignore</code> extensions</a></h2>
<p>Optionally, we can create/extend our <code>.gitignore</code> file to ignore files and
directories that are not helpful to track:</p>
<pre><code class="language-txt">pkg/repo
pkg/meta/hello_fuchsia.cm
pkg/hello_fuchsia_manifest
pkg/hello_fuchsia_package_manifest
</code></pre>
<h2 id="testing-30"><a class="header" href="#testing-30">Testing</a></h2>
<h3 id="running-unit-tests"><a class="header" href="#running-unit-tests">Running unit tests</a></h3>
<p>Tests can be run in the same way as a regular binary.</p>
<ul>
<li>
<p>If using <code>cargo</code>, you can simply pass <code>test --no-run</code>
to the <code>cargo</code> invocation and then repackage and rerun the Fuchsia package. From our previous example,
this would look like <code>cargo test --target x86_64-unknown-fuchsia --no-run</code>, and moving the executable
binary path found from the line <code>Executable unittests src/main.rs (target/x86_64-unknown-fuchsia/debug/deps/hello_fuchsia-&lt;HASH&gt;)</code>
into <code>pkg/hello_fuchsia.manifest</code>.</p>
</li>
<li>
<p>If using the compiled <code>rustc</code>, you can simply pass <code>--test</code>
to the <code>rustc</code> invocation and then repackage and rerun the Fuchsia package.</p>
</li>
</ul>
<p>The test harness will run the applicable unit tests.</p>
<p>Often when testing, you may want to pass additional command line arguments to
your binary. Additional arguments can be set in the component manifest:</p>
<p><strong><code>pkg/hello_fuchsia.cml</code></strong></p>
<pre><code class="language-txt">{
    include: [ "syslog/client.shard.cml" ],
    program: {
        runner: "elf",
        binary: "bin/hello_fuchsia",
        args: ["it_works"],
    },
}
</code></pre>
<p>This will pass the argument <code>it_works</code> to the binary, filtering the tests to
only those tests that match the pattern. There are many more configuration
options available in CML including environment variables. More documentation is
available on the <a href="https://fuchsia.dev/reference/cml">Fuchsia devsite</a>.</p>
<h3 id="running-the-compiler-test-suite"><a class="header" href="#running-the-compiler-test-suite">Running the compiler test suite</a></h3>
<p>The commands in this section assume that they are being run from inside your
local Rust source checkout:</p>
<pre><code class="language-sh">cd ${RUST_SRC_PATH}
</code></pre>
<p>To run the Rust test suite on an emulated Fuchsia device, you’ll also need to
download a copy of the Fuchsia SDK. The current minimum supported SDK version is
<a href="https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core/linux-amd64/+/version:20.20240412.3.1">20.20240412.3.1</a>.</p>
<p>Fuchsia’s test runner interacts with the Fuchsia emulator and is located at
<code>src/ci/docker/scripts/fuchsia-test-runner.py</code>. First, add the following
variables to your existing <code>config-env.sh</code>:</p>
<pre><code class="language-sh"># TEST_TOOLCHAIN_TMP_DIR can point anywhere, but it:
#  - must be less than 108 characters, otherwise qemu can't handle the path
#  - must be consistent across calls to this file (don't use `mktemp -d` here)
export TEST_TOOLCHAIN_TMP_DIR="/tmp/rust-tmp"

# Keep existing contents of `config-env.sh` from earlier, including SDK_PATH
</code></pre>
<p>We can then use the script to start our test environment with:</p>
<pre><code class="language-sh">( \
    source config-env.sh &amp;&amp;                                                   \
    src/ci/docker/scripts/fuchsia-test-runner.py start                        \
    --rust-build ${RUST_SRC_PATH}/build                                       \
    --sdk ${SDK_PATH}                                                         \
    --target {x86_64-unknown-fuchsia|aarch64-unknown-fuchsia}                 \
    --verbose                                                                 \
)
</code></pre>
<p>Where <code>${RUST_SRC_PATH}/build</code> is the <code>build-dir</code> set in <code>bootstrap.toml</code>.</p>
<p>Once our environment is started, we can run our tests using <code>x.py</code> as usual. The
test runner script will run the compiled tests on an emulated Fuchsia device. To
run the full <code>tests/ui</code> test suite:</p>
<pre><code class="language-sh">( \
    source config-env.sh &amp;&amp;                                                   \
    ./x.py                                                                    \
    --config bootstrap.toml                                                      \
    --stage=2                                                                 \
    test tests/ui                                                             \
    --target x86_64-unknown-fuchsia                                           \
    --run=always                                                              \
    --test-args --target-rustcflags                                           \
    --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/sysroot/lib             \
    --test-args --target-rustcflags                                           \
    --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/lib                     \
    --test-args --target-rustcflags                                           \
    --test-args -Clink-arg=--undefined-version                                \
    --test-args --remote-test-client                                          \
    --test-args src/ci/docker/scripts/fuchsia-test-runner.py                  \
)
</code></pre>
<p>By default, <code>x.py</code> compiles test binaries with <code>panic=unwind</code>. If you built your
Rust toolchain with <code>-Cpanic=abort</code>, you need to tell <code>x.py</code> to compile test
binaries with <code>panic=abort</code> as well:</p>
<pre><code class="language-sh">    --test-args --target-rustcflags                                           \
    --test-args -Cpanic=abort                                                 \
    --test-args --target-rustcflags                                           \
    --test-args -Zpanic_abort_tests                                           \
</code></pre>
<p>When finished testing, the test runner can be used to stop the test environment:</p>
<pre><code class="language-sh">src/ci/docker/scripts/fuchsia-test-runner.py stop
</code></pre>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="zxdb"><a class="header" href="#zxdb"><code>zxdb</code></a></h3>
<p>Debugging components running on a Fuchsia emulator can be done using the
console-mode debugger: <a href="https://fuchsia.dev/fuchsia-src/development/debugger">zxdb</a>. We will demonstrate attaching necessary symbol
paths to debug our <code>hello-fuchsia</code> component.</p>
<h3 id="attaching-zxdb"><a class="header" href="#attaching-zxdb">Attaching <code>zxdb</code></a></h3>
<p>In a separate terminal, issue the following command from our <code>hello_fuchsia</code>
directory to launch <code>zxdb</code>:</p>
<p><strong>In separate terminal</strong></p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \
    --symbol-path target/x86_64-unknown-fuchsia/debug
</code></pre>
<ul>
<li><code>--symbol-path</code> gets required symbol paths, which are
necessary for stepping through your program.</li>
</ul>
<p>The “<a href="#displaying-source-code-in-zxdb">displaying source code in <code>zxdb</code></a>”
section describes how you can display Rust and/or Fuchsia source code in your
debugging session.</p>
<h3 id="using-zxdb"><a class="header" href="#using-zxdb">Using <code>zxdb</code></a></h3>
<p>Once launched, you will be presented with the window:</p>
<pre><code class="language-sh">Connecting (use "disconnect" to cancel)...
Connected successfully.
👉 To get started, try "status" or "help".
[zxdb]
</code></pre>
<p>To attach to our program, we can run:</p>
<pre><code class="language-sh">[zxdb] attach hello_fuchsia
</code></pre>
<p><strong>Expected output</strong></p>
<pre><code class="language-sh">Waiting for process matching "hello_fuchsia".
Type "filter" to see the current filters.
</code></pre>
<p>Next, we can create a breakpoint at main using “b main”:</p>
<pre><code class="language-sh">[zxdb] b main
</code></pre>
<p><strong>Expected output</strong></p>
<pre><code class="language-sh">Created Breakpoint 1 @ main
</code></pre>
<p>Finally, we can re-run the “hello_fuchsia” component from our original
terminal:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx component run \
    --recreate \
    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm
</code></pre>
<p>Once our component is running, our <code>zxdb</code> window will stop execution
in our main as desired:</p>
<p><strong>Expected output</strong></p>
<pre><code class="language-txt">Breakpoint 1 now matching 1 addrs for main
🛑 on bp 1 hello_fuchsia::main() • main.rs:2
   1 fn main() {
 ▶ 2     println!("Hello Fuchsia!");
   3 }
   4
[zxdb]
</code></pre>
<p><code>zxdb</code> has similar commands to other debuggers like <a href="https://www.sourceware.org/gdb/">gdb</a>.
To list the available commands, run “help” in the
<code>zxdb</code> window or visit <a href="https://fuchsia.dev/fuchsia-src/development/debugger">the zxdb documentation</a>.</p>
<pre><code class="language-sh">[zxdb] help
</code></pre>
<p><strong>Expected output</strong></p>
<pre><code class="language-sh">Help!

  Type "help &lt;command&gt;" for command-specific help.

Other help topics (see "help &lt;topic&gt;")
...
</code></pre>
<h3 id="displaying-source-code-in-zxdb"><a class="header" href="#displaying-source-code-in-zxdb">Displaying source code in <code>zxdb</code></a></h3>
<p>By default, the debugger will not be able to display
source code while debugging. For our user code, we displayed
source code by pointing our debugger to our debug binary via
the <code>--symbol-path</code> arg. To display library source code in
the debugger, you must provide paths to the source using
<code>--build-dir</code>. For example, to display the Rust and Fuchsia
source code:</p>
<pre><code class="language-sh">${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \
    --symbol-path target/x86_64-unknown-fuchsia/debug \
    --build-dir ${RUST_SRC_PATH}/rust \
    --build-dir ${FUCHSIA_SRC_PATH}/fuchsia/out/default
</code></pre>
<ul>
<li><code>--build-dir</code> links against source code paths, which
are not strictly necessary for debugging, but is a nice-to-have
for displaying source code in <code>zxdb</code>.</li>
</ul>
<p>Linking to a Fuchsia checkout can help with debugging Fuchsia libraries,
such as <a href="https://cs.opensource.google/fuchsia/fuchsia/+/main:sdk/lib/fdio/">fdio</a>.</p>
<h3 id="debugging-the-compiler-test-suite"><a class="header" href="#debugging-the-compiler-test-suite">Debugging the compiler test suite</a></h3>
<p>Debugging the compiler test suite requires some special configuration:</p>
<p>First, we have to properly configure zxdb so it will be able to find debug
symbols and source information for our test. The test runner can do this for us
with:</p>
<pre><code class="language-sh">src/ci/docker/scripts/fuchsia-test-runner.py debug                            \
    --rust-src ${RUST_SRC_PATH}                                               \
    --fuchsia-src ${FUCHSIA_SRC_PATH}                                         \
    --test ${TEST}
</code></pre>
<p>where <code>${TEST}</code> is relative to Rust’s <code>tests</code> directory (e.g. <code>ui/abi/...</code>).</p>
<p>This will start a zxdb session that is properly configured for the specific test
being run. All three arguments are optional, so you can omit <code>--fuchsia-src</code> if
you don’t have it downloaded. Now is a good time to set any desired breakpoints,
like <code>b main</code>.</p>
<p>Next, we have to tell <code>x.py</code> not to optimize or strip debug symbols from our
test suite binaries. We can do this by passing some new arguments to <code>rustc</code>
through our <code>x.py</code> invocation. The full invocation is:</p>
<pre><code class="language-sh">( \
    source config-env.sh &amp;&amp;                                                   \
    ./x.py                                                                    \
    --config bootstrap.toml                                                      \
    --stage=2                                                                 \
    test tests/${TEST}                                                        \
    --target x86_64-unknown-fuchsia                                           \
    --run=always                                                              \
    --test-args --target-rustcflags                                           \
    --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/sysroot/lib             \
    --test-args --target-rustcflags                                           \
    --test-args -Lnative=${SDK_PATH}/arch/{x64|arm64}/lib                     \
    --test-args --target-rustcflags                                           \
    --test-args -Clink-arg=--undefined-version                                \
    --test-args --target-rustcflags                                           \
    --test-args -Cdebuginfo=2                                                 \
    --test-args --target-rustcflags                                           \
    --test-args -Copt-level=0                                                 \
    --test-args --target-rustcflags                                           \
    --test-args -Cstrip=none                                                  \
    --test-args --remote-test-client                                          \
    --test-args src/ci/docker/scripts/fuchsia-test-runner.py                  \
)
</code></pre>
<p><em>If you built your Rust toolchain with <code>panic=abort</code>, make sure to include the
previous flags so your test binaries are also compiled with <code>panic=abort</code>.</em></p>
<p>Upon running this command, the test suite binary will be run and zxdb will
attach and load any relevant debug symbols.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-unknown-trusty-and-armv7-unknown-trusty"><a class="header" href="#aarch64-unknown-trusty-and-armv7-unknown-trusty"><code>aarch64-unknown-trusty</code> and <code>armv7-unknown-trusty</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p><a href="https://source.android.com/docs/security/features/trusty">Trusty</a> is a secure Operating System that provides a Trusted Execution
Environment (TEE) for Android.</p>
<h2 id="target-maintainers-47"><a class="header" href="#target-maintainers-47">Target maintainers</a></h2>
<p><a href="https://github.com/randomPoison">@randomPoison</a>
<a href="https://github.com/ahomescu">@ahomescu</a></p>
<h2 id="requirements-40"><a class="header" href="#requirements-40">Requirements</a></h2>
<p>These targets are cross-compiled. They have no special requirements for the host.</p>
<p>Trusty targets have partial support for the standard library: <code>alloc</code> is fully
supported and <code>std</code> has limited support that excludes things like filesystem
access, network I/O, and spawning processes/threads. File descriptors are
supported for the purpose of IPC.</p>
<p>Trusty uses the ELF file format.</p>
<h2 id="building-the-target-30"><a class="header" href="#building-the-target-30">Building the target</a></h2>
<p>The targets can be built by enabling them for a <code>rustc</code> build, for example:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["aarch64-unknown-trusty", "armv7-unknown-trusty"]
</code></pre>
<h2 id="building-rust-programs-30"><a class="header" href="#building-rust-programs-30">Building Rust programs</a></h2>
<p>There is currently no supported way to build a Trusty app with Cargo. You can
follow the <a href="https://source.android.com/docs/security/features/trusty/download-and-build">Trusty build instructions</a> to build the Trusty kernel along with any
Rust apps that are setup in the project.</p>
<h2 id="testing-31"><a class="header" href="#testing-31">Testing</a></h2>
<p>See the <a href="https://source.android.com/docs/security/features/trusty/download-and-build">Trusty build instructions</a> for information on how to build Rust code
within the main Trusty project. The main project also includes infrastructure
for testing Rust applications within a QEMU emulator.</p>
<h2 id="cross-compilation-toolchains-and-c-code-16"><a class="header" href="#cross-compilation-toolchains-and-c-code-16">Cross-compilation toolchains and C code</a></h2>
<p>See the <a href="https://source.android.com/docs/security/features/trusty/download-and-build">Trusty build instructions</a> for information on how C code is built
within Trusty.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-kmc-solid_"><a class="header" href="#-kmc-solid_">*-kmc-solid_*</a></h1>
<p><strong>Tier: 3</strong></p>
<p><a href="https://www.kmckk.co.jp/eng/SOLID/">SOLID</a> embedded development platform by Kyoto Microcomputer Co., Ltd.</p>
<p>The target names follow this format: <code>$ARCH-kmc-solid_$KERNEL-$ABI</code>, where <code>$ARCH</code> specifies the target processor architecture, <code>$KERNEL</code> the base kernel, and <code>$ABI</code> the target ABI (optional). The following targets are currently defined:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target name</th><th><code>target_arch</code></th><th><code>target_vendor</code></th><th><code>target_os</code></th></tr>
</thead>
<tbody>
<tr><td><code>aarch64-kmc-solid_asp3</code></td><td><code>aarch64</code></td><td><code>kmc</code></td><td><code>solid_asp3</code></td></tr>
<tr><td><code>armv7a-kmc-solid_asp3-eabi</code></td><td><code>arm</code></td><td><code>kmc</code></td><td><code>solid_asp3</code></td></tr>
<tr><td><code>armv7a-kmc-solid_asp3-eabihf</code></td><td><code>arm</code></td><td><code>kmc</code></td><td><code>solid_asp3</code></td></tr>
</tbody>
</table>
</div>
<h2 id="target-maintainers-48"><a class="header" href="#target-maintainers-48">Target Maintainers</a></h2>
<p><a href="https://github.com/kawadakk">@kawadakk</a></p>
<h2 id="requirements-41"><a class="header" href="#requirements-41">Requirements</a></h2>
<p>This target is cross-compiled.
A platform-provided C compiler toolchain is required, though it can be substituted by <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm">GNU Arm Embedded Toolchain</a> for the purpose of building Rust and functional binaries.</p>
<h2 id="building-3"><a class="header" href="#building-3">Building</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["aarch64-kmc-solid_asp3"]
</code></pre>
<p>Make sure <code>aarch64-kmc-elf-gcc</code> is included in <code>$PATH</code>. Alternatively, you can use GNU Arm Embedded Toolchain by adding the following to <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.aarch64-kmc-solid_asp3]
cc = "arm-none-eabi-gcc"
</code></pre>
<h2 id="cross-compilation-8"><a class="header" href="#cross-compilation-8">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any hosts.</p>
<h2 id="testing-32"><a class="header" href="#testing-32">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-31"><a class="header" href="#building-rust-programs-31">Building Rust programs</a></h2>
<p>Building executables is not supported yet.</p>
<p>If <code>rustc</code> has support for that target and the library artifacts are available, then Rust static libraries can be built for that target:</p>
<pre><code class="language-shell">$ rustc --target aarch64-kmc-solid_asp3 your-code.rs --crate-type staticlib
$ ls libyour_code.a
</code></pre>
<p>On Rust Nightly it’s possible to build without the target artifacts available:</p>
<pre><code class="language-text">cargo build -Z build-std --target aarch64-kmc-solid_asp3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="csky-unknown-linux-gnuabiv2"><a class="header" href="#csky-unknown-linux-gnuabiv2"><code>csky-unknown-linux-gnuabiv2</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>This target supports <a href="https://github.com/c-sky">C-SKY</a> CPUs with <code>abi</code> v2 and <code>glibc</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>target</th><th style="text-align: center">std</th><th style="text-align: center">host</th><th>notes</th></tr>
</thead>
<tbody>
<tr><td><code>csky-unknown-linux-gnuabiv2</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>C-SKY abiv2 Linux (little endian)</td></tr>
<tr><td><code>csky-unknown-linux-gnuabiv2hf</code></td><td style="text-align: center">✓</td><td style="text-align: center"></td><td>C-SKY abiv2 Linux, hardfloat (little endian)</td></tr>
</tbody>
</table>
</div>
<p>Reference:</p>
<ul>
<li><a href="https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource//1695027452256/T-HEAD_800_Series_ABI_Standards_Manual.pdf">CSKY ABI Manual</a></li>
<li><a href="https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource/1356021/1619528643136/csky-linux-gnuabiv2-tools-x86_64-glibc-linux-4.9.56-20210423.tar.gz">csky-linux-gnuabiv2-toolchain</a></li>
<li><a href="https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource//1689324918932/xuantie-qemu-x86_64-Ubuntu-18.04-20230714-0202.tar.gz">csky-linux-gnuabiv2-qemu</a></li>
</ul>
<p>other links:</p>
<ul>
<li>https://c-sky.github.io/</li>
<li>https://gitlab.com/c-sky/</li>
</ul>
<h2 id="target-maintainers-49"><a class="header" href="#target-maintainers-49">Target maintainers</a></h2>
<p><a href="https://github.com/Dirreke">@Dirreke</a></p>
<h2 id="requirements-42"><a class="header" href="#requirements-42">Requirements</a></h2>
<h2 id="building-the-target-31"><a class="header" href="#building-the-target-31">Building the target</a></h2>
<h3 id="get-a-c-toolchain-1"><a class="header" href="#get-a-c-toolchain-1">Get a C toolchain</a></h3>
<p>Compiling rust for this target has been tested on <code>x86_64</code> linux hosts.  Other host types have not been tested, but may work, if you can find a suitable cross compilation toolchain for them.</p>
<p>If you don’t already have a suitable toolchain, you can download from <a href="https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource/1356021/1619528643136/csky-linux-gnuabiv2-tools-x86_64-glibc-linux-4.9.56-20210423.tar.gz">here</a>, and unpack it into a directory.</p>
<h3 id="configure-rust-1"><a class="header" href="#configure-rust-1">Configure rust</a></h3>
<p>The target can be built by enabling it for a <code>rustc</code> build, by placing the following in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["x86_64-unknown-linux-gnu", "csky-unknown-linux-gnuabiv2", "csky-unknown-linux-gnuabiv2hf"]
stage = 2

[target.csky-unknown-linux-gnuabiv2]
# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN
cc = "${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc"

[target.csky-unknown-linux-gnuabiv2hf]
# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN
cc = "${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc"
</code></pre>
<h3 id="build-1"><a class="header" href="#build-1">Build</a></h3>
<pre><code class="language-sh"># in rust dir
./x.py build --stage 2
</code></pre>
<h2 id="building-and-running-rust-programs-1"><a class="header" href="#building-and-running-rust-programs-1">Building and Running Rust programs</a></h2>
<p>To test cross-compiled binaries on a <code>x86_64</code> system, you can use the <code>qemu-cskyv2</code>. This avoids having a full emulated ARM system by doing dynamic binary translation and dynamic system call translation.  It lets you run CSKY programs directly on your <code>x86_64</code> kernel.  It’s very convenient!</p>
<p>To use:</p>
<ul>
<li>Install <code>qemu-cskyv2</code> (If you don’t already have a qemu, you can download from <a href="https://occ-oss-prod.oss-cn-hangzhou.aliyuncs.com/resource//1689324918932/xuantie-qemu-x86_64-Ubuntu-18.04-20230714-0202.tar.gz">here</a>, and unpack it into a directory.)</li>
<li>Link your built toolchain via:
<ul>
<li><code>rustup toolchain link stage2 ${RUST}/build/x86_64-unknown-linux-gnu/stage2</code></li>
</ul>
</li>
<li>Create a test program</li>
</ul>
<pre><code class="language-sh">cargo new hello_world
cd hello_world
</code></pre>
<ul>
<li>Build and run</li>
</ul>
<pre><code class="language-sh">CARGO_TARGET_CSKY_UNKNOWN_LINUX_GNUABIV2_RUNNER=${QEMU_PATH}/bin/qemu-cskyv2 -L ${TOOLCHAIN_PATH}/csky-linux-gnuabiv2/libc \
CARGO_TARGET_CSKY_UNKNOWN_LINUX_GNUABIV2_LINKER=${TOOLCHAIN_PATH}/bin/csky-linux-gnuabiv2-gcc \
RUSTFLAGS="-C target-feature=+crt-static" \
cargo +stage2 run --target csky-unknown-linux-gnuabiv2
</code></pre>
<p>Attention: The dynamic-linked program may nor be run by <code>qemu-cskyv2</code> but can be run on the target.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hexagon-unknown-linux-musl"><a class="header" href="#hexagon-unknown-linux-musl"><code>hexagon-unknown-linux-musl</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Target for cross-compiling Linux user-mode applications targeting the Hexagon
DSP architecture.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Descriptions</th></tr>
</thead>
<tbody>
<tr><td>hexagon-unknown-linux-musl</td><td>Hexagon 32-bit Linux</td></tr>
</tbody>
</table>
</div>
<h2 id="target-maintainers-50"><a class="header" href="#target-maintainers-50">Target maintainers</a></h2>
<p><a href="https://github.com/androm3da">@androm3da</a></p>
<h2 id="requirements-43"><a class="header" href="#requirements-43">Requirements</a></h2>
<p>The target is cross-compiled. This target supports <code>std</code>.  By default, code
generated with this target should run on Hexagon DSP hardware.</p>
<ul>
<li><code>-Ctarget-cpu=hexagonv73</code> adds support for instructions defined up to Hexagon V73.</li>
</ul>
<p>Binaries can be run using QEMU user emulation. On Debian-based systems, it should be
sufficient to install the package <code>qemu-user-static</code> to be able to run simple static
binaries:</p>
<pre><code class="language-text"># apt install qemu-user-static
# qemu-hexagon-static ./hello
</code></pre>
<p>In order to build linux programs with Rust, you will require a linker capable
of targeting hexagon.  You can use <code>clang</code>/<code>lld</code> from the <a href="https://github.com/quic/toolchain_for_hexagon/releases">hexagon toolchain
using exclusively public open source repos</a>.</p>
<p>Also included in that toolchain is the C library that can be used when creating
dynamically linked executables.</p>
<pre><code class="language-text"># /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/bin/qemu-hexagon -L /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr/ ./hello
</code></pre>
<h2 id="linking"><a class="header" href="#linking">Linking</a></h2>
<p>This target selects <code>rust-lld</code> by default.  Another option to use is
<a href="https://github.com/qualcomm/eld">eld</a>, which is also provided with
the opensource hexagon toolchain and the Hexagon SDK.</p>
<h2 id="building-the-target-32"><a class="header" href="#building-the-target-32">Building the target</a></h2>
<p>Because it is Tier 3, rust does not yet ship pre-compiled artifacts for this
target.</p>
<p>Therefore, you can build Rust with support for the target by adding it to the
target list in <code>bootstrap.toml</code>, a sample configuration is shown below.</p>
<pre><code class="language-toml">[build]
target = ["hexagon-unknown-linux-musl"]

[target.hexagon-unknown-linux-musl]

cc = "hexagon-unknown-linux-musl-clang"
cxx = "hexagon-unknown-linux-musl-clang++"
linker = "hexagon-unknown-linux-musl-clang"
ar = "hexagon-unknown-linux-musl-ar"
ranlib = "hexagon-unknown-linux-musl-ranlib"
musl-root = "/opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr"
llvm-libunwind = 'in-tree'
qemu-rootfs = "/opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr"
</code></pre>
<h2 id="testing-33"><a class="header" href="#testing-33">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-32"><a class="header" href="#building-rust-programs-32">Building Rust programs</a></h2>
<p>Download and install the hexagon open source toolchain from https://github.com/quic/toolchain_for_hexagon/releases</p>
<p>The following <code>.cargo/config</code> is needed inside any project directory to build
for the Hexagon Linux target:</p>
<pre><code class="language-toml">[build]
target = "hexagon-unknown-linux-musl"

[target.hexagon-unknown-linux-musl]
linker = "hexagon-unknown-linux-musl-clang"
ar = "hexagon-unknown-linux-musl-ar"
runner = "qemu-hexagon -L /opt/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr"
</code></pre>
<p>Edit the “runner” in <code>.cargo/config</code> to point to the path to your toolchain’s
C library.</p>
<pre><code class="language-text">...
runner = "qemu-hexagon -L /path/to/my/inst/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/target/hexagon-unknown-linux-musl/usr"
...
</code></pre>
<p>Build/run your rust program with <code>qemu-hexagon</code> in your <code>PATH</code>:</p>
<pre><code class="language-text">export PATH=/path/to/my/inst/clang+llvm-18.1.0-cross-hexagon-unknown-linux-musl/x86_64-linux-gnu/bin/:$PATH
cargo run -Zbuild-std -Zbuild-std-features=llvm-libunwind
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hexagon-unknown-none-elf"><a class="header" href="#hexagon-unknown-none-elf"><code>hexagon-unknown-none-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Rust for baremetal Hexagon DSPs.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Descriptions</th></tr>
</thead>
<tbody>
<tr><td>hexagon-unknown-none-elf</td><td>Hexagon 32-bit (freestanding, hardfloat)</td></tr>
</tbody>
</table>
</div>
<h2 id="target-maintainers-51"><a class="header" href="#target-maintainers-51">Target maintainers</a></h2>
<p><a href="https://github.com/androm3da">@androm3da</a></p>
<h2 id="requirements-44"><a class="header" href="#requirements-44">Requirements</a></h2>
<p>This target is cross-compiled.  There is no support for <code>std</code>. There is no
default allocator, but it’s possible to use <code>alloc</code> by supplying an allocator.</p>
<p>By default, code generated with this target should run on Hexagon DSP hardware.</p>
<ul>
<li><code>-Ctarget-cpu=hexagonv73</code> adds support for instructions defined up to Hexagon V73.</li>
</ul>
<p>Functions marked <code>extern "C"</code> use the <a href="https://lists.llvm.org/pipermail/llvm-dev/attachments/20190916/21516a52/attachment-0001.pdf">Hexagon architecture calling convention</a>.</p>
<p>This target generates PIC ELF binaries.</p>
<h2 id="linking-1"><a class="header" href="#linking-1">Linking</a></h2>
<p>This target selects <code>rust-lld</code> by default.  Another option to use is
<a href="https://github.com/qualcomm/eld">eld</a>, which is also provided with
<a href="https://github.com/quic/toolchain_for_hexagon">the opensource hexagon toolchain</a>
and the Hexagon SDK.</p>
<h2 id="building-the-target-33"><a class="header" href="#building-the-target-33">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
build-stage = 1
host = ["&lt;target for your host&gt;"]
target = ["&lt;target for your host&gt;", "hexagon-unknown-none-elf"]

[target.hexagon-unknown-none-elf]

cc = "hexagon-unknown-none-elf-clang"
cxx = "hexagon-unknown-none-elf-clang++"
linker = "hexagon-unknown-none-elf-clang"
ranlib = "hexagon-unknown-none-elf-ranlib"
ar = "hexagon-unknown-none-elf-ar"
llvm-libunwind = 'in-tree'
</code></pre>
<p>Replace <code>&lt;target for your host&gt;</code> with <code>x86_64-unknown-linux-gnu</code> or whatever
else is appropriate for your host machine.</p>
<h2 id="building-rust-programs-33"><a class="header" href="#building-rust-programs-33">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing-34"><a class="header" href="#testing-34">Testing</a></h2>
<p>Since <code>hexagon-unknown-none-elf</code> supports a variety of different environments and
does not support <code>std</code>, this target does not support running the Rust test suite.</p>
<h2 id="cross-compilation-toolchains-and-c-code-17"><a class="header" href="#cross-compilation-toolchains-and-c-code-17">Cross-compilation toolchains and C code</a></h2>
<p>This target has been tested using <code>qemu-system-hexagon</code>.</p>
<p>A common use case for <code>hexagon-unknown-none-elf</code> is building libraries that
link against C code and can be used in emulation or on a device with a
Hexagon DSP.</p>
<p>The Hexagon SDK has libraries which are useful to link against when running
on a device.</p>
<h1 id="standalone-os"><a class="header" href="#standalone-os">Standalone OS</a></h1>
<p>The script below will build an executable against “hexagon standalone OS”
which is suitable for emulation or bare-metal on-device testing.</p>
<p>First, run <code>cargo new --bin demo1_hexagon</code> then add the source below as
<code>src/main.rs</code>.  This program demonstrates the console output via semihosting.</p>
<pre><code class="language-rust ignore (platform-specific eh-personality-is-unstable)">#![no_std]
#![no_main]

extern "C" {
    fn putchar(ch: i32);
    fn _exit(code: i32) -&gt; !;
}

#[no_mangle]
extern "C" fn main() -&gt; i32 {
    let message = "Hello, this is Rust!";
    for b in message.bytes() {
        unsafe {
            putchar(b as i32);
        }
    }
    0
}

#[panic_handler]
fn panic(_panic: &amp;core::panic::PanicInfo) -&gt; ! {
    unsafe {
        _exit(1);
    }
}
</code></pre>
<p>Next, save the script below as <code>build.sh</code> and edit it to suit your
environment.</p>
<ul>
<li><code>hex_toolchain</code> below refers to the <a href="https://github.com/quic/toolchain_for_hexagon/releases">hexagon toolchain using exclusively
public open source repos</a>.</li>
<li><code>cc</code> below refers to clang.  You can use <code>clang</code> from your distribution, as
long as it’s at least <code>clang-17</code>.  Or you can use
<code>hexagon-unknown-none-elf-clang</code> from one of the <a href="https://github.com/quic/toolchain_for_hexagon/releases">hexagon open source toolchain
releases</a>.</li>
</ul>
<pre><code class="language-sh"># Hexagon SDK, required for target libraries:
hex_sdk_root=/local/mnt/workspace/Qualcomm/Hexagon_SDK/5.3.0.0
hex_sdk_toolchain=${hex_sdk_root}/tools/HEXAGON_Tools/8.6.06

sdk_libs=${hex_sdk_toolchain}/Tools/target/hexagon/lib
q6_arch=v65
g0_lib_path=${sdk_libs}/${q6_arch}/G0
pic_lib_path=${sdk_libs}/${q6_arch}/G0/pic

build_cfg=release
cargo build --target=hexagon-unknown-none-elf -Zbuild-std --release

# Builds an executable against "hexagon standalone OS" suitable for emulation:
${cc} --target=hexagon-unknown-none-elf -o testit \
    -fuse-ld=lld \
    -m${q6_arch} \
    -nodefaultlibs \
    -nostartfiles \
    ${g0_lib_path}/crt0_standalone.o \
    ${g0_lib_path}/crt0.o \
    ${g0_lib_path}/init.o \
    -L${sdk_libs}/${q6_arch}/ \
    -L${sdk_libs}/ \
    wrap.c \
    target/hexagon-unknown-none-elf/${build_cfg}/libdemo1_hexagon.rlib \
    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcore-*.rlib \
    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcompiler_builtins-*.rlib \
    -Wl,--start-group \
    -Wl,--defsym,_SDA_BASE_=0,--defsym,__sbss_start=0,--defsym,__sbss_end=0 \
    ${g0_lib_path}/libstandalone.a \
    ${g0_lib_path}/libc.a \
    -lgcc \
    -lc_eh \
    -Wl,--end-group \
    ${g0_lib_path}/fini.o \

${hex_toolchain}/x86_64-linux-gnu/bin/qemu-system-hexagon -monitor none -display none -kernel ./testit
</code></pre>
<h1 id="qurt-os"><a class="header" href="#qurt-os">QuRT OS</a></h1>
<p>First, run <code>cargo new --lib demo2_hexagon</code> then add the source below as
<code>src/lib.rs</code>.  This program demonstrates inline assembly and console output
via semihosting.</p>
<pre><code class="language-rust ignore (platform-specific eh-personality-is-unstable)">#![no_std]
#![no_main]
#![feature(lang_items)]
#![feature(asm_experimental_arch)]

use core::arch::asm;

extern "C" {
    fn putchar(ch: i32);
    fn _exit(code: i32) -&gt; !;
}

fn hexagon_specific() {
    let mut buffer = [0_u8; 128];

    unsafe {
        let mut x = &amp;buffer;
        asm!(
                "{{\n\t",
                "  v0=vmem({addr}+#0)\n\t",
                "  {tmp} = and({tmp}, #1)\n\t",
                "}}\n\t",
                addr = in(reg) x,
                tmp = out(reg) _,
            );
    }
}

#[no_mangle]
extern "C" fn hello() -&gt; i32 {
    let message = "Hello, this is Rust!\n";
    for b in message.bytes() {
        unsafe {
            putchar(b as i32);
        }
    }
    hexagon_specific();
    0
}

#[panic_handler]
fn panic(_panic: &amp;core::panic::PanicInfo) -&gt; ! {
    unsafe {
        _exit(1);
    }
}

#[lang = "eh_personality"]
fn rust_eh_personality() {}
</code></pre>
<p>Next, create a C program as an entry point, save the content below as
<code>wrap.c</code>:</p>
<pre><code class="language-C">int hello();

int main() {
    hello();
}
</code></pre>
<p>Then, save the script below as <code>build.sh</code> and edit it to suit your
environment.  The script below will build a shared object against the QuRT
RTOS which is suitable for emulation or on-device testing when loaded via
the fastrpc-shell.</p>
<pre><code class="language-sh"># Hexagon SDK, required for target libraries:
hex_sdk_root=/local/mnt/workspace/Qualcomm/Hexagon_SDK/5.3.0.0
hex_sdk_toolchain=${hex_sdk_root}/tools/HEXAGON_Tools/8.6.06

sdk_libs=${hex_sdk_toolchain}/Tools/target/hexagon/lib
q6_arch=v65
g0_lib_path=${sdk_libs}/${q6_arch}/G0
pic_lib_path=${sdk_libs}/${q6_arch}/G0/pic
runelf=${hex_sdk_root}/rtos/qurt/computev65/sdksim_bin/runelf.pbn
rmohs=${hex_sdk_root}/libs/run_main_on_hexagon/ship/hexagon_toolv86_${q6_arch}/run_main_on_hexagon_sim

# Builds a library suitable for loading into "run_main_on_hexagon_sim" for
# emulation or frpc shell on real target:
${cc} --target=hexagon-unknown-none-elf -o testit.so \
    -fuse-ld=lld \
    -fPIC -shared \
    -nostdlib \
    -Wl,-Bsymbolic \
      -Wl,--wrap=malloc \
      -Wl,--wrap=calloc \
      -Wl,--wrap=free \
      -Wl,--wrap=realloc \
      -Wl,--wrap=memalign \
    -m${q6_arch} \
    wrap.c \
    target/hexagon-unknown-none-elf/${build_cfg}/libdemo2_hexagon.rlib \
    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcore-*.rlib \
    target/hexagon-unknown-none-elf/${build_cfg}/deps/libcompiler_builtins-*.rlib \
    -Wl,-soname=testit \
    ${pic_lib_path}/libc.so

# -Bsymbolic above for memory alloc funcs is necessary to access the heap on
# target, but otherwise not required.

# multi-stage loader: runelf =&gt; run_main_on_hexagon_sim =&gt; testit.so{`main`}
${hex_toolchain}/x86_64-linux-gnu/bin/qemu-system-hexagon \
    -monitor none \
    -display none \
    -kernel ${runelf} \
    -append "${rmohs} -- ./testit.so"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hexagon-unknown-qurt"><a class="header" href="#hexagon-unknown-qurt"><code>hexagon-unknown-qurt</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Rust for Hexagon QuRT (Qualcomm Real-Time OS).</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>hexagon-unknown-qurt</td><td>Hexagon 32-bit QuRT</td></tr>
</tbody>
</table>
</div>
<h2 id="target-maintainers-52"><a class="header" href="#target-maintainers-52">Target maintainers</a></h2>
<p><a href="https://github.com/androm3da">@androm3da</a></p>
<h2 id="requirements-45"><a class="header" href="#requirements-45">Requirements</a></h2>
<p>This target is cross-compiled. There is support for <code>std</code>. The target uses
QuRT’s standard library and runtime.</p>
<p>By default, code generated with this target should run on Hexagon DSP hardware
running the QuRT real-time operating system.</p>
<ul>
<li><code>-Ctarget-cpu=hexagonv69</code> targets Hexagon V69 architecture (default)</li>
<li><code>-Ctarget-cpu=hexagonv73</code> adds support for instructions defined up to Hexagon V73</li>
</ul>
<p>Functions marked <code>extern "C"</code> use the <a href="https://lists.llvm.org/pipermail/llvm-dev/attachments/20190916/21516a52/attachment-0001.pdf">Hexagon architecture calling convention</a>.</p>
<p>This target generates position-independent ELF binaries by default, making it
suitable for both static images and dynamic shared objects.</p>
<p>The <a href="https://softwarecenter.qualcomm.com/catalog/item/Hexagon_SDK">Hexagon SDK</a> is
required for building programs for this target.</p>
<h2 id="linking-2"><a class="header" href="#linking-2">Linking</a></h2>
<p>This target selects <code>rust-lld</code> by default.  Another option to use is
<a href="https://github.com/qualcomm/eld">eld</a>, which is also provided with
<a href="https://github.com/quic/toolchain_for_hexagon">the opensource hexagon toolchain</a>
and the Hexagon SDK.</p>
<h2 id="building-the-target-34"><a class="header" href="#building-the-target-34">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
build-stage = 1
host = ["&lt;target for your host&gt;"]
target = ["&lt;target for your host&gt;", "hexagon-unknown-qurt"]

[target.hexagon-unknown-qurt]
cc = "hexagon-clang"
cxx = "hexagon-clang++"
ranlib = "llvm-ranlib"
ar = "llvm-ar"
llvm-libunwind = 'in-tree'
</code></pre>
<p>Replace <code>&lt;target for your host&gt;</code> with <code>x86_64-unknown-linux-gnu</code> or whatever
else is appropriate for your host machine.</p>
<h2 id="building-rust-programs-34"><a class="header" href="#building-rust-programs-34">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="static-image-targeting"><a class="header" href="#static-image-targeting">Static Image Targeting</a></h2>
<p>For static executables that run directly on QuRT, use the default target
configuration with additional linker flags:</p>
<pre><code class="language-sh"># Build a static executable for QuRT
cargo rustc --target hexagon-unknown-qurt -- \
    -C link-args="-static -nostdlib" \
    -C link-args="-L/opt/Hexagon_SDK/6.3.0.0/rtos/qurt/computev69/lib" \
    -C link-args="-lqurt -lc"
</code></pre>
<p>This approach is suitable for:</p>
<ul>
<li>Standalone QuRT applications</li>
<li>System-level services</li>
<li>Boot-time initialization code</li>
<li>Applications that need deterministic memory layout</li>
</ul>
<h2 id="user-loadable-shared-object-targeting"><a class="header" href="#user-loadable-shared-object-targeting">User-Loadable Shared Object Targeting</a></h2>
<p>For shared libraries that can be dynamically loaded by QuRT applications:</p>
<pre><code class="language-sh"># Build a shared object for QuRT
cargo rustc --target hexagon-unknown-qurt \
    --crate-type=cdylib -- \
    -C link-args="-shared -fPIC" \
    -C link-args="-L/opt/Hexagon_SDK/6.3.0.0/rtos/qurt/computev69/lib"
</code></pre>
<p>This approach is suitable for:</p>
<ul>
<li>Plugin architectures</li>
<li>Runtime-loadable modules</li>
<li>Libraries shared between multiple applications</li>
<li>Code that needs to be updated without system restart</li>
</ul>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<p>The target can be customized for different use cases:</p>
<h3 id="for-static-images"><a class="header" href="#for-static-images">For Static Images</a></h3>
<pre><code class="language-toml"># In .cargo/config.toml
[target.hexagon-unknown-qurt]
rustflags = [
    "-C", "link-args=-static",
    "-C", "link-args=-nostdlib",
    "-C", "target-feature=-small-data"
]
</code></pre>
<h3 id="for-shared-objects"><a class="header" href="#for-shared-objects">For Shared Objects</a></h3>
<pre><code class="language-toml"># In .cargo/config.toml
[target.hexagon-unknown-qurt]
rustflags = [
    "-C", "link-args=-shared",
    "-C", "link-args=-fPIC",
    "-C", "relocation-model=pic"
]
</code></pre>
<h2 id="testing-35"><a class="header" href="#testing-35">Testing</a></h2>
<p>Since <code>hexagon-unknown-qurt</code> requires the QuRT runtime environment, testing requires
either:</p>
<ul>
<li>Hexagon hardware with QuRT</li>
<li><code>hexagon-sim</code></li>
<li>QEMU (<code>qemu-system-hexagon</code>)</li>
</ul>
<h2 id="cross-compilation-toolchains-and-c-code-18"><a class="header" href="#cross-compilation-toolchains-and-c-code-18">Cross-compilation toolchains and C code</a></h2>
<p>This target requires the proprietary <a href="https://softwarecenter.qualcomm.com/catalog/item/Hexagon_SDK">Hexagon SDK toolchain for C interoperability</a>:</p>
<ul>
<li><strong>Sample SDK Path</strong>: <code>/opt/Hexagon_SDK/6.3.0.0/</code></li>
<li><strong>Toolchain</strong>: Use <code>hexagon-clang</code> from the Hexagon SDK</li>
<li><strong>Libraries</strong>: Link against QuRT system libraries as needed</li>
</ul>
<h3 id="c-interoperability-example"><a class="header" href="#c-interoperability-example">C Interoperability Example</a></h3>
<pre><code class="language-rust">// lib.rs
#![no_std]
extern crate std;

#[unsafe(no_mangle)]
pub extern "C" fn rust_function() -&gt; i32 {
    // Your Rust code here
    42
}

fn main() {
    // Example usage
    let result = rust_function();
    assert_eq!(result, 42);
}</code></pre>
<pre><code class="language-c">// wrapper.c
extern int rust_function(void);

int main() {
    return rust_function();
}
</code></pre>
<p>The target supports both static linking for standalone applications and dynamic
linking for modular architectures, making it flexible for various QuRT
deployment scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64-unknown-illumos-and-x86_64-unknown-illumos"><a class="header" href="#aarch64-unknown-illumos-and-x86_64-unknown-illumos"><code>aarch64-unknown-illumos</code> and <code>x86_64-unknown-illumos</code></a></h1>
<p><strong>Tier: 2/3</strong></p>
<p><a href="https://www.illumos.org/">illumos</a>, is a Unix operating system which provides next-generation features for downstream distributions,
including advanced system debugging, next generation filesystem, networking, and virtualization options.</p>
<h2 id="target-maintainers-53"><a class="header" href="#target-maintainers-53">Target maintainers</a></h2>
<p><a href="https://github.com/jclulow">@jclulow</a>
<a href="https://github.com/pfmooney">@pfmooney</a></p>
<h2 id="requirements-46"><a class="header" href="#requirements-46">Requirements</a></h2>
<p>The target supports host tools.</p>
<p>The illumos target supports <code>std</code> and uses the standard ELF file format.</p>
<p><code>x86_64-unknown-illumos</code> is a tier 2 target with host tools.
<code>aarch64-unknown-illumos</code> is a tier 3 target.</p>
<h2 id="building-the-target-35"><a class="header" href="#building-the-target-35">Building the target</a></h2>
<p>These targets can be built by adding <code>aarch64-unknown-illumos</code> and
<code>x86_64-unknown-illumos</code> as targets in the rustc list.</p>
<h2 id="building-rust-programs-35"><a class="header" href="#building-rust-programs-35">Building Rust programs</a></h2>
<p>Rust ships pre-compiled artifacts for the <code>x86_64-unknown-illumos</code> target.
Rust does not ship pre-compiled artifacts for <code>aarch64-unknown-illumos</code>,
it requires building the target either as shown above or using <code>-Zbuild-std</code>.</p>
<h2 id="testing-36"><a class="header" href="#testing-36">Testing</a></h2>
<p>Tests can be run in the same way as a regular binary.</p>
<h2 id="cross-compilation-toolchains-and-c-code-19"><a class="header" href="#cross-compilation-toolchains-and-c-code-19">Cross-compilation toolchains and C code</a></h2>
<p>The target supports C code.</p>
<p>The illumos project makes available <a href="https://github.com/illumos/sysroot">prebuilt sysroot artefacts</a> which can be used for cross compilation.
The official Rust binaries are cross-compiled using these artefacts.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="loongarch-unknown-linux-"><a class="header" href="#loongarch-unknown-linux-"><code>loongarch*-unknown-linux-*</code></a></h1>
<p><strong>Tier: 2 (with Host Tools)</strong></p>
<p><a href="https://loongson.github.io/LoongArch-Documentation/README-EN.html">LoongArch</a> Linux targets.
LoongArch is a RISC ISA developed by Loongson Technology Corporation Limited.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>loongarch64-unknown-linux-gnu</code></td><td>LoongArch64 Linux, LP64D ABI (kernel 5.19, glibc 2.36), LSX required</td></tr>
<tr><td><code>loongarch64-unknown-linux-musl</code></td><td>LoongArch64 Linux, LP64D ABI (kernel 5.19, musl 1.2.5), LSX required</td></tr>
</tbody>
</table>
</div>
<p>These support both native and cross builds, and have full support for <code>std</code>.</p>
<p>Reference material:</p>
<ul>
<li><a href="https://loongson.github.io/LoongArch-Documentation/README-EN.html">LoongArch ISA manuals</a></li>
<li><a href="https://github.com/loongson/la-abi-specs">Application Binary Interface for the LoongArch™ Architecture</a></li>
</ul>
<h2 id="target-maintainers-54"><a class="header" href="#target-maintainers-54">Target maintainers</a></h2>
<p><a href="https://github.com/heiher">@heiher</a>
<a href="https://github.com/xen0n">@xen0n</a></p>
<h2 id="requirements-47"><a class="header" href="#requirements-47">Requirements</a></h2>
<h3 id="os-version-6"><a class="header" href="#os-version-6">OS Version</a></h3>
<p>The minimum supported Linux version is 5.19.</p>
<p>Some Linux distributions, mostly commercial ones, may provide forked Linux
kernels that has a version number less than 5.19 for their LoongArch ports.
Such kernels may still get patched to be compatible with the upstream Linux
5.19 UAPI, therefore supporting the targets described in this document, but
this is not always the case. The <code>rustup</code> installer contains a check for this,
and will abort if incompatibility is detected.</p>
<h3 id="host-toolchain-1"><a class="header" href="#host-toolchain-1">Host toolchain</a></h3>
<p>The targets require a reasonably up-to-date LoongArch toolchain on the host.
Currently the following components are used by the Rust CI to build the target,
and the versions can be seen as the minimum requirement:</p>
<ul>
<li>GNU Binutils 2.42</li>
<li>GCC 14.x</li>
<li>glibc 2.36</li>
<li>linux-headers 5.19</li>
</ul>
<p>Of these, glibc and linux-headers are at their respective earliest versions with
mainline LoongArch support, so it is impossible to use older versions of these.
Older versions of Binutils and GCC will not work either, due to lack of support
for newer LoongArch ELF relocation types, among other features.</p>
<p>Recent LLVM/Clang toolchains may be able to build the targets, but are not
currently being actively tested.</p>
<h3 id="cpu-features"><a class="header" href="#cpu-features">CPU features</a></h3>
<p>These targets require the double-precision floating-point and LSX (LoongArch
SIMD Extension) features.</p>
<h2 id="building-4"><a class="header" href="#building-4">Building</a></h2>
<p>These targets are distributed through <code>rustup</code>, and otherwise require no
special configuration.</p>
<p>If you need to build your own Rust for some reason though, the targets can be
simply enabled in <code>bootstrap.toml</code>. For example:</p>
<pre><code class="language-toml">[build]
target = ["loongarch64-unknown-linux-gnu"]
</code></pre>
<p>Make sure the LoongArch toolchain binaries are reachable from <code>$PATH</code>.
Alternatively, you can explicitly configure the paths in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.loongarch64-unknown-linux-gnu]
# Adjust the paths to point at your toolchain
# Suppose the toolchain is placed at /TOOLCHAIN_PATH, and the cross prefix is
# "loongarch64-unknown-linux-gnu-":
cc = "/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc"
cxx = "/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-g++"
ar = "/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ar"
ranlib = "/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ranlib"
linker = "/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc"
</code></pre>
<h3 id="cross-compilation-9"><a class="header" href="#cross-compilation-9">Cross-compilation</a></h3>
<p>This target can be cross-compiled on a <code>x86_64-unknown-linux-gnu</code> host.
Other hosts are also likely to work, but not actively tested.</p>
<p>You can test the cross build directly on the host, thanks to QEMU linux-user emulation.
An example is given below:</p>
<pre><code class="language-sh"># Suppose the cross toolchain is placed at $TOOLCHAIN_PATH, with a cross prefix
# of "loongarch64-unknown-linux-gnu-".
export CC_loongarch64_unknown_linux_gnu="$TOOLCHAIN_PATH"/bin/loongarch64-unknown-linux-gnu-gcc
export CXX_loongarch64_unknown_linux_gnu="$TOOLCHAIN_PATH"/bin/loongarch64-unknown-linux-gnu-g++
export AR_loongarch64_unknown_linux_gnu="$TOOLCHAIN_PATH"/bin/loongarch64-unknown-linux-gnu-gcc-ar
export CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNU_LINKER="$TOOLCHAIN_PATH"/bin/loongarch64-unknown-linux-gnu-gcc

# Point qemu-loongarch64 to the LoongArch sysroot.
# Suppose the sysroot is located at "sysroot" below the toolchain root:
export CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNU_RUNNER="qemu-loongarch64 -L $TOOLCHAIN_PATH/sysroot"
# Or alternatively, if binfmt_misc is set up for running LoongArch binaries
# transparently:
export QEMU_LD_PREFIX="$TOOLCHAIN_PATH"/sysroot

cargo run --target loongarch64-unknown-linux-gnu --release
</code></pre>
<h2 id="testing-37"><a class="header" href="#testing-37">Testing</a></h2>
<p>There are no special requirements for testing and running the targets.
For testing cross builds on the host, please refer to the “Cross-compilation”
section above.</p>
<h2 id="building-rust-programs-36"><a class="header" href="#building-rust-programs-36">Building Rust programs</a></h2>
<p>As the targets are available through <code>rustup</code>, it is very easy to build Rust
programs for these targets: same as with other architectures.
Note that you will need a LoongArch C/C++ toolchain for linking, or if you want
to compile C code along with Rust (such as for Rust crates with C dependencies).</p>
<pre><code class="language-sh">rustup target add loongarch64-unknown-linux-gnu
cargo build --target loongarch64-unknown-linux-gnu
</code></pre>
<p>Availability of pre-built artifacts through <code>rustup</code> are as follows:</p>
<ul>
<li><code>loongarch64-unknown-linux-gnu</code>: since Rust 1.71;</li>
<li><code>loongarch64-unknown-linux-musl</code>: since Rust 1.81.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="loongarch-unknown-none"><a class="header" href="#loongarch-unknown-none"><code>loongarch*-unknown-none*</code></a></h1>
<p>Freestanding/bare-metal LoongArch binaries in ELF format: firmware, kernels, etc.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Description</th><th>Tier</th></tr>
</thead>
<tbody>
<tr><td><code>loongarch32-unknown-none</code></td><td>LoongArch 32-bit, ILP32D ABI (freestanding, hard-float)</td><td>Tier 3</td></tr>
<tr><td><code>loongarch32-unknown-none-softfloat</code></td><td>LoongArch 32-bit, ILP32S ABI (freestanding, soft-float)</td><td>Tier 3</td></tr>
<tr><td><code>loongarch64-unknown-none</code></td><td>LoongArch 64-bit, LP64D ABI (freestanding, hard-float)</td><td>Tier 2</td></tr>
<tr><td><code>loongarch64-unknown-none-softfloat</code></td><td>LoongArch 64-bit, LP64S ABI (freestanding, soft-float)</td><td>Tier 2</td></tr>
</tbody>
</table>
</div>
<h2 id="target-maintainers-55"><a class="header" href="#target-maintainers-55">Target maintainers</a></h2>
<p><a href="https://github.com/heiher">@heiher</a>
<a href="https://github.com/xen0n">@xen0n</a></p>
<h2 id="requirements-48"><a class="header" href="#requirements-48">Requirements</a></h2>
<p>This target is cross-compiled. There is no support for <code>std</code>. There is no
default allocator, but it’s possible to use <code>alloc</code> by supplying an allocator.</p>
<p>The <code>*-softfloat</code> target does not assume existence of FPU or any other LoongArch
ISA extension, and does not make use of any non-GPR register.
This allows the generated code to run in environments, such as kernels, which
may need to avoid the use of such registers or which may have special considerations
about the use of such registers (e.g. saving and restoring them to avoid breaking
userspace code using the same registers). You can change code generation to use
additional CPU features via the <code>-C target-feature=</code> codegen options to rustc, or
via the <code>#[target_feature]</code> mechanism within Rust code.</p>
<p>By default, code generated with the soft-float target should run on any
LoongArch hardware, with the hard-float target additionally requiring an FPU;
enabling additional target features may raise this baseline.</p>
<p>Code generated with the targets will use the <code>medium</code> code model by default.
You can change this using the <code>-C code-model=</code> option to rustc.</p>
<p>On <code>loongarch*-unknown-none*</code>, <code>extern "C"</code> uses the <a href="https://github.com/loongson/la-abi-specs/blob/release/lapcs.adoc">architecture’s standard calling convention</a>.</p>
<p>The targets generate binaries in the ELF format. Any alternate formats or
special considerations for binary layout will require linker options or linker
scripts.</p>
<h2 id="building-the-target-36"><a class="header" href="#building-the-target-36">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding them to the <code>target</code>
list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = [
  "loongarch32-unknown-none",
  "loongarch32-unknown-none-softfloat",
  "loongarch64-unknown-none",
  "loongarch64-unknown-none-softfloat",
]
</code></pre>
<h2 id="testing-38"><a class="header" href="#testing-38">Testing</a></h2>
<p>As the targets support a variety of different environments and do not support
<code>std</code>, they do not support running the Rust test suite.</p>
<h2 id="building-rust-programs-37"><a class="header" href="#building-rust-programs-37">Building Rust programs</a></h2>
<h3 id="loongarch32-unknown-none"><a class="header" href="#loongarch32-unknown-none">loongarch32-unknown-none*</a></h3>
<p>The <code>loongarch32-unknown-none*</code> targets are Tier 3, so you must build the Rust
compiler from source to use them.</p>
<pre><code class="language-sh"># target flag may be used with any cargo or rustc command
cargo build --target loongarch32-unknown-none
cargo build --target loongarch32-unknown-none-softfloat
</code></pre>
<h3 id="loongarch64-unknown-none"><a class="header" href="#loongarch64-unknown-none">loongarch64-unknown-none*</a></h3>
<p>Starting with Rust 1.74, precompiled artifacts are provided via <code>rustup</code>:</p>
<pre><code class="language-sh"># install cross-compile toolchain
rustup target add loongarch64-unknown-none
rustup target add loongarch64-unknown-none-softfloat
# target flag may be used with any cargo or rustc command
cargo build --target loongarch64-unknown-none
cargo build --target loongarch64-unknown-none-softfloat
</code></pre>
<h2 id="cross-compilation-toolchains-and-c-code-20"><a class="header" href="#cross-compilation-toolchains-and-c-code-20">Cross-compilation toolchains and C code</a></h2>
<p>For cross builds, you will need an appropriate LoongArch C/C++ toolchain for
linking, or if you want to compile C code along with Rust (such as for Rust
crates with C dependencies).</p>
<p>Rust <em>may</em> be able to use an <code>loongarch{32,64}-unknown-linux-{gnu,musl}-</code> toolchain with
appropriate standalone flags to build for this toolchain (depending on the assumptions
of that toolchain, see below), or you may wish to use a separate
<code>loongarch{32,64}-unknown-none</code> toolchain.</p>
<p>On some LoongArch hosts that use ELF binaries, you <em>may</em> be able to use the host
C toolchain, if it does not introduce assumptions about the host environment
that don’t match the expectations of a standalone environment. Otherwise, you
may need a separate toolchain for standalone/freestanding development, just as
when cross-compiling from a non-LoongArch platform.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-lynxos178-"><a class="header" href="#-lynxos178-"><code>*-lynxos178-*</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Targets for the LynxOS-178 operating system.</p>
<p><a href="https://www.lynx.com/products/lynxos-178-do-178c-certified-posix-rtos">LynxOS-178</a>
is a commercial RTOS designed for safety-critical real-time systems.  It is
developed by Lynx Software Technologies as part of the
<a href="https://www.lynx.com/solutions/safe-and-secure-operating-environment">MOSA.ic</a>
product suite.</p>
<p>Target triples available:</p>
<ul>
<li><code>x86_64-lynx-lynxos178</code></li>
</ul>
<h2 id="target-maintainers-56"><a class="header" href="#target-maintainers-56">Target maintainers</a></h2>
<p><a href="https://github.com/rfatykhov-lynx">@rfatykhov-lynx</a></p>
<h2 id="requirements-49"><a class="header" href="#requirements-49">Requirements</a></h2>
<p>To build Rust programs for LynxOS-178, you must first have LYNX MOSA.ic
installed on the build machine.</p>
<p>This target supports only cross-compilation, from the same hosts supported by
the Lynx CDK.</p>
<p>Currently only <code>no_std</code> programs are supported. Work to support <code>std</code> is in
progress.</p>
<h2 id="building-the-target-37"><a class="header" href="#building-the-target-37">Building the target</a></h2>
<p>You can build Rust with support for x86_64-lynx-lynxos178 by adding that
to the <code>target</code> list in <code>config.toml</code>, and then running <code>./x build --target x86_64-lynx-lynxos178 compiler</code>.</p>
<h2 id="building-rust-programs-38"><a class="header" href="#building-rust-programs-38">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will need to build Rust with the target enabled (see “Building
the target” above).</p>
<p>Before executing <code>cargo</code>, you must configure the environment to build LynxOS-178
binaries by running <code>source setup.sh</code> from the los178 directory.</p>
<p>If your program/crates contain procedural macros, Rust must be able to build
binaries for the host as well. The host gcc is hidden by sourcing setup.sh.  To
deal with this, add the following to your project’s <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu]
linker = "lynx-host-gcc"
</code></pre>
<p>(If necessary substitute your host target triple for x86_64-unknown-linux-gnu.)</p>
<p>To point <code>cargo</code> at the correct rustc binary, set the RUSTC environment
variable.</p>
<p>The core library should be usable. You can try by building it as part of your
project:</p>
<pre><code class="language-bash">cargo +nightly build -Z build-std=core --target x86_64-lynx-lynxos178
</code></pre>
<h2 id="testing-39"><a class="header" href="#testing-39">Testing</a></h2>
<p>Binaries built with rust can be provided to a LynxOS-178 instance on its file
system, where they can be executed. Rust binaries tend to be large, so it may
be necessary to strip them first.</p>
<p>It is possible to run the Rust testsuite by providing a test runner that takes
the test binary and executes it under LynxOS-178. Most (all?) tests won’t run
without std support though, which is not yet supported.</p>
<h2 id="cross-compilation-toolchains-and-c-code-21"><a class="header" href="#cross-compilation-toolchains-and-c-code-21">Cross-compilation toolchains and C code</a></h2>
<p>LYNX MOSA.ic comes with all the tools required to cross-compile C code for
LynxOS-178.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="m68k-unknown-linux-gnu"><a class="header" href="#m68k-unknown-linux-gnu">m68k-unknown-linux-gnu</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Motorola 680x0 Linux</p>
<h2 id="target-maintainers-57"><a class="header" href="#target-maintainers-57">Target Maintainers</a></h2>
<p><a href="https://github.com/glaubitz">@glaubitz</a>
<a href="https://github.com/ricky26">@ricky26</a></p>
<h2 id="requirements-50"><a class="header" href="#requirements-50">Requirements</a></h2>
<p>This target requires a Linux/m68k build environment for cross-compilation which
is available on Debian and Debian-based systems, openSUSE and other distributions.</p>
<p>On Debian, it should be sufficient to install a g++ cross-compiler for the m68k
architecture which will automatically pull in additional dependencies such as
the glibc cross development package:</p>
<pre><code class="language-text"># apt install g++-m68k-linux-gnu
</code></pre>
<p>Binaries can be run using QEMU user emulation. On Debian-based systems, it should be
sufficient to install the package <code>qemu-user-static</code> to be able to run simple static
binaries:</p>
<pre><code class="language-text"># apt install qemu-user-static
</code></pre>
<p>To run more complex programs, it will be necessary to set up a Debian/m68k chroot with
the help of the command <code>debootstrap</code>:</p>
<pre><code class="language-text"># apt install debootstrap debian-ports-archive-keyring
# debootstrap --keyring=/usr/share/keyrings/debian-ports-archive-keyring.gpg --arch=m68k unstable debian-68k http://ftp.ports.debian.org/debian-ports
</code></pre>
<p>This chroot can then seamlessly entered using the normal <code>chroot</code> command thanks to
QEMU user emulation:</p>
<pre><code class="language-text"># chroot /path/to/debian-68k
</code></pre>
<p>To get started with native builds, which are currently untested, a native Debian/m68k
system can be installed either on real hardware such as 68k-based Commodore Amiga or
Atari systems or emulated environments such as QEMU version 4.2 or newer or ARAnyM.</p>
<p>ISO images for installation are provided by the Debian Ports team and can be obtained
from the Debian CD image server available at:</p>
<p><a href="https://cdimage.debian.org/cdimage/ports/current/">https://cdimage.debian.org/cdimage/ports/current</a></p>
<p>Documentation for Debian/m68k is available on the Debian Wiki at:</p>
<p><a href="https://wiki.debian.org/M68k">https://wiki.debian.org/M68k</a></p>
<p>Support is available either through the <code>debian-68k</code> mailing list:</p>
<p><a href="https://lists.debian.org/debian-68k/">https://lists.debian.org/debian-68k/</a></p>
<p>or the <code>#debian-68k</code> IRC channel on OFTC network.</p>
<h2 id="building-5"><a class="header" href="#building-5">Building</a></h2>
<p>The codegen for this target should be built by default. However, core and std
are currently missing but are being worked on and should become available in
the near future.</p>
<h2 id="cross-compilation-10"><a class="header" href="#cross-compilation-10">Cross-compilation</a></h2>
<p>This target can be cross-compiled from a standard Debian or Debian-based, openSUSE or any
other distribution which has a basic m68k cross-toolchain available.</p>
<h2 id="testing-40"><a class="header" href="#testing-40">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-39"><a class="header" href="#building-rust-programs-39">Building Rust programs</a></h2>
<p>Rust programs can be built for that target:</p>
<pre><code class="language-text">rustc --target m68k-unknown-linux-gnu your-code.rs
</code></pre>
<p>Very simple programs can be run using the <code>qemu-m68k-static</code> program:</p>
<pre><code class="language-text">$ qemu-m68k-static your-code
</code></pre>
<p>For more complex applications, a chroot or native (emulated) Debian/m68k system are required
for testing.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="m68k-unknown-none-elf"><a class="header" href="#m68k-unknown-none-elf">m68k-unknown-none-elf</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Bare metal Motorola 680x0</p>
<h2 id="target-maintainers-58"><a class="header" href="#target-maintainers-58">Target Maintainers</a></h2>
<p><a href="https://github.com/knickish">@knickish</a></p>
<h2 id="requirements-51"><a class="header" href="#requirements-51">Requirements</a></h2>
<p>This target requires an m68k build environment for cross-compilation which
is available on Debian, Debian-based systems, openSUSE, and other distributions.
The gnu linker is currently required, as <code>lld</code> has no support for the <code>m68k</code> architecture</p>
<p>On Debian-based systems, it should be sufficient to install a g++ cross-compiler for the m68k
architecture which will automatically pull in additional dependencies such as
the glibc cross development package:</p>
<pre><code class="language-sh">apt install g++-m68k-linux-gnu
</code></pre>
<p>Binaries can be run using QEMU user emulation. On Debian-based systems, it should be
sufficient to install the package <code>qemu-user-static</code> to be able to run simple static
binaries:</p>
<pre><code class="language-text"># apt install qemu-user-static
</code></pre>
<h2 id="building-6"><a class="header" href="#building-6">Building</a></h2>
<p>At least llvm version <code>19.1.5</code> is required to build <code>core</code> and <code>alloc</code> for this target.</p>
<h2 id="cross-compilation-11"><a class="header" href="#cross-compilation-11">Cross-compilation</a></h2>
<p>This target can be cross-compiled from a standard Debian or Debian-based, openSUSE or any
other distribution which has a basic m68k cross-toolchain available.</p>
<h2 id="testing-41"><a class="header" href="#testing-41">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-40"><a class="header" href="#building-rust-programs-40">Building Rust programs</a></h2>
<p>Recommended <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[unstable]
build-std = ["panic_abort", "core", "alloc"]

[target.m68k-unknown-none-elf]
# as we're building for ELF, the m68k-linux linker should be adequate
linker = "m68k-linux-gnu-ld"

# the mold linker also supports m68k, remove the above line and uncomment the
# following ones to use that instead
# linker = "clang"
# rustflags = ["-C", "link-arg=-fuse-ld=/path/to/mold/binary"]
</code></pre>
<p>Rust programs can be built for this target using:</p>
<pre><code class="language-sh">cargo build --target m68k-unknown-none-elf
</code></pre>
<p>Very simple programs can be run using the <code>qemu-m68k-static</code> program:</p>
<pre><code class="language-sh">qemu-m68k-static your-code
</code></pre>
<p>For more complex applications, a native (or emulated) m68k system is required for testing.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mips64-openwrt-linux-musl"><a class="header" href="#mips64-openwrt-linux-musl"><code>mips64-openwrt-linux-musl</code></a></h1>
<p><strong>Tier: 3</strong></p>
<h2 id="target-maintainers-59"><a class="header" href="#target-maintainers-59">Target maintainers</a></h2>
<p><a href="https://github.com/Itus-Shield">@Itus-Shield</a></p>
<h2 id="requirements-52"><a class="header" href="#requirements-52">Requirements</a></h2>
<p>This target is cross-compiled. There is no support for <code>std</code>. There is no
default allocator, but it’s possible to use <code>alloc</code> by supplying an allocator.</p>
<p>By default, Rust code generated for this target uses <code>-msoft-float</code> and is
dynamically linked.</p>
<p>This target generated binaries in the ELF format.</p>
<h2 id="building-the-target-38"><a class="header" href="#building-the-target-38">Building the target</a></h2>
<p>This target is built exclusively within the <code>OpenWrt</code> build system via
the <code>rust-lang</code> HOST package</p>
<h2 id="building-rust-programs-41"><a class="header" href="#building-rust-programs-41">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above).</p>
<h2 id="testing-42"><a class="header" href="#testing-42">Testing</a></h2>
<p>As <code>mips64-openwrt-linux-musl</code> supports a variety of different environments and does
not support <code>std</code>, this target does not support running the Rust testsuite at this
time.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mips64-unknown-linux-muslabi64"><a class="header" href="#mips64-unknown-linux-muslabi64">mips64-unknown-linux-muslabi64</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Target for 64-bit big endian MIPS Linux programs using musl libc and the N64 ABI.</p>
<h2 id="target-maintainers-60"><a class="header" href="#target-maintainers-60">Target maintainers</a></h2>
<p><a href="https://github.com/Gelbpunkt">@Gelbpunkt</a></p>
<h2 id="requirements-53"><a class="header" href="#requirements-53">Requirements</a></h2>
<p>Building the target itself requires a 64-bit big endian MIPS compiler that is
supported by <code>cc-rs</code>.</p>
<h2 id="building-the-target-39"><a class="header" href="#building-the-target-39">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["mips64-unknown-linux-muslabi64"]
</code></pre>
<p>Make sure your C compiler is included in <code>$PATH</code>, then add it to the
<code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.mips64-unknown-linux-muslabi64]
cc = "mips64-linux-musl-gcc"
cxx = "mips64-linux-musl-g++"
ar = "mips64-linux-musl-ar"
linker = "mips64-linux-musl-gcc"
</code></pre>
<h2 id="building-rust-programs-42"><a class="header" href="#building-rust-programs-42">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will first need to build Rust with the target enabled (see
“Building the target” above).</p>
<h2 id="cross-compilation-12"><a class="header" href="#cross-compilation-12">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-43"><a class="header" href="#testing-43">Testing</a></h2>
<p>This target can be tested as normal with <code>x.py</code> on a 64-bit big endian MIPS
host or via QEMU emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mipsel-sony-psx"><a class="header" href="#mipsel-sony-psx">mipsel-sony-psx</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Sony PlayStation 1 (psx)</p>
<h2 id="designated-developer"><a class="header" href="#designated-developer">Designated Developer</a></h2>
<p><a href="https://github.com/ayrtonm">@ayrtonm</a></p>
<h2 id="requirements-54"><a class="header" href="#requirements-54">Requirements</a></h2>
<p>This target is cross-compiled.
It has no special requirements for the host.</p>
<h2 id="building-7"><a class="header" href="#building-7">Building</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["mipsel-sony-psx"]
</code></pre>
<h2 id="cross-compilation-13"><a class="header" href="#cross-compilation-13">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-44"><a class="header" href="#testing-44">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-43"><a class="header" href="#building-rust-programs-43">Building Rust programs</a></h2>
<p>Since it is Tier 3, rust doesn’t ship pre-compiled artifacts for this target.</p>
<p>Just use the <code>build-std</code> nightly cargo feature to build the <code>core</code> and <code>alloc</code> libraries:</p>
<pre><code class="language-shell">cargo build -Zbuild-std=core,alloc --target mipsel-sony-psx
</code></pre>
<p>The command above generates an ELF. To generate binaries in the PSEXE format that emulators run, you can use <a href="https://github.com/ayrtonm/psx-sdk-rs#readme">cargo-psx</a>:</p>
<pre><code class="language-shell">cargo psx build
</code></pre>
<p>or use <code>-Clink-arg=--oformat=binary</code> to produce a flat binary.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mipsel-unknown-linux-gnu"><a class="header" href="#mipsel-unknown-linux-gnu"><code>mipsel-unknown-linux-gnu</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Little-endian 32 bit MIPS for Linux with `glibc.</p>
<h2 id="target-maintainers-61"><a class="header" href="#target-maintainers-61">Target maintainers</a></h2>
<p><a href="https://github.com/LukasWoodtli">@LukasWoodtli</a></p>
<h2 id="requirements-55"><a class="header" href="#requirements-55">Requirements</a></h2>
<p>The target supports std on Linux. Host tools are supported but not tested.</p>
<h2 id="building-the-target-40"><a class="header" href="#building-the-target-40">Building the target</a></h2>
<p>For cross compilation the GNU C compiler for the mipsel architecture needs to
be installed. On Ubuntu install the packets: <code>gcc-mipsel-linux-gnu</code> and
<code>g++-mipsel-linux-gnu</code>.</p>
<p>Add <code>mipsel-unknown-linux-gnu</code> as <code>target</code> list in <code>config.toml</code>.</p>
<h2 id="building-rust-programs-44"><a class="header" href="#building-rust-programs-44">Building Rust programs</a></h2>
<p>Rust does not ship pre-compiled artifacts for this target. To compile for
this target, you will need to build Rust with the target enabled (see
“Building the target” above).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mips-mti-none-elf"><a class="header" href="#mips-mti-none-elf"><code>mips*-mti-none-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>MIPS32r2 baremetal softfloat, Big Endian or Little Endian.</p>
<ul>
<li>mips-mti-none-elf</li>
<li>mipsel-mti-none-elf</li>
</ul>
<h2 id="target-maintainers-62"><a class="header" href="#target-maintainers-62">Target maintainers</a></h2>
<p><a href="https://github.com/wzssyqa">@wzssyqa</a></p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>These 2 targets, aka mips-mti-none-elf and mipsel-mti-none-elf, are for
baremetal development of MIPS32r2. The lld is used instead of Gnu-ld.</p>
<h2 id="requirements-56"><a class="header" href="#requirements-56">Requirements</a></h2>
<p>The target only supports cross compilation and no host tools. The target
supports <code>alloc</code> with a default allocator while only support <code>no-std</code> development.</p>
<p>The vendor name <code>mti</code> follows the naming of gcc to indicate MIPS32r2.</p>
<h2 id="cross-compilation-toolchains-and-c-code-22"><a class="header" href="#cross-compilation-toolchains-and-c-code-22">Cross-compilation toolchains and C code</a></h2>
<p>Compatible C code can be built for this target on any compiler that has a MIPS32r2
target.  On clang and ld.lld linker, it can be generated using the
<code>-march=mips</code>/<code>-march=mipsel</code>, <code>-mabi=32</code> with llvm features flag
<code>features=+mips32r2,+soft-float,+noabicalls</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mipsisar6-unknown-linux-gnu"><a class="header" href="#mipsisar6-unknown-linux-gnu">mipsisa*r6*-unknown-linux-gnu*</a></h1>
<p><strong>Tier: 3</strong></p>
<p><a href="https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00083-2B-MIPS64INT-AFP-06.01.pdf">MIPS Release 6</a>, or simply MIPS R6, is the latest iteration of the MIPS instruction set architecture (ISA).</p>
<p>MIPS R6 is experimental in nature, as there is not yet real hardware. However, Qemu emulation is available and we have two Linux distros maintained for development and evaluation purposes. This documentation describes the Rust support for MIPS R6 targets under <code>mipsisa*r6*-unknown-linux-gnu*</code>.</p>
<p>The target name follow this format: <code>&lt;machine&gt;-&lt;vendor&gt;-&lt;os&gt;&lt;abi_suffix&gt;</code>, where <code>&lt;machine&gt;</code> specifies the CPU family/model, <code>&lt;vendor&gt;</code> specifies the vendor and <code>&lt;os&gt;</code> the operating system name. The <code>&lt;abi_suffix&gt;</code> denotes the base ABI (32/n32/64/o64).</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ABI suffix</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>abi64</td><td>Uses the 64-bit (64) ABI</td></tr>
<tr><td>abin32</td><td>Uses the n32 ABI</td></tr>
<tr><td>N/A</td><td>Uses the (assumed) 32-bit (32) ABI</td></tr>
</tbody>
</table>
</div>
<h2 id="target-maintainers-63"><a class="header" href="#target-maintainers-63">Target Maintainers</a></h2>
<p><a href="https://github.com/chenx97">@chenx97</a>
<a href="https://github.com/709924470">@709924470</a>
<a href="https://github.com/Cyanoxygen">@Cyanoxygen</a>
<a href="https://github.com/Fearyncess">@Fearyncess</a></p>
<h2 id="requirements-57"><a class="header" href="#requirements-57">Requirements</a></h2>
<h3 id="cc-toolchain"><a class="header" href="#cc-toolchain">C/C++ Toolchain</a></h3>
<p>A GNU toolchain for one of the MIPS R6 target is required. <a href="https://aosc.io/">AOSC OS</a> provides working native and cross-compiling build environments. You may also supply your own a toolchain consisting of recent versions of GCC and Binutils.</p>
<h3 id="target-libraries"><a class="header" href="#target-libraries">Target libraries</a></h3>
<p>A minimum set of libraries is required to perform dynamic linking:</p>
<ul>
<li>GNU glibc</li>
<li>OpenSSL</li>
<li>Zlib</li>
<li>Linux API Headers</li>
</ul>
<p>This set of libraries should be installed to make up minimal target sysroot.</p>
<p>For AOSC OS, You may install such a sysroot with the following commands:</p>
<pre><code class="language-sh">cd /tmp

# linux+api, glibc, and file system structure are included in the toolchain.
sudo apt install gcc+cross-mips64r6el binutils+cross-mips64r6el

# Download and extract required libraries.
wget https://repo.aosc.io/debs/pool/stable/main/z/zlib_1.2.13-0_mips64r6el.deb -O zlib.deb
wget https://repo.aosc.io/debs/pool/stable/main/o/openssl_1.1.1q-1_mips64r6el.deb -O openssl.deb

# Extract them to your desired location.
for i in zlib openssl ; do
    sudo dpkg-deb -vx $i.deb /var/ab/cross-root/mips64r6el
done

# Workaround a possible ld bug when using -Wl,-Bdynamic.
sudo sed -i 's|/usr|=/usr|g' /var/ab/cross-root/mips64r6el/usr/lib/libc.so
</code></pre>
<p>For other distros, you may build them manually.</p>
<h2 id="building-8"><a class="header" href="#building-8">Building</a></h2>
<p>The following procedure outlines the build process for the MIPS64 R6 target with 64-bit (64) ABI (<code>mipsisa64r6el-unknown-linux-gnuabi64</code>).</p>
<h3 id="prerequisite-disable-debuginfo"><a class="header" href="#prerequisite-disable-debuginfo">Prerequisite: Disable debuginfo</a></h3>
<p>An LLVM bug makes rustc crash if debug or debug info generation is enabled. You need to edit <code>bootstrap.toml</code> to disable this:</p>
<pre><code class="language-toml">[rust]
debug = false
debug-info-level = 0
</code></pre>
<h3 id="prerequisite-enable-rustixs-libc-backend"><a class="header" href="#prerequisite-enable-rustixs-libc-backend">Prerequisite: Enable rustix’s libc backend</a></h3>
<p>The crate <code>rustix</code> may try to link itself against MIPS R2 assembly, resulting in linkage error. To avoid this, you may force <code>rustix</code> to use its fallback <code>libc</code> backend by setting relevant <code>RUSTFLAGS</code>:</p>
<pre><code class="language-sh">export RUSTFLAGS="--cfg rustix_use_libc"
</code></pre>
<p>This will trigger warnings during build, as <code>-D warnings</code> is enabled by default. Disable <code>-D warnings</code> by editing <code>bootstrap.toml</code> to append the following:</p>
<pre><code class="language-toml">[rust]
deny-warnings = false
</code></pre>
<h3 id="prerequisite-supplying-openssl"><a class="header" href="#prerequisite-supplying-openssl">Prerequisite: Supplying OpenSSL</a></h3>
<p>As a Tier 3 target, <code>openssl_sys</code> lacks the vendored OpenSSL library for this target. You will need to provide a prebuilt OpenSSL library to link <code>cargo</code>. Since we have a pre-configured sysroot, we can point to it directly:</p>
<pre><code class="language-sh">export MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_NO_VENDOR=y
export MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_DIR="/var/ab/cross-root/mips64r6el/usr"
</code></pre>
<p>On Debian, you may need to provide library path and include path separately:</p>
<pre><code class="language-sh">export MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_NO_VENDOR=y
export MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_LIB_DIR="/usr/lib/mipsisa64r6el-linux-gnuabi64/"
export MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_OPENSSL_INCLUDE_DIR="/usr/include"
</code></pre>
<h3 id="launching-xpy"><a class="header" href="#launching-xpy">Launching <code>x.py</code></a></h3>
<pre><code class="language-toml">[build]
target = ["mipsisa64r6el-unknown-linux-gnuabi64"]
</code></pre>
<p>Make sure that <code>mipsisa64r6el-unknown-linux-gnuabi64-gcc</code> is available from your executable search path (<code>$PATH</code>).</p>
<p>Alternatively, you can specify the directories to all necessary toolchain executables in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.mipsisa64r6el-unknown-linux-gnuabi64]
# Adjust the paths below to point to your toolchain installation prefix.
cc = "/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc"
cxx = "/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-g++"
ar = "/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc-ar"
ranlib = "/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-ranlib"
linker = "/toolchain_prefix/bin/mipsisa64r6el-unknown-linux-gnuabi64-gcc"
</code></pre>
<p>Or, you can specify your cross compiler toolchain with an environment variable:</p>
<pre><code class="language-sh">export CROSS_COMPILE="/opt/abcross/mips64r6el/bin/mipsisa64r6el-aosc-linux-gnuabi64-"
</code></pre>
<p>Finally, launch the build script:</p>
<pre><code class="language-sh">./x.py build
</code></pre>
<h3 id="tips"><a class="header" href="#tips">Tips</a></h3>
<ul>
<li>Avoid setting <code>cargo-native-static</code> to <code>false</code>, as this will result in a redundant artifact error while building clippy:
<pre><code class="language-text">duplicate artifacts found when compiling a tool, this typically means that something was recompiled because a transitive dependency has different features activated than in a previous build:

the following dependencies have different features:
    syn 2.0.8 (registry+https://github.com/rust-lang/crates.io-index)
`clippy-driver` additionally enabled features {"full"} at ...
`cargo` additionally enabled features {} at ...

to fix this you will probably want to edit the local src/tools/rustc-workspace-hack/Cargo.toml crate, as that will update the dependency graph to ensure that these crates all share the same feature set
thread 'main' panicked at 'tools should not compile multiple copies of the same crate', tool.rs:250:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
</li>
</ul>
<h2 id="building-rust-programs-45"><a class="header" href="#building-rust-programs-45">Building Rust programs</a></h2>
<p>To build Rust programs for MIPS R6 targets, for instance, the <code>mipsisa64r6el-unknown-linux-gnuabi64</code> target:</p>
<pre><code class="language-bash">cargo build --target mipsisa64r6el-unknown-linux-gnuabi64
</code></pre>
<h2 id="testing-45"><a class="header" href="#testing-45">Testing</a></h2>
<p>To test a cross-compiled binary on your build system, install the Qemu user emulator that support the MIPS R6 architecture (<code>qemu-user-mipsel</code> or <code>qemu-user-mips64el</code>). GCC runtime libraries (<code>libgcc_s</code>) for the target architecture should be present in target sysroot to run the program.</p>
<pre><code class="language-sh">env \
    CARGO_TARGET_MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_LINKER="/opt/abcross/mips64r6el/bin/mipsisa64r6el-aosc-linux-gnuabi64-gcc" \
    CARGO_TARGET_MIPSISA64R6EL_UNKNOWN_LINUX_GNUABI64_RUNNER="qemu-mips64el-static -L /var/ab/cross-root/mips64r6el" \
    cargo run --release \
        --target mipsisa64r6el-unknown-linux-gnuabi64
</code></pre>
<h2 id="tips-for-building-rust-programs-for-mips-r6"><a class="header" href="#tips-for-building-rust-programs-for-mips-r6">Tips for building Rust programs for MIPS R6</a></h2>
<ul>
<li>Until we finalize a fix, please make sure the aforementioned workarounds for <code>rustix</code> crate and LLVM are always applied. This can be achieved by setting the relevant environment variables, and editing <code>Cargo.toml</code> before building.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nvptx64-nvidia-cuda"><a class="header" href="#nvptx64-nvidia-cuda"><code>nvptx64-nvidia-cuda</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>This is the target meant for deploying code for Nvidia® accelerators based on their CUDA
platform.</p>
<h2 id="target-maintainers-64"><a class="header" href="#target-maintainers-64">Target maintainers</a></h2>
<p><a href="https://github.com/kjetilkjeka">@kjetilkjeka</a></p>
<h2 id="requirements-58"><a class="header" href="#requirements-58">Requirements</a></h2>
<p>This target is <code>no_std</code>, and uses the <code>llvm-bitcode-linker</code> by default. For PTX output, build with crate-type <code>cdylib</code>.
The necessary components for this workflow are:</p>
<ul>
<li><code>rustup toolchain add nightly</code></li>
<li><code>rustup component add llvm-tools --toolchain nightly</code></li>
<li><code>rustup component add llvm-bitcode-linker --toolchain nightly</code></li>
</ul>
<p>There are two options for using the core library:</p>
<ul>
<li><code>rustup component add rust-src --toolchain nightly</code> and build using <code>-Z build-std=core</code>.</li>
<li><code>rustup target add nvptx64-nvidia-cuda --toolchain nightly</code></li>
</ul>
<h3 id="target-and-features"><a class="header" href="#target-and-features">Target and features</a></h3>
<p>It is generally necessary to specify the target, such as <code>-C target-cpu=sm_89</code>, because the default is very old. This implies two target features: <code>sm_89</code> and <code>ptx78</code> (and all preceding features within <code>sm_*</code> and <code>ptx*</code>). Rust will default to using the oldest PTX version that supports the target processor (see <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#release-notes-ptx-release-history">this table</a>), which maximizes driver compatibility.
One can use <code>-C target-feature=+ptx80</code> to choose a later PTX version without changing the target (the default in this case, <code>ptx78</code>, requires CUDA driver version 11.8, while <code>ptx80</code> would require driver version 12.0).
Later PTX versions may allow more efficient code generation.</p>
<p>Although Rust follows LLVM in representing <code>ptx*</code> and <code>sm_*</code> as target features, they should be thought of as having crate granularity, set via (either via <code>-Ctarget-cpu</code> and optionally <code>-Ctarget-feature</code>).
While the compiler accepts <code>#[target_feature(enable = "ptx80", enable = "sm_89")]</code>, it is not supported, may not behave as intended, and may become erroneous in the future.</p>
<h2 id="building-rust-kernels"><a class="header" href="#building-rust-kernels">Building Rust kernels</a></h2>
<p>A <code>no_std</code> crate containing one or more functions with <code>extern "ptx-kernel"</code> can be compiled to PTX using a command like the following.</p>
<pre><code class="language-console">$ RUSTFLAGS='-Ctarget-cpu=sm_89' cargo +nightly rustc --target=nvptx64-nvidia-cuda -Zbuild-std=core --crate-type=cdylib
</code></pre>
<p>Intrinsics in <code>core::arch::nvptx</code> may use <code>#[cfg(target_feature = "...")]</code>, thus it’s necessary to use <code>-Zbuild-std=core</code> with appropriate <code>RUSTFLAGS</code>. The following components are needed for this workflow:</p>
<pre><code class="language-console">$ rustup component add rust-src --toolchain nightly
$ rustup component add llvm-tools --toolchain nightly
$ rustup component add llvm-bitcode-linker --toolchain nightly
</code></pre>
<h2 id="target-specific-restrictions"><a class="header" href="#target-specific-restrictions">Target specific restrictions</a></h2>
<p>The PTX instruction set architecture has special requirements regarding what is
and isn’t allowed. In order to avoid producing invalid PTX or generating undefined
behavior by LLVM, some Rust language features are disallowed when compiling for this target.</p>
<h3 id="static-initializers-must-be-acyclic"><a class="header" href="#static-initializers-must-be-acyclic">Static initializers must be acyclic</a></h3>
<p>A static’s initializer must not form a cycle with itself or another static’s
initializer. Therefore, the compiler will reject not only the self-referencing static <code>A</code>,
but all of the following statics.</p>
<pre><code class="language-Rust">struct Foo(&amp;'static Foo);

static A: Foo = Foo(&amp;A); //~ ERROR static initializer forms a cycle involving `A`

static B0: Foo = Foo(&amp;B1); //~ ERROR static initializer forms a cycle involving `B0`
static B1: Foo = Foo(&amp;B0);

static C0: Foo = Foo(&amp;C1); //~ ERROR static initializer forms a cycle involving `C0`
static C1: Foo = Foo(&amp;C2);
static C2: Foo = Foo(&amp;C0);
</code></pre>
<p>Initializers that are acyclic are allowed:</p>
<pre><code class="language-Rust">struct Bar(&amp;'static u32);

static BAR: Bar = Bar(&amp;INT); // is allowed
static INT: u32 = 42u32; // also allowed
</code></pre>
<!-- FIXME: fill this out

## Requirements

Does the target support host tools, or only cross-compilation? Does the target
support std, or alloc (either with a default allocator, or if the user supplies
an allocator)?

Document the expectations of binaries built for the target. Do they assume
specific minimum features beyond the baseline of the CPU/environment/etc? What
version of the OS or environment do they expect?

Are there notable `#[target_feature(...)]` or `-C target-feature=` values that
programs may wish to use?

What calling convention does `extern "C"` use on the target?

What format do binaries use by default? ELF, PE, something else?

## Building the target

If Rust doesn't build the target by default, how can users build it? Can users
just add it to the `target` list in `bootstrap.toml`?

## Building Rust programs

Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
"Building the target" above), or build your own copy of `core` by using
`build-std` or similar.

## Testing

Does the target support running binaries, or do binaries have varying
expectations that prevent having a standard way to run them? If users can run
binaries, can they do so in some common emulator, or do they need native
hardware? Does the target support running the Rust testsuite?

## Cross-compilation toolchains and C code

Does the target support C code? If so, what toolchain target should users use
to build compatible C code? (This may match the target triple, or it may be a
toolchain for a different target triple, potentially with specific options or
caveats.)

-->
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc-unknown-openbsd"><a href="#powerpc-unknown-openbsd" class="header">powerpc-unknown-openbsd</a></h1>
<h2 id="designated-maintainers"><a class="header" href="#designated-maintainers">Designated maintainers</a></h2>
<p><code>powerpc-unknown-openbsd</code> is not maintained by OpenBSD developers and there are currently no active rustc maintainers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc-unknown-linux-gnuspe"><a class="header" href="#powerpc-unknown-linux-gnuspe">powerpc-unknown-linux-gnuspe</a></h1>
<p><strong>Tier: 3</strong></p>
<p><code>powerpc-unknown-linux-gnuspe</code> is a target for Linux on 32-bit PowerPC
processors that implement the Signal Processing Engine (SPE), such as e500, and
uses a different ABI than standard <code>powerpc-unknown-linux-gnu</code>.
When building for other 32-bit PowerPC processors, use
<code>powerpc-unknown-linux-gnu</code> instead.</p>
<p>See also <a href="https://wiki.debian.org/PowerPCSPEPort">Debian Wiki</a> for details on
this platform, and <a href="https://web.archive.org/web/20120608163804/https://www.power.org/resources/downloads/Power-Arch-32-bit-ABI-supp-1.0-Unified.pdf">ABI reference</a>
for details on SPE ABI.</p>
<p>Note that support for PowerPC SPE by GCC was <a href="https://gcc.gnu.org/gcc-8/changes.html">removed in GCC 9</a>,
so recent GCC cannot be used as linker/compiler for this target.</p>
<h2 id="target-maintainers-65"><a class="header" href="#target-maintainers-65">Target maintainers</a></h2>
<p>There are currently no formally documented target maintainers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc-unknown-linux-muslspe"><a class="header" href="#powerpc-unknown-linux-muslspe">powerpc-unknown-linux-muslspe</a></h1>
<p><strong>Tier: 3</strong></p>
<p>This target is very similar to already existing ones like <code>powerpc-unknown-linux-musl</code> and <code>powerpc-unknown-linux-gnuspe</code>.
This one has PowerPC SPE support for musl. Unfortunately, the last supported gcc version with PowerPC SPE is 8.4.0.</p>
<p>See also <a href="#powerpc-unknown-linux-gnuspe">platform support documentation of <code>powerpc-unknown-linux-gnuspe</code></a> for information about PowerPC SPE.</p>
<h2 id="target-maintainers-66"><a class="header" href="#target-maintainers-66">Target maintainers</a></h2>
<p><a href="https://github.com/BKPepe">@BKPepe</a></p>
<h2 id="requirements-59"><a class="header" href="#requirements-59">Requirements</a></h2>
<p>This target is cross-compiled. There is no support for <code>std</code>. There is no
default allocator, but it’s possible to use <code>alloc</code> by supplying an allocator.</p>
<p>This target generated binaries in the ELF format.</p>
<h2 id="building-the-target-41"><a class="header" href="#building-the-target-41">Building the target</a></h2>
<p>This target was tested and used within the <code>OpenWrt</code> build system for CZ.NIC Turris 1.x routers using Freescale P2020.</p>
<h2 id="building-rust-programs-46"><a class="header" href="#building-rust-programs-46">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing-46"><a class="header" href="#testing-46">Testing</a></h2>
<p>This is a cross-compiled target and there is no support to run rustc test suite.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc64-ibm-aix"><a class="header" href="#powerpc64-ibm-aix"><code>powerpc64-ibm-aix</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Rust for AIX operating system, currently only 64-bit PowerPC is supported.</p>
<h2 id="target-maintainers-67"><a class="header" href="#target-maintainers-67">Target maintainers</a></h2>
<p><a href="https://github.com/daltenty">@daltenty</a>
<a href="https://github.com/gilamn5tr">@gilamn5tr</a>
<a href="https://github.com/amy-kwan">@amy-kwan</a></p>
<h2 id="requirements-60"><a class="header" href="#requirements-60">Requirements</a></h2>
<p>This target supports host tools, std and alloc. This target cannot be cross-compiled as for now, mainly because of the unavailability of system linker on other platforms.</p>
<p>Binary built for this target is expected to run on Power7 or newer CPU, and AIX 7.2 or newer version.</p>
<p>Binary format of this platform is <a href="https://www.ibm.com/docs/en/aix/7.2?topic=formats-xcoff-object-file-format">XCOFF</a>. Archive file format is <a href="https://www.ibm.com/docs/en/aix/7.2?topic=formats-ar-file-format-big">‘AIX big format’</a>.</p>
<h2 id="testing-47"><a class="header" href="#testing-47">Testing</a></h2>
<p>This target supports running test suites natively, but it’s not available to cross-compile and execute in emulator.</p>
<h2 id="interoperability-with-c-code"><a class="header" href="#interoperability-with-c-code">Interoperability with C code</a></h2>
<p>This target supports C code. C code compiled by XL, Open XL and Clang are compatible with Rust. Typical triple of AIX on 64-bit PowerPC of these compilers are also <code>powerpc64-ibm-aix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc64-unknown-linux-musl"><a class="header" href="#powerpc64-unknown-linux-musl">powerpc64-unknown-linux-musl</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Target for 64-bit big endian PowerPC Linux programs using musl libc.
This target uses the ELF v2 ABI.</p>
<h2 id="target-maintainers-68"><a class="header" href="#target-maintainers-68">Target maintainers</a></h2>
<p><a href="https://github.com/Gelbpunkt">@Gelbpunkt</a>
<a href="https://github.com/famfo">@famfo</a>
<a href="https://github.com/neuschaefer">@neuschaefer</a></p>
<h2 id="requirements-61"><a class="header" href="#requirements-61">Requirements</a></h2>
<p>Building the target itself requires a 64-bit big endian PowerPC compiler that
is supported by <code>cc-rs</code>.</p>
<h2 id="building-the-target-42"><a class="header" href="#building-the-target-42">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["powerpc64-unknown-linux-musl"]
</code></pre>
<p>Make sure your C compiler is included in <code>$PATH</code>, then add it to the
<code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.powerpc64-unknown-linux-musl]
cc = "powerpc64-linux-musl-gcc"
cxx = "powerpc64-linux-musl-g++"
ar = "powerpc64-linux-musl-ar"
linker = "powerpc64-linux-musl-gcc"
</code></pre>
<h2 id="building-rust-programs-47"><a class="header" href="#building-rust-programs-47">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will first need to build Rust with the target enabled (see
“Building the target” above).</p>
<h2 id="cross-compilation-14"><a class="header" href="#cross-compilation-14">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-48"><a class="header" href="#testing-48">Testing</a></h2>
<p>This target can be tested as normal with <code>x.py</code> on a 64-bit big endian PowerPC
host or via QEMU emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc64le-unknown-linux-gnu"><a class="header" href="#powerpc64le-unknown-linux-gnu"><code>powerpc64le-unknown-linux-gnu</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>Target for 64-bit little endian PowerPC Linux programs</p>
<h2 id="target-maintainers-69"><a class="header" href="#target-maintainers-69">Target maintainers</a></h2>
<p><a href="https://github.com/daltenty">@daltenty</a>
<a href="https://github.com/gilamn5tr">@gilamn5tr</a>
<a href="https://github.com/amy-kwan">@amy-kwan</a></p>
<h2 id="requirements-62"><a class="header" href="#requirements-62">Requirements</a></h2>
<p>Building the target itself requires a 64-bit little endian PowerPC compiler that is supported by <code>cc-rs</code>.</p>
<h2 id="building-the-target-43"><a class="header" href="#building-the-target-43">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["powerpc64le-unknown-linux-gnu"]
</code></pre>
<p>Make sure your C compiler is included in <code>$PATH</code>, then add it to the <code>config.toml</code>:</p>
<pre><code class="language-toml">[target.powerpc64le-unknown-linux-gnu]
cc = "powerpc64le-linux-gnu-gcc"
cxx = "powerpc64le-linux-gnu-g++"
ar = "powerpc64le-linux-gnu-ar"
linker = "powerpc64le-linux-gnu-gcc"
</code></pre>
<h2 id="building-rust-programs-48"><a class="header" href="#building-rust-programs-48">Building Rust programs</a></h2>
<p>This target is distributed through <code>rustup</code>, and requires no special
configuration.</p>
<h2 id="cross-compilation-15"><a class="header" href="#cross-compilation-15">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-49"><a class="header" href="#testing-49">Testing</a></h2>
<p>This target can be tested as normal with <code>x.py</code> on a 64-bit little endian
PowerPC host or via QEMU emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc64le-unknown-linux-musl"><a class="header" href="#powerpc64le-unknown-linux-musl">powerpc64le-unknown-linux-musl</a></h1>
<p><strong>Tier: 2</strong></p>
<p>Target for 64-bit little endian PowerPC Linux programs using musl libc.</p>
<h2 id="target-maintainers-70"><a class="header" href="#target-maintainers-70">Target maintainers</a></h2>
<p><a href="https://github.com/Gelbpunkt">@Gelbpunkt</a>
<a href="https://github.com/famfo">@famfo</a>
<a href="https://github.com/neuschaefer">@neuschaefer</a></p>
<h2 id="requirements-63"><a class="header" href="#requirements-63">Requirements</a></h2>
<p>Building the target itself requires a 64-bit little endian PowerPC compiler that is supported by <code>cc-rs</code>.</p>
<h2 id="building-the-target-44"><a class="header" href="#building-the-target-44">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["powerpc64le-unknown-linux-musl"]
</code></pre>
<p>Make sure your C compiler is included in <code>$PATH</code>, then add it to the <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.powerpc64le-unknown-linux-musl]
cc = "powerpc64le-linux-musl-gcc"
cxx = "powerpc64le-linux-musl-g++"
ar = "powerpc64le-linux-musl-ar"
linker = "powerpc64le-linux-musl-gcc"
</code></pre>
<h2 id="building-rust-programs-49"><a class="header" href="#building-rust-programs-49">Building Rust programs</a></h2>
<p>This target are distributed through <code>rustup</code>, and otherwise require no
special configuration.</p>
<h2 id="cross-compilation-16"><a class="header" href="#cross-compilation-16">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-50"><a class="header" href="#testing-50">Testing</a></h2>
<p>This target can be tested as normal with <code>x.py</code> on a 64-bit little endian
PowerPC host or via QEMU emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv32eememc-unknown-none-elf"><a class="header" href="#riscv32eememc-unknown-none-elf"><code>riscv32{e,em,emc}-unknown-none-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Bare-metal target for RISC-V CPUs with the RV32E, RV32EM and RV32EMC ISAs.</p>
<h2 id="target-maintainers-71"><a class="header" href="#target-maintainers-71">Target maintainers</a></h2>
<p><a href="https://github.com/hegza">@hegza</a></p>
<h2 id="requirements-64"><a class="header" href="#requirements-64">Requirements</a></h2>
<p>The target is cross-compiled, and uses static linking. No external toolchain is
required and the default <code>rust-lld</code> linker works, but you must specify a linker
script.</p>
<h2 id="building-the-target-45"><a class="header" href="#building-the-target-45">Building the target</a></h2>
<p>This target is included in Rust and can be installed via <code>rustup</code>.</p>
<h2 id="testing-51"><a class="header" href="#testing-51">Testing</a></h2>
<p>This is a cross-compiled <code>no-std</code> target, which must be run either in a
simulator or by programming them onto suitable hardware. It is not possible to
run the Rust test-suite on this target.</p>
<h2 id="cross-compilation-toolchains-and-c-code-23"><a class="header" href="#cross-compilation-toolchains-and-c-code-23">Cross-compilation toolchains and C code</a></h2>
<p>This target supports C code. If interlinking with C or C++, you may need to use
<code>riscv32-unknown-elf-gcc</code> as a linker instead of <code>rust-lld</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv32iimimaimcimacimafc-unknown-none-elf"><a class="header" href="#riscv32iimimaimcimacimafc-unknown-none-elf"><code>riscv32{i,im,ima,imc,imac,imafc}-unknown-none-elf</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>Bare-metal target for RISC-V CPUs with the RV32I, RV32IM, RV32IMC, RV32IMAFC and RV32IMAC ISAs.</p>
<p><strong>Tier: 3</strong></p>
<p>Bare-metal target for RISC-V CPUs with the RV32IMA ISA.</p>
<h2 id="target-maintainers-72"><a class="header" href="#target-maintainers-72">Target maintainers</a></h2>
<ul>
<li>Rust Embedded Working Group, <a href="https://github.com/rust-embedded/wg#the-risc-v-team">RISC-V team</a></li>
</ul>
<h2 id="requirements-65"><a class="header" href="#requirements-65">Requirements</a></h2>
<p>The target is cross-compiled, and uses static linking. No external toolchain
is required and the default <code>rust-lld</code> linker works, but you must specify
a linker script. The <a href="https://crates.io/crates/riscv-rt"><code>riscv-rt</code></a> crate provides a suitable one. The
<a href="https://github.com/riscv-rust/riscv-rust-quickstart"><code>riscv-rust-quickstart</code></a> repository gives an example of an RV32 project.</p>
<h2 id="building-the-target-46"><a class="header" href="#building-the-target-46">Building the target</a></h2>
<p>This target is included in Rust and can be installed via <code>rustup</code>.</p>
<h2 id="testing-52"><a class="header" href="#testing-52">Testing</a></h2>
<p>This is a cross-compiled <code>no-std</code> target, which must be run either in a simulator
or by programming them onto suitable hardware. It is not possible to run the
Rust test-suite on this target.</p>
<h2 id="cross-compilation-toolchains-and-c-code-24"><a class="header" href="#cross-compilation-toolchains-and-c-code-24">Cross-compilation toolchains and C code</a></h2>
<p>This target supports C code. If interlinking with C or C++, you may need to use
<code>riscv32-unknown-elf-gcc</code> as a linker instead of <code>rust-lld</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv32im-risc0-zkvm-elf"><a class="header" href="#riscv32im-risc0-zkvm-elf"><code>riscv32im-risc0-zkvm-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>RISC Zero’s Zero Knowledge Virtual Machine (zkVM) implementing the RV32IM instruction set.</p>
<h2 id="target-maintainers-73"><a class="header" href="#target-maintainers-73">Target maintainers</a></h2>
<p><a href="https://github.com/flaub">@flaub</a>
<a href="https://github.com/jbruestle">@jbruestle</a></p>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<p>This target is an execution environment to produce a proof of execution of
a RISC-V ELF binary and any output that the developer of the binary wishes to
display publicly. In order to do this, the target will execute the ELF to
generate a receipt containing the output of the computation along with a
cryptographic seal. This receipt can be verified to ensure the integrity of the
computation and its result. This target is implemented as software only; it has
no hardware implementation.</p>
<p>We have a cargo extension called <a href="https://docs.rs/cargo-risczero/latest/cargo_risczero/">cargo-risczero</a> that allow users to generate
project templates, install tools for improved user experience, build the binary
using a docker environment and test programs.</p>
<h2 id="requirements-66"><a class="header" href="#requirements-66">Requirements</a></h2>
<p>The target only supports cross compilation and no host tools. The target
supports <code>alloc</code> with a default allocator and has experimental support for
<code>std</code>. The target expects the binaries to be in ELF.</p>
<p>The target’s execution environment is single threaded, non-preemptive, and does
not support any privileged instructions, nor unaligned accesses. At the time of
writing the VM has 192 MB of memory and text/data, heap, and stack need to be
with in the address range <code>0x400</code> - <code>0x0C000000</code>. The binaries themselves expect
no operating system and can be thought of as running on bare-metal. The target
does not use <code>#[target_feature(...)]</code> or <code>-C target-feature=</code> values.</p>
<p>Calling <code>extern "C"</code> on the target uses the C calling convention outlined in the
<a href="https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf">RISC-V specification</a>.</p>
<h2 id="building-for-the-zkvm"><a class="header" href="#building-for-the-zkvm">Building for the zkVM</a></h2>
<p>Programs for the zkVM could be built by adding it to the <code>target</code> list in
<code>bootstrap.toml</code>. However, we recommend building programs in our starter template
generated by the <a href="https://docs.rs/cargo-risczero/latest/cargo_risczero/">cargo-risczero</a> utility and the <a href="https://crates.io/crates/risc0-build">risc0-build</a> crate. This
crate calls <code>rustc</code> with <code>-C "link-arg=-Ttext=</code> so that it maps the text in the
appropriate location as well as generating variables that represent the ELF and
a unique ID associated with the ELF. The starter template provides developers
with system calls that are useful to zero knowledge computing such as writing to
the public output, hashing using sha256, and multiply big integers.</p>
<h2 id="building-rust-programs-50"><a class="header" href="#building-rust-programs-50">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above). We do not recommend using <code>build-std</code> as we have
run into issues building core in the past on our starter template. An alternate
solution is to download the risc0 tool chain by running <code>cargo risczero install</code>.</p>
<h2 id="testing-53"><a class="header" href="#testing-53">Testing</a></h2>
<p>Note: the target is implemented as a software emulator called the zkVM and there
is no hardware implementation of the target.</p>
<p>The most practical way to test the target program is to use our starter template
that can be generated by using the <code>cargo risczero new</code> command. The template
generates a sample “host” and “guest” code. The guest code compiled to the
target (which is RV32IM) whereas the “host” code is compiled to run on the
programmer’s machine running either a Linux distribution or macOS. The host
program is responsible for running the guest binary on the zkVM and retrieving
its public output.</p>
<p>The target currently does not support running the Rust test suite.</p>
<h2 id="cross-compilation-toolchains-and-c-code-25"><a class="header" href="#cross-compilation-toolchains-and-c-code-25">Cross-compilation toolchains and C code</a></h2>
<p>Compatible C code can be built for this target on any compiler that has a RV32IM
target.  On clang and ld.lld linker, it can be generated using the
<code>-march=rv32im</code>, <code>-mabi=ilp32</code> with llvm features flag <code>features=+m</code> and llvm
target <code>riscv32-unknown-none</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv32imac-unknown-xous-elf"><a class="header" href="#riscv32imac-unknown-xous-elf">riscv32imac-unknown-xous-elf</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Xous microkernel, message-based operating system that powers devices such as Precursor and Betrusted. The operating system is written entirely in Rust, so no additional software is required to compile programs for Xous.</p>
<h2 id="target-maintainers-74"><a class="header" href="#target-maintainers-74">Target maintainers</a></h2>
<p><a href="https://github.com/xobs">@xobs</a></p>
<h2 id="requirements-67"><a class="header" href="#requirements-67">Requirements</a></h2>
<p>Building the target itself requires a RISC-V compiler that is supported by <code>cc-rs</code>. For example, you can use the prebuilt <a href="https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack/releases/latest">xPack</a> toolchain.</p>
<p>Cross-compiling programs does not require any additional software beyond the toolchain. Prebuilt versions of the toolchain are available <a href="https://github.com/betrusted-io/rust/releases">from Betrusted</a>.</p>
<h2 id="building-the-target-47"><a class="header" href="#building-the-target-47">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["riscv32imac-unknown-xous-elf"]
</code></pre>
<p>Make sure your C compiler is included in <code>$PATH</code>, then add it to the <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.riscv32imac-unknown-xous-elf]
cc = "riscv-none-elf-gcc"
ar = "riscv-none-elf-ar"
</code></pre>
<h2 id="building-rust-programs-51"><a class="header" href="#building-rust-programs-51">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will need to do one of the following:</p>
<ul>
<li>Build Rust with the target enabled (see “Building the target” above)</li>
<li>Build your own copy of <code>core</code> by using <code>build-std</code> or similar</li>
<li>Download a prebuilt toolchain <a href="https://github.com/betrusted-io/rust/releases">from Betrusted</a></li>
</ul>
<h2 id="cross-compilation-17"><a class="header" href="#cross-compilation-17">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-54"><a class="header" href="#testing-54">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv64im-unknown-none-elf"><a class="header" href="#riscv64im-unknown-none-elf"><code>riscv64im-unknown-none-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Bare-metal target for RISC-V CPUs with the RV64IM ISA.</p>
<h2 id="target-maintainers-75"><a class="header" href="#target-maintainers-75">Target maintainers</a></h2>
<ul>
<li>Rust Embedded Working Group, <a href="https://github.com/rust-embedded/wg#the-risc-v-team">RISC-V team</a></li>
</ul>
<h2 id="requirements-68"><a class="header" href="#requirements-68">Requirements</a></h2>
<p>This target is cross-compiled and uses static linking. The target supports <code>core</code> and <code>alloc</code>, but not <code>std</code>.</p>
<p>As the RV64IM ISA lacks the “A” (Atomics) extension, atomic operations are emulated using the <code>+forced-atomics</code> feature.</p>
<p>No external toolchain is required and the default <code>rust-lld</code> linker works, but you must specify a linker script. The <a href="https://crates.io/crates/riscv-rt"><code>riscv-rt</code></a> crate provides suitable linker scripts. The <a href="https://github.com/riscv-rust/riscv-rust-quickstart"><code>riscv-rust-quickstart</code></a> repository gives examples of RISC-V bare-metal projects.</p>
<h2 id="building-the-target-48"><a class="header" href="#building-the-target-48">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code> list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
target = ["riscv64im-unknown-none-elf"]
</code></pre>
<p>Alternatively, you can use the <code>-Z build-std</code> flag to build the standard library on-demand:</p>
<pre><code class="language-bash">cargo build -Z build-std=core,alloc --target riscv64im-unknown-none-elf
</code></pre>
<h2 id="building-rust-programs-52"><a class="header" href="#building-rust-programs-52">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for this target (see “Building the target” above)</p>
<h2 id="testing-55"><a class="header" href="#testing-55">Testing</a></h2>
<p>This is a cross-compiled <code>no-std</code> target, which must be run either in a simulator or by programming onto suitable hardware. It is not possible to run the Rust test-suite on this target.</p>
<h2 id="cross-compilation-toolchains-and-c-code-26"><a class="header" href="#cross-compilation-toolchains-and-c-code-26">Cross-compilation toolchains and C code</a></h2>
<p>This target supports C code. If interlinking with C or C++, you may need to use <code>riscv64-unknown-elf-gcc</code> with the appropriate <code>-march=rv64im -mabi=lp64</code> flags as a linker instead of <code>rust-lld</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv64gc-unknown-linux-gnu"><a class="header" href="#riscv64gc-unknown-linux-gnu"><code>riscv64gc-unknown-linux-gnu</code></a></h1>
<p><strong>Tier: 2 (with Host Tools)</strong></p>
<p>RISC-V targets using the <em>RV64I</em> base instruction set with the <em>G</em> collection of extensions, as well as the <em>C</em> extension.</p>
<h2 id="target-maintainers-76"><a class="header" href="#target-maintainers-76">Target maintainers</a></h2>
<p><a href="https://github.com/kito-cheng">@kito-cheng</a>
<a href="https://github.com/michaelmaitland">@michaelmaitland</a>
<a href="https://github.com/robin-randhawa-sifive">@robin-randhawa-sifive</a>
<a href="https://github.com/topperc">@topperc</a></p>
<h2 id="requirements-69"><a class="header" href="#requirements-69">Requirements</a></h2>
<p>This target requires:</p>
<ul>
<li>Linux Kernel version 4.20 or later</li>
<li>glibc 2.17 or later</li>
</ul>
<h2 id="building-the-target-49"><a class="header" href="#building-the-target-49">Building the target</a></h2>
<p>These targets are distributed through <code>rustup</code>, and otherwise require no
special configuration.</p>
<p>If you need to build your own Rust for some reason though, the targets can be
enabled in <code>bootstrap.toml</code>. For example:</p>
<pre><code class="language-toml">[build]
target = ["riscv64gc-unknown-linux-gnu"]
</code></pre>
<h2 id="building-rust-programs-53"><a class="header" href="#building-rust-programs-53">Building Rust programs</a></h2>
<p>On a RISC-V host, the <code>riscv64gc-unknown-linux-gnu</code> target should be automatically
installed and used by default.</p>
<p>On a non-RISC-V host, add the target:</p>
<pre><code class="language-bash">rustup target add riscv64gc-unknown-linux-gnu
</code></pre>
<p>Then cross compile crates with:</p>
<pre><code class="language-bash">cargo build --target riscv64gc-unknown-linux-gnu
</code></pre>
<h2 id="testing-56"><a class="header" href="#testing-56">Testing</a></h2>
<p>There are no special requirements for testing and running the targets.
For testing cross builds on the host, please refer to the “Cross-compilation
toolchains and C code”
section below.</p>
<h2 id="cross-compilation-toolchains-and-c-code-27"><a class="header" href="#cross-compilation-toolchains-and-c-code-27">Cross-compilation toolchains and C code</a></h2>
<p>A RISC-V toolchain can be obtained for Windows/Mac/Linux from the
<a href="https://github.com/riscv-collab/riscv-gnu-toolchain"><code>riscv-gnu-toolchain</code></a>
repository. Binaries are available via
<a href="https://www.embecosm.com/resources/tool-chain-downloads/#riscv-linux">embecosm</a>,
and may also be available from your OS’s package manager.</p>
<p>On Ubuntu, a RISC-V toolchain can be installed with:</p>
<pre><code class="language-bash">apt install gcc-riscv64-linux-gnu g++-riscv64-linux-gnu libc6-dev-riscv64-cross
</code></pre>
<p>Depending on your system, you may need to configure the target to use the GNU
GCC linker. To use it, add the following to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.riscv64gc-unknown-linux-gnu]
linker = "riscv64-linux-gnu-gcc"
</code></pre>
<p>If your <code>riscv64-linux-gnu-*</code> toolchain is not in your <code>PATH</code> you may need to
configure additional settings:</p>
<pre><code class="language-toml">[target.riscv64gc-unknown-linux-gnu]
# Adjust the paths to point at your toolchain
cc = "/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-gcc"
cxx = "/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-g++"
ar = "/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-ar"
ranlib = "/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-ranlib"
linker = "/TOOLCHAIN_PATH/bin/riscv64-linux-gnu-gcc"
</code></pre>
<p>To test cross compiled binaries on a non-RISCV-V host, you can use
<a href="https://www.qemu.org/docs/master/system/target-riscv.html"><code>qemu</code></a>.
On Ubuntu, a RISC-V emulator can be obtained with:</p>
<pre><code class="language-bash">apt install qemu-system-riscv64
</code></pre>
<p>Then, in <code>.cargo/config.toml</code> set the <code>runner</code>:</p>
<pre><code class="language-toml">[target.riscv64gc-unknown-linux-gnu]
runner = "qemu-riscv64-static -L /usr/riscv64-linux-gnu -cpu rv64"
</code></pre>
<p>On Mac and Linux, it’s also possible to use
<a href="https://github.com/lima-vm/lima"><code>lima</code></a> to emulate RISC-V in a similar way to
how WSL2 works on Windows:</p>
<pre><code class="language-bash">limactl start template://riscv
limactl shell riscv
</code></pre>
<p>Using <a href="https://docs.docker.com/build/buildkit/">Docker (with BuildKit)</a> the
<a href="https://hub.docker.com/r/riscv64/ubuntu"><code>riscv64/ubuntu</code></a> image can be used
to build or run <code>riscv64gc-unknown-linux-gnu</code> binaries.</p>
<pre><code class="language-bash">docker run --platform linux/riscv64 -ti --rm --mount "type=bind,src=$(pwd),dst=/checkout" riscv64/ubuntu bash
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv64gc-unknown-linux-musl"><a class="header" href="#riscv64gc-unknown-linux-musl">riscv64gc-unknown-linux-musl</a></h1>
<p><strong>Tier: 2</strong></p>
<p>Target for RISC-V Linux programs using musl libc.</p>
<h2 id="target-maintainers-77"><a class="header" href="#target-maintainers-77">Target maintainers</a></h2>
<p><a href="https://github.com/Amanieu">@Amanieu</a>
<a href="https://github.com/kraj">@kraj</a></p>
<h2 id="requirements-70"><a class="header" href="#requirements-70">Requirements</a></h2>
<p>Building the target itself requires a RISC-V compiler that is supported by <code>cc-rs</code>.</p>
<h2 id="building-the-target-50"><a class="header" href="#building-the-target-50">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["riscv64gc-unknown-linux-musl"]
</code></pre>
<p>Make sure your C compiler is included in <code>$PATH</code>, then add it to the <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[target.riscv64gc-unknown-linux-musl]
cc = "riscv64-linux-gnu-gcc"
cxx = "riscv64-linux-gnu-g++"
ar = "riscv64-linux-gnu-ar"
linker = "riscv64-linux-gnu-gcc"
</code></pre>
<h2 id="building-rust-programs-54"><a class="header" href="#building-rust-programs-54">Building Rust programs</a></h2>
<p>This target are distributed through <code>rustup</code>, and otherwise require no
special configuration.</p>
<h2 id="cross-compilation-18"><a class="header" href="#cross-compilation-18">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-57"><a class="header" href="#testing-57">Testing</a></h2>
<p>This target can be tested as normal with <code>x.py</code> on a RISC-V host or via QEMU
emulation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv64a23-unknown-linux-gnu"><a class="header" href="#riscv64a23-unknown-linux-gnu"><code>riscv64a23-unknown-linux-gnu</code></a></h1>
<p><strong>Tier: 2 (without Host Tools)</strong></p>
<p>RISC-V target using the ratified <a href="https://github.com/riscv/riscv-profiles/blob/main/src/rva23-profile.adoc">RVA23 Profile</a>.
This target will enable all mandary features of rva23u64 by default.</p>
<h2 id="target-maintainers-78"><a class="header" href="#target-maintainers-78">Target maintainers</a></h2>
<p><a href="https://github.com/ZhongyaoChen">@ZhongyaoChen</a>
<a href="https://github.com/CaiWeiran">@CaiWeiran</a></p>
<h2 id="requirements-71"><a class="header" href="#requirements-71">Requirements</a></h2>
<p>This target can be sucessfully build on the following platform: ubuntu 24.04 (Linux Kernel version 6.8.0, glibc 2.39).</p>
<p>Other platforms may work, but are not tested. Please contanct if you encounter any issues.</p>
<h2 id="building-the-target-51"><a class="header" href="#building-the-target-51">Building the target</a></h2>
<p>Tier-2 targets are distributed through <code>rustup</code>. Install the target with:</p>
<pre><code class="language-bash">rustup target add riscv64a23-unknown-linux-gnu
</code></pre>
<h2 id="building-rust-programs-55"><a class="header" href="#building-rust-programs-55">Building Rust programs</a></h2>
<p>Cross compile crates with:</p>
<pre><code class="language-bash">cargo build --target=riscv64a23-unknown-linux-gnu
</code></pre>
<p>For cross-compilation, you may need to install the appropriate linker:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt-get install gcc-riscv64-linux-gnu

# Then set the linker
RUSTFLAGS="-C linker=riscv64-linux-gnu-gcc" cargo build --target=riscv64a23-unknown-linux-gnu
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="s390x-unknown-linux-gnu"><a class="header" href="#s390x-unknown-linux-gnu"><code>s390x-unknown-linux-gnu</code></a></h1>
<p><strong>Tier: 2 (with Host Tools)</strong></p>
<p>IBM z/Architecture (s390x) targets (including IBM Z and LinuxONE) running Linux.</p>
<h2 id="target-maintainers-79"><a class="header" href="#target-maintainers-79">Target maintainers</a></h2>
<p><a href="https://github.com/uweigand">@uweigand</a>
<a href="https://github.com/cuviper">@cuviper</a></p>
<h2 id="requirements-72"><a class="header" href="#requirements-72">Requirements</a></h2>
<p>This target requires:</p>
<ul>
<li>Linux Kernel version 3.2 or later</li>
<li>glibc 2.17 or later</li>
</ul>
<p>Code generated by the target uses the z/Architecture ISA assuming a minimum
architecture level of z10 (Eighth Edition of the z/Architecture Principles
of Operation), and is compliant with the s390x ELF ABI.</p>
<p>Reference material:</p>
<ul>
<li><a href="https://publibfp.dhe.ibm.com/epubs/pdf/a227832d.pdf">z/Architecture Principles of Operation</a></li>
<li><a href="https://github.com/IBM/s390x-abi">z/Architecture ELF Application Binary Interface</a></li>
</ul>
<h2 id="building-the-target-52"><a class="header" href="#building-the-target-52">Building the target</a></h2>
<p>This target is distributed through <code>rustup</code>, and otherwise requires no
special configuration.</p>
<p>If you need to build your own Rust for some reason though, the target can be
enabled in <code>bootstrap.toml</code>. For example:</p>
<pre><code class="language-toml">[build]
target = ["s390x-unknown-linux-gnu"]
</code></pre>
<h2 id="building-rust-programs-56"><a class="header" href="#building-rust-programs-56">Building Rust programs</a></h2>
<p>On a s390x Linux host, the <code>s390x-unknown-linux-gnu</code> target should be
automatically installed and used by default.</p>
<p>On a non-s390x host, add the target:</p>
<pre><code class="language-bash">rustup target add s390x-unknown-linux-gnu
</code></pre>
<p>Then cross compile crates with:</p>
<pre><code class="language-bash">cargo build --target s390x-unknown-linux-gnu
</code></pre>
<h2 id="testing-58"><a class="header" href="#testing-58">Testing</a></h2>
<p>There are no special requirements for testing and running the target.
For testing cross builds on the host, please refer to the “Cross-compilation
toolchains and C code” section below.</p>
<p>If you want to do native testing but do not have your own s390x
machine, there are several options how to get access to one:</p>
<ul>
<li>
<p>The <a href="https://linuxone.cloud.marist.edu/">IBM LinuxONE Community Cloud</a> provides a
self-service portal where you can create s390x virtual machine
instances.  These are intended for temporary use (limited to 120 days).</p>
</li>
<li>
<p>The <a href="https://community.ibm.com/zsystems/form/l1cc-oss-vm-request/">IBM LinuxONE Open Source Cloud</a> provides
permanent access to s390x machines.  This requires approval by IBM,
which will normally be granted if you’re planning to use the machine
to work on an open-source project that is relevant to the IBM Z
ecosystem - the Rust compiler would certainly qualify.</p>
</li>
</ul>
<h2 id="cross-compilation-toolchains-and-c-code-28"><a class="header" href="#cross-compilation-toolchains-and-c-code-28">Cross-compilation toolchains and C code</a></h2>
<p>Rust code built using the target is compatible with C code compiled with
GCC or Clang using the <code>s390x-unknown-linux-gnu</code> target triple (via either
native or cross-compilation).</p>
<p>On Ubuntu, a s390x cross-toolchain can be installed with:</p>
<pre><code class="language-bash">apt install gcc-s390x-linux-gnu g++-s390x-linux-gnu libc6-dev-s390x-cross
</code></pre>
<p>Depending on your system, you may need to configure the target to use the GNU
GCC linker. To use it, add the following to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.s390x-unknown-linux-gnu]
linker = "s390x-linux-gnu-gcc"
</code></pre>
<p>If your <code>s390x-linux-gnu-*</code> toolchain is not in your <code>PATH</code> you may need to
configure additional settings:</p>
<pre><code class="language-toml">[target.s390x-unknown-linux-gnu]
# Adjust the paths to point at your toolchain
cc = "/TOOLCHAIN_PATH/bin/s390x-linux-gnu-gcc"
cxx = "/TOOLCHAIN_PATH/bin/s390x-linux-gnu-g++"
ar = "/TOOLCHAIN_PATH/bin/s390x-linux-gnu-ar"
ranlib = "/TOOLCHAIN_PATH/bin/s390x-linux-gnu-ranlib"
linker = "/TOOLCHAIN_PATH/bin/s390x-linux-gnu-gcc"
</code></pre>
<p>To test cross compiled binaries on a non-s390x host, you can use
<a href="https://www.qemu.org/docs/master/system/target-s390x.html"><code>qemu</code></a>.
On Ubuntu, a s390x emulator can be obtained with:</p>
<pre><code class="language-bash">apt install qemu-system-s390x
</code></pre>
<p>Then, in <code>.cargo/config.toml</code> set the <code>runner</code>:</p>
<pre><code class="language-toml">[target.s390x-unknown-linux-gnu]
runner = "qemu-s390x-static -L /usr/s390x-linux-gnu"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="s390x-unknown-linux-musl"><a class="header" href="#s390x-unknown-linux-musl"><code>s390x-unknown-linux-musl</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>IBM z/Architecture (s390x) targets (including IBM Z and LinuxONE) running Linux.</p>
<h2 id="target-maintainers-80"><a class="header" href="#target-maintainers-80">Target maintainers</a></h2>
<p><a href="https://github.com/uweigand">@uweigand</a>
<a href="https://github.com/Gelbpunkt">@Gelbpunkt</a></p>
<h2 id="requirements-73"><a class="header" href="#requirements-73">Requirements</a></h2>
<p>This target requires:</p>
<ul>
<li>Linux Kernel version 3.2 or later</li>
<li>musl 1.2.5 or later</li>
</ul>
<p>Code generated by the target uses the z/Architecture ISA assuming a minimum
architecture level of z10 (Eighth Edition of the z/Architecture Principles
of Operation), and is compliant with the s390x ELF ABI.</p>
<p>Reference material:</p>
<ul>
<li><a href="https://publibfp.dhe.ibm.com/epubs/pdf/a227832d.pdf">z/Architecture Principles of Operation</a></li>
<li><a href="https://github.com/IBM/s390x-abi">z/Architecture ELF Application Binary Interface</a></li>
</ul>
<h2 id="building-the-target-53"><a class="header" href="#building-the-target-53">Building the target</a></h2>
<p>Because it is Tier 3, Rust does not yet ship pre-compiled artifacts for this
target.</p>
<p>Therefore, you can build Rust with support for the target by adding it to the
target list in <code>bootstrap.toml</code>, a sample configuration is shown below.</p>
<pre><code class="language-toml">[build]
target = ["s390x-unknown-linux-musl"]
</code></pre>
<h2 id="building-rust-programs-57"><a class="header" href="#building-rust-programs-57">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will first need to build Rust with the target enabled (see
“Building the target” above).</p>
<h2 id="testing-59"><a class="header" href="#testing-59">Testing</a></h2>
<p>There are no special requirements for testing and running the target.
For testing cross builds on the host, please refer to the “Cross-compilation
toolchains and C code” section below.</p>
<h2 id="cross-compilation-toolchains-and-c-code-29"><a class="header" href="#cross-compilation-toolchains-and-c-code-29">Cross-compilation toolchains and C code</a></h2>
<p>Rust code built using the target is compatible with C code compiled with
GCC or Clang using the <code>s390x-unknown-linux-musl</code> target triple (via either
native or cross-compilation).</p>
<p>Depending on your system, you may need to configure the target to use the GNU
GCC linker. To use it, add the following to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.s390x-unknown-linux-musl]
linker = "s390x-linux-musl-gcc"
</code></pre>
<p>If your <code>s390x-linux-musl-*</code> toolchain is not in your <code>PATH</code> you may need to
configure additional settings:</p>
<pre><code class="language-toml">[target.s390x-unknown-linux-musl]
# Adjust the paths to point at your toolchain
cc = "/TOOLCHAIN_PATH/bin/s390x-linux-musl-gcc"
cxx = "/TOOLCHAIN_PATH/bin/s390x-linux-musl-g++"
ar = "/TOOLCHAIN_PATH/bin/s390x-linux-musl-ar"
ranlib = "/TOOLCHAIN_PATH/bin/s390x-linux-musl-ranlib"
linker = "/TOOLCHAIN_PATH/bin/s390x-linux-musl-gcc"
</code></pre>
<p>To test cross compiled binaries on a non-s390x host, you can use
<a href="https://www.qemu.org/docs/master/system/target-s390x.html"><code>qemu</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sparc-unknown-none-elf"><a class="header" href="#sparc-unknown-none-elf"><code>sparc-unknown-none-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Rust for bare-metal 32-bit SPARC V7 and V8 systems, e.g. the Gaisler LEON3.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Descriptions</th></tr>
</thead>
<tbody>
<tr><td>sparc-unknown-none-elf</td><td>SPARC V7 32-bit (freestanding, hardfloat)</td></tr>
</tbody>
</table>
</div>
<h2 id="target-maintainers-81"><a class="header" href="#target-maintainers-81">Target maintainers</a></h2>
<p><a href="https://github.com/jonathanpallant">@jonathanpallant</a></p>
<h2 id="requirements-74"><a class="header" href="#requirements-74">Requirements</a></h2>
<p>This target is cross-compiled. There is no support for <code>std</code>. There is no
default allocator, but it’s possible to use <code>alloc</code> by supplying an allocator.</p>
<p>By default, code generated with this target should run on any <code>SPARC</code> hardware;
enabling additional target features may raise this baseline.</p>
<ul>
<li>
<p><code>-Ctarget-cpu=v8</code> adds the extra SPARC V8 instructions.</p>
</li>
<li>
<p><code>-Ctarget-cpu=leon3</code> adds the SPARC V8 instructions and sets up scheduling to
suit the Gaisler Leon3.</p>
</li>
</ul>
<p>Functions marked <code>extern "C"</code> use the <a href="https://sparc.org/technical-documents/">standard SPARC architecture calling
convention</a>.</p>
<p>This target generates ELF binaries. Any alternate formats or special
considerations for binary layout will require linker options or linker scripts.</p>
<h2 id="building-the-target-54"><a class="header" href="#building-the-target-54">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
build-stage = 1
host = ["&lt;target for your host&gt;"]
target = ["&lt;target for your host&gt;", "sparc-unknown-none-elf"]
</code></pre>
<p>Replace <code>&lt;target for your host&gt;</code> with <code>x86_64-unknown-linux-gnu</code> or whatever
else is appropriate for your host machine.</p>
<h2 id="building-rust-programs-58"><a class="header" href="#building-rust-programs-58">Building Rust programs</a></h2>
<p>To build with this target, pass it to the <code>--target</code> argument, like:</p>
<pre><code class="language-console">cargo build --target sparc-unknown-none-elf
</code></pre>
<p>This target uses GCC as a linker, and so you will need an appropriate GCC
compatible <code>sparc-unknown-none</code> toolchain. The default linker binary is
<code>sparc-elf-gcc</code>, but you can override this in your project configuration, as
follows:</p>
<p><code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.sparc-unknown-none-elf]
linker = "sparc-custom-elf-gcc"
</code></pre>
<h2 id="testing-60"><a class="header" href="#testing-60">Testing</a></h2>
<p>As <code>sparc-unknown-none-elf</code> supports a variety of different environments and does
not support <code>std</code>, this target does not support running the Rust test suite.</p>
<h2 id="cross-compilation-toolchains-and-c-code-30"><a class="header" href="#cross-compilation-toolchains-and-c-code-30">Cross-compilation toolchains and C code</a></h2>
<p>This target was initially tested using <a href="https://www.gaisler.com/index.php/downloads/compilers">BCC2</a> from Gaisler, along with the TSIM
Leon3 processor simulator. Both <a href="https://www.gaisler.com/index.php/downloads/compilers">BCC2</a> GCC and <a href="https://www.gaisler.com/index.php/downloads/compilers">BCC2</a> Clang have been shown to
work. To work with these tools, your project configuration should contain
something like:</p>
<p><code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.sparc-unknown-none-elf]
linker = "sparc-gaisler-elf-gcc"
runner = "tsim-leon3"

[build]
target = ["sparc-unknown-none-elf"]
rustflags = "-Ctarget-cpu=leon3"
</code></pre>
<p>With this configuration, running <code>cargo run</code> will compile your code for the
SPARC V8 compatible Gaisler Leon3 processor and then start the <code>tsim-leon3</code>
simulator. The <code>libcore</code> was pre-compiled as part of the <code>rustc</code> compilation
process using the SPARC V7 baseline, but if you are using a nightly toolchain
you can use the
<a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std"><code>-Z build-std=core</code></a>
option to rebuild <code>libcore</code> from source. This may be useful if you want to
compile it for SPARC V8 and take advantage of the extra instructions.</p>
<p><code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.sparc-unknown-none-elf]
linker = "sparc-gaisler-elf-gcc"
runner = "tsim-leon3"

[build]
target = ["sparc-unknown-none-elf"]
rustflags = "-Ctarget-cpu=leon3"

[unstable]
build-std = ["core"]
</code></pre>
<p>Either way, once the simulator is running, simply enter the command <code>run</code> to
start the code executing in the simulator.</p>
<p>The default C toolchain libraries are linked in, so with the Gaisler <a href="https://www.gaisler.com/index.php/downloads/compilers">BCC2</a>
toolchain, and using its default Leon3 BSP, you can use call the C <code>putchar</code>
function and friends to output to the simulator console. The default linker
script is also appropriate for the Leon3 simulator, so no linker script is
required.</p>
<p>Here’s a complete example using the above config file:</p>
<pre><code class="language-rust ignore (cannot-test-this-because-it-assumes-special-libc-functions)">#![no_std]
#![no_main]

extern "C" {
    fn putchar(ch: i32);
    fn _exit(code: i32) -&gt; !;
}

#[no_mangle]
extern "C" fn main() -&gt; i32 {
    let message = "Hello, this is Rust!";
    for b in message.bytes() {
        unsafe {
            putchar(b as i32);
        }
    }
    0
}

#[panic_handler]
fn panic(_panic: &amp;core::panic::PanicInfo) -&gt; ! {
    unsafe {
        _exit(1);
    }
}</code></pre>
<pre><code class="language-console">$ cargo run --target=sparc-unknown-none-elf
   Compiling sparc-demo-rust v0.1.0 (/work/sparc-demo-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 3.44s
     Running `tsim-leon3 target/sparc-unknown-none-elf/debug/sparc-demo-rust`

 TSIM3 LEON3 SPARC simulator, version 3.1.9 (evaluation version)

 Copyright (C) 2023, Frontgrade Gaisler - all rights reserved.
 This software may only be used with a valid license.
 For latest updates, go to https://www.gaisler.com/
 Comments or bug-reports to support@gaisler.com

 This TSIM evaluation version will expire 2023-11-28

Number of CPUs: 2
system frequency: 50.000 MHz
icache: 1 * 4 KiB, 16 bytes/line (4 KiB total)
dcache: 1 * 4 KiB, 16 bytes/line (4 KiB total)
Allocated 8192 KiB SRAM memory, in 1 bank at 0x40000000
Allocated 32 MiB SDRAM memory, in 1 bank at 0x60000000
Allocated 8192 KiB ROM memory at 0x00000000
section: .text, addr: 0x40000000, size: 20528 bytes
section: .rodata, addr: 0x40005030, size: 128 bytes
section: .data, addr: 0x400050b0, size: 1176 bytes
read 347 symbols

tsim&gt; run
  Initializing and starting from 0x40000000
Hello, this is Rust!

  Program exited normally on CPU 0.
tsim&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sparcv9-sun-solaris"><a class="header" href="#sparcv9-sun-solaris">sparcv9-sun-solaris</a></h1>
<h1 id="x86_64-pc-solaris"><a class="header" href="#x86_64-pc-solaris">x86_64-pc-solaris</a></h1>
<p><strong>Tier: 2</strong></p>
<p>Rust for Solaris operating system.</p>
<h2 id="target-maintainers-82"><a class="header" href="#target-maintainers-82">Target maintainers</a></h2>
<p><a href="https://github.com/psumbera">@psumbera</a>
<a href="https://github.com/kulikjak">@kulikjak</a></p>
<h2 id="requirements-75"><a class="header" href="#requirements-75">Requirements</a></h2>
<p>The <code>sparcv9-sun-solaris</code> and <code>x86_64-pc-solaris</code> targets are Tier 2 with host tools.</p>
<p>Binary built for these targets are expected to run on sparcv9 or x86_64, and Solaris 11.4.</p>
<h2 id="testing-61"><a class="header" href="#testing-61">Testing</a></h2>
<p>For testing you can download Oracle Solaris 11.4 CBE release from:</p>
<p>https://www.oracle.com/uk/solaris/solaris11/downloads/solaris-downloads.html</p>
<p>Solaris CBE release is also available for GitHub CI:</p>
<p>https://github.com/vmactions/solaris-vm</p>
<p>Latest Solaris 11.4 SRU can be tested at Compile farm project:</p>
<p>https://portal.cfarm.net/machines/list/ (cfarm215, cfarm215)</p>
<p>There are no official Rust binaries for Solaris available for Rustup yet. But you can eventually download unofficial from:</p>
<p>https://github.com/psumbera/solaris-rust</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nto-qnx"><a class="header" href="#nto-qnx">nto-qnx</a></h1>
<p><strong>Tier: 3</strong></p>
<p>The <a href="https://blackberry.qnx.com">QNX®</a> Neutrino (nto) Real-time operating system. Known as QNX OS
from version 8 onwards.</p>
<p>This support has been implemented jointly by <a href="https://www.elektrobit.com">Elektrobit Automotive GmbH</a>
and <a href="https://blackberry.qnx.com">QNX</a>.</p>
<h2 id="target-maintainers-83"><a class="header" href="#target-maintainers-83">Target maintainers</a></h2>
<p><a href="https://github.com/flba-eb">@flba-eb</a>
<a href="https://github.com/gh-tr">@gh-tr</a>
<a href="https://github.com/jonathanpallant">@jonathanpallant</a>
<a href="https://github.com/japaric">@japaric</a></p>
<h2 id="requirements-76"><a class="header" href="#requirements-76">Requirements</a></h2>
<p>Currently, the following QNX versions and compilation targets are supported:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target Tuple</th><th>QNX Version</th><th>Target Architecture</th><th style="text-align: center">Full support</th><th style="text-align: center"><code>no_std</code> support</th></tr>
</thead>
<tbody>
<tr><td><code>aarch64-unknown-nto-qnx800</code></td><td>QNX OS 8.0</td><td>AArch64</td><td style="text-align: center">?</td><td style="text-align: center">✓</td></tr>
<tr><td><code>x86_64-pc-nto-qnx800</code></td><td>QNX OS 8.0</td><td>x86_64</td><td style="text-align: center">?</td><td style="text-align: center">✓</td></tr>
<tr><td><code>aarch64-unknown-nto-qnx710</code></td><td>QNX Neutrino 7.1 with io-pkt</td><td>AArch64</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td></tr>
<tr><td><code>x86_64-pc-nto-qnx710</code></td><td>QNX Neutrino 7.1 with io-pkt</td><td>x86_64</td><td style="text-align: center">✓</td><td style="text-align: center">✓</td></tr>
<tr><td><code>aarch64-unknown-nto-qnx710_iosock</code></td><td>QNX Neutrino 7.1 with io-sock</td><td>AArch64</td><td style="text-align: center">?</td><td style="text-align: center">✓</td></tr>
<tr><td><code>x86_64-pc-nto-qnx710_iosock</code></td><td>QNX Neutrino 7.1 with io-sock</td><td>x86_64</td><td style="text-align: center">?</td><td style="text-align: center">✓</td></tr>
<tr><td><code>aarch64-unknown-nto-qnx700</code></td><td>QNX Neutrino 7.0</td><td>AArch64</td><td style="text-align: center">?</td><td style="text-align: center">✓</td></tr>
<tr><td><code>i686-pc-nto-qnx700</code></td><td>QNX Neutrino 7.0</td><td>x86</td><td style="text-align: center"></td><td style="text-align: center">✓</td></tr>
</tbody>
</table>
</div>
<p>On QNX Neutrino 7.0 and 7.1, <code>io-pkt</code> is used as network stack by default.
QNX Neutrino 7.1 includes the optional network stack <code>io-sock</code>.
QNX OS 8.0 always uses <code>io-sock</code>. QNX OS 8.0 support is currently work in progress.</p>
<p>Adding other architectures that are supported by QNX is possible.</p>
<p>In the table above, ‘full support’ indicates support for building Rust applications with the full standard library. A ‘?’ means that support is in-progress.
‘<code>no_std</code> support’ is for building <code>#![no_std]</code> applications where only <code>core</code> and <code>alloc</code> are available.</p>
<p>For building or using the Rust toolchain for QNX, the
<a href="https://blackberry.qnx.com/en/products/foundation-software/qnx-software-development-platform">QNX Software Development Platform (SDP)</a>
must be installed and initialized.
Initialization is usually done by sourcing <code>qnxsdp-env.sh</code> (this will be installed as part of the SDP, see also installation instruction provided with the SDP).
Afterwards <a href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.utilities/topic/q/qcc.html"><code>qcc</code></a> (QNX C/C++ compiler)
should be available (in the <code>$PATH</code> variable).
<code>qcc</code> will be called e.g. for linking executables.</p>
<p>When linking <code>no_std</code> applications, they must link against <code>libc.so</code> (see example). This is
required because applications always link against the <code>crt</code> library and <code>crt</code> depends on <code>libc.so</code>.
This is done automatically when using the standard library.</p>
<h3 id="disabling-relocation-read-only-relro"><a class="header" href="#disabling-relocation-read-only-relro">Disabling RELocation Read-Only (RELRO)</a></h3>
<p>While not recommended by default, some QNX kernel setups may require the <code>RELRO</code> to be disabled with <code>-C relro_level=off</code>, e.g. by adding it to the <code>.cargo/config.toml</code> file:</p>
<pre><code class="language-toml">[target.aarch64-unknown-nto-qnx700]
rustflags = ["-C", "relro_level=off"]
</code></pre>
<p>If your QNX kernel does not allow it, and <code>relro</code> is not disabled, running compiled binary would fail with <code>syntax error: ... unexpected</code> or similar.  This is due to kernel trying to interpret compiled binary with <code>/bin/sh</code>, and obviously failing.  To verify that this is really the case, run your binary with the <code>DL_DEBUG=all</code> env var, and look for this output. If you see it, you should disable <code>relro</code> as described above.</p>
<pre><code class="language-text">Resolution scope for Executable-&gt;/bin/sh:
        Executable-&gt;/bin/sh
        libc.so.4-&gt;/usr/lib/ldqnx-64.so.2
</code></pre>
<h3 id="small-example-application"><a class="header" href="#small-example-application">Small example application</a></h3>
<p>Small <code>no_std</code> example is shown below. Applications using the standard library work as well.</p>
<pre><code class="language-rust ignore (platform-specific)">#![no_std]
#![no_main]
#![feature(lang_items)]

// We must always link against libc, even if no external functions are used
// "extern C" - Block can be empty but must be present
#[link(name = "c")]
extern "C" {
    pub fn printf(format: *const core::ffi::c_char, ...) -&gt; core::ffi::c_int;
}

#[no_mangle]
pub extern "C" fn main(_argc: core::ffi::c_int, _argv: *const *const u8) -&gt; core::ffi::c_int {
    const HELLO: &amp;'static str = "Hello World, the answer is %d\n\0";
    unsafe {
        printf(HELLO.as_ptr() as *const _, 42);
    }
    0
}

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo&lt;'_&gt;) -&gt; ! {
    loop {}
}

#[lang = "eh_personality"]
#[no_mangle]
pub extern "C" fn rust_eh_personality() {}</code></pre>
<p>The QNX support in Rust has been tested with QNX Neutrino 7.0 and 7.1. Support for QNX OS 8.0 is a work in progress.</p>
<p>There are no further known requirements.</p>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>For conditional compilation, following QNX specific attributes are defined:</p>
<ul>
<li><code>target_os</code> = <code>"nto"</code></li>
<li><code>target_env</code> = <code>"nto71"</code> (for QNX Neutrino 7.1 with “classic” network stack “io_pkt”)</li>
<li><code>target_env</code> = <code>"nto71_iosock"</code> (for QNX Neutrino 7.1 with network stack “io_sock”)</li>
<li><code>target_env</code> = <code>"nto70"</code> (for QNX Neutrino 7.0)</li>
<li><code>target_env</code> = <code>"nto80"</code> (for QNX OS 8.0)</li>
</ul>
<h2 id="building-the-target-55"><a class="header" href="#building-the-target-55">Building the target</a></h2>
<ol>
<li>
<p>Create a <code>bootstrap.toml</code></p>
<p>Example content:</p>
<pre><code class="language-toml">profile = "compiler"
change-id = 999999
</code></pre>
</li>
<li>
<p>Compile the Rust toolchain for an <code>x86_64-unknown-linux-gnu</code> host</p>
<p>Compiling the Rust toolchain requires the same environment variables used for compiling C binaries.
Refer to the <a href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.prog/topic/devel_OS_version.html">QNX developer manual</a>.</p>
<p>To compile for QNX, environment variables must be set to use the correct tools and compiler switches:</p>
<ul>
<li><code>CC_&lt;target&gt;=qcc</code></li>
<li><code>CFLAGS_&lt;target&gt;=&lt;nto_cflag&gt;</code></li>
<li><code>CXX_&lt;target&gt;=qcc</code></li>
<li><code>AR_&lt;target&gt;=&lt;nto_ar&gt;</code></li>
</ul>
<p>With:</p>
<ul>
<li>
<p><code>&lt;target&gt;</code> target triplet using underscores instead of hyphens, e.g. <code>aarch64_unknown_nto_qnx710</code></p>
</li>
<li>
<p><code>&lt;nto_cflag&gt;</code></p>
<ul>
<li><code>-Vgcc_ntox86_cxx</code> for x86 (32 bit)</li>
<li><code>-Vgcc_ntox86_64_cxx</code> for x86_64 (64 bit)</li>
<li><code>-Vgcc_ntoaarch64le_cxx</code> for Aarch64 (64 bit)</li>
</ul>
</li>
<li>
<p><code>&lt;nto_ar&gt;</code></p>
<ul>
<li><code>ntox86-ar</code> for x86 (32 bit)</li>
<li><code>ntox86_64-ar</code> for x86_64 (64 bit)</li>
<li><code>ntoaarch64-ar</code> for Aarch64 (64 bit)</li>
</ul>
</li>
</ul>
<p>Example to build the Rust toolchain including a standard library for x86_64-linux-gnu and Aarch64-QNX-7.1:</p>
<pre><code class="language-bash">export build_env='
    CC_aarch64_unknown_nto_qnx710=qcc
    CFLAGS_aarch64_unknown_nto_qnx710=-Vgcc_ntoaarch64le_cxx
    CXX_aarch64_unknown_nto_qnx710=qcc
    AR_aarch64_unknown_nto_qnx710=ntoaarch64-ar
    '

env $build_env \
    ./x.py build \
        --target x86_64-unknown-linux-gnu,aarch64-unknown-nto-qnx710 \
        rustc library/core library/alloc library/std
</code></pre>
</li>
</ol>
<h2 id="running-the-rust-test-suite"><a class="header" href="#running-the-rust-test-suite">Running the Rust test suite</a></h2>
<p>The test suites of the Rust compiler and standard library can be executed much like other Rust targets.
The environment for testing should match the one used during compiler compilation (refer to <code>build_env</code> and <code>qcc</code>/<code>PATH</code> above) with the
addition of the TEST_DEVICE_ADDR environment variable.
The TEST_DEVICE_ADDR variable controls the remote runner and should point to the target, despite localhost being shown in the following example.
Note that some tests are failing which is why they are currently excluded by the target maintainers which can be seen in the following example.</p>
<p>To run all tests on a x86_64 QNX Neutrino 7.1 target:</p>
<pre><code class="language-bash">export TEST_DEVICE_ADDR="localhost:12345" # must address the test target, can be a SSH tunnel
export build_env=&lt;see above&gt;

# Disable tests that only work on the host or don't make sense for this target.
# See also:
# - src/ci/docker/host-x86_64/i686-gnu/Dockerfile
# - https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Running.20tests.20on.20remote.20target
# - .github/workflows/ci.yml
export exclude_tests='
    --exclude src/bootstrap
    --exclude src/tools/error_index_generator
    --exclude src/tools/linkchecker
    --exclude tests/ui-fulldeps
    --exclude rustc
    --exclude rustdoc'

env $build_env \
    ./x.py test \
        $exclude_tests \
        --stage 1 \
        --target x86_64-pc-nto-qnx710
</code></pre>
<h2 id="building-rust-programs-59"><a class="header" href="#building-rust-programs-59">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target.
To compile for this target, you must either build Rust with the target enabled (see “Building the target” above),
or build your own copy of <code>core</code> by using <code>build-std</code> or similar.</p>
<h2 id="testing-62"><a class="header" href="#testing-62">Testing</a></h2>
<p>Compiled executables can run directly on QNX.</p>
<h3 id="rust-std-library-test-suite"><a class="header" href="#rust-std-library-test-suite">Rust std library test suite</a></h3>
<p>The target needs sufficient resources to execute all tests. The commands below assume that a QEMU image
is used.</p>
<ul>
<li>
<p>Ensure that the temporary directory used by <code>remote-test-server</code> has enough free space and inodes.
5GB of free space and 40000 inodes are known to be sufficient (the test will create more than 32k files).
To create a QEMU image in an empty directory, run this command inside the directory:</p>
<pre><code class="language-bash">mkqnximage --type=qemu --ssh-ident=$HOME/.ssh/id_ed25519.pub --data-size=5000 --data-inodes=40000
</code></pre>
<p><code>/data</code> should have enough free resources.
Set the <code>TMPDIR</code> environment variable accordingly when running <code>remote-test-server</code>, e.g.:</p>
<pre><code class="language-bash">TMPDIR=/data/tmp/rust remote-test-server --bind 0.0.0.0:12345
</code></pre>
</li>
<li>
<p>Ensure the TCP stack can handle enough parallel connections (default is 200, should be 300 or higher).
After creating an image (see above), edit the file <code>output/build/startup.sh</code>:</p>
<ol>
<li>Search for <code>io-pkt-v6-hc</code></li>
<li>Add the parameter <code>-ptcpip threads_max=300</code>, e.g.:
<pre><code class="language-text">io-pkt-v6-hc -U 33:33 -d e1000 -ptcpip threads_max=300
</code></pre>
</li>
<li>Update the image by running <code>mkqnximage</code> again with the same parameters as above for creating it.</li>
</ol>
</li>
<li>
<p>Running and stopping the virtual machine</p>
<p>To start the virtual machine, run inside the directory of the VM:</p>
<pre><code class="language-bash">mkqnximage --run=-h
</code></pre>
<p>To stop the virtual machine, run inside the directory of the VM:</p>
<pre><code class="language-bash">mkqnximage --stop
</code></pre>
</li>
<li>
<p>Ensure local networking</p>
<p>Ensure that ‘localhost’ is getting resolved to 127.0.0.1. If you can’t ping the localhost, some tests may fail.
Ensure it’s appended to /etc/hosts (if first <code>ping</code> command fails).
Commands have to be executed inside the virtual machine!</p>
<pre><code class="language-bash">$ ping localhost
ping: Cannot resolve "localhost" (Host name lookup failure)

$ echo "127.0.0.1 localhost" &gt;&gt; /etc/hosts

$ ping localhost
PING localhost (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=1 ms
</code></pre>
</li>
</ul>
<h2 id="cross-compilation-toolchains-and-c-code-31"><a class="header" href="#cross-compilation-toolchains-and-c-code-31">Cross-compilation toolchains and C code</a></h2>
<p>Compiling C code requires the same environment variables to be set as compiling the Rust toolchain (see above),
to ensure <code>qcc</code> is used with proper arguments.
To ensure compatibility, do not specify any further arguments that for example change calling conventions or memory layout.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unikraft-linux-musl"><a class="header" href="#-unikraft-linux-musl"><code>*-unikraft-linux-musl</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Targets for the <a href="https://unikraft.org/">Unikraft</a> Unikernel Development Kit (with musl).</p>
<p>Target triplets available so far:</p>
<ul>
<li><code>x86_64-unikraft-linux-musl</code></li>
</ul>
<h2 id="target-maintainers-84"><a class="header" href="#target-maintainers-84">Target maintainers</a></h2>
<p><a href="https://github.com/mkroening">@mkroening</a></p>
<h2 id="requirements-77"><a class="header" href="#requirements-77">Requirements</a></h2>
<p>These targets only support cross-compilation.
The targets do support std.</p>
<p>Unikraft pretends to behave exactly like Linux.
How much of that functionality is available depends on the individual unikernel configuration.
For example, the basic Unikraft + musl config does not support <code>poll</code> or networking out of the box.
That functionality requires enabling <a href="https://github.com/unikraft/unikraft/blob/RELEASE-0.13.1/lib/posix-event/Config.uk"><code>LIBPOSIX_EVENT</code></a> or <a href="https://github.com/unikraft/lib-lwip">lwIP</a> respectively.</p>
<p>The Unikraft targets follow Linux’s <code>extern "C"</code> calling convention.</p>
<p>For these targets, <code>rustc</code> does not perform the final linking step.
Instead, the Unikraft build system will produce the final Unikernel image for the selected platform (e.g., KVM, Linux user space, and Xen).</p>
<h2 id="building-the-targets"><a class="header" href="#building-the-targets">Building the targets</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code> list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-unikraft-linux-musl"]
</code></pre>
<h2 id="building-rust-programs-60"><a class="header" href="#building-rust-programs-60">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for these targets.
To compile for these targets, you will either need to build Rust with the targets enabled
(see “Building the targets” above), or build your own copy of <code>core</code> by using <code>build-std</code> or similar.</p>
<p>Linking requires a <a href="https://github.com/unikraft/kraftkit">KraftKit</a> shim.
See <a href="https://github.com/unikraft/kraftkit/issues/612">unikraft/kraftkit#612</a> for more information.</p>
<h2 id="testing-63"><a class="header" href="#testing-63">Testing</a></h2>
<p>The targets do support running binaries in the form of unikernel images.
How the unikernel image is run depends on the specific platform (e.g., KVM, Linux user space, and Xen).
The targets do not support running the Rust test suite.</p>
<h2 id="cross-compilation-toolchains-and-c-code-32"><a class="header" href="#cross-compilation-toolchains-and-c-code-32">Cross-compilation toolchains and C code</a></h2>
<p>The targets do support C code.
To build compatible C code, you have to use the same compiler and flags as does the Unikraft build system for your specific configuration.
The easiest way to achieve that, is to build the C code with the Unikraft build system when building your unikernel image.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-helenos"><a class="header" href="#-unknown-helenos"><code>*-unknown-helenos</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Targets for <a href="https://www.helenos.org">HelenOS</a>.
These targets allow compiling user-space applications, that you can then copy into your HelenOS ISO image to run them.</p>
<p>Target triplets available:</p>
<ul>
<li><code>x86_64-unknown-helenos</code></li>
<li><code>sparc64-unknown-helenos</code></li>
<li><code>powerpc-unknown-helenos</code></li>
<li><code>aarch64-unknown-helenos</code></li>
<li><code>i686-unknown-helenos</code>*</li>
</ul>
<p>On i686, some portions of native HelenOS libraries run into issues due to vector instructions accessing variables from the stack that seems
to be misaligned. It is not clear if this is fault of HelenOS or Rust. Most programs work, but for example calling <code>ui_window_create</code> from HelenOS
libui does not work.</p>
<h2 id="target-maintainers-85"><a class="header" href="#target-maintainers-85">Target maintainers</a></h2>
<ul>
<li>Matěj Volf (<a href="https://github.com/mvolfik">@mvolfik</a>)</li>
</ul>
<h2 id="requirements-78"><a class="header" href="#requirements-78">Requirements</a></h2>
<p>These targets only support cross-compilation. The targets will<sup class="footnote-reference" id="fr-helenos-libstd-pending-1"><a href="#footnote-helenos-libstd-pending">1</a></sup> support libstd, although support of some platform features (filesystem, networking) may be limited.</p>
<p>You need to have a local clone of the HelenOS repository and the HelenOS toolchain set up, no HelenOS-Rust development artifacts are available.</p>
<h2 id="building-9"><a class="header" href="#building-9">Building</a></h2>
<p>If you want to avoid the full setup, fully automated Docker-based build system is available at https://github.com/mvolfik/helenos-rust-autobuild</p>
<h3 id="helenos-toolchain-setup"><a class="header" href="#helenos-toolchain-setup">HelenOS toolchain setup</a></h3>
<p>For compilation of standard library, you need to build the HelenOS toolchain (because Rust needs to use <code>*-helenos-gcc</code> as linker) and its libraries (libc and a few others). See <a href="https://www.helenos.org/wiki/UsersGuide/CompilingFromSource#a2.Buildasupportedcross-compiler">this HelenOS wiki page</a> for instruction on setting up the build. At the end of step 4 (<em>Configure and build</em>), after <code>ninja image_path</code>, invoke <code>ninja export-dev</code> to build the shared libraries.</p>
<p>Copy the libraries to the path where the compiler automatically searches for them. This will be the directory where you installed the toolchain (for example <code>~/.local/share/HelenOS/cross/i686-helenos/lib</code>). In the folder where you built HelenOS, you can run these commands:</p>
<pre><code class="language-sh">touch /tmp/test.c
HELENOS_LIB_PATH="$(realpath "$(amd64-helenos-gcc -v -c /tmp/test.c 2&gt;&amp;1 | grep LIBRARY_PATH | cut -d= -f2 | cut -d: -f2)")"
# use sparc64-helenos-gcc above for the SPARC toolchain, etc
cp -P export-dev/lib/* "$HELENOS_LIB_PATH"
</code></pre>
<h3 id="building-the-target-56"><a class="header" href="#building-the-target-56">Building the target</a></h3>
<p>When you have the HelenOS toolchain set up and installed in your path, you can build the Rust toolchain using the standard procedure. See <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html">rustc dev guide</a>.</p>
<p>In the most simple case, this means that you can run <code>./x build library --stage 1 --target x86_64-unknown-linux-gnu,&lt;arch&gt;-unknown-helenos</code> (the first target triple should be your host machine, adjust accordingly). Then run <code>rustup toolchain link mytoolchain build/host/stage1</code> to allow using your toolchain for building Rust programs.</p>
<h3 id="building-rust-programs-61"><a class="header" href="#building-rust-programs-61">Building Rust programs</a></h3>
<p>If you linked the toolchain above as <code>mytoolchain</code>, run <code>cargo +mytoolchain build --target &lt;arch&gt;-unknown-helenos</code>.</p>
<h2 id="testing-64"><a class="header" href="#testing-64">Testing</a></h2>
<p>After you build a Rust program for HelenOS, you can put it into the <code>dist</code> directory of the HelenOS build, build the ISO image, and then run it either in an emulator, or on real hardware. See HelenOS wiki for further instructions on running the OS.</p>
<p>Running the Rust testsuite has not been attempted yet due to missing host tools (thus the test suite can’t be run natively) and insufficient networking support (thus we can’t use the <code>remote-test-server</code> tool).</p>
<h2 id="cross-compilation-toolchains-and-c-code-33"><a class="header" href="#cross-compilation-toolchains-and-c-code-33">Cross-compilation toolchains and C code</a></h2>
<p>You should be able to cross-compile and link any needed C code using <code>&lt;arch&gt;-helenos-gcc</code> that you built above. However, note that clang support is highly lacking. Therefore, to run tools such as <code>bindgen</code>, you will need to provide flag <code>-nostdinc</code> and manually specify the include paths to HelenOS headers, which you will find in the <code>export-dev</code> folder + in the cross-compilation toolchain (e.g. <code>~/.local/share/HelenOS/cross/lib/gcc/i686-helenos/14.2.0/include</code>). You can see an example of proper build.rs at https://github.com/mvolfik/helenos-ui-rs/blob/master/build.rs</p>
<hr>
<ol class="footnote-definition">
<li id="footnote-helenos-libstd-pending">
<p>libstd is not yet available, because it needs to be done in a separate PR, because compiler support needs to be merged first to allow creating libc bindings <a href="#fr-helenos-libstd-pending-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-hermit"><a class="header" href="#-unknown-hermit"><code>*-unknown-hermit</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>The <a href="https://github.com/hermit-os">Hermit</a> unikernel target allows compiling your applications into self-contained, specialized unikernel images that can be run in small virtual machines.</p>
<p>Target triplets available so far:</p>
<ul>
<li><code>x86_64-unknown-hermit</code></li>
<li><code>aarch64-unknown-hermit</code></li>
<li><code>aarch64_be-unknown-hermit</code></li>
<li><code>riscv64gc-unknown-hermit</code></li>
</ul>
<h2 id="target-maintainers-86"><a class="header" href="#target-maintainers-86">Target maintainers</a></h2>
<p><a href="https://github.com/stlankes">@stlankes</a>
<a href="https://github.com/mkroening">@mkroening</a></p>
<h2 id="requirements-79"><a class="header" href="#requirements-79">Requirements</a></h2>
<p>These targets only support cross-compilation.
The targets do support std.</p>
<p>When building binaries for this target, the Hermit unikernel is built from scratch.
The application developer themselves specializes the target and sets corresponding expectations.</p>
<p>The Hermit targets follow Linux’s <code>extern "C"</code> calling convention.</p>
<p>Hermit binaries have the ELF format.</p>
<h2 id="building-the-target-57"><a class="header" href="#building-the-target-57">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code> list in <code>bootstrap.toml</code>.
To run the Hermit build scripts, you also have to enable your host target.
The build scripts rely on <code>llvm-tools</code> and binaries are linked using <code>rust-lld</code>, so those have to be enabled as well.</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = [
    "&lt;HOST_TARGET&gt;",
    "x86_64-unknown-hermit",
    "aarch64-unknown-hermit",
    "aarch64_be-unknown-hermit",
    "riscv64gc-unknown-hermit",
]

[rust]
lld = true
llvm-tools = true
</code></pre>
<h2 id="building-rust-programs-62"><a class="header" href="#building-rust-programs-62">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for these targets.
To compile for these targets, you will either need to build Rust with the targets enabled
(see “Building the targets” above), or build your own copy of <code>core</code> by using <code>build-std</code> or similar.</p>
<p>As all Hermit programs are unikernels, building a Rust program also requires including the operating system code. A guide for doing so is provided in our starter <a href="https://github.com/hermit-os/hermit-rs-template">hermit-rs-template</a>.</p>
<h2 id="testing-65"><a class="header" href="#testing-65">Testing</a></h2>
<p>The targets support running binaries in the form of self-contained unikernel images.
These images can be chainloaded by Hermit’s <a href="https://github.com/hermit-os/loader">loader</a> or hypervisor (<a href="https://github.com/hermit-os/uhyve">Uhyve</a>).
QEMU can be used to boot Hermit binaries using the loader on any architecture.
The targets do not support running the Rust test suite.</p>
<h2 id="cross-compilation-toolchains-and-c-code-34"><a class="header" href="#cross-compilation-toolchains-and-c-code-34">Cross-compilation toolchains and C code</a></h2>
<p>The targets do not yet support C code and Rust code at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-freebsd"><a class="header" href="#-unknown-freebsd">*-unknown-freebsd</a></h1>
<p><strong>Tier: 2/3</strong></p>
<p><a href="https://www.FreeBSD.org/">FreeBSD</a> multi-platform 4.4BSD-based UNIX-like operating system.</p>
<h2 id="target-maintainers-87"><a class="header" href="#target-maintainers-87">Target maintainers</a></h2>
<p><a href="https://github.com/asomers">@asomers</a>
<a href="https://github.com/MikaelUrankar">@MikaelUrankar</a></p>
<h2 id="requirements-80"><a class="header" href="#requirements-80">Requirements</a></h2>
<p>The <code>x86_64-unknown-freebsd</code> target is Tier 2 with host tools.
<code>i686-unknown-freebsd</code> is Tier 2 without host tools.  Other targets are Tier 3.
See <a href="#platform-support">platform-support.md</a> for the full list.</p>
<p>We commit that rustc will run on all currently supported releases of
<a href="https://www.freebsd.org/security/#sup">FreeBSD</a> .  EoL releases may be supported for a time, too.
The same guarantees apply for the standard library and the libc crate.</p>
<p>Specific release support matrix, as of Rust 1.82.0:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>FreeBSD Release</th><th>rustc</th><th>std</th><th>libc</th></tr>
</thead>
<tbody>
<tr><td>10</td><td>&lt; 1.78.0</td><td>?</td><td>?</td></tr>
<tr><td>11</td><td>&lt; 1.78.0</td><td>&lt; 1.78.0</td><td>current</td></tr>
<tr><td>12+</td><td>current</td><td>current</td><td>current</td></tr>
</tbody>
</table>
</div>
<p><code>extern "C"</code> uses the official calling convention of the respective
architectures.</p>
<p>FreeBSD OS binaries use the ELF file format.</p>
<h2 id="building-rust-programs-63"><a class="header" href="#building-rust-programs-63">Building Rust programs</a></h2>
<p>The <code>x86_64-unknown-freebsd</code> and <code>i686-unknown-freebsd</code> artifacts are
distributed by the rust project and may be installed with rustup.  Other
targets are built by the ports system and may be installed with
<a href="https://man.freebsd.org/cgi/man.cgi?query=pkg">pkg(7)</a> or <a href="https://man.freebsd.org/cgi/man.cgi?query=ports">ports(7)</a>.</p>
<p>By default the <code>i686-unknown-freebsd</code> target uses SSE2 instructions.  To build
code that does not require SSE2, build lang/rust from <a href="https://man.freebsd.org/cgi/man.cgi?query=ports">ports</a> and
disable the <code>SSE2</code> option at build time.  That will produce non-compliant
behavior.  See <a href="https://github.com/rust-lang/rust/issues/114479">issue #114479</a>.</p>
<h2 id="testing-66"><a class="header" href="#testing-66">Testing</a></h2>
<p>The Rust test suite can be run natively. It can also be run from the FreeBSD
ports tree with the <code>make test</code> command from within the lang/rust directory.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-managarm-mlibc"><a class="header" href="#-unknown-managarm-mlibc"><code>*-unknown-managarm-mlibc</code></a></h1>
<p><strong>Tier: 3</strong></p>
<h2 id="target-maintainers-88"><a class="header" href="#target-maintainers-88">Target Maintainers</a></h2>
<ul>
<li><a href="https://github.com/no92">@no92</a></li>
<li><a href="https://github.com/64">@64</a></li>
<li><a href="https://github.com/Dennisbonke">@Dennisbonke</a></li>
</ul>
<h2 id="requirements-81"><a class="header" href="#requirements-81">Requirements</a></h2>
<p>This target is cross-compiled. There is currently no support for <code>std</code> yet. It generates binaries in the ELF format. Currently, we support the <code>x86_64</code>, <code>aarch64</code> and <code>riscv64gc</code> architectures. The examples below <code>$ARCH</code> should be substituted for one of the supported architectures.</p>
<h2 id="building-the-target-58"><a class="header" href="#building-the-target-58">Building the target</a></h2>
<p>Managarm has upstream support in LLVM since the release of 21.1.0.</p>
<p>Set up your <code>bootstrap.toml</code> like this:</p>
<pre><code class="language-toml">change-id = 142379

[llvm]
targets = "X86;AArch64;RISCV"
download-ci-llvm = false

[build]
target = ["$ARCH-unknown-managarm-mlibc", "x86_64-unknown-linux-gnu"]

[target.x86_64-unknown-linux-gnu]
llvm-config = "/path/to/your/llvm/bin/llvm-config"

[target.$ARCH-unknown-managarm-mlibc]
llvm-config = "/path/to/your/llvm/bin/llvm-config"
</code></pre>
<h2 id="building-rust-programs-64"><a class="header" href="#building-rust-programs-64">Building Rust programs</a></h2>
<p>Build a <code>$ARCH-managarm-gcc</code> using our <a href="https://github.com/managarm/gcc">gcc fork</a>.</p>
<pre><code class="language-toml">[build]
rustc = "/path/to/the/rust-prefix/bin/rustc"
target = "$ARCH-unknown-managarm-mlibc"

[target.$ARCH-unknown-managarm-mlibc]
linker = "/path/to/the/managarm-gcc/bin/$ARCH-managarm-gcc"
</code></pre>
<h2 id="testing-67"><a class="header" href="#testing-67">Testing</a></h2>
<p>This target does not support running the Rust testsuite yet.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64-unknown-motor"><a class="header" href="#x86_64-unknown-motor"><code>x86_64-unknown-motor</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p><a href="https://github.com/moturus/motor-os">Motor OS</a> is a new operating system
for virtualized environments.</p>
<h2 id="target-maintainers-89"><a class="header" href="#target-maintainers-89">Target maintainers</a></h2>
<p><a href="https://github.com/lasiotus">@lasiotus</a></p>
<h2 id="requirements-82"><a class="header" href="#requirements-82">Requirements</a></h2>
<p>This target is cross-compiled. There are no special requirements for the host.</p>
<p>Motor OS uses the ELF file format.</p>
<h2 id="building-the-target-toolchain"><a class="header" href="#building-the-target-toolchain">Building the target toolchain</a></h2>
<p>Motor OS target toolchain can be
<a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html">built using <code>x.py</code></a>:</p>
<p>The bootstrap file:</p>
<pre><code class="language-toml">[build]
host = ["x86_64-unknown-linux-gnu"]
target = ["x86_64-unknown-linux-gnu", "x86_64-unknown-motor"]
</code></pre>
<p>The build command:</p>
<pre><code class="language-sh">./x.py build --stage 2 clippy library
</code></pre>
<h2 id="building-rust-programs-65"><a class="header" href="#building-rust-programs-65">Building Rust programs</a></h2>
<p>See the <a href="https://github.com/moturus/motor-os/blob/main/docs/recipes/hello-motor-os.md">Hello Motor OS</a>
example.</p>
<h2 id="testing-68"><a class="header" href="#testing-68">Testing</a></h2>
<p>Cross-compiled Rust binaries and test artifacts can be executed in Motor OS VMs,
as described in the <a href="https://github.com/moturus/motor-os/blob/main/docs/build.md">build doc</a>
and the
<a href="https://github.com/moturus/motor-os/blob/main/docs/recipes/hello-motor-os.md">Hello Motor OS</a>
example.</p>
<h2 id="cross-compilation-toolchains-and-c-code-35"><a class="header" href="#cross-compilation-toolchains-and-c-code-35">Cross-compilation toolchains and C code</a></h2>
<p>C code can be compiled as part of Rust cargo projects. However, there is
no libc support.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-netbsd"><a class="header" href="#-unknown-netbsd">*-unknown-netbsd</a></h1>
<p><a href="https://www.NetBSD.org/">NetBSD</a> multi-platform 4.4BSD-based UNIX-like operating system.</p>
<p>The target names follow this format: <code>$ARCH-unknown-netbsd{-$SUFFIX}</code>,
where <code>$ARCH</code> specifies the target processor architecture and
<code>-$SUFFIX</code> (optional) might indicate the ABI. The following targets
are currently defined running NetBSD:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target tier</th><th>Target name</th><th>NetBSD Platform</th></tr>
</thead>
<tbody>
<tr><td>2 (with host tools)</td><td><code>x86_64-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/amd64/">amd64 / x86_64 systems</a></td></tr>
<tr><td>3</td><td><code>armv7-unknown-netbsd-eabihf</code></td><td><a href="https://wiki.netbsd.org/ports/evbarm/">32-bit ARMv7 systems with hard-float</a></td></tr>
<tr><td>3</td><td><code>armv6-unknown-netbsd-eabihf</code></td><td><a href="https://wiki.netbsd.org/ports/evbarm/">32-bit ARMv6 systems with hard-float</a></td></tr>
<tr><td>3</td><td><code>aarch64-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/evbarm/">64-bit ARM systems, little-endian</a></td></tr>
<tr><td>3</td><td><code>aarch64_be-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/evbarm/">64-bit ARM systems, big-endian</a></td></tr>
<tr><td>3</td><td><code>i586-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/i386/">32-bit i386, restricted to Pentium</a></td></tr>
<tr><td>3</td><td><code>i686-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/i386/">32-bit i386 with SSE</a></td></tr>
<tr><td>3</td><td><code>mipsel-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/evbmips/">32-bit mips, requires mips32 cpu support</a></td></tr>
<tr><td>3</td><td><code>powerpc-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/macppc/">Various 32-bit PowerPC systems, e.g. MacPPC</a></td></tr>
<tr><td>3</td><td><code>riscv64gc-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/riscv/">64-bit RISC-V</a></td></tr>
<tr><td>3</td><td><code>sparc64-unknown-netbsd</code></td><td><a href="https://wiki.netbsd.org/ports/sparc64/">Sun UltraSPARC systems</a></td></tr>
</tbody>
</table>
</div>
<p>All use the “native” <code>stdc++</code> library which goes along with the natively
supplied GNU C++ compiler for the given OS version.  Many of the bootstraps
are built for NetBSD 9.x, although some exceptions exist (some
are built for NetBSD 8.x but also work on newer OS versions).</p>
<h2 id="target-maintainers-90"><a class="header" href="#target-maintainers-90">Target Maintainers</a></h2>
<p><a href="https://github.com/he32">@he32</a>
<a href="https://github.com/0323pin">@0323pin</a></p>
<p>Further contacts:</p>
<ul>
<li><a href="https://github.com/NetBSD/pkgsrc-wip/blob/master/rust188/Makefile">NetBSD/pkgsrc-wip’s rust</a> maintainer (see MAINTAINER variable). This package is part of “pkgsrc work-in-progress” and is used for deployment and testing of new versions of rust.  Note that we have the convention of having multiple rust versions active in pkgsrc-wip at any one time, so the version number is part of the directory name, and from time to time old versions are culled so this is not a fully “stable” link.</li>
<li><a href="https://github.com/NetBSD/pkgsrc/tree/trunk/lang/rust">NetBSD’s pkgsrc lang/rust</a> for the “proper” package in pkgsrc.</li>
<li><a href="https://github.com/NetBSD/pkgsrc/tree/trunk/lang/rust-bin">NetBSD’s pkgsrc lang/rust-bin</a> which re-uses the bootstrap kit as a binary distribution and therefore avoids the rather protracted native build time of rust itself</li>
</ul>
<p>Fallback to pkgsrc-users@NetBSD.org, or fault reporting via NetBSD’s
bug reporting system.</p>
<h2 id="requirements-83"><a class="header" href="#requirements-83">Requirements</a></h2>
<p>The <code>x86_64-unknown-netbsd</code> artifacts is being distributed by the
rust project.</p>
<p>The other targets are built by the target maintainers (see above),
and the targets are initially cross-compiled, but many if not most
of them are also built natively as part of testing.</p>
<h2 id="building-10"><a class="header" href="#building-10">Building</a></h2>
<p>The default build mode for the packages is a native build.</p>
<h2 id="cross-compilation-19"><a class="header" href="#cross-compilation-19">Cross-compilation</a></h2>
<p>These targets can be cross-compiled, and we do that via the pkgsrc
package(s).</p>
<p>Cross-compilation typically requires the “tools” and “dest” trees
resulting from a normal cross-build of NetBSD itself, ref. our main
build script, <code>build.sh</code>.</p>
<p>See e.g. <a href="https://github.com/NetBSD/pkgsrc/tree/trunk/lang/rust/do-cross.mk">do-cross.mk
Makefile</a>
for the Makefile used to cross-build all the above NetBSD targets
(except for the <code>amd64</code> target).</p>
<p>The major option for the rust build is whether to build rust with
the LLVM rust carries in its distribution, or use the LLVM package
installed from pkgsrc.  The <code>PKG_OPTIONS.rust</code> option is
<code>rust-internal-llvm</code>, ref.  <a href="https://github.com/NetBSD/pkgsrc/blob/trunk/lang/rust/options.mk">the rust package’s options.mk make
fragment</a>.
It defaults to being set for a few of the above platforms, for
various reasons (see comments), but is otherwise unset and therefore
indicates use of the pkgsrc LLVM.</p>
<h2 id="testing-69"><a class="header" href="#testing-69">Testing</a></h2>
<p>The Rust testsuite could presumably be run natively.</p>
<p>For the systems where the maintainer can build natively, the rust
compiler itself is re-built natively.  This involves the rust compiler
being re-built with the newly self-built rust compiler, so exercises
the result quite extensively.</p>
<p>Additionally, for some systems we build <code>librsvg</code>, and for the more
capable systems we build and test <code>firefox</code> (amd64, i386, aarch64).</p>
<h2 id="building-rust-programs-66"><a class="header" href="#building-rust-programs-66">Building Rust programs</a></h2>
<p>Rust ships pre-compiled artifacts for the <code>x86_64-unknown-netbsd</code>
target.</p>
<p>For the other systems mentioned above, using the <code>pkgsrc</code> route is
probably the easiest, possibly via the <code>rust-bin</code> package to save
time, see the <code>RUST_TYPE</code> variable from the <code>rust.mk</code> Makefile
fragment.</p>
<p>The pkgsrc rust package has a few files to assist with building
pkgsrc packages written in rust, ref. the <code>rust.mk</code> and <code>cargo.mk</code>
Makefile fragments in the <code>lang/rust</code> package.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-openbsd"><a class="header" href="#-unknown-openbsd">*-unknown-openbsd</a></h1>
<p><strong>Tier: 3</strong></p>
<p><a href="https://www.openbsd.org/">OpenBSD</a> multi-platform 4.4BSD-based UNIX-like operating system.</p>
<p>The target names follow this format: <code>$ARCH-unknown-openbsd</code>, where <code>$ARCH</code> specifies the target processor architecture. The following targets are currently defined:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target name</th><th>C++ library</th><th>OpenBSD Platform</th></tr>
</thead>
<tbody>
<tr><td><code>aarch64-unknown-openbsd</code></td><td>libc++</td><td><a href="https://www.openbsd.org/arm64.html">64-bit ARM systems</a></td></tr>
<tr><td><code>i686-unknown-openbsd</code></td><td>libc++</td><td><a href="https://www.openbsd.org/i386.html">Standard PC and clones based on the Intel i386 architecture and compatible processors</a></td></tr>
<tr><td><code>powerpc64-unknown-openbsd</code></td><td>libc++</td><td><a href="https://www.openbsd.org/powerpc64.html">IBM POWER-based PowerNV systems</a></td></tr>
<tr><td><code>riscv64gc-unknown-openbsd</code></td><td>libc++</td><td><a href="https://www.openbsd.org/riscv64.html">64-bit RISC-V systems</a></td></tr>
<tr><td><code>sparc64-unknown-openbsd</code></td><td>estdc++</td><td><a href="https://www.openbsd.org/sparc64.html">Sun UltraSPARC and Fujitsu SPARC64 systems</a></td></tr>
<tr><td><code>x86_64-unknown-openbsd</code></td><td>libc++</td><td><a href="https://www.openbsd.org/amd64.html">AMD64-based systems</a></td></tr>
</tbody>
</table>
</div>
<p>Note that all OS versions are <em>major</em> even if using X.Y notation (<code>6.8</code> and <code>6.9</code> are different major versions) and could be binary incompatibles (with breaking changes).</p>
<h2 id="target-maintainers-91"><a class="header" href="#target-maintainers-91">Target Maintainers</a></h2>
<p><a href="https://github.com/semarie">@semarie</a></p>
<p>Further contacts:</p>
<ul>
<li><a href="https://cvsweb.openbsd.org/cgi-bin/cvsweb/ports/lang/rust/Makefile?rev=HEAD&amp;content-type=text/x-cvsweb-markup">lang/rust</a> maintainer (see MAINTAINER variable)</li>
</ul>
<p>Fallback to ports@openbsd.org, OpenBSD third parties public mailing-list (with openbsd developers readers)</p>
<h2 id="requirements-84"><a class="header" href="#requirements-84">Requirements</a></h2>
<p>These targets are natively compiled and could be cross-compiled.
C compiler toolchain is required for the purpose of building Rust and functional binaries.</p>
<h2 id="building-11"><a class="header" href="#building-11">Building</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = ["$ARCH-unknown-openbsd"]

[target.$ARCH-unknown-openbsd]
cc = "$ARCH-openbsd-cc"
</code></pre>
<h2 id="cross-compilation-20"><a class="header" href="#cross-compilation-20">Cross-compilation</a></h2>
<p>These targets can be cross-compiled, but LLVM might not build out-of-box.</p>
<h2 id="testing-70"><a class="header" href="#testing-70">Testing</a></h2>
<p>The Rust testsuite could be run natively.</p>
<h2 id="building-rust-programs-67"><a class="header" href="#building-rust-programs-67">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for these targets.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-redox"><a class="header" href="#-unknown-redox"><code>*-unknown-redox</code></a></h1>
<p><strong>Tier: 2/3</strong></p>
<p>Targets for the <a href="https://redox-os.org/">Redox OS</a> operating
system.</p>
<p>Target triplets available so far:</p>
<ul>
<li><code>x86_64-unknown-redox</code> (tier 2)</li>
<li><code>aarch64-unknown-redox</code> (tier 3)</li>
<li><code>i586-unknown-redox</code> (tier 3)</li>
<li><code>riscv64gc-unknown-redox</code> (tier 3)</li>
</ul>
<h2 id="target-maintainers-92"><a class="header" href="#target-maintainers-92">Target maintainers</a></h2>
<p><a href="https://github.com/jackpot51">@jackpot51</a></p>
<h2 id="requirements-85"><a class="header" href="#requirements-85">Requirements</a></h2>
<p>These targets are natively compiled and can be cross-compiled. Std is fully supported.</p>
<p>The targets are only expected to work with the latest version of Redox OS as the ABI is not yet stable.</p>
<p><code>extern "C"</code> uses the official calling convention of the respective architectures.</p>
<p>Redox OS binaries use ELF as file format.</p>
<h2 id="building-the-target-59"><a class="header" href="#building-the-target-59">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code> list in <code>bootstrap.toml</code>. In addition a copy of <a href="https://gitlab.redox-os.org/redox-os/relibc">relibc</a> needs to be present in the linker search path.</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = [
    "&lt;HOST_TARGET&gt;",
    "x86_64-unknown-redox",
    "aarch64-unknown-redox",
    "i586-unknown-redox",
    "riscv64gc-unknown-redox",
]
</code></pre>
<h2 id="building-rust-programs-and-testing"><a class="header" href="#building-rust-programs-and-testing">Building Rust programs and testing</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for Redox OS except for x86_64-unknown-redox.</p>
<p>The easiest way to build and test programs for Redox OS is using <a href="https://gitlab.redox-os.org/redox-os/redoxer">redoxer</a> which sets up the required compiler toolchain for building as well as runs programs inside a Redox OS VM using QEMU.</p>
<h2 id="cross-compilation-toolchains-and-c-code-36"><a class="header" href="#cross-compilation-toolchains-and-c-code-36">Cross-compilation toolchains and C code</a></h2>
<p>The target supports C code. Pre-compiled C toolchains can be found at <a href="https://static.redox-os.org/toolchain/">https://static.redox-os.org/toolchain/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-unknown-uefi"><a class="header" href="#-unknown-uefi"><code>*-unknown-uefi</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>Unified Extensible Firmware Interface (UEFI) targets for application, driver,
and core UEFI binaries.</p>
<p>Available targets:</p>
<ul>
<li><code>aarch64-unknown-uefi</code></li>
<li><code>i686-unknown-uefi</code></li>
<li><code>x86_64-unknown-uefi</code></li>
</ul>
<h2 id="target-maintainers-93"><a class="header" href="#target-maintainers-93">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/dvdhrm">@dvdhrm</a></li>
<li><a href="https://github.com/nicholasbishop">@nicholasbishop</a></li>
<li>(for <code>aarch64-unknown-uefi</code> only) <a href="https://github.com/rust-lang/team/blob/master/teams/arm-maintainers.toml">@rust-lang/arm-maintainers</a> (<a href="mailto:rust@arm.com">rust@arm.com</a>)</li>
</ul>
<h2 id="requirements-86"><a class="header" href="#requirements-86">Requirements</a></h2>
<p>All UEFI targets can be used as <code>no-std</code> environments via cross-compilation.
Support for <code>std</code> is present, but incomplete and extremely new. <code>alloc</code> is supported if
an allocator is provided by the user or if using std. No host tools are supported.</p>
<p>The UEFI environment resembles the environment for Microsoft Windows, with some
minor differences. Therefore, cross-compiling for UEFI works with the same
tools as cross-compiling for Windows. The target binaries are PE32+ encoded,
the calling convention is different for each architecture, but matches what
Windows uses (if the architecture is supported by Windows). The special
<code>efiapi</code> Rust calling-convention chooses the right ABI for the target platform
(<code>extern "C"</code> is incorrect on Intel targets at least). The specification has an
elaborate section on the different supported calling-conventions, if more
details are desired.</p>
<p>MMX, SSE, and other FP-units are disabled by default, to allow for compilation
of core UEFI code that runs before they are set up. This can be overridden for
individual compilations via rustc command-line flags. Not all firmwares
correctly configure those units, though, so careful inspection is required.</p>
<p>As native to PE32+, binaries are position-dependent, but can be relocated at
runtime if their desired location is unavailable. The code must be statically
linked. Dynamic linking is not supported. Code is shared via UEFI interfaces,
rather than dynamic linking. Additionally, UEFI forbids running code on
anything but the boot CPU/thread, nor is interrupt-usage allowed (apart from
the timer interrupt). Device drivers are required to use polling methods.</p>
<p>UEFI uses a single address-space to run all code in. Multiple applications can
be loaded simultaneously and are dispatched via cooperative multitasking on a
single stack.</p>
<p>By default, the UEFI targets use the <code>link</code>-flavor of the LLVM linker <code>lld</code> to
link binaries into the final PE32+ file suffixed with <code>*.efi</code>. The PE subsystem
is set to <code>EFI_APPLICATION</code>, but can be modified by passing <code>/subsystem:&lt;...&gt;</code>
to the linker. Similarly, the entry-point is set to <code>efi_main</code> but can be
changed via <code>/entry:&lt;...&gt;</code>. The panic-strategy is set to <code>abort</code>,</p>
<p>The UEFI specification is available online for free:
<a href="https://uefi.org/specifications">UEFI Specification Directory</a></p>
<h2 id="building-rust-for-uefi-targets"><a class="header" href="#building-rust-for-uefi-targets">Building rust for UEFI targets</a></h2>
<p>Rust can be built for the UEFI targets by enabling them in the <code>rustc</code> build
configuration. Note that you can only build the standard libraries. The
compiler and host tools currently cannot be compiled for UEFI targets. A sample
configuration would be:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-unknown-uefi"]
</code></pre>
<h2 id="building-rust-programs-68"><a class="header" href="#building-rust-programs-68">Building Rust programs</a></h2>
<p>Starting with Rust 1.67, precompiled artifacts are provided via
<code>rustup</code>. For example, to use <code>x86_64-unknown-uefi</code>:</p>
<pre><code class="language-sh"># install cross-compile toolchain
rustup target add x86_64-unknown-uefi
# target flag may be used with any cargo or rustc command
cargo build --target x86_64-unknown-uefi
</code></pre>
<h3 id="building-a-driver"><a class="header" href="#building-a-driver">Building a driver</a></h3>
<p>There are three types of UEFI executables: application, boot service
driver, and runtime driver. All of Rust’s UEFI targets default to
producing applications. To build a driver instead, pass a
<a href="https://learn.microsoft.com/en-us/cpp/build/reference/subsystem"><code>subsystem</code></a> linker flag with a value of
<code>efi_boot_service_driver</code> or <code>efi_runtime_driver</code>.</p>
<p>Example:</p>
<pre><code class="language-toml"># In .cargo/config.toml:
[build]
rustflags = ["-C", "link-args=/subsystem:efi_runtime_driver"]
</code></pre>
<h2 id="testing-71"><a class="header" href="#testing-71">Testing</a></h2>
<p>UEFI applications can be copied into the ESP on any UEFI system and executed
via the firmware boot menu. The qemu suite allows emulating UEFI systems and
executing UEFI applications as well. See its documentation for details.</p>
<p>The <a href="https://github.com/Richard-W/uefi-run">uefi-run</a> rust tool is a simple
wrapper around <code>qemu</code> that can spawn UEFI applications in qemu. You can install
it via <code>cargo install uefi-run</code> and execute qemu applications as
<code>uefi-run ./application.efi</code>.</p>
<h2 id="cross-compilation-toolchains-and-c-code-37"><a class="header" href="#cross-compilation-toolchains-and-c-code-37">Cross-compilation toolchains and C code</a></h2>
<p>There are 3 common ways to compile native C code for UEFI targets:</p>
<ul>
<li>Use the official SDK by Intel:
<a href="https://github.com/tianocore/edk2">Tianocore/EDK2</a>. This supports a
multitude of platforms, comes with the full specification transposed into C,
lots of examples and build-system integrations. This is also the only
officially supported platform by Intel, and is used by many major firmware
implementations. Any code compiled via the SDK is compatible to rust binaries
compiled for the UEFI targets. You can link them directly into your rust
binaries, or call into each other via UEFI protocols.</li>
<li>Use the <strong>GNU-EFI</strong> suite. This approach is used by many UEFI applications
in the Linux/OSS ecosystem. The GCC compiler is used to compile ELF binaries,
and linked with a pre-loader that converts the ELF binary to PE32+
<strong>at runtime</strong>. You can combine such binaries with the rust UEFI targets only
via UEFI protocols. Linking both into the same executable will fail, since
one is an ELF executable, and one a PE32+. If linking to <strong>GNU-EFI</strong>
executables is desired, you must compile your rust code natively for the same
GNU target as <strong>GNU-EFI</strong> and use their pre-loader. This requires careful
consideration about which calling-convention to use when calling into native
UEFI protocols, or calling into linked <strong>GNU-EFI</strong> code (similar to how these
differences need to be accounted for when writing <strong>GNU-EFI</strong> C code).</li>
<li>Use native Windows targets. This means compiling your C code for the Windows
platform as if it was the UEFI platform. This works for static libraries, but
needs adjustments when linking into an UEFI executable. You can, however,
link such static libraries seamlessly into rust code compiled for UEFI
targets. Be wary of any includes that are not specifically suitable for UEFI
targets (especially the C standard library includes are not always
compatible). Freestanding compilations are recommended to avoid
incompatibilities.</li>
</ul>
<h2 id="ecosystem"><a class="header" href="#ecosystem">Ecosystem</a></h2>
<p>The rust language has a long history of supporting UEFI targets. Many crates
have been developed to provide access to UEFI protocols and make UEFI
programming more ergonomic in rust. The following list is a short overview (in
alphabetical ordering):</p>
<ul>
<li><strong><a href="https://github.com/gurry/efi">efi</a></strong>: <em>Ergonomic Rust bindings for writing UEFI applications</em>. Provides
<em>rustified</em> access to UEFI protocols, implements allocators and a safe
environment to write UEFI applications.</li>
<li><strong><a href="https://github.com/r-efi/r-efi">r-efi</a></strong>: <em>UEFI Reference Specification Protocol Constants and Definitions</em>.
A pure transpose of the UEFI specification into rust. This provides the raw
definitions from the specification, without any extended helpers or
<em>rustification</em>. It serves as baseline to implement any more elaborate rust
UEFI layers.</li>
<li><strong><a href="https://github.com/rust-osdev/uefi-rs">uefi-rs</a></strong>: <em>Safe and easy-to-use wrapper for building UEFI apps</em>. An
elaborate library providing safe abstractions for UEFI protocols and
features. It implements allocators and provides an execution environment to
UEFI applications written in rust.</li>
<li><strong><a href="https://github.com/Richard-W/uefi-run">uefi-run</a></strong>: <em>Run UEFI applications</em>. A small wrapper around <em>qemu</em> to spawn
UEFI applications in an emulated <code>x86_64</code> machine.</li>
</ul>
<h2 id="example-freestanding"><a class="header" href="#example-freestanding">Example: Freestanding</a></h2>
<p>The following code is a valid UEFI application returning immediately upon
execution with an exit code of 0. A panic handler is provided. This is executed
by rust on panic. For simplicity, we simply end up in an infinite loop.</p>
<p>This example can be compiled as binary crate via <code>cargo</code>:</p>
<pre><code class="language-sh">cargo build --target x86_64-unknown-uefi
</code></pre>
<pre><code class="language-rust ignore (platform-specific eh-personality-is-unstable)">#![no_main]
#![no_std]

#[panic_handler]
fn panic_handler(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}

#[export_name = "efi_main"]
pub extern "C" fn main(_h: *mut core::ffi::c_void, _st: *mut core::ffi::c_void) -&gt; usize {
    0
}</code></pre>
<h2 id="example-hello-world"><a class="header" href="#example-hello-world">Example: Hello World</a></h2>
<p>This is an example UEFI application that prints “Hello World!”, then waits for
key input before it exits. It serves as base example how to write UEFI
applications without any helper modules other than the standalone UEFI protocol
definitions provided by the <code>r-efi</code> crate.</p>
<p>This extends the “Freestanding” example and builds upon its setup. See there
for instruction how to compile this as binary crate.</p>
<p>Note that UEFI uses UTF-16 strings. Since rust literals are UTF-8, we have to
use an open-coded, zero-terminated, UTF-16 array as argument to
<code>output_string()</code>. Similarly to the panic handler, real applications should
rather use UTF-16 modules.</p>
<pre><code class="language-rust ignore (platform-specific eh-personality-is-unstable)">#![no_main]
#![no_std]

use r_efi::efi;

#[panic_handler]
fn panic_handler(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}

#[export_name = "efi_main"]
pub extern "C" fn main(_h: efi::Handle, st: *mut efi::SystemTable) -&gt; efi::Status {
    let s = [
        0x0048u16, 0x0065u16, 0x006cu16, 0x006cu16, 0x006fu16, // "Hello"
        0x0020u16, //                                             " "
        0x0057u16, 0x006fu16, 0x0072u16, 0x006cu16, 0x0064u16, // "World"
        0x0021u16, //                                             "!"
        0x000au16, //                                             "\n"
        0x0000u16, //                                             NUL
    ];

    // Print "Hello World!".
    let r =
        unsafe { ((*(*st).con_out).output_string)((*st).con_out, s.as_ptr() as *mut efi::Char16) };
    if r.is_error() {
        return r;
    }

    // Wait for key input, by waiting on the `wait_for_key` event hook.
    let r = unsafe {
        let mut x: usize = 0;
        ((*(*st).boot_services).wait_for_event)(1, &amp;mut (*(*st).con_in).wait_for_key, &amp;mut x)
    };
    if r.is_error() {
        return r;
    }

    efi::Status::SUCCESS
}</code></pre>
<h2 id="rust-std-for-uefi"><a class="header" href="#rust-std-for-uefi">Rust std for UEFI</a></h2>
<p>This section contains information on how to use std on UEFI.</p>
<h3 id="build-std"><a class="header" href="#build-std">Build std</a></h3>
<p>The building std part is pretty much the same as the official <a href="https://rustc-dev-guide.rust-lang.org/getting-started.html">docs</a>.
The linker that should be used is <code>rust-lld</code>. Here is a sample <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[rust]
lld = true
</code></pre>
<p>Then just build using <code>x.py</code>:</p>
<pre><code class="language-sh">./x.py build --target x86_64-unknown-uefi --stage 1
</code></pre>
<p>Alternatively, it is possible to use the <code>build-std</code> feature. However, you must use a toolchain which has the UEFI std patches.
Then just build the project using the following command:</p>
<pre><code class="language-sh">cargo build --target x86_64-unknown-uefi -Zbuild-std=std,panic_abort
</code></pre>
<h3 id="implemented-features"><a class="header" href="#implemented-features">Implemented features</a></h3>
<h4 id="alloc"><a class="header" href="#alloc">alloc</a></h4>
<ul>
<li>Implemented using <code>EFI_BOOT_SERVICES.AllocatePool()</code> and <code>EFI_BOOT_SERVICES.FreePool()</code>.</li>
<li>Passes all the tests.</li>
<li>Currently uses <code>EfiLoaderData</code> as the <code>EFI_ALLOCATE_POOL-&gt;PoolType</code>.</li>
</ul>
<h4 id="cmath"><a class="header" href="#cmath">cmath</a></h4>
<ul>
<li>Provided by compiler-builtins.</li>
</ul>
<h4 id="env"><a class="header" href="#env">env</a></h4>
<ul>
<li>Just some global constants.</li>
</ul>
<h4 id="locks"><a class="header" href="#locks">locks</a></h4>
<ul>
<li>The provided locks should work on all standard single-threaded UEFI implementations.</li>
</ul>
<h4 id="os_str"><a class="header" href="#os_str">os_str</a></h4>
<ul>
<li>While the strings in UEFI should be valid UCS-2, in practice, many implementations just do not care and use UTF-16 strings.</li>
<li>Thus, the current implementation supports full UTF-16 strings.</li>
</ul>
<h4 id="stdio"><a class="header" href="#stdio">stdio</a></h4>
<ul>
<li>Uses <code>Simple Text Input Protocol</code> and <code>Simple Text Output Protocol</code>.</li>
<li>Note: UEFI uses CRLF for new line. This means Enter key is registered as CR instead of LF.</li>
</ul>
<h4 id="args"><a class="header" href="#args">args</a></h4>
<ul>
<li>Uses <code>EFI_LOADED_IMAGE_PROTOCOL-&gt;LoadOptions</code></li>
</ul>
<h2 id="example-hello-world-with-std"><a class="header" href="#example-hello-world-with-std">Example: Hello World With std</a></h2>
<p>The following code features a valid UEFI application, including <code>stdio</code> and <code>alloc</code> (<code>OsString</code> and <code>Vec</code>):</p>
<p>This example can be compiled as binary crate via <code>cargo</code> using the toolchain
compiled from the above source (named custom):</p>
<pre><code class="language-sh">cargo +custom build --target x86_64-unknown-uefi
</code></pre>
<pre><code class="language-rust ignore (platform-specific)">#![feature(uefi_std)]

use r_efi::{efi, protocols::simple_text_output};
use std::{
  ffi::OsString,
  os::uefi::{env, ffi::OsStrExt}
};

pub fn main() {
  println!("Starting Rust Application...");

  // Use System Table Directly
  let st = env::system_table().as_ptr() as *mut efi::SystemTable;
  let mut s: Vec&lt;u16&gt; = OsString::from("Hello World!\n").encode_wide().collect();
  s.push(0);
  let r =
      unsafe {
        let con_out: *mut simple_text_output::Protocol = (*st).con_out;
        let output_string: extern "efiapi" fn(_: *mut simple_text_output::Protocol, *mut u16) -&gt; efi::Status = (*con_out).output_string;
        output_string(con_out, s.as_ptr() as *mut efi::Char16)
      };
  assert!(!r.is_error())
}</code></pre>
<h3 id="bootservices"><a class="header" href="#bootservices">BootServices</a></h3>
<p>The current implementation of std makes <code>BootServices</code> unavailable once <code>ExitBootServices</code> is called. Refer to <a href="https://edk2-docs.gitbook.io/edk-ii-uefi-driver-writer-s-guide/7_driver_entry_point/711_runtime_drivers">Runtime Drivers</a> for more information regarding how to handle switching from using physical addresses to using virtual addresses.</p>
<p>Note: It should be noted that it is up to the user to drop all allocated memory before <code>ExitBootServices</code> is called.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-pc-windows-msvc"><a class="header" href="#-pc-windows-msvc"><code>*-pc-windows-msvc</code></a></h1>
<p>Windows MSVC targets.</p>
<p><strong>Tier 1 with host tools:</strong></p>
<ul>
<li><code>aarch64-pc-windows-msvc</code>: Windows on ARM64.</li>
<li><code>i686-pc-windows-msvc</code>: Windows on 32-bit x86.</li>
<li><code>x86_64-pc-windows-msvc</code>: Windows on 64-bit x86.</li>
</ul>
<h2 id="target-maintainers-94"><a class="header" href="#target-maintainers-94">Target maintainers</a></h2>
<p><a href="https://github.com/ChrisDenton">@ChrisDenton</a>
<a href="https://github.com/dpaoliello">@dpaoliello</a>
<a href="https://github.com/Fulgen301">@Fulgen301</a>
<a href="https://github.com/lambdageek">@lambdageek</a>
<a href="https://github.com/sivadeilra">@sivadeilra</a>
<a href="https://github.com/wesleywiser">@wesleywiser</a></p>
<h2 id="requirements-87"><a class="header" href="#requirements-87">Requirements</a></h2>
<h3 id="os-version-7"><a class="header" href="#os-version-7">OS version</a></h3>
<p>Windows 10 or higher is required for client installs, Windows Server 2016 or higher is required for server installs.</p>
<h3 id="host-tooling-1"><a class="header" href="#host-tooling-1">Host tooling</a></h3>
<p>The minimum supported Visual Studio version is 2017 but this support is not actively tested in CI.
It is <strong>highly</strong> recommended to use the latest version of VS (currently VS 2022).</p>
<h3 id="platform-details"><a class="header" href="#platform-details">Platform details</a></h3>
<p>These targets fully implement the Rust standard library.</p>
<p>The <code>extern "C"</code> calling convention conforms to Microsoft’s default calling convention for the given architecture: <a href="https://learn.microsoft.com/en-us/cpp/cpp/cdecl?view=msvc-170"><code>__cdecl</code></a> on <code>i686</code>, <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170"><code>x64</code></a> on <code>x86_64</code> and <a href="https://learn.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=msvc-170"><code>ARM64</code></a> on <code>aarch64</code>.</p>
<p>The <code>*-windows-msvc</code> targets produce PE/COFF binaries with CodeView debuginfo, the native formats used on Windows.</p>
<h2 id="building-rust-programs-69"><a class="header" href="#building-rust-programs-69">Building Rust programs</a></h2>
<p>These targets are distributed via <code>rustup</code> and can be installed via <code>rustup component add [--toolchain {name}] {target}</code>.</p>
<p>For example, adding the 32-bit x86 target to the <code>nightly</code> toolchain:</p>
<pre><code class="language-text">rustup component add --toolchain nightly i686-pc-windows-msvc
</code></pre>
<p>or adding the ARM64 target to the active toolchain:</p>
<pre><code class="language-text">rustup component add aarch64-pc-windows-msvc
</code></pre>
<h2 id="testing-72"><a class="header" href="#testing-72">Testing</a></h2>
<p>There are no special requirements for testing and running this target.</p>
<h2 id="cross-compilation-toolchains-and-c-code-38"><a class="header" href="#cross-compilation-toolchains-and-c-code-38">Cross-compilation toolchains and C code</a></h2>
<p>Architectural cross-compilation from one Windows host to a different Windows platform is natively supported by the MSVC toolchain provided the appropriate components are selected when using the VS Installer.</p>
<p>Cross-compilation from a non-Windows host to a <code>*-windows-msvc</code> target <em>may</em> be possible but is not supported.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64-uwp-windows-msvc-i686-uwp-windows-msvc-thumbv7a-uwp-windows-msvc-and-aarch64-uwp-windows-msvc"><a class="header" href="#x86_64-uwp-windows-msvc-i686-uwp-windows-msvc-thumbv7a-uwp-windows-msvc-and-aarch64-uwp-windows-msvc"><code>x86_64-uwp-windows-msvc</code>, <code>i686-uwp-windows-msvc</code>, <code>thumbv7a-uwp-windows-msvc</code> and <code>aarch64-uwp-windows-msvc</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Windows targets for Universal Windows Platform (UWP) applications, using MSVC toolchain.</p>
<h2 id="target-maintainers-95"><a class="header" href="#target-maintainers-95">Target maintainers</a></h2>
<p><a href="https://github.com/bdbai">@bdbai</a></p>
<h2 id="requirements-88"><a class="header" href="#requirements-88">Requirements</a></h2>
<p>These targets are cross-compiled with std support. The host requirement and
binary format are the same as the corresponding non-UWP targets (i.e.
<code>x86_64-pc-windows-msvc</code>, <code>i686-pc-windows-msvc</code>, <code>thumbv7a-pc-windows-msvc</code>
and <code>aarch64-pc-windows-msvc</code>).</p>
<h2 id="building-the-targets-1"><a class="header" href="#building-the-targets-1">Building the targets</a></h2>
<p>The targets can be built by enabling them for a <code>rustc</code> build, for example:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-uwp-windows-msvc", "aarch64-uwp-windows-msvc"]
</code></pre>
<h2 id="building-rust-programs-70"><a class="header" href="#building-rust-programs-70">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for these targets. To compile for
these targets, you will either need to build Rust with the targets enabled (see
“Building the targets” above), or build your own copy of <code>std</code> by using
<code>build-std</code> or similar.</p>
<p>Example of building a Rust project for x64 UWP using <code>build-std</code>:</p>
<pre><code class="language-pwsh">cargo build -Z build-std=std,panic_abort --target x86_64-uwp-windows-msvc
</code></pre>
<h2 id="testing-73"><a class="header" href="#testing-73">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="cross-compilation-toolchains-and-c-code-39"><a class="header" href="#cross-compilation-toolchains-and-c-code-39">Cross-compilation toolchains and C code</a></h2>
<p>In general, the toolchain target should match the corresponding non-UWP
targets. Beware that not all Win32 APIs behave the same way in UWP, and some
are restricted in <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/appcontainer-for-legacy-applications-">AppContainer</a>
or even not available at all. If the C code being compiled happens to use any
of restricted or unavailable APIs, consider using allowed alternatives or
disable certain feature sets to avoid using them.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-wrs-vxworks"><a class="header" href="#-wrs-vxworks"><code>*-wrs-vxworks</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Targets for the VxWorks operating
system.</p>
<p>Target triplets available:</p>
<ul>
<li><code>x86_64-wrs-vxworks</code></li>
<li><code>aarch64-wrs-vxworks</code></li>
<li><code>i686-wrs-vxworks</code></li>
<li><code>armv7-wrs-vxworks-eabihf</code></li>
<li><code>powerpc-wrs-vxworks</code></li>
<li><code>powerpc64-wrs-vxworks</code></li>
<li><code>powerpc-wrs-vxworks-spe</code></li>
<li><code>riscv32-wrs-vxworks</code></li>
<li><code>riscv64-wrs-vxworks</code></li>
</ul>
<h2 id="target-maintainers-96"><a class="header" href="#target-maintainers-96">Target maintainers</a></h2>
<p><a href="https://github.com/biabbas">@biabbas</a>
<a href="https://github.com/hax0kartik">@hax0kartik</a></p>
<h2 id="requirements-89"><a class="header" href="#requirements-89">Requirements</a></h2>
<h3 id="os-version-8"><a class="header" href="#os-version-8">OS version</a></h3>
<p>The minimum supported version is VxWorks 7.</p>
<h2 id="building-12"><a class="header" href="#building-12">Building</a></h2>
<p>Rust for each target can be cross-compiled with its specific target vsb configuration. Std support is added but not yet fully tested.</p>
<h2 id="building-the-target-60"><a class="header" href="#building-the-target-60">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the <code>target</code> list in <code>bootstrap.toml</code>. In addition the workbench and wr-cc have to configured and activated.</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = [
    "&lt;HOST_TARGET&gt;",
    "x86_64-wrs-vxworks",
    "aarch64-wrs-vxworks",
    "i686-wrs-vxworks",
    "armv7-wrs-vxworks-eabihf",
    "powerpc-wrs-vxworks",
    "powerpc64-wrs-vxworks",
    "powerpc-wrs-vxworks-spe",
]
</code></pre>
<h2 id="building-rust-programs-71"><a class="header" href="#building-rust-programs-71">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for VxWorks.</p>
<p>The easiest way to build and test programs for VxWorks is to use the shipped rustc and cargo in VxWorks workbench, following the official windriver guidelines.</p>
<h2 id="cross-compilation-toolchains-and-c-code-40"><a class="header" href="#cross-compilation-toolchains-and-c-code-40">Cross-compilation toolchains and C code</a></h2>
<p>The target supports C code. Pre-compiled C toolchains can be found in provided VxWorks workbench.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32-wasip1"><a class="header" href="#wasm32-wasip1"><code>wasm32-wasip1</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>The <code>wasm32-wasip1</code> target is a WebAssembly compilation target which
assumes that the <a href="https://github.com/WebAssembly/WASI/tree/main/legacy/preview1">WASIp1</a> (aka “WASI preview1”) set of “syscalls” are available
for use in the standard library. This target explicitly supports interop with
non-Rust code such as C and C++.</p>
<p>The <a href="https://github.com/WebAssembly/WASI/tree/main/legacy/preview1">WASIp1</a> set of syscalls is standard insofar as it was written down once by
a set of folks and has not changed since then. Additionally the <a href="https://github.com/WebAssembly/WASI/tree/main/legacy/preview1">WASIp1</a>
syscalls have been adapted and adopted into a number of runtimes and embeddings.
It is not standard in the sense that there are no formal semantics for each
syscall and APIs are no longer receiving any maintenance (e.g. no new APIs, no
new documentation, etc). After <a href="https://github.com/WebAssembly/WASI/tree/main/legacy/preview1">WASIp1</a> was originally developed in 2019 the
WASI standard effort has since been “rebased” on top of the <a href="https://github.com/webassembly/component-model">Component Model</a>.
This was a large change to the WASI specification and was released as 0.2.0
(“WASIp2” colloquially) in January 2024. Current standardization efforts are
focused on the Component Model-based definition of WASI. At this point the
<code>wasm32-wasip1</code> Rust target is intended for historical compatibility with
<a href="https://github.com/WebAssembly/WASI/tree/main/legacy/preview1">WASIp1</a> set of syscalls.</p>
<p>Today the <code>wasm32-wasip1</code> target will generate core WebAssembly modules
which will import functions from the <code>wasi_snapshot_preview1</code> module for
OS-related functionality (e.g. printing).</p>
<blockquote>
<p><strong>Note</strong>: Prior to March 2024 this target was known as <code>wasm32-wasi</code> with some
historical context found in old MCPs:</p>
<ul>
<li><a href="https://github.com/rust-lang/compiler-team/issues/607">Rename wasm32-wasi target to wasm32-wasip1</a></li>
<li><a href="https://github.com/rust-lang/compiler-team/issues/695">Smooth the renaming transition of wasm32-wasi</a></li>
</ul>
</blockquote>
<h2 id="target-maintainers-97"><a class="header" href="#target-maintainers-97">Target maintainers</a></h2>
<p>When this target was added to the compiler platform-specific documentation here
was not maintained at that time. This means that the list below is not
exhaustive and there are more interested parties in this target. That being
said since when this document was last updated those interested in maintaining
this target are:</p>
<p><a href="https://github.com/alexcrichton">@alexcrichton</a>
<a href="https://github.com/loganek">@loganek</a></p>
<h2 id="requirements-90"><a class="header" href="#requirements-90">Requirements</a></h2>
<p>This target is cross-compiled. The target includes support for <code>std</code> itself,
but not all of the standard library works. For example spawning a thread will
always return an error (see the <code>wasm32-wasip1-threads</code> target for
example). Another example is that spawning a process will always return an
error. Operations such as opening a file, however, will be implemented by
calling WASI-defined APIs.</p>
<p>The WASI targets for Rust are explicitly intended to interoperate with other
languages compiled to WebAssembly, for example C/C++. Any ABI differences or
mismatches are considered bugs that need to be fixed.</p>
<p>By default the WASI targets in Rust ship in rustup with a precompiled copy of
<a href="https://github.com/WebAssembly/wasi-libc"><code>wasi-libc</code></a> meaning that a WebAssembly-targeting-Clang is not required to
use the WASI targets from Rust.  If there is no actual interoperation with C
then <code>rustup target add wasm32-wasip1</code> is all that’s needed to get
started with WASI.</p>
<p>Note that this behavior can be controlled with <code>-Clinker</code> and
<code>-Clink-self-contained</code>, however. By specifying <code>clang</code> as a linker and
disabling the <code>link-self-contained</code> option an external version of <code>libc.a</code> can
be used instead.</p>
<h2 id="building-the-target-61"><a class="header" href="#building-the-target-61">Building the target</a></h2>
<p>To build this target first acquire a copy of
<a href="https://github.com/WebAssembly/wasi-sdk/"><code>wasi-sdk</code></a>. At this time version 22
is the minimum needed.</p>
<p>Next configure the <code>WASI_SDK_PATH</code> environment variable to point to where this
is installed. For example:</p>
<pre><code class="language-text">export WASI_SDK_PATH=/path/to/wasi-sdk-22.0
</code></pre>
<p>Next be sure to enable LLD when building Rust from source as LLVM’s <code>wasm-ld</code>
driver for LLD is required when linking WebAssembly code together. Rust’s build
system will automatically pick up any necessary binaries and programs from
<code>WASI_SDK_PATH</code>.</p>
<h2 id="building-rust-programs-72"><a class="header" href="#building-rust-programs-72">Building Rust programs</a></h2>
<p>The <code>wasm32-wasip1</code> target is shipped with rustup so users can install
the target with:</p>
<pre><code class="language-text">rustup target add wasm32-wasip1
</code></pre>
<p>Rust programs can be built for that target:</p>
<pre><code class="language-text">rustc --target wasm32-wasip1 your-code.rs
</code></pre>
<h2 id="cross-compilation-21"><a class="header" href="#cross-compilation-21">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any hosts.</p>
<h2 id="testing-74"><a class="header" href="#testing-74">Testing</a></h2>
<p>This target is tested in rust-lang/rust CI on all merges. A subset of tests are
run in the <code>test-various</code> builder such as the UI tests and libcore tests. This
can be tested locally, for example, with:</p>
<pre><code class="language-text">./x.py test --target wasm32-wasip1 tests/ui
</code></pre>
<h2 id="conditionally-compiling-code"><a class="header" href="#conditionally-compiling-code">Conditionally compiling code</a></h2>
<p>It’s recommended to conditionally compile code for this target with:</p>
<pre><code class="language-text">#[cfg(all(target_os = "wasi", target_env = "p1"))]
</code></pre>
<p>Note that the <code>target_env = "p1"</code> condition first appeared in Rust 1.80. Prior
to Rust 1.80 the <code>target_env</code> condition was not set.</p>
<h2 id="enabled-webassembly-features"><a class="header" href="#enabled-webassembly-features">Enabled WebAssembly features</a></h2>
<p>The default set of WebAssembly features enabled for compilation is currently the
same as <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a>. See the
documentation there for more information.</p>
<h2 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h2>
<p>This target is compiled with <code>-Cpanic=abort</code> by default. For information on
using <code>-Cpanic=unwind</code> see the <a href="#unwinding-2">documentation about unwinding for
<code>wasm32-unknown-unknown</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32-wasip1-threads"><a class="header" href="#wasm32-wasip1-threads"><code>wasm32-wasip1-threads</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>The <code>wasm32-wasip1-threads</code> target is a new and still (as of July 2023) an
experimental target. This target is an extension to <code>wasm32-wasip1</code> target,
originally known as <code>wasm32-wasi</code>. It extends the original target with a
standardized set of syscalls that are intended to empower WebAssembly binaries
with native multi threading capabilities.</p>
<blockquote>
<p><strong>Note</strong>: Prior to March 2024 this target was known as
<code>wasm32-wasi-preview1-threads</code>, and even longer before that it was known as
<code>wasm32-wasi-threads</code>.</p>
</blockquote>
<h2 id="target-maintainers-98"><a class="header" href="#target-maintainers-98">Target maintainers</a></h2>
<p><a href="https://github.com/g0djan">@g0djan</a>
<a href="https://github.com/alexcrichton">@alexcrichton</a>
<a href="https://github.com/abrown">@abrown</a>
<a href="https://github.com/loganek">@loganek</a></p>
<h2 id="requirements-91"><a class="header" href="#requirements-91">Requirements</a></h2>
<p>This target is cross-compiled. The target supports <code>std</code> fully.</p>
<p>The Rust target definition here is interesting in a few ways. We want to
serve two use cases here with this target:</p>
<ul>
<li>First, we want Rust usage of the target to be as hassle-free as possible,
ideally avoiding the need to configure and install a local wasm32-wasip1-threads
toolchain.</li>
<li>Second, one of the primary use cases of LLVM’s new wasm backend and the
wasm support in LLD is that any compiled language can interoperate with
any other. The <code>wasm32-wasip1-threads</code> target is the first with a viable C
standard library and sysroot common definition, so we want Rust and C/C++
code to interoperate when compiled to <code>wasm32-unknown-unknown</code>.</li>
</ul>
<p>You’ll note, however, that the two goals above are somewhat at odds with one
another. To attempt to solve both use cases in one go we define a target
that (ab)uses the <code>crt-static</code> target feature to indicate which one you’re
in.</p>
<h3 id="no-interop-with-c-required"><a class="header" href="#no-interop-with-c-required">No interop with C required</a></h3>
<p>By default the <code>crt-static</code> target feature is enabled, and when enabled
this means that the bundled version of <code>libc.a</code> found in <code>liblibc.rlib</code>
is used. This isn’t intended really for interoperation with a C because it
may be the case that Rust’s bundled C library is incompatible with a
foreign-compiled C library. In this use case, though, we use <code>rust-lld</code> and
some copied crt startup object files to ensure that you can download the
wasi target for Rust and you’re off to the races, no further configuration
necessary.
All in all, by default, no external dependencies are required. You can
compile <code>wasm32-wasip1-threads</code> binaries straight out of the box. You can’t, however,
reliably interoperate with C code in this mode (yet).</p>
<h3 id="interop-with-c-required"><a class="header" href="#interop-with-c-required">Interop with C required</a></h3>
<p>For the second goal we repurpose the <code>target-feature</code> flag, meaning that
you’ll need to do a few things to have C/Rust code interoperate.</p>
<ol>
<li>All Rust code needs to be compiled with <code>-C target-feature=-crt-static</code>,
indicating that the bundled C standard library in the Rust sysroot will
not be used.</li>
<li>If you’re using rustc to build a linked artifact then you’ll need to
specify <code>-C linker</code> to a <code>clang</code> binary that supports
<code>wasm32-wasip1-threads</code> and is configured with the <code>wasm32-wasip1-threads</code> sysroot. This
will cause Rust code to be linked against the libc.a that the specified
<code>clang</code> provides.</li>
<li>If you’re building a staticlib and integrating Rust code elsewhere, then
compiling with <code>-C target-feature=-crt-static</code> is all you need to do.</li>
</ol>
<p>All in all, by default, no external dependencies are required. You can
compile <code>wasm32-wasip1-threads</code> binaries straight out of the box. You can’t, however,
reliably interoperate with C code in this mode (yet).</p>
<p>Also note that at this time the <code>wasm32-wasip1-threads</code> target assumes the
presence of other merged wasm proposals such as (with their LLVM feature flags):</p>
<ul>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/bulk-memory-operations/Overview.md">Bulk memory</a> - <code>+bulk-memory</code></li>
<li>Mutable imported globals - <code>+mutable-globals</code></li>
<li>Atomics - <code>+atomics</code></li>
</ul>
<p>LLVM 16 is required for this target. The reason is related to linker flags: prior to LLVM 16, –import-memory and –export-memory were not allowed together. The reason both are needed is an artifact of how WASI currently does things; see https://github.com/WebAssembly/WASI/issues/502 for more details.</p>
<p>The target intends to match the corresponding Clang target for its <code>"C"</code> ABI.</p>
<blockquote>
<p><strong>Note</strong>: due to the relatively early-days nature of this target when working
with this target you may encounter LLVM bugs. If an assertion hit or a bug is
found it’s recommended to open an issue either with rust-lang/rust or ideally
with LLVM itself.</p>
</blockquote>
<h2 id="platform-requirements"><a class="header" href="#platform-requirements">Platform requirements</a></h2>
<p>The runtime should support the same set of APIs as any other supported wasi target for interacting with the host environment through the WASI standard. The runtime also should have implementation of <a href="https://github.com/WebAssembly/wasi-threads">wasi-threads proposal</a>.</p>
<p>This target is not a stable target. This means that there are a few engines
which implement the <code>wasi-threads</code> feature and if they do they’re likely behind a
flag, for example:</p>
<ul>
<li>Wasmtime - <code>--wasi threads</code></li>
<li><a href="https://github.com/bytecodealliance/wasm-micro-runtime">WAMR</a> - needs to be built with WAMR_BUILD_LIB_WASI_THREADS=1</li>
</ul>
<h2 id="building-the-target-62"><a class="header" href="#building-the-target-62">Building the target</a></h2>
<p>Users need to install or built wasi-sdk since release 20.0
https://github.com/WebAssembly/wasi-sdk/releases/tag/wasi-sdk-20
and specify path to <em>wasi-root</em> <code>bootstrap.toml</code></p>
<pre><code class="language-toml">[target.wasm32-wasip1-threads]
wasi-root = ".../wasi-libc/sysroot"
</code></pre>
<p>After that users can build this by adding it to the <code>target</code> list in
<code>bootstrap.toml</code>, or with <code>-Zbuild-std</code>.</p>
<h2 id="building-rust-programs-73"><a class="header" href="#building-rust-programs-73">Building Rust programs</a></h2>
<p>From Rust Nightly 1.71.1 (2023-08-03) on the artifacts are shipped pre-compiled:</p>
<pre><code class="language-text">rustup target add wasm32-wasip1-threads --toolchain nightly
</code></pre>
<p>Rust programs can be built for that target:</p>
<pre><code class="language-text">rustc --target wasm32-wasip1-threads your-code.rs
</code></pre>
<h2 id="cross-compilation-22"><a class="header" href="#cross-compilation-22">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any hosts.</p>
<h2 id="testing-75"><a class="header" href="#testing-75">Testing</a></h2>
<p>Currently testing is not well supported for <code>wasm32-wasip1-threads</code> and the
Rust project doesn’t run any tests for this target. However the UI testsuite can be run
manually following this instructions:</p>
<ol start="0">
<li>Ensure <a href="https://github.com/bytecodealliance/wasm-micro-runtime">wamr</a>, <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a>
or another engine that supports <code>wasi-threads</code> is installed and can be found in the <code>$PATH</code> env variable.</li>
<li>Clone master branch.</li>
<li>Apply such <a href="https://github.com/g0djan/rust/compare/godjan/wasi-threads...g0djan:rust:godjan/wasi-run-ui-tests?expand=1">a change</a> with an engine from the step 1.</li>
<li>Run <code>./x.py test --target wasm32-wasip1-threads tests/ui</code> and save the list of failed tests.</li>
<li>Checkout branch with your changes.</li>
<li>Apply such <a href="https://github.com/g0djan/rust/compare/godjan/wasi-threads...g0djan:rust:godjan/wasi-run-ui-tests?expand=1">a change</a> with an engine from the step 1.</li>
<li>Run <code>./x.py test --target wasm32-wasip1-threads tests/ui</code> and save the list of failed tests.</li>
<li>For both lists of failed tests run <code>cat list | sort &gt; sorted_list</code> and compare it with <code>diff sorted_list1 sorted_list2</code>.</li>
</ol>
<h2 id="conditionally-compiling-code-1"><a class="header" href="#conditionally-compiling-code-1">Conditionally compiling code</a></h2>
<p>It’s recommended to conditionally compile code for this target with:</p>
<pre><code class="language-text">#[cfg(all(target_os = "wasi", target_env = "p1", target_feature = "atomics"))]
</code></pre>
<p>Prior to Rust 1.80 the <code>target_env = "p1"</code> key was not set. Currently the
<code>target_feature = "atomics"</code> is Nightly-only. Note that the precise <code>#[cfg]</code>
necessary to detect this target may change as the target becomes more stable.</p>
<h2 id="enabled-webassembly-features-1"><a class="header" href="#enabled-webassembly-features-1">Enabled WebAssembly features</a></h2>
<p>The default set of WebAssembly features enabled for compilation includes two
more features in addition to that which
<a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a> enables:</p>
<ul>
<li><code>bulk-memory</code></li>
<li><code>atomics</code></li>
</ul>
<p>For more information about features see the documentation for
<a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a>, but note that the
<code>mvp</code> CPU in LLVM does not support this target as it’s required that
<code>bulk-memory</code>, <code>atomics</code>, and <code>mutable-globals</code> are all enabled.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32-wasip2"><a class="header" href="#wasm32-wasip2"><code>wasm32-wasip2</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>The <code>wasm32-wasip2</code> target is a new and still (as of January 2024) an
experimental target. This target is an extension to <code>wasm32-wasip1</code> target,
originally known as <code>wasm32-wasi</code>. It is the next evolution in the development of
wasi (the <a href="https://wasi.dev">WebAssembly System Interface</a>) that uses the WebAssembly
<a href="https://github.com/WebAssembly/component-model">component model</a> to allow for a standardized set of syscalls that are intended to empower
WebAssembly binaries with native host capabilities.</p>
<h2 id="target-maintainers-99"><a class="header" href="#target-maintainers-99">Target maintainers</a></h2>
<p><a href="https://github.com/alexcrichton">@alexcrichton</a>
<a href="https://github.com/rylev">@rylev</a></p>
<h2 id="requirements-92"><a class="header" href="#requirements-92">Requirements</a></h2>
<p>This target is cross-compiled. The target supports <code>std</code> fully.</p>
<h2 id="platform-requirements-1"><a class="header" href="#platform-requirements-1">Platform requirements</a></h2>
<p>The WebAssembly runtime should support the wasi preview 2 API set. Runtimes also
are required to support components since this target outputs a component as
opposed to a core wasm module. As of the time of this writing Wasmtime 17 and
above is able to run this target natively with no extra flags.</p>
<h2 id="building-the-target-63"><a class="header" href="#building-the-target-63">Building the target</a></h2>
<p>To build this target first acquire a copy of
<a href="https://github.com/WebAssembly/wasi-sdk/"><code>wasi-sdk</code></a>. At this time version 22
is the minimum needed.</p>
<p>Next configure the <code>WASI_SDK_PATH</code> environment variable to point to where this
is installed. For example:</p>
<pre><code class="language-text">export WASI_SDK_PATH=/path/to/wasi-sdk-22.0
</code></pre>
<p>Next be sure to enable LLD when building Rust from source as LLVM’s <code>wasm-ld</code>
driver for LLD is required when linking WebAssembly code together. Rust’s build
system will automatically pick up any necessary binaries and programs from
<code>WASI_SDK_PATH</code>.</p>
<h2 id="testing-76"><a class="header" href="#testing-76">Testing</a></h2>
<p>This target is not tested in CI at this time. Locally it can be tested with a
<code>wasmtime</code> binary in <code>PATH</code> like so:</p>
<pre><code class="language-text">./x.py test --target wasm32-wasip2 tests/ui
</code></pre>
<h2 id="conditionally-compiling-code-2"><a class="header" href="#conditionally-compiling-code-2">Conditionally compiling code</a></h2>
<p>It’s recommended to conditionally compile code for this target with:</p>
<pre><code class="language-text">#[cfg(all(target_os = "wasi", target_env = "p2"))]
</code></pre>
<h2 id="enabled-webassembly-features-2"><a class="header" href="#enabled-webassembly-features-2">Enabled WebAssembly features</a></h2>
<p>The default set of WebAssembly features enabled for compilation is currently the
same as <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a>. See the
documentation there for more information.</p>
<h2 id="unwinding-1"><a class="header" href="#unwinding-1">Unwinding</a></h2>
<p>This target is compiled with <code>-Cpanic=abort</code> by default. For information on
using <code>-Cpanic=unwind</code> see the <a href="#unwinding-2">documentation about unwinding for
<code>wasm32-unknown-unknown</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32-wasip3"><a class="header" href="#wasm32-wasip3"><code>wasm32-wasip3</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>The <code>wasm32-wasip3</code> target is the next stage of evolution of the
<a href="#wasm32-wasip2"><code>wasm32-wasip2</code></a> target. The <code>wasm32-wasip3</code> target enables
the Rust standard library to use WASIp3 APIs to implement various pieces of
functionality. WASIp3 brings native async support over WASIp2, which integrates
well with Rust’s <code>async</code> ecosystem.</p>
<blockquote>
<p><strong>Note</strong>: As of 2025-10-01 WASIp3 has not yet been approved by the WASI
subgroup of the WebAssembly Community Group. Development is expected to
conclude in late 2025 or early 2026. Until then the Rust standard library
won’t actually use WASIp3 APIs on the <code>wasm32-wasip3</code> target as they are not
yet stable and would reduce the stability of this target. Once WASIp3 is
approved, however, the standard library will update to use WASIp3 natively.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: This target does not yet build as of 2025-10-01 due to and update
needed in the <code>libc</code> crate. Using it will require a <code>[patch]</code> for now.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: Until the standard library is fully migrated to use the <code>wasip3</code>
crate then components produced for <code>wasm32-wasip3</code> may import WASIp2 APIs.
This is considered a transitionary phase until fully support of libstd is
implemented.</p>
</blockquote>
<h2 id="target-maintainers-100"><a class="header" href="#target-maintainers-100">Target maintainers</a></h2>
<p><a href="https://github.com/alexcrichton">@alexcrichton</a></p>
<h2 id="requirements-93"><a class="header" href="#requirements-93">Requirements</a></h2>
<p>This target is cross-compiled. The target supports <code>std</code> fully.</p>
<h2 id="platform-requirements-2"><a class="header" href="#platform-requirements-2">Platform requirements</a></h2>
<p>The WebAssembly runtime should support both WASIp2 and WASIp3. Runtimes also
are required to support components since this target outputs a component as
opposed to a core wasm module. Two example runtimes for WASIp3 are <a href="https://wasmtime.dev/">Wasmtime</a>
and <a href="https://github.com/bytecodealliance/jco">Jco</a>.</p>
<h2 id="building-the-target-64"><a class="header" href="#building-the-target-64">Building the target</a></h2>
<p>To build this target first acquire a copy of
<a href="https://github.com/WebAssembly/wasi-sdk/"><code>wasi-sdk</code></a>. At this time version 22
is the minimum needed.</p>
<p>Next configure the <code>WASI_SDK_PATH</code> environment variable to point to where this
is installed. For example:</p>
<pre><code class="language-text">export WASI_SDK_PATH=/path/to/wasi-sdk-22.0
</code></pre>
<p>Next be sure to enable LLD when building Rust from source as LLVM’s <code>wasm-ld</code>
driver for LLD is required when linking WebAssembly code together. Rust’s build
system will automatically pick up any necessary binaries and programs from
<code>WASI_SDK_PATH</code>.</p>
<h2 id="testing-77"><a class="header" href="#testing-77">Testing</a></h2>
<p>This target is not tested in CI at this time. Locally it can be tested with a
<code>wasmtime</code> binary in <code>PATH</code> like so:</p>
<pre><code class="language-text">./x.py test --target wasm32-wasip3 tests/ui
</code></pre>
<h2 id="conditionally-compiling-code-3"><a class="header" href="#conditionally-compiling-code-3">Conditionally compiling code</a></h2>
<p>It’s recommended to conditionally compile code for this target with:</p>
<pre><code class="language-text">#[cfg(all(target_os = "wasi", target_env = "p3"))]
</code></pre>
<h2 id="enabled-webassembly-features-3"><a class="header" href="#enabled-webassembly-features-3">Enabled WebAssembly features</a></h2>
<p>The default set of WebAssembly features enabled for compilation is currently the
same as <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a>. See the
documentation there for more information.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32-wali-linux-"><a class="header" href="#wasm32-wali-linux-"><code>wasm32-wali-linux-*</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>WebAssembly targets that use the <a href="https://github.com/arjunr2/WALI">WebAssembly Linux Interface (WALI)</a> with 32-bit memory. The latest status of the WALI specification and support are documented within the repo.</p>
<p>WALI offers seamless targetability of traditional Linux applications to Wasm by exposing Linux syscalls strategically into the sandbox. Numerous applications and build system work unmodified over WALI, including complex low-level system libraries – a list of applications are included in the research paper linked in the main repo.</p>
<p>From the wider Wasm ecosystem perspective, implementing WALI within engines allows layering of high-level security policies (e.g. WASI) above it, arming the latter’s implementations with sandboxing and portability.</p>
<h2 id="target-maintainers-101"><a class="header" href="#target-maintainers-101">Target maintainers</a></h2>
<p><a href="https://github.com/arjunr2">@arjunr2</a></p>
<h2 id="requirements-94"><a class="header" href="#requirements-94">Requirements</a></h2>
<h3 id="compilation"><a class="header" href="#compilation">Compilation</a></h3>
<p>This target is cross-compiled and requires an installation of the <a href="https://github.com/arjunr2/WALI">WALI compiler/sysroot</a>. This produces standard <code>wasm32</code> binaries with the WALI interface methods as module imports that need to be implemented by a supported engine (see the  “Execution” section below).</p>
<p><code>wali</code> targets <em>minimally require</em> the following LLVM feature flags:</p>
<ul>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/bulk-memory-operations/Overview.md">Bulk memory</a> - <code>+bulk-memory</code></li>
<li>Mutable imported globals - <code>+mutable-globals</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/sign-extension-ops/Overview.md">Sign-extending operations</a> - <code>+sign-ext</code></li>
<li><a href="https://github.com/WebAssembly/threads/blob/main/proposals/threads/Overview.md">Threading/Atomics</a> - <code>+atomics</code></li>
</ul>
<blockquote>
<p><strong>Note</strong>: Users can expect that new enabled-by-default Wasm features for LLVM are transitively incorporatable into this target – see <a href="#wasm32-unknown-unknown">wasm32-unknown-unknown</a> for detailed information on WebAssembly features.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: The WALI ABI is similar to default Clang wasm32 ABIs but <em>not identical</em>. The primary difference is 64-bit <code>long</code> types as opposed to 32-bit for wasm32. This is required to maintain minimum source code changes for 64-bit host platforms currently supported. This may change in the future as the spec evolves.</p>
</blockquote>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>Running generated WALI binaries also requires a supported compliant engine implementation – a working implementation in the <a href="https://github.com/arjunr2/WALI">WebAssembly Micro-Runtime (WAMR)</a> is included in the repo.</p>
<blockquote>
<p><strong>Note</strong>: WALI is still somewhat experimental and bugs may exist in the Rust support, WALI toolchain, or the LLVM compiler. The former can be filed in Rust repos while the latter two in the WALI repo.</p>
</blockquote>
<h2 id="building-the-target-65"><a class="header" href="#building-the-target-65">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>config.toml</code>, and pointing to the toolchain artifacts from the previous section (“Requirements-&gt;Compilation”). A sample <code>config.toml</code> for the <code>musl</code> environment will look like this, where <code>&lt;WALI-root&gt;</code> is the absolute path to the root directory of the <a href="https://github.com/arjunr2/WALI">WALI repo</a>:</p>
<pre><code class="language-toml">[build]
target = ["wasm32-wali-linux-musl"]

[target.wasm32-wali-linux-musl]
musl-root = "&lt;WALI&gt;/wali-musl/sysroot"
llvm-config = "&lt;WALI&gt;/llvm-project/build/bin/llvm-config"
cc = "&lt;WALI&gt;/llvm-project/build/bin/clang-18"
cxx = "&lt;WALI&gt;/llvm-project/build/bin/clang-18"
ar = "&lt;WALI&gt;/llvm-project/build/bin/llvm-ar"
ranlib = "&lt;WALI&gt;/llvm-project/build/bin/llvm-ranlib"
llvm-libunwind = "system"
crt-static = true
</code></pre>
<blockquote>
<p>The <code>llvm-config</code> settings are only temporary, and the changes will eventually be upstreamed into LLVM</p>
</blockquote>
<h2 id="building-rust-programs-74"><a class="header" href="#building-rust-programs-74">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<p>Rust program builds can use this target normally. Currently, linking WALI programs may require pointing the <code>linker</code> to the llvm build in the <a href="https://doc.rust-lang.org/cargo/reference/config.html">Cargo config</a> (until LLVM is upstreamed). A <code>config.toml</code> for Cargo will look like the following:</p>
<pre><code class="language-toml">[target.wasm32-wali-linux-musl]
linker = "&lt;WALI&gt;/llvm-project/build/bin/lld"
</code></pre>
<p>Note that the following <code>cfg</code> directives are set for <code>wasm32-wali-linux-*</code>:</p>
<ul>
<li><code>cfg(target_arch = "wasm32")</code></li>
<li><code>cfg(target_family = {"wasm", "unix"})</code></li>
<li><code>cfg(target_r = "wasm")</code></li>
<li><code>cfg(target_os = "linux")</code></li>
<li><code>cfg(target_env = *)</code></li>
</ul>
<h3 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h3>
<p>Hardware or platform-specific support, besides <code>syscall</code> is mostly unsupported in WALI for ISA portability (these tend to be uncommon).</p>
<h2 id="testing-78"><a class="header" href="#testing-78">Testing</a></h2>
<p>Currently testing is not supported for <code>wali</code> targets and the Rust project doesn’t run any tests for this target.</p>
<p>However, standard ISA-agnostic tests for Linux should be thereotically reusable for WALI targets and minor changes. Testing integration will be continually incorporated as support evolves.</p>
<h2 id="cross-compilation-toolchains-and-c-code-41"><a class="header" href="#cross-compilation-toolchains-and-c-code-41">Cross-compilation toolchains and C code</a></h2>
<p>Most fully featured C code is compilable with the WALI toolchain – examples can be seen in the repo.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32-unknown-emscripten"><a class="header" href="#wasm32-unknown-emscripten"><code>wasm32-unknown-emscripten</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>The <code>wasm32-unknown-emscripten</code> target is a WebAssembly compilation target which
uses the <a href="https://emscripten.org/">Emscripten</a> compiler toolchain. Emscripten is
a C/C++ toolchain designed to make it as easy as possible to port C/C++ code
written for Linux to run on the web or in other JavaScript runtimes such as Node.
It thus provides POSIX-compatible (musl) <code>libc</code> and <code>libstd</code> implementations and
many Linux APIs, access to the OpenGL and SDL APIs, and the ability to run arbitrary
JavaScript code, all based on web APIs using JS glue code. With the
<code>wasm32-unknown-emscripten</code> target, Rust code can interoperate with Emscripten’s
ecosystem, C/C++ and JS code, and web APIs.</p>
<p>One existing user of this target is the
<a href="https://pyodide.org/"><code>pyodide</code> project</a> which provides a Python runtime in
WebAssembly using Emscripten and compiles Python extension modules written in Rust
to the <code>wasm32-unknown-emscripten</code> target.</p>
<p>If you want to generate a standalone WebAssembly binary that does not require
access to the web APIs or the Rust standard library, the
<a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a> target may be better
suited for you. However, <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a>
does not (easily) support interop with C/C++ code. Please refer to the
<a href="https://crates.io/crates/wasm-bindgen">wasm-bindgen</a> crate in case you want to
interoperate with JavaScript with this target.</p>
<p>Like Emscripten, the WASI targets <a href="#wasm32-wasip1"><code>wasm32-wasip1</code></a> and
<a href="#wasm32-wasip2"><code>wasm32-wasip2</code></a> also provide access to the host environment,
support interop with C/C++ (and other languages), and support most of the Rust
standard library. While the WASI targets are portable across different hosts
(web and non-web), WASI has no standard way of accessing web APIs, whereas
Emscripten has the ability to run arbitrary JS from WASM and access many web APIs.
If you are only targeting the web and need to access web APIs, the
<code>wasm32-unknown-emscripten</code> target may be preferable.</p>
<h2 id="target-maintainers-102"><a class="header" href="#target-maintainers-102">Target maintainers</a></h2>
<p><a href="https://github.com/hoodmane">@hoodmane</a>
<a href="https://github.com/juntyr">@juntyr</a></p>
<h2 id="requirements-95"><a class="header" href="#requirements-95">Requirements</a></h2>
<p>This target is cross-compiled. The Emscripten compiler toolchain <code>emcc</code> must be
installed to link WASM binaries for this target. You can install <code>emcc</code> using:</p>
<pre><code class="language-sh">git clone https://github.com/emscripten-core/emsdk.git --depth 1
./emsdk/emsdk install 3.1.68
./emsdk/emsdk activate 3.1.68
source ./emsdk/emsdk_env.sh
</code></pre>
<p>Please refer to <a href="https://emscripten.org/docs/getting_started/downloads.html">https://emscripten.org/docs/getting_started/downloads.html</a> for
further details and instructions.</p>
<h2 id="building-the-target-66"><a class="header" href="#building-the-target-66">Building the target</a></h2>
<p>Building this target can be done by:</p>
<ul>
<li>Configure the <code>wasm32-unknown-emscripten</code> target to get built.</li>
<li>Ensure the <code>WebAssembly</code> target backend is not disabled in LLVM.</li>
</ul>
<p>These are all controlled through <code>bootstrap.toml</code> options. It should be possible
to build this target on any platform. A minimal example configuration would be:</p>
<pre><code class="language-toml">[llvm]
targets = "WebAssembly"

[build]
build-stage = 1
target = ["wasm32-unknown-emscripten"]
</code></pre>
<h2 id="building-rust-programs-75"><a class="header" href="#building-rust-programs-75">Building Rust programs</a></h2>
<p>Rust programs can be compiled by adding this target via rustup:</p>
<pre><code class="language-sh">$ rustup target add wasm32-unknown-emscripten
</code></pre>
<p>and then compiling with the target:</p>
<pre><code class="language-sh">$ rustc foo.rs --target wasm32-unknown-emscripten
$ file foo.wasm
</code></pre>
<h2 id="cross-compilation-23"><a class="header" href="#cross-compilation-23">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="emscripten-abi-compatibility"><a class="header" href="#emscripten-abi-compatibility">Emscripten ABI Compatibility</a></h2>
<p>The Emscripten compiler toolchain does not follow a semantic versioning scheme
that clearly indicates when breaking changes to the ABI can be made.
Additionally, Emscripten offers many different ABIs even for a single version of
Emscripten depending on the linker flags used, e.g. <code>-fwasm-exceptions</code> and
<code>-sWASM_BIGINT</code>. If the ABIs do not match, your code may exhibit undefined
behaviour.</p>
<p>To ensure that the ABIs of your Rust code, of the Rust standard library, and of
other code compiled for Emscripten all match, you should rebuild the Rust standard
library with your local Emscripten version and settings using:</p>
<pre><code class="language-sh">cargo +nightly -Zbuild-std build
</code></pre>
<p>If you still want to use the pre-compiled <code>std</code> from rustup, you should ensure
that your local Emscripten matches the version used by Rust and be careful about
any <code>-C link-arg</code>s that you compiled your Rust code with.</p>
<h2 id="testing-79"><a class="header" href="#testing-79">Testing</a></h2>
<p>This target is not extensively tested in CI for the rust-lang/rust repository. It
can be tested locally, for example, with:</p>
<pre><code class="language-sh">EMCC_CFLAGS="-s MAXIMUM_MEMORY=2GB" ./x.py test --target wasm32-unknown-emscripten --skip src/tools/linkchecker
</code></pre>
<p>To run these tests, both <code>emcc</code> and <code>node</code> need to be in your <code>$PATH</code>. You can
install <code>node</code>, for example, using <code>nvm</code> by following the instructions at
<a href="https://github.com/nvm-sh/nvm#install--update-script">https://github.com/nvm-sh/nvm#install--update-script</a>.</p>
<p>If you need to test WebAssembly compatibility <em>in general</em>, it is recommended
to test the <a href="#wasm32-wasip1"><code>wasm32-wasip1</code></a> target instead.</p>
<h2 id="conditionally-compiling-code-4"><a class="header" href="#conditionally-compiling-code-4">Conditionally compiling code</a></h2>
<p>It’s recommended to conditionally compile code for this target with:</p>
<pre><code class="language-text">#[cfg(target_os = "emscripten")]
</code></pre>
<p>It may sometimes be necessary to conditionally compile code for WASM targets
which do <em>not</em> use emscripten, which can be achieved with:</p>
<pre><code class="language-text">#[cfg(all(target_family = "wasm", not(target_os = "emscripten)))]
</code></pre>
<h2 id="enabled-webassembly-features-4"><a class="header" href="#enabled-webassembly-features-4">Enabled WebAssembly features</a></h2>
<p>WebAssembly is an evolving standard which adds new features such as new
instructions over time. This target’s default set of supported WebAssembly
features will additionally change over time. The <code>wasm32-unknown-emscripten</code> target
inherits the default settings of LLVM which typically, but not necessarily, matches
the default settings of Emscripten as well. At link time, <code>emcc</code> configures the
linker to use Emscripten’s settings.</p>
<p>Please refer to the <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a>
target’s documentation on which WebAssembly features Rust enables by default, how
features can be disabled, and how Rust code can be conditionally compiled based on
which features are enabled.</p>
<p>Note that Rust code compiled for <code>wasm32-unknown-emscripten</code> currently enables
<code>-fwasm-exceptions</code> (legacy WASM exceptions) by default unless the Rust code is
compiled with <code>-Cpanic=abort</code>. It is possible to use JS exceptions by passing
the flag <code>-Z emscripten-wasm-eh=false</code> but this will be removed in the future.</p>
<p>Please refer to the <a href="#emscripten-abi-compatibility">Emscripten ABI compatibility</a>
section to ensure that the features that are enabled do not cause an ABI mismatch
between your Rust code, the pre-compiled Rust standard library, and other code compiled
for Emscripten.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32-unknown-unknown"><a class="header" href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>The <code>wasm32-unknown-unknown</code> target is a WebAssembly compilation target which
does not import any functions from the host for the standard library. This is
the “minimal” WebAssembly in the sense of making the fewest assumptions about
the host environment. This target is often used when compiling to the web or
JavaScript environments as there is no standard for what functions can be
imported on the web. This target can also be useful for creating minimal or
bare-bones WebAssembly binaries.</p>
<p>The <code>wasm32-unknown-unknown</code> target has support for the Rust standard library
but many parts of the standard library do not work and return errors. For
example <code>println!</code> does nothing, <code>std::fs</code> always return errors, and
<code>std::thread::spawn</code> will panic. There is no means by which this can be
overridden. For a WebAssembly target that more fully supports the standard
library see the <a href="#wasm32-wasip1"><code>wasm32-wasip1</code></a> or
<a href="#wasm32-wasip2"><code>wasm32-wasip2</code></a> targets.</p>
<p>The <code>wasm32-unknown-unknown</code> target has full support for the <code>core</code> and <code>alloc</code>
crates. It additionally supports the <code>HashMap</code> type in the <code>std</code> crate, although
hash maps are not randomized like they are on other platforms.</p>
<p>One existing user of this target (please feel free to edit and expand this list
too) is the <a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code> project</a>
which facilitates Rust code interoperating with JavaScript code. Note, though,
that not all uses of <code>wasm32-unknown-unknown</code> are using JavaScript and the web.</p>
<h2 id="target-maintainers-103"><a class="header" href="#target-maintainers-103">Target maintainers</a></h2>
<p>When this target was added to the compiler, platform-specific documentation here
was not maintained at that time. This means that the list below is not
exhaustive, and there are more interested parties in this target. That being
said, those interested in maintaining this target are:</p>
<p><a href="https://github.com/alexcrichton">@alexcrichton</a></p>
<h2 id="requirements-96"><a class="header" href="#requirements-96">Requirements</a></h2>
<p>This target is cross-compiled. The target includes support for <code>std</code> itself,
but as mentioned above many pieces of functionality that require an operating
system do not work and will return errors.</p>
<p>This target currently has no equivalent in C/C++. There is no C/C++ toolchain
for this target. While interop is theoretically possible it’s recommended to
instead use one of:</p>
<ul>
<li><a href="#wasm32-unknown-emscripten"><code>wasm32-unknown-emscripten</code></a> - for web-based
use cases the Emscripten toolchain is typically chosen for running C/C++.</li>
<li><a href="#wasm32-wasip1"><code>wasm32-wasip1</code></a> - the wasi-sdk toolchain is used to
compile C/C++ on this target and can interop with Rust code. WASI works on
the web so far as there’s no blocker, but an implementation of WASI APIs
must be either chosen or reimplemented.</li>
</ul>
<p>This target has no build requirements beyond what’s in-tree in the Rust
repository. Linking binaries requires LLD to be enabled for the <code>wasm-ld</code>
driver. This target uses the <code>dlmalloc</code> crate as the default global allocator.</p>
<h2 id="building-the-target-67"><a class="header" href="#building-the-target-67">Building the target</a></h2>
<p>Building this target can be done by:</p>
<ul>
<li>Configure the <code>wasm32-unknown-unknown</code> target to get built.</li>
<li>Configure LLD to be built.</li>
<li>Ensure the <code>WebAssembly</code> target backend is not disabled in LLVM.</li>
</ul>
<p>These are all controlled through <code>bootstrap.toml</code> options. It should be possible
to build this target on any platform.</p>
<h2 id="building-rust-programs-76"><a class="header" href="#building-rust-programs-76">Building Rust programs</a></h2>
<p>Rust programs can be compiled by adding this target via rustup:</p>
<pre><code class="language-sh">$ rustup target add wasm32-unknown-unknown
</code></pre>
<p>and then compiling with the target:</p>
<pre><code class="language-sh">$ rustc foo.rs --target wasm32-unknown-unknown
$ file foo.wasm
</code></pre>
<h2 id="cross-compilation-24"><a class="header" href="#cross-compilation-24">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any host.</p>
<h2 id="testing-80"><a class="header" href="#testing-80">Testing</a></h2>
<p>This target is not tested in CI for the rust-lang/rust repository. Many tests
must be disabled to run on this target and failures are non-obvious because
<code>println!</code> doesn’t work in the standard library. It’s recommended to test the
<code>wasm32-wasip1</code> target instead for WebAssembly compatibility.</p>
<h2 id="conditionally-compiling-code-5"><a class="header" href="#conditionally-compiling-code-5">Conditionally compiling code</a></h2>
<p>It’s recommended to conditionally compile code for this target with:</p>
<pre><code class="language-text">#[cfg(all(target_family = "wasm", target_os = "unknown"))]
</code></pre>
<p>Note that there is no way to tell via <code>#[cfg]</code> whether code will be running on
the web or not.</p>
<h2 id="enabled-webassembly-features-5"><a class="header" href="#enabled-webassembly-features-5">Enabled WebAssembly features</a></h2>
<p>WebAssembly is an evolving standard which adds new features such as new
instructions over time. This target’s default set of supported WebAssembly
features will additionally change over time. The <code>wasm32-unknown-unknown</code> target
inherits the default settings of LLVM which typically matches the default
settings of Emscripten as well.</p>
<p>Changes to WebAssembly go through a <a href="https://github.com/WebAssembly/proposals">proposals process</a> but reaching
the final stage (stage 5) does not automatically mean that the feature will be
enabled in LLVM and Rust by default. At this time the general guidance is that
features must be present in most engines for a “good chunk of time” before
they’re enabled in LLVM by default. There is currently no exact number of
months or engines that are required to enable features by default.</p>
<p>As of the time of this writing the proposals that are enabled by default (the
<code>generic</code> CPU in LLVM terminology) are:</p>
<ul>
<li><code>multivalue</code></li>
<li><code>mutable-globals</code></li>
<li><code>reference-types</code></li>
<li><code>sign-ext</code></li>
<li><code>nontrapping-fptoint</code> (Rust 1.87.0+, LLVM 20+)</li>
<li><code>bulk-memory</code> (Rust 1.87.0+, LLVM 20+)</li>
</ul>
<p>If you’re compiling WebAssembly code for an engine that does not support a
feature in LLVM’s default feature set then the feature must be disabled at
compile time. There are two approaches to choose from:</p>
<ul>
<li>
<p>If you are targeting a feature set no smaller than the W3C WebAssembly Core
1.0 recommendation – which is equivalent to the WebAssembly MVP plus the
<code>mutable-globals</code> feature – and you are building <code>no_std</code>, then you can
simply use the <a href="#wasm32v1-none"><code>wasm32v1-none</code> target</a> instead of
<code>wasm32-unknown-unknown</code>, which uses only those minimal features and
includes a core and alloc library built with only those minimal features.</p>
</li>
<li>
<p>Otherwise – if you need std, or if you need to target the ultra-minimal
“MVP” feature set, excluding <code>mutable-globals</code> – you will need to manually
specify <code>-Ctarget-cpu=mvp</code> and also rebuild the stdlib using that target to
ensure no features are used in the stdlib. This in turn requires use of a
nightly compiler.</p>
</li>
</ul>
<p>Compiling all code for the initial release of WebAssembly looks like:</p>
<pre><code class="language-sh">$ export RUSTFLAGS=-Ctarget-cpu=mvp
$ cargo +nightly build -Zbuild-std=panic_abort,std --target wasm32-unknown-unknown
</code></pre>
<p>Here the <code>mvp</code> “cpu” is a placeholder in LLVM for disabling all supported
features by default. Cargo’s <a href="../cargo/reference/unstable.html#build-std"><code>-Zbuild-std</code></a> feature, a Nightly Rust feature, is
then used to recompile the standard library in addition to your own code. This
will produce a binary that uses only the original WebAssembly features by
default and no proposals since its inception.</p>
<p>To enable individual features on either this target or <code>wasm32v1-none</code>, pass
arguments of the form <code>-Ctarget-feature=+foo</code>.  Available features for Rust code
itself are documented in the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#wasm32-or-wasm64">reference</a> and can also be found through:</p>
<pre><code class="language-sh">$ rustc -Ctarget-feature=help --target wasm32-unknown-unknown
</code></pre>
<p>You’ll need to consult your WebAssembly engine’s documentation to learn more
about the supported WebAssembly features the engine has.</p>
<p>Note that it is still possible for Rust crates and libraries to enable
WebAssembly features on a per-function level. This means that the build
command above may not be sufficient to disable all WebAssembly features. If the
final binary still has SIMD instructions, for example, the function in question
will need to be found and the crate in question will likely contain something
like:</p>
<pre><code class="language-rust ignore (not-always-compiled-to-wasm)">#[target_feature(enable = "simd128")]
fn foo() {
    // ...
}</code></pre>
<p>In this situation there is no compiler flag to disable emission of SIMD
instructions and the crate must instead be modified to not include this function
at compile time either by default or through a Cargo feature. For crate authors
it’s recommended to avoid <code>#[target_feature(enable = "...")]</code> except where
necessary and instead use:</p>
<pre><code class="language-rust ignore (not-always-compiled-to-wasm)">#[cfg(target_feature = "simd128")]
fn foo() {
    // ...
}</code></pre>
<p>That is to say instead of enabling target features it’s recommended to
conditionally compile code instead. This is notably different to the way native
platforms such as x86_64 work, and this is due to the fact that WebAssembly
binaries must only contain code the engine understands. Native binaries work so
long as the CPU doesn’t execute unknown code dynamically at runtime.</p>
<h2 id="unwinding-2"><a class="header" href="#unwinding-2">Unwinding</a></h2>
<p>By default the <code>wasm32-unknown-unknown</code> target is compiled with <code>-Cpanic=abort</code>.
Historically this was due to the fact that there was no way to catch panics in
wasm, but since mid-2025 the WebAssembly <a href="https://github.com/WebAssembly/exception-handling"><code>exception-handling</code>
proposal</a> reached
stabilization. LLVM has support for this proposal as well and when this is all
combined together it’s possible to enable <code>-Cpanic=unwind</code> on wasm targets.</p>
<p>Compiling wasm targets with <code>-Cpanic=unwind</code> is not as easy as just passing
<code>-Cpanic=unwind</code>, however:</p>
<pre><code class="language-sh">$ rustc foo.rs -Cpanic=unwind --target wasm32-unknown-unknown
error: the crate `panic_unwind` does not have the panic strategy `unwind`
</code></pre>
<p>Notably the precompiled standard library that is shipped through Rustup is
compiled with <code>-Cpanic=abort</code>, not <code>-Cpanic=unwind</code>. While this is the case
you’re going to be required to use Cargo’s <a href="../cargo/reference/unstable.html#build-std"><code>-Zbuild-std</code></a> feature to build with
unwinding support:</p>
<pre><code class="language-sh">$ RUSTFLAGS='-Cpanic=unwind' cargo +nightly build --target wasm32-unknown-unknown -Zbuild-std
</code></pre>
<p>Note, however, that as of 2025-10-03 LLVM is still using the “legacy exception
instructions” by default, not the officially standard version of the
exception-handling proposal:</p>
<pre><code class="language-sh">$ wasm-tools validate target/wasm32-unknown-unknown/debug/foo.wasm
error: &lt;sysroot&gt;/library/std/src/sys/backtrace.rs:161:5
function `std::sys::backtrace::__rust_begin_short_backtrace` failed to validate

Caused by:
    0: func 2 failed to validate
    1: legacy_exceptions feature required for try instruction (at offset 0x880)
</code></pre>
<p>Fixing this requires passing <code>-Cllvm-args=-wasm-use-legacy-eh=false</code> to the Rust
compiler as well:</p>
<pre><code class="language-sh">$ RUSTFLAGS='-Cpanic=unwind -Cllvm-args=-wasm-use-legacy-eh=false' cargo +nightly build --target wasm32-unknown-unknown -Zbuild-std
$ wasm-tools validate target/wasm32-unknown-unknown/debug/foo.wasm
</code></pre>
<p>At this time there are no concrete plans for adding new targets to the Rust
compiler which have <code>-Cpanic=unwind</code> enabled-by-default. The most likely route
to having this enabled is that in a few years when the <code>exception-handling</code>
target feature is enabled by default in LLVM (due to browsers/runtime support
propagating widely enough) the targets will switch to using <code>-Cpanic=unwind</code> by
default. This is not for certain, however, and will likely be accompanied with
either an MCP or an RFC about changing all wasm targets in the same manner. In
the meantime using <code>-Cpanic=unwind</code> will require using <a href="../cargo/reference/unstable.html#build-std"><code>-Zbuild-std</code></a> and
passing the appropriate flags to rustc.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm32v1-none"><a class="header" href="#wasm32v1-none"><code>wasm32v1-none</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>The <code>wasm32v1-none</code> target is a WebAssembly compilation target that:</p>
<ul>
<li>Imports nothing from its host environment</li>
<li>Enables no proposals / features past the <a href="https://www.w3.org/TR/wasm-core-1/">W3C WebAssembly Core 1.0 spec</a></li>
</ul>
<p>The target is very similar to <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code></a> and similarly uses LLVM’s <code>wasm32-unknown-unknown</code> backend target. It contains only three minor differences:</p>
<ul>
<li>Setting the <code>target-cpu</code> to <code>mvp</code> rather than the default <code>generic</code>. Requesting <code>mvp</code> disables <em>all</em> WebAssembly proposals / LLVM target feature flags.</li>
<li>Enabling the <a href="https://github.com/WebAssembly/mutable-global">Import/Export of Mutable Globals</a> proposal (i.e. the <code>+mutable-globals</code> LLVM target feature flag)</li>
<li>Not compiling the <code>std</code> library at all, rather than compiling it with stubs.</li>
</ul>
<h2 id="target-maintainers-104"><a class="header" href="#target-maintainers-104">Target maintainers</a></h2>
<p><a href="https://github.com/alexcrichton">@alexcrichton</a>
<a href="https://github.com/graydon">@graydon</a></p>
<h2 id="requirements-97"><a class="header" href="#requirements-97">Requirements</a></h2>
<p>This target is cross-compiled. It does not support <code>std</code>, only <code>core</code> and <code>alloc</code>. Since it imports nothing from its environment, any <code>std</code> parts that use OS facilities would be stubbed out with functions-that-fail anyways, and the experience of working with the stub <code>std</code> in the <code>wasm32-unknown-unknown</code> target was deemed not something worth repeating here.</p>
<p>Everything else about this target’s requirements, building, usage and testing is the same as what’s described in the <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code> document</a>, just using the target string <code>wasm32v1-none</code> in place of <code>wasm32-unknown-unknown</code>.</p>
<h2 id="conditionally-compiling-code-6"><a class="header" href="#conditionally-compiling-code-6">Conditionally compiling code</a></h2>
<p>It’s recommended to conditionally compile code for this target with:</p>
<pre><code class="language-text">#[cfg(all(target_family = "wasm", target_os = "none"))]
</code></pre>
<p>Note that there is no way to tell via <code>#[cfg]</code> whether code will be running on
the web or not.</p>
<h2 id="enabled-webassembly-features-6"><a class="header" href="#enabled-webassembly-features-6">Enabled WebAssembly features</a></h2>
<p>As noted above, <em>no WebAssembly proposals past 1.0</em> are enabled on this target by default. Indeed, the entire point of this target is to have a way to compile for a stable “no post-1.0 proposals” subset of WebAssembly <em>on stable Rust</em>.</p>
<p>The <a href="https://www.w3.org/TR/wasm-core-1/">W3C WebAssembly Core 1.0 spec</a> was adopted as a W3C recommendation in December 2019, and includes exactly one “post-MVP” proposal: the <a href="https://github.com/WebAssembly/mutable-global">Import/Export of Mutable Globals</a> proposal.</p>
<p>All subsequent proposals are <em>disabled</em> on this target by default, though they can be individually enabled by passing LLVM target-feature flags.</p>
<p>For reference sake, the set of proposals that LLVM supports at the time of writing, that this target <em>does not enable by default</em>, are listed here along with their LLVM target-feature flags:</p>
<ul>
<li>Post-1.0 proposals (integrated into the WebAssembly core 2.0 spec):
<ul>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/bulk-memory-operations/Overview.md">Bulk memory</a> - <code>+bulk-memory</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/sign-extension-ops/Overview.md">Sign-extending operations</a> - <code>+sign-ext</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/nontrapping-float-to-int-conversion/Overview.md">Non-trapping fp-to-int operations</a> - <code>+nontrapping-fptoint</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/multi-value/Overview.md">Multi-value</a> - <code>+multivalue</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/reference-types/Overview.md">Reference Types</a> - <code>+reference-types</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/simd/SIMD.md">Fixed-width SIMD</a> - <code>+simd128</code></li>
</ul>
</li>
<li>Post-2.0 proposals:
<ul>
<li><a href="https://github.com/webassembly/threads">Threads</a> (supported by atomics) - <code>+atomics</code></li>
<li><a href="https://github.com/WebAssembly/exception-handling">Exception handling</a>  - <code>+exception-handling</code></li>
<li><a href="https://github.com/WebAssembly/extended-const">Extended Constant Expressions</a>  - <code>+extended-const</code></li>
<li><a href="https://github.com/WebAssembly/half-precision">Half Precision</a>  - <code>+half-precision</code></li>
<li><a href="https://github.com/WebAssembly/multi-memory">Multiple memories</a>- <code>+multimemory</code></li>
<li><a href="https://github.com/WebAssembly/relaxed-simd">Relaxed SIMD</a> - <code>+relaxed-simd</code></li>
<li><a href="https://github.com/WebAssembly/tail-call">Tail call</a> - <code>+tail-call</code></li>
</ul>
</li>
</ul>
<p>Additional proposals in the future are, of course, also not enabled by default.</p>
<h2 id="rationale-relative-to-wasm32-unknown-unknown"><a class="header" href="#rationale-relative-to-wasm32-unknown-unknown">Rationale relative to wasm32-unknown-unknown</a></h2>
<p>As noted in the <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code> document</a>, it is possible to compile with <code>--target wasm32-unknown-unknown</code> and disable all WebAssembly proposals “by hand”, by passing <code>-Ctarget-cpu=mvp</code>. Furthermore one can enable proposals one by one by passing LLVM target feature flags, such as <code>-Ctarget-feature=+mutable-globals</code>.</p>
<p>Is it therefore reasonable to wonder what the difference is between building with this:</p>
<pre><code class="language-sh">$ rustc --target wasm32-unknown-unknown -Ctarget-cpu=mvp -Ctarget-feature=+mutable-globals
</code></pre>
<p>and building with this:</p>
<pre><code class="language-sh">$ rustc --target wasm32v1-none
</code></pre>
<p>The difference is in how the <code>core</code> and <code>alloc</code> crates are compiled for distribution with the toolchain, and whether it works on <em>stable</em> Rust toolchains or requires <em>nightly</em> ones. Again referring back to the <a href="#wasm32-unknown-unknown"><code>wasm32-unknown-unknown</code> document</a>, note that to disable all post-MVP proposals on that target one <em>actually</em> has to compile with this:</p>
<pre><code class="language-sh">$ export RUSTFLAGS="-Ctarget-cpu=mvp -Ctarget-feature=+mutable-globals"
$ cargo +nightly build -Zbuild-std=panic_abort,std --target wasm32-unknown-unknown
</code></pre>
<p>Which not only rebuilds <code>std</code>, <code>core</code> and <code>alloc</code> (which is somewhat costly and annoying) but more importantly requires the use of nightly Rust toolchains (for the <code>-Zbuild-std</code> flag). This is very undesirable for the target audience, which consists of people targeting WebAssembly implementations that prioritize stability, simplicity and/or security over feature support.</p>
<p>This <code>wasm32v1-none</code> target exists as an alternative option that works on stable Rust toolchains, without rebuilding the stdlib.</p>
<h2 id="unwinding-3"><a class="header" href="#unwinding-3">Unwinding</a></h2>
<p>This target is compiled with <code>-Cpanic=abort</code> by default. Using <code>-Cpanic=unwind</code>
would require using the WebAssembly exception-handling proposal stabilized
mid-2025, and if that’s desired then you most likely don’t want to use this
target and instead want to use <code>wasm32-unknown-unknown</code> instead. It’s unlikely
that this target will ever support unwinding with the precompiled artifacts
shipped through rustup. For documentation about using <code>-Zbuild-std</code> to enable
using <code>-Cpanic=unwind</code> see the <a href="#unwinding-2">documentation of
<code>wasm32-unknown-unknown</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm64-unknown-unknown"><a class="header" href="#wasm64-unknown-unknown"><code>wasm64-unknown-unknown</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>WebAssembly target which uses 64-bit memories, relying on the <a href="https://github.com/webassembly/memory64">memory64</a>
WebAssembly proposal.</p>
<h2 id="target-maintainers-105"><a class="header" href="#target-maintainers-105">Target maintainers</a></h2>
<p><a href="https://github.com/alexcrichton">@alexcrichton</a></p>
<h2 id="requirements-98"><a class="header" href="#requirements-98">Requirements</a></h2>
<p>This target is cross-compiled. The target supports <code>std</code> in the same manner as
the <code>wasm32-unknown-unknown</code> target which is to say that it comes with the
standard library but many I/O functions such as <code>std::fs</code> and <code>std::net</code> will
simply return error. Additionally I/O operations like <code>println!</code> don’t actually
do anything and the prints aren’t routed anywhere. This is the same as the
<code>wasm32-unknown-unknown</code> target. This target comes by default with an allocator,
currently <a href="http://gee.cs.oswego.edu/dl/html/malloc.html">dlmalloc</a> which is <a href="https://github.com/alexcrichton/dlmalloc-rs">ported to rust</a>.</p>
<p>The difference of this target with <code>wasm32-unknown-unknown</code> is that it’s
compiled for 64-bit memories instead of 32-bit memories. This means that <code>usize</code>
is 8-bytes large as well as pointers. The tradeoff, though, is that the maximum
memory size is now the full 64-bit address space instead of the 4GB as limited
by the 32-bit address space for <code>wasm32-unknown-unknown</code>.</p>
<p>This target is not a stable target. The <a href="https://github.com/webassembly/memory64">memory64</a> WebAssembly proposal is still
in-progress and not standardized. This means that there are not many engines
which implement the <code>memory64</code> feature and if they do they’re likely behind a
flag, for example:</p>
<ul>
<li>Nodejs - <code>--experimental-wasm-memory64</code></li>
<li>Wasmtime - <code>--wasm memory64</code></li>
</ul>
<p>Also note that at this time the <code>wasm64-unknown-unknown</code> target assumes the
presence of other merged wasm proposals such as (with their LLVM feature flags):</p>
<ul>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/bulk-memory-operations/Overview.md">Bulk memory</a> - <code>+bulk-memory</code></li>
<li>Mutable imported globals - <code>+mutable-globals</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/sign-extension-ops/Overview.md">Sign-extending operations</a> - <code>+sign-ext</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/nontrapping-float-to-int-conversion/Overview.md">Non-trapping fp-to-int operations</a> - <code>+nontrapping-fptoint</code></li>
</ul>
<p>The <code>wasm64-unknown-unknown</code> target intends to match the default Clang targets
for its <code>"C"</code> ABI, which is likely to be the same as Clang’s
<code>wasm32-unknown-unknown</code> largely.</p>
<blockquote>
<p><strong>Note</strong>: due to the relatively early-days nature of this target when working
with this target you may encounter LLVM bugs. If an assertion hit or a bug is
found it’s recommended to open an issue either with rust-lang/rust or ideally
with LLVM itself.</p>
</blockquote>
<p>This target does not support <code>panic=unwind</code> at this time.</p>
<h2 id="building-the-target-68"><a class="header" href="#building-the-target-68">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>bootstrap.toml</code>, and the target also requires <code>lld</code> to be built to work.</p>
<pre><code class="language-toml">[build]
target = ["wasm64-unknown-unknown"]

[rust]
lld = true
</code></pre>
<h2 id="building-rust-programs-77"><a class="header" href="#building-rust-programs-77">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>std</code> by using
<code>build-std</code> or similar.</p>
<p>Note that the following <code>cfg</code> directives are set for <code>wasm64-unknown-unknown</code>:</p>
<ul>
<li><code>cfg(target_arch = "wasm64")</code></li>
<li><code>cfg(target_family = "wasm")</code></li>
</ul>
<h2 id="testing-81"><a class="header" href="#testing-81">Testing</a></h2>
<p>Currently testing is not well supported for <code>wasm64-unknown-unknown</code> and the
Rust project doesn’t run any tests for this target. Testing support sort of
works but without <code>println!</code> it’s not the most exciting tests to run.</p>
<h2 id="cross-compilation-toolchains-and-c-code-42"><a class="header" href="#cross-compilation-toolchains-and-c-code-42">Cross-compilation toolchains and C code</a></h2>
<p>Compiling Rust code with C code for <code>wasm64-unknown-unknown</code> is theoretically
possible, but there are no known toolchains to do this at this time. At the time
of this writing there is no known “libc” for wasm that works with
<code>wasm64-unknown-unknown</code>, which means that mixing C &amp; Rust with this target
effectively cannot be done.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-windows-gnu"><a class="header" href="#-windows-gnu">*-windows-gnu</a></h1>
<p><strong>⚠️ This documentation page is a stub, you can help improving it by sending a PR. ⚠️</strong></p>
<p><strong>Tier: 1/2 (with host tools)</strong></p>
<p>Target triples available:</p>
<ul>
<li><code>i686-pc-windows-gnu</code>: Tier 2</li>
<li><code>x86_64-pc-windows-gnu</code>: Tier 1</li>
</ul>
<h2 id="target-maintainers-106"><a class="header" href="#target-maintainers-106">Target maintainers</a></h2>
<p><strong>⚠️ These targets do not have any maintainers and are not properly maintained. ⚠️</strong></p>
<p>If you are using this target, consider signing up to become a target maintainer.
See the target tier policy for details.
Without maintainers, these targets may be demoted in the future.</p>
<h2 id="requirements-99"><a class="header" href="#requirements-99">Requirements</a></h2>
<p>These targets support std and host tools.</p>
<p>Unlike their MSVC counterparts, windows-gnu targets support cross-compilation and are free of all MSVC licensing implications.</p>
<p>They follow Windows calling convention for <code>extern "C"</code>.</p>
<p>Like with any other Windows target, created binaries are in PE format.</p>
<h2 id="building-rust-programs-78"><a class="header" href="#building-rust-programs-78">Building Rust programs</a></h2>
<p>Rust does ship a pre-compiled std library for those targets.
That means one can easily compile and cross-compile for those targets from other hosts if C proper toolchain is installed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-windows-gnullvm"><a class="header" href="#-windows-gnullvm">*-windows-gnullvm</a></h1>
<p><strong>Tier: 2 (with host tools)</strong></p>
<p>Windows targets similar to <code>*-windows-gnu</code> but using UCRT as the runtime and various LLVM tools/libraries instead of
GCC/Binutils.</p>
<p>Target triples available so far:</p>
<ul>
<li><code>aarch64-pc-windows-gnullvm</code></li>
<li><code>i686-pc-windows-gnullvm</code></li>
<li><code>x86_64-pc-windows-gnullvm</code></li>
</ul>
<h2 id="target-maintainers-107"><a class="header" href="#target-maintainers-107">Target maintainers</a></h2>
<p><a href="https://github.com/mati865">@mati865</a>
<a href="https://github.com/thomcc">@thomcc</a></p>
<h2 id="requirements-100"><a class="header" href="#requirements-100">Requirements</a></h2>
<p>Building those targets requires an LLVM-based C toolchain, for example, <a href="https://github.com/mstorsjo/llvm-mingw">llvm-mingw</a> or <a href="https://www.msys2.org/docs/environments">MSYS2</a> with CLANG*
environment.</p>
<p>Binaries for this target should be at least on par with <code>*-windows-gnu</code> in terms of requirements and functionality,
except for implicit self-contained mode (explained in <a href="#building-rust-programs-79">the section below</a>).</p>
<p>Those targets follow Windows calling convention for <code>extern "C"</code>.</p>
<p>Like with any other Windows target, created binaries are in PE format.</p>
<h2 id="building-the-target-69"><a class="header" href="#building-the-target-69">Building the target</a></h2>
<p>Both native and cross-compilation builds are supported and function similarly to other Rust targets.</p>
<h2 id="building-rust-programs-79"><a class="header" href="#building-rust-programs-79">Building Rust programs</a></h2>
<p>Rust ships both std and host tools for those targets. That allows using them as both the host and the target.</p>
<p>When used as the host and building pure Rust programs, no additional C toolchain is required.
The only requirements are to install <code>rust-mingw</code> component and to set <code>rust-lld</code> as the linker.
Otherwise, you will need to install the C toolchain mentioned previously.
There is no automatic fallback to <code>rust-lld</code> when the C toolchain is missing yet, but it may be added in the future.</p>
<h2 id="testing-82"><a class="header" href="#testing-82">Testing</a></h2>
<p>Created binaries work fine on Windows and Linux with Wine using native hardware.
Testing AArch64 on x86_64 is problematic, though, and requires launching a whole AArch64 system with QEMU.</p>
<p>Most of the x86_64 testsuite does pass, but because it isn’t run on CI, different failures are expected over time.</p>
<h2 id="cross-compilation-toolchains-and-c-code-43"><a class="header" href="#cross-compilation-toolchains-and-c-code-43">Cross-compilation toolchains and C code</a></h2>
<p>Compatible C code can be built with Clang’s <code>aarch64-pc-windows-gnu</code>, <code>i686-pc-windows-gnullvm</code> and
<code>x86_64-pc-windows-gnu</code> targets as long as LLVM-based C toolchains are used. Those include:</p>
<ul>
<li><a href="https://github.com/mstorsjo/llvm-mingw">llvm-mingw</a></li>
<li><a href="https://www.msys2.org/docs/environments">MSYS2</a> with CLANG* environment</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-win7-windows-gnu"><a class="header" href="#-win7-windows-gnu">*-win7-windows-gnu</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Windows targets continuing support of Windows 7.</p>
<p>Target triples:</p>
<ul>
<li><code>i686-win7-windows-gnu</code></li>
<li><code>x86_64-win7-windows-gnu</code></li>
</ul>
<h2 id="target-maintainers-108"><a class="header" href="#target-maintainers-108">Target maintainers</a></h2>
<p><a href="https://github.com/tbu-">@tbu-</a></p>
<h2 id="requirements-101"><a class="header" href="#requirements-101">Requirements</a></h2>
<p>This target supports all of core, alloc, std and test. Host
tools may also work, though those are not currently tested.</p>
<p>Those targets follow Windows calling convention for extern “C”.</p>
<p>Like any other Windows target, the created binaries are in PE format.</p>
<h2 id="building-the-target-70"><a class="header" href="#building-the-target-70">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the target list in bootstrap.toml:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-win7-windows-gnu"]
</code></pre>
<h2 id="building-rust-programs-80"><a class="header" href="#building-rust-programs-80">Building Rust programs</a></h2>
<p>Rust does not ship pre-compiled artifacts for this target. To compile for this
target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy by using <code>build-std</code> or
similar.</p>
<h2 id="testing-83"><a class="header" href="#testing-83">Testing</a></h2>
<p>Created binaries work fine on Windows or Wine using native hardware. Remote
testing is possible using the <code>remote-test-server</code> described <a href="https://rustc-dev-guide.rust-lang.org/tests/running.html#running-tests-on-a-remote-machine">here</a>.</p>
<h2 id="cross-compilation-toolchains-and-c-code-44"><a class="header" href="#cross-compilation-toolchains-and-c-code-44">Cross-compilation toolchains and C code</a></h2>
<p>Compatible C code can be built with gcc’s <code>{i686,x86_64}-w64-mingw32-gcc</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-win7-windows-msvc"><a class="header" href="#-win7-windows-msvc">*-win7-windows-msvc</a></h1>
<p><strong>Tier: 3</strong></p>
<p>Windows targets continuing support of Windows 7.</p>
<p>Target triples:</p>
<ul>
<li><code>i686-win7-windows-msvc</code></li>
<li><code>x86_64-win7-windows-msvc</code></li>
</ul>
<h2 id="target-maintainers-109"><a class="header" href="#target-maintainers-109">Target maintainers</a></h2>
<p><a href="https://github.com/roblabla">@roblabla</a></p>
<h2 id="requirements-102"><a class="header" href="#requirements-102">Requirements</a></h2>
<p>This target supports all of core, alloc, std and test. This is automatically
tested every night on private infrastructure hosted by the maintainer. Host
tools may also work, though it is not guaranteed. Last known success built
version of rustc with host tools (x86_64) is 1.91.0.</p>
<p>Those targets follow Windows calling convention for extern “C”.</p>
<p>Like any other Windows target, the created binaries are in PE format.</p>
<h2 id="building-the-target-71"><a class="header" href="#building-the-target-71">Building the target</a></h2>
<p>You can build Rust with support for the targets by adding it to the target list in bootstrap.toml:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-win7-windows-msvc"]
</code></pre>
<h2 id="building-rust-programs-81"><a class="header" href="#building-rust-programs-81">Building Rust programs</a></h2>
<p>Rust does not ship pre-compiled artifacts for this target. To compile for this
target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy by using <code>build-std</code> or
similar.</p>
<h2 id="testing-84"><a class="header" href="#testing-84">Testing</a></h2>
<p>Created binaries work fine on Windows or Wine using native hardware. Remote
testing is possible using the <code>remote-test-server</code> described <a href="https://rustc-dev-guide.rust-lang.org/tests/running.html#running-tests-on-a-remote-machine">here</a>.</p>
<h2 id="cross-compilation-toolchains-and-c-code-45"><a class="header" href="#cross-compilation-toolchains-and-c-code-45">Cross-compilation toolchains and C code</a></h2>
<p>Compatible C code can be built with either MSVC’s <code>cl.exe</code> or LLVM’s clang-cl.</p>
<p>Cross-compilation is possible using clang-cl/lld-link. It also requires the
Windows SDK, which can be acquired using <a href="https://github.com/Jake-Shadle/xwin"><code>xwin</code></a>.</p>
<ul>
<li>
<p>Install <code>clang-cl</code> and <code>lld-link</code> on your machine, and make sure they are in
your $PATH.</p>
</li>
<li>
<p>Install <code>xwin</code>: <code>cargo install xwin</code></p>
</li>
<li>
<p>Use <code>xwin</code> to install the Windows SDK: <code>xwin splat --output winsdk</code></p>
</li>
<li>
<p>Create an <code>xwin-lld-link</code> script with the following content:</p>
<pre><code class="language-bash">#!/usr/bin/env bash
set -e
XWIN=/path/to/winsdk
lld-link "$@" /libpath:$XWIN/crt/lib/x86_64 /libpath:$XWIN/sdk/lib/um/x86_64 /libpath:$XWIN/sdk/lib/ucrt/x86_64
</code></pre>
</li>
<li>
<p>Create an <code>xwin-clang-cl</code> script with the following content:</p>
<pre><code class="language-bash">#!/usr/bin/env bash
set -e
XWIN=/path/to/winsdk
clang-cl /imsvc "$XWIN/crt/include" /imsvc "$XWIN/sdk/include/ucrt" /imsvc "$XWIN/sdk/include/um" /imsvc "$XWIN/sdk/include/shared" --target="x86_64-pc-windows-msvc" "$@"
</code></pre>
</li>
<li>
<p>In your bootstrap.toml, add the following lines:</p>
<pre><code class="language-toml">[target.x86_64-win7-windows-msvc]
linker = "path/to/xwin-lld-link"
cc = "path/to/xwin-clang-cl"
</code></pre>
</li>
</ul>
<p>You should now be able to cross-compile the Rust std, and any rust program.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64-fortanix-unknown-sgx"><a class="header" href="#x86_64-fortanix-unknown-sgx"><code>x86_64-fortanix-unknown-sgx</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>Secure enclaves using <a href="https://www.intel.com/content/www/us/en/developer/tools/software-guard-extensions/overview.html">Intel Software Guard Extensions
(SGX)</a>
based on the ABI defined by Fortanix for the <a href="https://edp.fortanix.com/">Enclave Development Platform
(EDP)</a>.</p>
<h2 id="target-maintainers-110"><a class="header" href="#target-maintainers-110">Target maintainers</a></h2>
<p><a href="https://github.com/jethrogb">@jethrogb</a>
<a href="https://github.com/raoulstrackx">@raoulstrackx</a>
<a href="https://github.com/aditijannu">@aditijannu</a></p>
<p>Further contacts:</p>
<p>The <a href="mailto:edp.maintainers@fortanix.com">EDP team</a> at Fortanix.</p>
<h2 id="requirements-103"><a class="header" href="#requirements-103">Requirements</a></h2>
<p>The target supports <code>std</code> with a default allocator. Only cross compilation is
supported.</p>
<p>Binaries support all CPUs that include Intel SGX. Only 64-bit mode is supported.</p>
<p>Not all <code>std</code> features are supported, see <a href="https://edp.fortanix.com/docs/concepts/rust-std/">Using Rust’s
std</a> for details.</p>
<p>The <code>extern "C"</code> calling convention is the System V AMD64 ABI.</p>
<p>The supported ABI is the
<a href="https://edp.fortanix.com/docs/api/fortanix_sgx_abi/index.html">fortanix-sgx-abi</a>.</p>
<p>The compiler output is ELF, but the native format for the platform is the SGX
stream (SGXS) format. A converter like
<a href="https://crates.io/crates/fortanix-sgx-tools">ftxsgx-elf2sgxs</a> is needed.</p>
<p>Programs in SGXS format adhering to the Fortanix SGX ABI can be run with any
compatible runner, such as
<a href="https://crates.io/crates/fortanix-sgx-tools">ftxsgx-runner</a>.</p>
<p>See the <a href="https://edp.fortanix.com/docs/installation/guide/">EDP installation
guide</a> for recommendations
on how to setup a development and runtime environment.</p>
<h2 id="building-the-target-72"><a class="header" href="#building-the-target-72">Building the target</a></h2>
<p>As a tier 2 target, the target is built by the Rust project.</p>
<p>You can configure bootstrap like so:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-fortanix-unknown-sgx"]
</code></pre>
<h2 id="building-rust-programs-82"><a class="header" href="#building-rust-programs-82">Building Rust programs</a></h2>
<p>Standard build flows using <code>cargo</code> or <code>rustc</code> should work.</p>
<h2 id="testing-85"><a class="header" href="#testing-85">Testing</a></h2>
<p>The Rust test suite as well as custom unit and integration tests will run on
hardware that has Intel SGX enabled if a cargo runner is configured correctly,
see the requirements section.</p>
<h2 id="cross-compilation-toolchains-and-c-code-46"><a class="header" href="#cross-compilation-toolchains-and-c-code-46">Cross-compilation toolchains and C code</a></h2>
<p>C code is not generally supported, as there is no libc. C code compiled for
x86-64 in freestanding mode using the System V AMD64 ABI may work. The
<a href="https://crates.io/crates/rs-libc">rs-libc</a> crate contains a subset of libc
that’s known to work with this target.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64-pc-cygwin"><a class="header" href="#x86_64-pc-cygwin"><code>x86_64-pc-cygwin</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Windows targets supporting Cygwin.
The <code>*-cygwin</code> targets are <strong>not</strong> intended as native target for applications,
a developer writing Windows applications should use the <code>*-pc-windows-*</code> targets instead, which are <em>native</em> Windows.</p>
<p>Cygwin is only intended as an emulation layer for Unix-only programs which do not support the native Windows targets.</p>
<h2 id="target-maintainers-111"><a class="header" href="#target-maintainers-111">Target maintainers</a></h2>
<p><a href="https://github.com/Berrysoft">@Berrysoft</a></p>
<h2 id="requirements-104"><a class="header" href="#requirements-104">Requirements</a></h2>
<p>This target is cross compiled. It needs <code>x86_64-pc-cygwin-gcc</code> as linker.</p>
<p>The <code>target_os</code> of the target is <code>cygwin</code>, and it is <code>unix</code>.</p>
<h2 id="building-the-target-73"><a class="header" href="#building-the-target-73">Building the target</a></h2>
<p>For cross-compilation you want LLVM at least 20.1.0-rc1.
No native builds on Cygwin now.
The tracking issue for host tools on Cygwin is <a href="https://github.com/rust-lang/rust/issues/137819">#137819</a>.</p>
<h2 id="building-rust-programs-83"><a class="header" href="#building-rust-programs-83">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing-86"><a class="header" href="#testing-86">Testing</a></h2>
<p>Created binaries work fine on Windows with Cygwin.</p>
<h2 id="cross-compilation-toolchains-and-c-code-47"><a class="header" href="#cross-compilation-toolchains-and-c-code-47">Cross-compilation toolchains and C code</a></h2>
<p>Compatible C code can be built with GCC shipped with Cygwin. Clang is untested.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64-unknown-linux-none"><a class="header" href="#x86_64-unknown-linux-none"><code>x86_64-unknown-linux-none</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Freestanding x86-64 linux binary with no dependency on libc.</p>
<h2 id="target-maintainers-112"><a class="header" href="#target-maintainers-112">Target maintainers</a></h2>
<p><a href="https://github.com/morr0ne">@morr0ne</a></p>
<h2 id="requirements-105"><a class="header" href="#requirements-105">Requirements</a></h2>
<p>This target is cross compiled and can be built from any host.</p>
<p>This target has no support for host tools, std, or alloc.</p>
<p>One of the primary motivations of the target is to write a dynamic linker and libc in Rust.
For that, the target defaults to position-independent code and position-independent executables (PIE) by default.
PIE binaries need relocation at runtime. This is usually done by the dynamic linker or libc.
You can use <code>-Crelocation-model=static</code> to create a position-dependent binary that does not need relocation at runtime.</p>
<h2 id="building-the-target-74"><a class="header" href="#building-the-target-74">Building the target</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-unknown-linux-none"]
</code></pre>
<h2 id="building-rust-programs-84"><a class="header" href="#building-rust-programs-84">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
“Building the target” above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing-87"><a class="header" href="#testing-87">Testing</a></h2>
<p>Created binaries will run on linux without any external requirements</p>
<h2 id="cross-compilation-toolchains-and-c-code-48"><a class="header" href="#cross-compilation-toolchains-and-c-code-48">Cross-compilation toolchains and C code</a></h2>
<p>Support for C code is currently untested</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64-unknown-none"><a class="header" href="#x86_64-unknown-none"><code>x86_64-unknown-none</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>Freestanding/bare-metal x86-64 binaries in ELF format: firmware, kernels, etc.</p>
<h2 id="target-maintainers-113"><a class="header" href="#target-maintainers-113">Target maintainers</a></h2>
<p><a href="https://github.com/haraldh">@haraldh</a>
<a href="https://github.com/mikeleany">@mikeleany</a></p>
<h2 id="requirements-106"><a class="header" href="#requirements-106">Requirements</a></h2>
<p>This target is cross-compiled. There is no support for <code>std</code>. There is no
default allocator, but it’s possible to use <code>alloc</code> by supplying an allocator.</p>
<p>By default, Rust code generated for this target does not use any vector or
floating-point registers (e.g. SSE, AVX). This allows the generated code to run
in environments, such as kernels, which may need to avoid the use of such
registers or which may have special considerations about the use of such
registers (e.g. saving and restoring them to avoid breaking userspace code
using the same registers). You can change code generation to use additional CPU
features via the <code>-C target-feature=</code> codegen options to rustc, or via the
<code>#[target_feature]</code> mechanism within Rust code.</p>
<p>By default, code generated with this target should run on any <code>x86_64</code>
hardware; enabling additional target features may raise this baseline.</p>
<p>Code generated with this target will use the <code>kernel</code> code model by default.
You can change this using the <code>-C code-model=</code> option to rustc.</p>
<p>On <code>x86_64-unknown-none</code>, <code>extern "C"</code> uses the <a href="https://gitlab.com/x86-psABIs/x86-64-ABI">standard System V calling
convention</a>, without red zones.</p>
<p>This target generates binaries in the ELF format. Any alternate formats or
special considerations for binary layout will require linker options or linker
scripts.</p>
<h2 id="building-the-target-75"><a class="header" href="#building-the-target-75">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>bootstrap.toml</code>:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = ["x86_64-unknown-none"]
</code></pre>
<h2 id="building-rust-programs-85"><a class="header" href="#building-rust-programs-85">Building Rust programs</a></h2>
<p>Starting with Rust 1.62, precompiled artifacts are provided via <code>rustup</code>:</p>
<pre><code class="language-text"># install cross-compile toolchain
rustup target add x86_64-unknown-none
# target flag may be used with any cargo or rustc command
cargo build --target x86_64-unknown-none
</code></pre>
<h2 id="testing-88"><a class="header" href="#testing-88">Testing</a></h2>
<p>As <code>x86_64-unknown-none</code> supports a variety of different environments and does
not support <code>std</code>, this target does not support running the Rust test suite.</p>
<h2 id="cross-compilation-toolchains-and-c-code-49"><a class="header" href="#cross-compilation-toolchains-and-c-code-49">Cross-compilation toolchains and C code</a></h2>
<p>If you want to compile C code along with Rust (such as for Rust crates with C
dependencies), you will need an appropriate <code>x86_64</code> toolchain.</p>
<p>Rust <em>may</em> be able to use an <code>x86_64-linux-gnu-</code> toolchain with appropriate
standalone flags to build for this toolchain (depending on the assumptions of
that toolchain, see below), or you may wish to use a separate
<code>x86_64-unknown-none</code> (or <code>x86_64-elf-</code>) toolchain.</p>
<p>On some <code>x86_64</code> hosts that use ELF binaries, you <em>may</em> be able to use the host
C toolchain, if it does not introduce assumptions about the host environment
that don’t match the expectations of a standalone environment. Otherwise, you
may need a separate toolchain for standalone/freestanding development, just as
when cross-compiling from a non-<code>x86_64</code> platform.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_64-unknown-linux-gnuasan"><a class="header" href="#x86_64-unknown-linux-gnuasan"><code>x86_64-unknown-linux-gnuasan</code></a></h1>
<p><strong>Tier: 2</strong></p>
<p>Target mirroring <code>x86_64-unknown-linux-gnu</code> with AddressSanitizer enabled by
default.
The goal of this target is to allow shipping ASAN-instrumented standard
libraries through rustup, enabling a fully instrumented binary without requiring
nightly features (build-std).
Once build-std stabilizes, this target is no longer needed and will be removed.</p>
<h2 id="target-maintainers-114"><a class="header" href="#target-maintainers-114">Target maintainers</a></h2>
<ul>
<li><a href="https://github.com/jakos-sec">@jakos-sec</a></li>
<li><a href="https://github.com/1c3t3a">@1c3t3a</a></li>
<li>[@rust-lang/project-exploit-mitigations][project-exploit-mitigations]</li>
</ul>
<h2 id="requirements-107"><a class="header" href="#requirements-107">Requirements</a></h2>
<p>The target is for cross-compilation only. Host tools are not supported, since
there is no need to have the host tools instrumented with ASAN. std is fully
supported.</p>
<p>In all other aspects the target is equivalent to <code>x86_64-unknown-linux-gnu</code>.</p>
<h2 id="building-the-target-76"><a class="header" href="#building-the-target-76">Building the target</a></h2>
<p>The target can be built by enabling it for a rustc build:</p>
<pre><code class="language-toml">[build]
target = ["x86_64-unknown-linux-gnuasan"]
</code></pre>
<h2 id="building-rust-programs-86"><a class="header" href="#building-rust-programs-86">Building Rust programs</a></h2>
<p>Rust programs can be compiled by adding this target via rustup:</p>
<pre><code class="language-sh">$ rustup target add x86_64-unknown-linux-gnuasan
</code></pre>
<p>and then compiling with the target:</p>
<pre><code class="language-sh">$ rustc foo.rs --target x86_64-unknown-linux-gnuasan
</code></pre>
<h2 id="testing-89"><a class="header" href="#testing-89">Testing</a></h2>
<p>Created binaries will run on Linux without any external requirements.</p>
<h2 id="cross-compilation-toolchains-and-c-code-50"><a class="header" href="#cross-compilation-toolchains-and-c-code-50">Cross-compilation toolchains and C code</a></h2>
<p>The target supports C code and should use the same toolchain target as
<code>x86_64-unknown-linux-gnu</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="xtensa--none-elf"><a class="header" href="#xtensa--none-elf"><code>xtensa-*-none-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Targets for Xtensa CPUs.</p>
<h2 id="target-maintainers-115"><a class="header" href="#target-maintainers-115">Target maintainers</a></h2>
<p><a href="https://github.com/MabezDev">@MabezDev</a>
<a href="https://github.com/SergioGasquez">@SergioGasquez</a></p>
<h2 id="requirements-108"><a class="header" href="#requirements-108">Requirements</a></h2>
<p>The target names follow this format: <code>xtensa-$CPU</code>, where <code>$CPU</code> specifies the target chip. The following targets are currently defined:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target name</th><th>Target CPU(s)</th></tr>
</thead>
<tbody>
<tr><td><code>xtensa-esp32-none-elf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32">ESP32</a></td></tr>
<tr><td><code>xtensa-esp32s2-none-elf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-s2">ESP32-S2</a></td></tr>
<tr><td><code>xtensa-esp32s3-none-elf</code></td><td><a href="https://www.espressif.com/en/products/socs/esp32-s3">ESP32-S3</a></td></tr>
</tbody>
</table>
</div>
<p>Xtensa targets that support <code>std</code> are documented in the <a href="#-espidf">ESP-IDF platform support document</a></p>
<h2 id="building-the-targets-2"><a class="header" href="#building-the-targets-2">Building the targets</a></h2>
<p>The targets can be built by installing the <a href="https://github.com/esp-rs/rust/">Xtensa enabled Rust channel</a>. See instructions in the <a href="https://docs.espressif.com/projects/rust/book/installation/index.html">RISC-V and Xtensa Targets section of The Rust on ESP Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-nuttx-elf"><a class="header" href="#-nuttx-elf"><code>*-nuttx-elf</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Targets for the <a href="https://github.com/apache/nuttx">Apache NuttX</a>.</p>
<p>Apache NuttX is a real-time operating system (RTOS) with an emphasis on standards compliance and small footprint. It is scalable from 8-bit to 64-bit microcontroller environments. The primary governing standards in NuttX are POSIX and ANSI standards.</p>
<p>NuttX adopts additional standard APIs from Unix and other common RTOSs, such as VxWorks. These APIs are used for functionality not available under the POSIX and ANSI standards. However, some APIs, like fork(), are not appropriate for deeply-embedded environments and are not implemented in NuttX.</p>
<p>For brevity, many parts of the documentation will refer to Apache NuttX as simply NuttX.</p>
<h2 id="target-maintainers-116"><a class="header" href="#target-maintainers-116">Target maintainers</a></h2>
<p><a href="https://github.com/no1wudi">@no1wudi</a></p>
<h2 id="requirements-109"><a class="header" href="#requirements-109">Requirements</a></h2>
<p>The target name follow this format: <code>ARCH[-VENDOR]-nuttx-ABI</code>, where <code>ARCH</code> is the target architecture, <code>VENDOR</code> is the vendor name, and <code>ABI</code> is the ABI used.</p>
<p>The following target names are defined:</p>
<ul>
<li><code>aarch64-unknown-nuttx</code></li>
<li><code>armv7a-nuttx-eabi</code></li>
<li><code>armv7a-nuttx-eabihf</code></li>
<li><code>thumbv6m-nuttx-eabi</code></li>
<li><code>thumbv7a-nuttx-eabi</code></li>
<li><code>thumbv7a-nuttx-eabihf</code></li>
<li><code>thumbv7m-nuttx-eabi</code></li>
<li><code>thumbv7em-nuttx-eabi</code></li>
<li><code>thumbv7em-nuttx-eabihf</code></li>
<li><code>thumbv8m.base-nuttx-eabi</code></li>
<li><code>thumbv8m.main-nuttx-eabi</code></li>
<li><code>thumbv8m.main-nuttx-eabihf</code></li>
<li><code>riscv32imc-unknown-nuttx-elf</code></li>
<li><code>riscv32imac-unknown-nuttx-elf</code></li>
<li><code>riscv32imafc-unknown-nuttx-elf</code></li>
<li><code>riscv64imac-unknown-nuttx-elf</code></li>
<li><code>riscv64gc-unknown-nuttx-elf</code></li>
</ul>
<h2 id="building-the-target-77"><a class="header" href="#building-the-target-77">Building the target</a></h2>
<p>The target can be built by enabling it in the <code>rustc</code> build:</p>
<pre><code class="language-toml">[build]
target = "riscv32imc-unknown-nuttx-elf"

[target.'riscv32imc-unknown-nuttx-elf']
linker = "riscv-none-elf-gcc"
</code></pre>
<p>The toolchain for the target can be found in <a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">NuttX’s quick start guide</a>.</p>
<h2 id="testing-90"><a class="header" href="#testing-90">Testing</a></h2>
<p>This is a cross-compiled <code>no-std</code> target, which must be run either in a simulator
or by programming them onto suitable hardware. It is not possible to run the
Rust test-suite on this target.</p>
<h2 id="cross-compilation-toolchains-and-c-code-51"><a class="header" href="#cross-compilation-toolchains-and-c-code-51">Cross-compilation toolchains and C code</a></h2>
<p>This target supports C code. If interlinking with C or C++, you may need to use
<code>riscv-none-elf-gcc</code> or <code>arm-none-eabi-gcc</code> as a linker instead of <code>rust-lld</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
