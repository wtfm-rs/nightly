<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Warn-by-default Lints - The rustc book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../../css/general-2459343d.css">
        <link rel="stylesheet" href="../../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex-a631a4e8.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc-46ab57f5.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The rustc book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/rustc" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/edit/main/src/doc/rustc/src/lints/listing/warn-by-default.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="warn-by-default-lints"><a class="header" href="#warn-by-default-lints">Warn-by-default Lints</a></h1>
<p>These lints are all set to the ‘warn’ level by default.</p>
<ul>
<li><a href="#aarch64-softfloat-neon"><code>aarch64_softfloat_neon</code></a></li>
<li><a href="#ambiguous-glob-imported-traits"><code>ambiguous_glob_imported_traits</code></a></li>
<li><a href="#ambiguous-glob-imports"><code>ambiguous_glob_imports</code></a></li>
<li><a href="#ambiguous-glob-reexports"><code>ambiguous_glob_reexports</code></a></li>
<li><a href="#ambiguous-panic-imports"><code>ambiguous_panic_imports</code></a></li>
<li><a href="#ambiguous-wide-pointer-comparisons"><code>ambiguous_wide_pointer_comparisons</code></a></li>
<li><a href="#anonymous-parameters"><code>anonymous_parameters</code></a></li>
<li><a href="#array-into-iter"><code>array_into_iter</code></a></li>
<li><a href="#asm-sub-register"><code>asm_sub_register</code></a></li>
<li><a href="#async-fn-in-trait"><code>async_fn_in_trait</code></a></li>
<li><a href="#bad-asm-style"><code>bad_asm_style</code></a></li>
<li><a href="#bare-trait-object"><code>bare-trait-object</code></a></li>
<li><a href="#bare-trait-objects"><code>bare_trait_objects</code></a></li>
<li><a href="#boxed-slice-into-iter"><code>boxed_slice_into_iter</code></a></li>
<li><a href="#break-with-label-and-loop"><code>break_with_label_and_loop</code></a></li>
<li><a href="#clashing-extern-declarations"><code>clashing_extern_declarations</code></a></li>
<li><a href="#coherence-leak-check"><code>coherence_leak_check</code></a></li>
<li><a href="#confusable-idents"><code>confusable_idents</code></a></li>
<li><a href="#const-evaluatable-unchecked"><code>const_evaluatable_unchecked</code></a></li>
<li><a href="#const-item-interior-mutations"><code>const_item_interior_mutations</code></a></li>
<li><a href="#const-item-mutation"><code>const_item_mutation</code></a></li>
<li><a href="#dangling-pointers-from-locals"><code>dangling_pointers_from_locals</code></a></li>
<li><a href="#dangling-pointers-from-temporaries"><code>dangling_pointers_from_temporaries</code></a></li>
<li><a href="#dead-code"><code>dead_code</code></a></li>
<li><a href="#deprecated"><code>deprecated</code></a></li>
<li><a href="#deprecated-where-clause-location"><code>deprecated_where_clause_location</code></a></li>
<li><a href="#double-negations"><code>double_negations</code></a></li>
<li><a href="#drop-bounds"><code>drop_bounds</code></a></li>
<li><a href="#dropping-copy-types"><code>dropping_copy_types</code></a></li>
<li><a href="#dropping-references"><code>dropping_references</code></a></li>
<li><a href="#duplicate-macro-attributes"><code>duplicate_macro_attributes</code></a></li>
<li><a href="#dyn-drop"><code>dyn_drop</code></a></li>
<li><a href="#ellipsis-inclusive-range-patterns"><code>ellipsis_inclusive_range_patterns</code></a></li>
<li><a href="#exported-private-dependencies"><code>exported_private_dependencies</code></a></li>
<li><a href="#for-loops-over-fallibles"><code>for_loops_over_fallibles</code></a></li>
<li><a href="#forbidden-lint-groups"><code>forbidden_lint_groups</code></a></li>
<li><a href="#forgetting-copy-types"><code>forgetting_copy_types</code></a></li>
<li><a href="#forgetting-references"><code>forgetting_references</code></a></li>
<li><a href="#function-casts-as-integer"><code>function_casts_as_integer</code></a></li>
<li><a href="#function-item-references"><code>function_item_references</code></a></li>
<li><a href="#hidden-glob-reexports"><code>hidden_glob_reexports</code></a></li>
<li><a href="#improper-ctypes"><code>improper_ctypes</code></a></li>
<li><a href="#improper-ctypes-definitions"><code>improper_ctypes_definitions</code></a></li>
<li><a href="#improper-gpu-kernel-arg"><code>improper_gpu_kernel_arg</code></a></li>
<li><a href="#incomplete-features"><code>incomplete_features</code></a></li>
<li><a href="#inline-always-mismatching-target-features"><code>inline_always_mismatching_target_features</code></a></li>
<li><a href="#inline-no-sanitize"><code>inline_no_sanitize</code></a></li>
<li><a href="#integer-to-ptr-transmutes"><code>integer_to_ptr_transmutes</code></a></li>
<li><a href="#internal-features"><code>internal_features</code></a></li>
<li><a href="#invalid-from-utf8"><code>invalid_from_utf8</code></a></li>
<li><a href="#invalid-nan-comparisons"><code>invalid_nan_comparisons</code></a></li>
<li><a href="#invalid-value"><code>invalid_value</code></a></li>
<li><a href="#irrefutable-let-patterns"><code>irrefutable_let_patterns</code></a></li>
<li><a href="#large-assignments"><code>large_assignments</code></a></li>
<li><a href="#late-bound-lifetime-arguments"><code>late_bound_lifetime_arguments</code></a></li>
<li><a href="#malformed-diagnostic-attributes"><code>malformed_diagnostic_attributes</code></a></li>
<li><a href="#malformed-diagnostic-format-literals"><code>malformed_diagnostic_format_literals</code></a></li>
<li><a href="#map-unit-fn"><code>map_unit_fn</code></a></li>
<li><a href="#mismatched-lifetime-syntaxes"><code>mismatched_lifetime_syntaxes</code></a></li>
<li><a href="#misplaced-diagnostic-attributes"><code>misplaced_diagnostic_attributes</code></a></li>
<li><a href="#missing-abi"><code>missing_abi</code></a></li>
<li><a href="#missing-gpu-kernel-export-name"><code>missing_gpu_kernel_export_name</code></a></li>
<li><a href="#mixed-script-confusables"><code>mixed_script_confusables</code></a></li>
<li><a href="#named-arguments-used-positionally"><code>named_arguments_used_positionally</code></a></li>
<li><a href="#no-mangle-generic-items"><code>no_mangle_generic_items</code></a></li>
<li><a href="#non-fmt-panic"><code>non-fmt-panic</code></a></li>
<li><a href="#non-camel-case-types"><code>non_camel_case_types</code></a></li>
<li><a href="#non-contiguous-range-endpoints"><code>non_contiguous_range_endpoints</code></a></li>
<li><a href="#non-fmt-panics"><code>non_fmt_panics</code></a></li>
<li><a href="#non-local-definitions"><code>non_local_definitions</code></a></li>
<li><a href="#non-shorthand-field-patterns"><code>non_shorthand_field_patterns</code></a></li>
<li><a href="#non-snake-case"><code>non_snake_case</code></a></li>
<li><a href="#non-upper-case-globals"><code>non_upper_case_globals</code></a></li>
<li><a href="#noop-method-call"><code>noop_method_call</code></a></li>
<li><a href="#opaque-hidden-inferred-bound"><code>opaque_hidden_inferred_bound</code></a></li>
<li><a href="#overlapping-patterns"><code>overlapping-patterns</code></a></li>
<li><a href="#overlapping-range-endpoints"><code>overlapping_range_endpoints</code></a></li>
<li><a href="#path-statements"><code>path_statements</code></a></li>
<li><a href="#private-bounds"><code>private_bounds</code></a></li>
<li><a href="#private-interfaces"><code>private_interfaces</code></a></li>
<li><a href="#ptr-to-integer-transmute-in-consts"><code>ptr_to_integer_transmute_in_consts</code></a></li>
<li><a href="#redundant-semicolon"><code>redundant-semicolon</code></a></li>
<li><a href="#redundant-semicolons"><code>redundant_semicolons</code></a></li>
<li><a href="#refining-impl-trait-internal"><code>refining_impl_trait_internal</code></a></li>
<li><a href="#refining-impl-trait-reachable"><code>refining_impl_trait_reachable</code></a></li>
<li><a href="#renamed-and-removed-lints"><code>renamed_and_removed_lints</code></a></li>
<li><a href="#repr-c-enums-larger-than-int"><code>repr_c_enums_larger_than_int</code></a></li>
<li><a href="#rtsan-nonblocking-async"><code>rtsan_nonblocking_async</code></a></li>
<li><a href="#self-constructor-from-outer-item"><code>self_constructor_from_outer_item</code></a></li>
<li><a href="#special-module-name"><code>special_module_name</code></a></li>
<li><a href="#stable-features"><code>stable_features</code></a></li>
<li><a href="#static-mut-ref"><code>static-mut-ref</code></a></li>
<li><a href="#static-mut-refs"><code>static_mut_refs</code></a></li>
<li><a href="#suspicious-double-ref-op"><code>suspicious_double_ref_op</code></a></li>
<li><a href="#tail-call-track-caller"><code>tail_call_track_caller</code></a></li>
<li><a href="#trivial-bounds"><code>trivial_bounds</code></a></li>
<li><a href="#type-alias-bounds"><code>type_alias_bounds</code></a></li>
<li><a href="#tyvar-behind-raw-pointer"><code>tyvar_behind_raw_pointer</code></a></li>
<li><a href="#uncommon-codepoints"><code>uncommon_codepoints</code></a></li>
<li><a href="#unconditional-recursion"><code>unconditional_recursion</code></a></li>
<li><a href="#uncovered-param-in-projection"><code>uncovered_param_in_projection</code></a></li>
<li><a href="#unexpected-cfgs"><code>unexpected_cfgs</code></a></li>
<li><a href="#unfulfilled-lint-expectations"><code>unfulfilled_lint_expectations</code></a></li>
<li><a href="#ungated-async-fn-track-caller"><code>ungated_async_fn_track_caller</code></a></li>
<li><a href="#uninhabited-static"><code>uninhabited_static</code></a></li>
<li><a href="#unknown-diagnostic-attributes"><code>unknown_diagnostic_attributes</code></a></li>
<li><a href="#unknown-lints"><code>unknown_lints</code></a></li>
<li><a href="#unnameable-test-items"><code>unnameable_test_items</code></a></li>
<li><a href="#unnecessary-transmutes"><code>unnecessary_transmutes</code></a></li>
<li><a href="#unpredictable-function-pointer-comparisons"><code>unpredictable_function_pointer_comparisons</code></a></li>
<li><a href="#unreachable-code"><code>unreachable_code</code></a></li>
<li><a href="#unreachable-patterns"><code>unreachable_patterns</code></a></li>
<li><a href="#unstable-name-collision"><code>unstable-name-collision</code></a></li>
<li><a href="#unstable-name-collisions"><code>unstable_name_collisions</code></a></li>
<li><a href="#unstable-syntax-pre-expansion"><code>unstable_syntax_pre_expansion</code></a></li>
<li><a href="#unsupported-calling-conventions"><code>unsupported_calling_conventions</code></a></li>
<li><a href="#unsupported-fn-ptr-calling-conventions"><code>unsupported_fn_ptr_calling_conventions</code></a></li>
<li><a href="#unused-doc-comment"><code>unused-doc-comment</code></a></li>
<li><a href="#unused-tuple-struct-fields"><code>unused-tuple-struct-fields</code></a></li>
<li><a href="#unused-allocation"><code>unused_allocation</code></a></li>
<li><a href="#unused-assignments"><code>unused_assignments</code></a></li>
<li><a href="#unused-associated-type-bounds"><code>unused_associated_type_bounds</code></a></li>
<li><a href="#unused-attributes"><code>unused_attributes</code></a></li>
<li><a href="#unused-braces"><code>unused_braces</code></a></li>
<li><a href="#unused-comparisons"><code>unused_comparisons</code></a></li>
<li><a href="#unused-doc-comments"><code>unused_doc_comments</code></a></li>
<li><a href="#unused-features"><code>unused_features</code></a></li>
<li><a href="#unused-imports"><code>unused_imports</code></a></li>
<li><a href="#unused-labels"><code>unused_labels</code></a></li>
<li><a href="#unused-macros"><code>unused_macros</code></a></li>
<li><a href="#unused-must-use"><code>unused_must_use</code></a></li>
<li><a href="#unused-mut"><code>unused_mut</code></a></li>
<li><a href="#unused-parens"><code>unused_parens</code></a></li>
<li><a href="#unused-unsafe"><code>unused_unsafe</code></a></li>
<li><a href="#unused-variables"><code>unused_variables</code></a></li>
<li><a href="#unused-visibilities"><code>unused_visibilities</code></a></li>
<li><a href="#useless-ptr-null-checks"><code>useless_ptr_null_checks</code></a></li>
<li><a href="#uses-power-alignment"><code>uses_power_alignment</code></a></li>
<li><a href="#varargs-without-pattern"><code>varargs_without_pattern</code></a></li>
<li><a href="#warnings"><code>warnings</code></a></li>
<li><a href="#while-true"><code>while_true</code></a></li>
</ul>
<h2 id="aarch64-softfloat-neon"><a class="header" href="#aarch64-softfloat-neon">aarch64-softfloat-neon</a></h2>
<p>The <code>aarch64_softfloat_neon</code> lint detects usage of <code>#[target_feature(enable = "neon")]</code> on
softfloat aarch64 targets. Enabling this target feature causes LLVM to alter the ABI of
function calls, making this attribute unsound to use.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-rust ignore (needs aarch64-unknown-none-softfloat)">#[target_feature(enable = "neon")]
fn with_neon() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: enabling the `neon` target feature on the current target is unsound due to ABI issues
  --&gt; $DIR/abi-incompatible-target-feature-attribute-fcw.rs:11:18
   |
   | #[target_feature(enable = "neon")]
   |                  ^^^^^^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #134375 &lt;https://github.com/rust-lang/rust/issues/134375&gt;
</code></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>If a function like <code>with_neon</code> above ends up containing calls to LLVM builtins, those will
not use the correct ABI. This is caused by a lack of support in LLVM for mixing code with
and without the <code>neon</code> target feature. The target feature should never have been stabilized
on this target due to this issue, but the problem was not known at the time of
stabilization.</p>
<h2 id="ambiguous-glob-imported-traits"><a class="header" href="#ambiguous-glob-imported-traits">ambiguous-glob-imported-traits</a></h2>
<p>The <code>ambiguous_glob_imported_traits</code> lint reports uses of traits that are
imported ambiguously via glob imports. Previously, this was not enforced
due to a bug in rustc.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_glob_imported_traits)]
mod m1 {
   pub trait Trait {
           fn method1(&amp;self) {}
       }
       impl Trait for u8 {}
   }
   mod m2 {
       pub trait Trait {
           fn method2(&amp;self) {}
       }
       impl Trait for u8 {}
   }

 fn main() {
     use m1::*;
     use m2::*;
     0u8.method1();
     0u8.method2();
 }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: Use of ambiguously glob imported trait `Trait`
  --&gt; lint_example.rs:18:10
   |
16 |      use m1::*;
   |          -- `Trait` imported ambiguously here
17 |      use m2::*;
18 |      0u8.method1();
   |          ^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #147992 &lt;https://github.com/rust-lang/rust/issues/147992&gt;
   = help: Import `Trait` explicitly
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_glob_imported_traits)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h3>
<p>When multiple traits with the same name are brought into scope through glob imports,
one trait becomes the “primary” one while the others are shadowed. Methods from the
shadowed traits (e.g. <code>method2</code>) become inaccessible, while methods from the “primary”
trait (e.g. <code>method1</code>) still resolve. Ideally, none of the ambiguous traits would be in scope,
but we have to allow this for now because of backwards compatibility.
This lint reports uses of these “primary” traits that are ambiguous.</p>
<p>This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="ambiguous-glob-imports"><a class="header" href="#ambiguous-glob-imports">ambiguous-glob-imports</a></h2>
<p>The <code>ambiguous_glob_imports</code> lint detects glob imports that should report ambiguity
errors, but previously didn’t do that due to rustc bugs.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_glob_imports)]
pub fn foo() -&gt; u32 {
    use sub::*;
    C
}

mod sub {
    mod mod1 { pub const C: u32 = 1; }
    mod mod2 { pub const C: u32 = 2; }

    pub use mod1::*;
    pub use mod2::*;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `C` is ambiguous
  --&gt; lint_example.rs:5:5
   |
 5 |     C
   |     ^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 &lt;https://github.com/rust-lang/rust/issues/114095&gt;
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `C` could refer to the constant imported here
  --&gt; lint_example.rs:12:13
   |
12 |     pub use mod1::*;
   |             ^^^^^^^
   = help: consider adding an explicit import of `C` to disambiguate
note: `C` could also refer to the constant imported here
  --&gt; lint_example.rs:13:13
   |
13 |     pub use mod2::*;
   |             ^^^^^^^
   = help: consider adding an explicit import of `C` to disambiguate
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_glob_imports)]
   |         ^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<p>Previous versions of Rust compile it successfully because it
had lost the ambiguity error when resolve <code>use sub::mod2::*</code>.</p>
<p>This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="ambiguous-glob-reexports"><a class="header" href="#ambiguous-glob-reexports">ambiguous-glob-reexports</a></h2>
<p>The <code>ambiguous_glob_reexports</code> lint detects cases where names re-exported via globs
collide. Downstream users trying to use the same name re-exported from multiple globs
will receive a warning pointing out redefinition of the same name.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_glob_reexports)]
pub mod foo {
    pub type X = u8;
}

pub mod bar {
    pub type Y = u8;
    pub type X = u8;
}

pub use foo::*;
pub use bar::*;


pub fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: ambiguous glob re-exports
  --&gt; lint_example.rs:11:9
   |
11 | pub use foo::*;
   |         ^^^^^^ the name `X` in the type namespace is first re-exported here
12 | pub use bar::*;
   |         ------ but the name `X` in the type namespace is also re-exported here
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_glob_reexports)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h3>
<p>This was previously accepted but it could silently break a crate’s downstream users code.
For example, if <code>foo::*</code> and <code>bar::*</code> were re-exported before <code>bar::X</code> was added to the
re-exports, down stream users could use <code>this_crate::X</code> without problems. However, adding
<code>bar::X</code> would cause compilation errors in downstream crates because <code>X</code> is defined
multiple times in the same namespace of <code>this_crate</code>.</p>
<h2 id="ambiguous-panic-imports"><a class="header" href="#ambiguous-panic-imports">ambiguous-panic-imports</a></h2>
<p>The <code>ambiguous_panic_imports</code> lint detects ambiguous core and std panic imports, but
previously didn’t do that due to <code>#[macro_use]</code> prelude macro import.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(ambiguous_panic_imports)]
#![no_std]

extern crate std;
use std::prelude::v1::*;

fn xx() {
    panic!(); // resolves to core::panic
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `panic` is ambiguous
  --&gt; lint_example.rs:9:5
   |
 9 |     panic!(); // resolves to core::panic
   |     ^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #147319 &lt;https://github.com/rust-lang/rust/issues/147319&gt;
   = note: ambiguous because of a conflict between a name from a glob import and an outer scope during import or macro resolution
note: `panic` could refer to the macro imported here
  --&gt; lint_example.rs:6:5
   |
 6 | use std::prelude::v1::*;
   |     ^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `panic` to disambiguate
note: `panic` could also refer to the macro defined here
  --&gt; /Users/runner/work/rust/rust/library/core/src/prelude/mod.rs:59:13
   |
59 |     pub use super::v1::*;
   |             ^^^^^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(ambiguous_panic_imports)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h3>
<p>Future versions of Rust will no longer accept the ambiguous resolution.</p>
<p>This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the future.</p>
<h2 id="ambiguous-wide-pointer-comparisons"><a class="header" href="#ambiguous-wide-pointer-comparisons">ambiguous-wide-pointer-comparisons</a></h2>
<p>The <code>ambiguous_wide_pointer_comparisons</code> lint checks comparison
of <code>*const/*mut ?Sized</code> as the operands.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-rust"><span class="boring">struct A;
</span><span class="boring">struct B;
</span>
<span class="boring">trait T {}
</span><span class="boring">impl T for A {}
</span><span class="boring">impl T for B {}
</span>
let ab = (A, B);
let a = &amp;ab.0 as *const dyn T;
let b = &amp;ab.1 as *const dyn T;

let _ = a == b;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: ambiguous wide pointer comparison, the comparison includes metadata which may not be expected
  --&gt; lint_example.rs:13:9
   |
13 | let _ = a == b;
   |         ^^^^^^
   |
   = note: `#[warn(ambiguous_wide_pointer_comparisons)]` on by default
help: use `std::ptr::addr_eq` or untyped pointers to only compare their addresses
   |
13 - let _ = a == b;
13 + let _ = std::ptr::addr_eq(a, b);
   |

</code></pre>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation</a></h3>
<p>The comparison includes metadata which may not be expected.</p>
<h2 id="anonymous-parameters"><a class="header" href="#anonymous-parameters">anonymous-parameters</a></h2>
<p>The <code>anonymous_parameters</code> lint detects anonymous parameters in trait
definitions.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(anonymous_parameters)]
// edition 2015
pub trait Foo {
    fn foo(usize);
}
fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: anonymous parameters are deprecated and will be removed in the next edition
 --&gt; lint_example.rs:4:12
  |
4 |     fn foo(usize);
  |            ^^^^^ help: try naming the parameter or explicitly ignoring it: `_: usize`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/trait-fn-parameters.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(anonymous_parameters)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation</a></h3>
<p>This syntax is mostly a historical accident, and can be worked around
quite easily by adding an <code>_</code> pattern or a descriptive identifier:</p>
<pre><code class="language-rust">trait Foo {
    fn foo(_: usize);
}</code></pre>
<p>This syntax is now a hard error in the 2018 edition. In the 2015
edition, this lint is “warn” by default. This lint
enables the <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag to
automatically transition old code from the 2015 edition to 2018. The
tool will run this lint and automatically apply the
suggested fix from the compiler (which is to add <code>_</code> to each
parameter). This provides a completely automated way to update old
code for a new edition. See <a href="https://github.com/rust-lang/rust/issues/41686">issue #41686</a> for more details.</p>
<h2 id="array-into-iter"><a class="header" href="#array-into-iter">array-into-iter</a></h2>
<p>The <code>array_into_iter</code> lint detects calling <code>into_iter</code> on arrays.</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span>[1, 2, 3].into_iter().for_each(|n| { *n; });</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this method call resolves to `&lt;&amp;[T; N] as IntoIterator&gt;::into_iter` (due to backwards compatibility), but will resolve to `&lt;[T; N] as IntoIterator&gt;::into_iter` in Rust 2021
 --&gt; lint_example.rs:3:11
  |
3 | [1, 2, 3].into_iter().for_each(|n| { *n; });
  |           ^^^^^^^^^
  |
  = warning: this changes meaning in Rust 2021
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html&gt;
  = note: `#[warn(array_into_iter)]` (part of `#[warn(rust_2021_compatibility)]`) on by default
help: use `.iter()` instead of `.into_iter()` to avoid ambiguity
  |
3 - [1, 2, 3].into_iter().for_each(|n| { *n; });
3 + [1, 2, 3].iter().for_each(|n| { *n; });
  |
help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value
  |
3 - [1, 2, 3].into_iter().for_each(|n| { *n; });
3 + IntoIterator::into_iter([1, 2, 3]).for_each(|n| { *n; });
  |

</code></pre>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation</a></h3>
<p>Since Rust 1.53, arrays implement <code>IntoIterator</code>. However, to avoid
breakage, <code>array.into_iter()</code> in Rust 2015 and 2018 code will still
behave as <code>(&amp;array).into_iter()</code>, returning an iterator over
references, just like in Rust 1.52 and earlier.
This only applies to the method call syntax <code>array.into_iter()</code>, not to
any other syntax such as <code>for _ in array</code> or <code>IntoIterator::into_iter(array)</code>.</p>
<h2 id="asm-sub-register"><a class="header" href="#asm-sub-register">asm-sub-register</a></h2>
<p>The <code>asm_sub_register</code> lint detects using only a subset of a register
for inline asm inputs.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-x86_64)">#[cfg(target_arch="x86_64")]
use std::arch::asm;

fn main() {
    #[cfg(target_arch="x86_64")]
    unsafe {
        asm!("mov {0}, {0}", in(reg) 0i16);
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: formatting may not be suitable for sub-register argument
 --&gt; src/main.rs:7:19
  |
7 |         asm!("mov {0}, {0}", in(reg) 0i16);
  |                   ^^^  ^^^           ---- for this argument
  |
  = note: `#[warn(asm_sub_register)]` on by default
  = help: use the `x` modifier to have the register formatted as `ax`
  = help: or use the `r` modifier to keep the default formatting of `rax`
</code></pre>
<h3 id="explanation-8"><a class="header" href="#explanation-8">Explanation</a></h3>
<p>Registers on some architectures can use different names to refer to a
subset of the register. By default, the compiler will use the name for
the full register size. To explicitly use a subset of the register,
you can override the default by using a modifier on the template
string operand to specify when subregister to use. This lint is issued
if you pass in a value with a smaller data type than the default
register size, to alert you of possibly using the incorrect width. To
fix this, add the suggested modifier to the template, or cast the
value to the correct size.</p>
<p>See <a href="https://doc.rust-lang.org/nightly/reference/inline-assembly.html#template-modifiers">register template modifiers</a> in the reference for more details.</p>
<h2 id="async-fn-in-trait"><a class="header" href="#async-fn-in-trait">async-fn-in-trait</a></h2>
<p>The <code>async_fn_in_trait</code> lint detects use of <code>async fn</code> in the
definition of a publicly-reachable trait.</p>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><code class="language-rust">pub trait Trait {
    async fn method(&amp;self);
}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
 --&gt; lint_example.rs:2:5
  |
2 |     async fn method(&amp;self);
  |     ^^^^^
  |
  = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
  = note: `#[warn(async_fn_in_trait)]` on by default
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
  |
2 -     async fn method(&amp;self);
2 +     fn method(&amp;self) -&gt; impl std::future::Future&lt;Output = ()&gt; + Send;
  |

</code></pre>
<h3 id="explanation-9"><a class="header" href="#explanation-9">Explanation</a></h3>
<p>When <code>async fn</code> is used in a trait definition, the trait does not
promise that the opaque <a href="https://doc.rust-lang.org/core/future/trait.Future.html"><code>Future</code></a> returned by the associated function
or method will implement any <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits">auto traits</a> such as <a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a>. This may
be surprising and may make the associated functions or methods on the
trait less useful than intended. On traits exposed publicly from a
crate, this may affect downstream crates whose authors cannot alter
the trait definition.</p>
<p>For example, this code is invalid:</p>
<pre><code class="language-rust compile_fail">pub trait Trait {
    async fn method(&amp;self) {}
}

fn test&lt;T: Trait&gt;(x: T) {
    fn spawn&lt;T: Send&gt;(_: T) {}
    spawn(x.method()); // Not OK.
}</code></pre>
<p>This lint exists to warn authors of publicly-reachable traits that
they may want to consider desugaring the <code>async fn</code> to a normal <code>fn</code>
that returns an opaque <code>impl Future&lt;..&gt; + Send</code> type.</p>
<p>For example, instead of:</p>
<pre><code class="language-rust">pub trait Trait {
    async fn method(&amp;self) {}
}</code></pre>
<p>The author of the trait may want to write:</p>
<pre><code class="language-rust">use core::future::Future;
pub trait Trait {
    fn method(&amp;self) -&gt; impl Future&lt;Output = ()&gt; + Send { async {} }
}</code></pre>
<p>This still allows the use of <code>async fn</code> within impls of the trait.
However, it also means that the trait will never be compatible with
impls where the returned <a href="https://doc.rust-lang.org/core/future/trait.Future.html"><code>Future</code></a> of the method does not implement
<code>Send</code>.</p>
<p>Conversely, if the trait is used only locally, if it is never used in
generic functions, or if it is only used in single-threaded contexts
that do not care whether the returned <a href="https://doc.rust-lang.org/core/future/trait.Future.html"><code>Future</code></a> implements <a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a>,
then the lint may be suppressed.</p>
<h2 id="bad-asm-style"><a class="header" href="#bad-asm-style">bad-asm-style</a></h2>
<p>The <code>bad_asm_style</code> lint detects the use of the <code>.intel_syntax</code> and
<code>.att_syntax</code> directives.</p>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-x86_64)">#[cfg(target_arch="x86_64")]
use std::arch::asm;

fn main() {
    #[cfg(target_arch="x86_64")]
    unsafe {
        asm!(
            ".att_syntax",
            "movq %{0}, %{0}", in(reg) 0usize
        );
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead
 --&gt; src/main.rs:8:14
  |
8 |             ".att_syntax",
  |              ^^^^^^^^^^^
  |
  = note: `#[warn(bad_asm_style)]` on by default
</code></pre>
<h3 id="explanation-10"><a class="header" href="#explanation-10">Explanation</a></h3>
<p>On x86, <code>asm!</code> uses the intel assembly syntax by default. While this
can be switched using assembler directives like <code>.att_syntax</code>, using the
<code>att_syntax</code> option is recommended instead because it will also properly
prefix register placeholders with <code>%</code> as required by AT&amp;T syntax.</p>
<h2 id="bare-trait-object"><a class="header" href="#bare-trait-object">bare-trait-object</a></h2>
<p>The lint <code>bare-trait-object</code> has been renamed to <a href="#bare-trait-objects"><code>bare-trait-objects</code></a>.</p>
<h2 id="bare-trait-objects"><a class="header" href="#bare-trait-objects">bare-trait-objects</a></h2>
<p>The <code>bare_trait_objects</code> lint suggests using <code>dyn Trait</code> for trait
objects.</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><code class="language-rust edition2018">trait Trait { }

fn takes_trait_object(_: Box&lt;Trait&gt;) {
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: trait objects without an explicit `dyn` are deprecated
 --&gt; lint_example.rs:4:30
  |
4 | fn takes_trait_object(_: Box&lt;Trait&gt;) {
  |                              ^^^^^
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;
  = note: `#[warn(bare_trait_objects)]` (part of `#[warn(rust_2021_compatibility)]`) on by default
help: if this is a dyn-compatible trait, use `dyn`
  |
4 | fn takes_trait_object(_: Box&lt;dyn Trait&gt;) {
  |                              +++

</code></pre>
<h3 id="explanation-11"><a class="header" href="#explanation-11">Explanation</a></h3>
<p>Without the <code>dyn</code> indicator, it can be ambiguous or confusing when
reading code as to whether or not you are looking at a trait object.
The <code>dyn</code> keyword makes it explicit, and adds a symmetry to contrast
with <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters"><code>impl Trait</code></a>.</p>
<h2 id="boxed-slice-into-iter"><a class="header" href="#boxed-slice-into-iter">boxed-slice-into-iter</a></h2>
<p>The <code>boxed_slice_into_iter</code> lint detects calling <code>into_iter</code> on boxed slices.</p>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<pre><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this method call resolves to `&lt;&amp;Box&lt;[T]&gt; as IntoIterator&gt;::into_iter` (due to backwards compatibility), but will resolve to `&lt;Box&lt;[T]&gt; as IntoIterator&gt;::into_iter` in Rust 2024
 --&gt; lint_example.rs:3:34
  |
3 | vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });
  |                                  ^^^^^^^^^
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/intoiterator-box-slice.html&gt;
  = note: `#[warn(boxed_slice_into_iter)]` (part of `#[warn(rust_2024_compatibility)]`) on by default
help: use `.iter()` instead of `.into_iter()` to avoid ambiguity
  |
3 - vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });
3 + vec![1, 2, 3].into_boxed_slice().iter().for_each(|n| { *n; });
  |
help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value
  |
3 - vec![1, 2, 3].into_boxed_slice().into_iter().for_each(|n| { *n; });
3 + IntoIterator::into_iter(vec![1, 2, 3].into_boxed_slice()).for_each(|n| { *n; });
  |

</code></pre>
<h3 id="explanation-12"><a class="header" href="#explanation-12">Explanation</a></h3>
<p>Since Rust 1.80.0, boxed slices implement <code>IntoIterator</code>. However, to avoid
breakage, <code>boxed_slice.into_iter()</code> in Rust 2015, 2018, and 2021 code will still
behave as <code>(&amp;boxed_slice).into_iter()</code>, returning an iterator over
references, just like in Rust 1.79.0 and earlier.
This only applies to the method call syntax <code>boxed_slice.into_iter()</code>, not to
any other syntax such as <code>for _ in boxed_slice</code> or <code>IntoIterator::into_iter(boxed_slice)</code>.</p>
<h2 id="break-with-label-and-loop"><a class="header" href="#break-with-label-and-loop">break-with-label-and-loop</a></h2>
<p>The <code>break_with_label_and_loop</code> lint detects labeled <code>break</code> expressions with
an unlabeled loop as their value expression.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-rust">'label: loop {
    break 'label loop { break 42; };
};</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression
 --&gt; lint_example.rs:3:5
  |
3 |     break 'label loop { break 42; };
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(break_with_label_and_loop)]` on by default
help: wrap this expression in parentheses
  |
3 |     break 'label (loop { break 42; });
  |                  +                  +

</code></pre>
<h3 id="explanation-13"><a class="header" href="#explanation-13">Explanation</a></h3>
<p>In Rust, loops can have a label, and <code>break</code> expressions can refer to that label to
break out of specific loops (and not necessarily the innermost one). <code>break</code> expressions
can also carry a value expression, which can be another loop. A labeled <code>break</code> with an
unlabeled loop as its value expression is easy to confuse with an unlabeled break with
a labeled loop and is thus discouraged (but allowed for compatibility); use parentheses
around the loop expression to silence this warning. Unlabeled <code>break</code> expressions with
labeled loops yield a hard error, which can also be silenced by wrapping the expression
in parentheses.</p>
<h2 id="clashing-extern-declarations"><a class="header" href="#clashing-extern-declarations">clashing-extern-declarations</a></h2>
<p>The <code>clashing_extern_declarations</code> lint detects when an <code>extern fn</code>
has been declared with the same name but different types.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<pre><code class="language-rust">mod m {
    unsafe extern "C" {
        fn foo();
    }
}

unsafe extern "C" {
    fn foo(_: u32);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `foo` redeclared with a different signature
 --&gt; lint_example.rs:9:5
  |
4 |         fn foo();
  |         --------- `foo` previously declared here
...
9 |     fn foo(_: u32);
  |     ^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration
  |
  = note: expected `unsafe extern "C" fn()`
             found `unsafe extern "C" fn(u32)`
  = note: `#[warn(clashing_extern_declarations)]` on by default

</code></pre>
<h3 id="explanation-14"><a class="header" href="#explanation-14">Explanation</a></h3>
<p>Because two symbols of the same name cannot be resolved to two
different functions at link time, and one function cannot possibly
have two types, a clashing extern declaration is almost certainly a
mistake. Check to make sure that the <code>extern</code> definitions are correct
and equivalent, and possibly consider unifying them in one location.</p>
<p>This lint does not run between crates because a project may have
dependencies which both rely on the same extern function, but declare
it in a different (but valid) way. For example, they may both declare
an opaque type for one or more of the arguments (which would end up
distinct types), or use types that are valid conversions in the
language the <code>extern fn</code> is defined in. In these cases, the compiler
can’t say that the clashing declaration is incorrect.</p>
<h2 id="coherence-leak-check"><a class="header" href="#coherence-leak-check">coherence-leak-check</a></h2>
<p>The <code>coherence_leak_check</code> lint detects conflicting implementations of
a trait that are only distinguished by the old leak-check code.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<pre><code class="language-rust">trait SomeTrait { }
impl SomeTrait for for&lt;'a&gt; fn(&amp;'a u8) { }
impl&lt;'a&gt; SomeTrait for fn(&amp;'a u8) { }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: conflicting implementations of trait `SomeTrait` for type `for&lt;'a&gt; fn(&amp;'a u8)`
 --&gt; lint_example.rs:4:1
  |
3 | impl SomeTrait for for&lt;'a&gt; fn(&amp;'a u8) { }
  | ------------------------------------- first implementation here
4 | impl&lt;'a&gt; SomeTrait for fn(&amp;'a u8) { }
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for&lt;'a&gt; fn(&amp;'a u8)`
  |
  = warning: the behavior may change in a future release
  = note: for more information, see issue #56105 &lt;https://github.com/rust-lang/rust/issues/56105&gt;
  = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details
  = note: `#[warn(coherence_leak_check)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-15"><a class="header" href="#explanation-15">Explanation</a></h3>
<p>In the past, the compiler would accept trait implementations for
identical functions that differed only in where the lifetime binder
appeared. Due to a change in the borrow checker implementation to fix
several bugs, this is no longer allowed. However, since this affects
existing code, this is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future.</p>
<p>Code relying on this pattern should introduce “<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">newtypes</a>”,
like <code>struct Foo(for&lt;'a&gt; fn(&amp;'a u8))</code>.</p>
<p>See <a href="https://github.com/rust-lang/rust/issues/56105">issue #56105</a> for more details.</p>
<h2 id="confusable-idents"><a class="header" href="#confusable-idents">confusable-idents</a></h2>
<p>The <code>confusable_idents</code> lint detects visually confusable pairs between
identifiers.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<pre><code class="language-rust">// Latin Capital Letter E With Caron
pub const Ě: i32 = 1;
// Latin Capital Letter E With Breve
pub const Ĕ: i32 = 2;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: found both `Ě` and `Ĕ` as identifiers, which look alike
 --&gt; lint_example.rs:5:11
  |
3 | pub const Ě: i32 = 1;
  |           - other identifier used here
4 | // Latin Capital Letter E With Breve
5 | pub const Ĕ: i32 = 2;
  |           ^ this identifier can be confused with `Ě`
  |
  = note: `#[warn(confusable_idents)]` on by default

</code></pre>
<h3 id="explanation-16"><a class="header" href="#explanation-16">Explanation</a></h3>
<p>This lint warns when different identifiers may appear visually similar,
which can cause confusion.</p>
<p>The confusable detection algorithm is based on <a href="https://www.unicode.org/reports/tr39/#Confusable_Detection">Unicode® Technical
Standard #39 Unicode Security Mechanisms Section 4 Confusable
Detection</a>. For every distinct identifier X execute
the function <code>skeleton(X)</code>. If there exist two distinct identifiers X
and Y in the same crate where <code>skeleton(X) = skeleton(Y)</code> report it.
The compiler uses the same mechanism to check if an identifier is too
similar to a keyword.</p>
<p>Note that the set of confusable characters may change over time.
Beware that if you “forbid” this lint that existing code may fail in
the future.</p>
<h2 id="const-evaluatable-unchecked"><a class="header" href="#const-evaluatable-unchecked">const-evaluatable-unchecked</a></h2>
<p>The <code>const_evaluatable_unchecked</code> lint detects a generic constant used
in a type.</p>
<h3 id="example-17"><a class="header" href="#example-17">Example</a></h3>
<pre><code class="language-rust">const fn foo&lt;T&gt;() -&gt; usize {
    if size_of::&lt;*mut T&gt;() &lt; 8 { // size of *mut T does not depend on T
        4
    } else {
        8
    }
}

fn test&lt;T&gt;() {
    let _ = [0; foo::&lt;T&gt;()];
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot use constants which depend on generic parameters in types
  --&gt; lint_example.rs:11:17
   |
11 |     let _ = [0; foo::&lt;T&gt;()];
   |                 ^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #76200 &lt;https://github.com/rust-lang/rust/issues/76200&gt;
   = note: `#[warn(const_evaluatable_unchecked)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-17"><a class="header" href="#explanation-17">Explanation</a></h3>
<p>In the 1.43 release, some uses of generic parameters in array repeat
expressions were accidentally allowed. This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a>
lint to transition this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/76200">issue
#76200</a> for a more detailed description and possible fixes.</p>
<h2 id="const-item-interior-mutations"><a class="header" href="#const-item-interior-mutations">const-item-interior-mutations</a></h2>
<p>The <code>const_item_interior_mutations</code> lint checks for calls which
mutates an interior mutable const-item.</p>
<h3 id="example-18"><a class="header" href="#example-18">Example</a></h3>
<pre><code class="language-rust">use std::sync::Once;

const INIT: Once = Once::new(); // using `INIT` will always create a temporary and
                                // never modify it-self on use, should be a `static`
                                // instead for shared use

fn init() {
    INIT.call_once(|| {
        println!("Once::call_once first call");
    });
    INIT.call_once(|| {                          // this second will also print
        println!("Once::call_once second call"); // as each call to `INIT` creates
    });                                          // new temporary
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: mutation of an interior mutable `const` item with call to `call_once`
  --&gt; lint_example.rs:9:5
   |
 9 |       INIT.call_once(|| {
   |       ^---
   |       |
   |  _____`INIT` is a interior mutable `const` item of type `std::sync::Once`
   | |
10 | |         println!("Once::call_once first call");
11 | |     });
   | |______^
   |
   = note: each usage of a `const` item creates a new temporary
   = note: only the temporaries and never the original `const INIT` will be modified
   = help: for more details on interior mutability see &lt;https://doc.rust-lang.org/reference/interior-mutability.html&gt;
   = note: `#[warn(const_item_interior_mutations)]` on by default
help: for a shared instance of `INIT`, consider making it a `static` item instead
   |
 4 - const INIT: Once = Once::new(); // using `INIT` will always create a temporary and
 4 + static INIT: Once = Once::new(); // using `INIT` will always create a temporary and
   |


warning: mutation of an interior mutable `const` item with call to `call_once`
  --&gt; lint_example.rs:12:5
   |
12 |       INIT.call_once(|| {                          // this second will also print
   |       ^---
   |       |
   |  _____`INIT` is a interior mutable `const` item of type `std::sync::Once`
   | |
13 | |         println!("Once::call_once second call"); // as each call to `INIT` creates
14 | |     });                                          // new temporary
   | |______^
   |
   = note: each usage of a `const` item creates a new temporary
   = note: only the temporaries and never the original `const INIT` will be modified
   = help: for more details on interior mutability see &lt;https://doc.rust-lang.org/reference/interior-mutability.html&gt;
help: for a shared instance of `INIT`, consider making it a `static` item instead
   |
 4 - const INIT: Once = Once::new(); // using `INIT` will always create a temporary and
 4 + static INIT: Once = Once::new(); // using `INIT` will always create a temporary and
   |

</code></pre>
<h3 id="explanation-18"><a class="header" href="#explanation-18">Explanation</a></h3>
<p>Calling a method which mutates an interior mutable type has no effect as const-item
are essentially inlined wherever they are used, meaning that they are copied
directly into the relevant context when used rendering modification through
interior mutability ineffective across usage of that const-item.</p>
<p>The current implementation of this lint only warns on significant <code>std</code> and
<code>core</code> interior mutable types, like <code>Once</code>, <code>AtomicI32</code>, … this is done out
of prudence to avoid false-positive and may be extended in the future.</p>
<h2 id="const-item-mutation"><a class="header" href="#const-item-mutation">const-item-mutation</a></h2>
<p>The <code>const_item_mutation</code> lint detects attempts to mutate a <code>const</code>
item.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><code class="language-rust">const FOO: [i32; 1] = [0];

fn main() {
    FOO[0] = 1;
    // This will print "[0]".
    println!("{:?}", FOO);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: attempting to modify a `const` item
 --&gt; lint_example.rs:4:5
  |
4 |     FOO[0] = 1;
  |     ^^^^^^^^^^
  |
  = note: each usage of a `const` item creates a new temporary; the original `const` item will not be modified
note: `const` item defined here
 --&gt; lint_example.rs:1:1
  |
1 | const FOO: [i32; 1] = [0];
  | ^^^^^^^^^^^^^^^^^^^
  = note: `#[warn(const_item_mutation)]` on by default

</code></pre>
<h3 id="explanation-19"><a class="header" href="#explanation-19">Explanation</a></h3>
<p>Trying to directly mutate a <code>const</code> item is almost always a mistake.
What is happening in the example above is that a temporary copy of the
<code>const</code> is mutated, but the original <code>const</code> is not. Each time you
refer to the <code>const</code> by name (such as <code>FOO</code> in the example above), a
separate copy of the value is inlined at that location.</p>
<p>This lint checks for writing directly to a field (<code>FOO.field = some_value</code>) or array entry (<code>FOO[0] = val</code>), or taking a mutable
reference to the const item (<code>&amp;mut FOO</code>), including through an
autoderef (<code>FOO.some_mut_self_method()</code>).</p>
<p>There are various alternatives depending on what you are trying to
accomplish:</p>
<ul>
<li>First, always reconsider using mutable globals, as they can be
difficult to use correctly, and can make the code more difficult to
use or understand.</li>
<li>If you are trying to perform a one-time initialization of a global:
<ul>
<li>If the value can be computed at compile-time, consider using
const-compatible values (see <a href="https://doc.rust-lang.org/reference/const_eval.html">Constant Evaluation</a>).</li>
<li>For more complex single-initialization cases, consider using
<a href="https://doc.rust-lang.org/stable/std/sync/struct.LazyLock.html"><code>std::sync::LazyLock</code></a>.</li>
</ul>
</li>
<li>If you truly need a mutable global, consider using a <a href="https://doc.rust-lang.org/reference/items/static-items.html"><code>static</code></a>,
which has a variety of options:
<ul>
<li>Simple data types can be directly defined and mutated with an
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>atomic</code></a> type.</li>
<li>More complex types can be placed in a synchronization primitive
like a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, which can be initialized with one of the options
listed above.</li>
<li>A <a href="https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics">mutable <code>static</code></a> is a low-level primitive, requiring unsafe.
Typically This should be avoided in preference of something
higher-level like one of the above.</li>
</ul>
</li>
</ul>
<h2 id="dangling-pointers-from-locals"><a class="header" href="#dangling-pointers-from-locals">dangling-pointers-from-locals</a></h2>
<p>The <code>dangling_pointers_from_locals</code> lint detects getting a pointer to data
of a local that will be dropped at the end of the function.</p>
<h3 id="example-20"><a class="header" href="#example-20">Example</a></h3>
<pre><code class="language-rust">fn f() -&gt; *const u8 {
    let x = 0;
    &amp;x // returns a dangling ptr to `x`
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function returns a dangling pointer to dropped local variable `x`
 --&gt; lint_example.rs:4:5
  |
2 | fn f() -&gt; *const u8 {
  |           --------- return type is `*const u8`
3 |     let x = 0;
  |         - local variable `x` is dropped at the end of the function
4 |     &amp;x // returns a dangling ptr to `x`
  |     ^^
  |
  = note: a dangling pointer is safe, but dereferencing one is undefined behavior
  = note: for more information, see &lt;https://doc.rust-lang.org/reference/destructors.html&gt;
  = note: `#[warn(dangling_pointers_from_locals)]` on by default

</code></pre>
<h3 id="explanation-20"><a class="header" href="#explanation-20">Explanation</a></h3>
<p>Returning a pointer from a local value will not prolong its lifetime,
which means that the value can be dropped and the allocation freed
while the pointer still exists, making the pointer dangling.
This is not an error (as far as the type system is concerned)
but probably is not what the user intended either.</p>
<p>If you need stronger guarantees, consider using references instead,
as they are statically verified by the borrow-checker to never dangle.</p>
<h2 id="dangling-pointers-from-temporaries"><a class="header" href="#dangling-pointers-from-temporaries">dangling-pointers-from-temporaries</a></h2>
<p>The <code>dangling_pointers_from_temporaries</code> lint detects getting a pointer to data
of a temporary that will immediately get dropped.</p>
<h3 id="example-21"><a class="header" href="#example-21">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">unsafe fn use_data(ptr: *const u8) { }
</span>fn gather_and_use(bytes: impl Iterator&lt;Item = u8&gt;) {
    let x: *const u8 = bytes.collect::&lt;Vec&lt;u8&gt;&gt;().as_ptr();
    unsafe { use_data(x) }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this creates a dangling pointer because temporary `Vec&lt;u8&gt;` is dropped at end of statement
 --&gt; lint_example.rs:5:51
  |
5 |     let x: *const u8 = bytes.collect::&lt;Vec&lt;u8&gt;&gt;().as_ptr();
  |                        -------------------------- ^^^^^^ pointer created here
  |                        |
  |                        this `Vec&lt;u8&gt;` is dropped at end of statement
  |
  = help: bind the `Vec&lt;u8&gt;` to a variable such that it outlives the pointer returned by `as_ptr`
  = note: a dangling pointer is safe, but dereferencing one is undefined behavior
  = note: returning a pointer to a local variable will always result in a dangling pointer
  = note: for more information, see &lt;https://doc.rust-lang.org/reference/destructors.html&gt;
  = note: `#[warn(dangling_pointers_from_temporaries)]` on by default

</code></pre>
<h3 id="explanation-21"><a class="header" href="#explanation-21">Explanation</a></h3>
<p>Getting a pointer from a temporary value will not prolong its lifetime,
which means that the value can be dropped and the allocation freed
while the pointer still exists, making the pointer dangling.
This is not an error (as far as the type system is concerned)
but probably is not what the user intended either.</p>
<p>If you need stronger guarantees, consider using references instead,
as they are statically verified by the borrow-checker to never dangle.</p>
<h2 id="dead-code"><a class="header" href="#dead-code">dead-code</a></h2>
<p>The <code>dead_code</code> lint detects unused, unexported items.</p>
<h3 id="example-22"><a class="header" href="#example-22">Example</a></h3>
<pre><code class="language-rust">fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function `foo` is never used
 --&gt; lint_example.rs:2:4
  |
2 | fn foo() {}
  |    ^^^
  |
  = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-22"><a class="header" href="#explanation-22">Explanation</a></h3>
<p>Dead code may signal a mistake or unfinished code. To silence the
warning for individual items, prefix the name with an underscore such
as <code>_foo</code>. If it was intended to expose the item outside of the crate,
consider adding a visibility modifier like <code>pub</code>.</p>
<p>To preserve the numbering of tuple structs with unused fields,
change the unused fields to have unit type or use
<code>PhantomData</code>.</p>
<p>Otherwise consider removing the unused code.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Removing fields that are only used for side-effects and never
read will result in behavioral changes. Examples of this
include:</p>
<ul>
<li>If a field’s value performs an action when it is dropped.</li>
<li>If a field’s type does not implement an auto trait
(e.g. <code>Send</code>, <code>Sync</code>, <code>Unpin</code>).</li>
</ul>
<p>For side-effects from dropping field values, this lint should
be allowed on those fields. For side-effects from containing
field types, <code>PhantomData</code> should be used.</p>
<h2 id="deprecated"><a class="header" href="#deprecated">deprecated</a></h2>
<p>The <code>deprecated</code> lint detects use of deprecated items.</p>
<h3 id="example-23"><a class="header" href="#example-23">Example</a></h3>
<pre><code class="language-rust">#[deprecated]
fn foo() {}

fn bar() {
    foo();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of deprecated function `main::foo`
 --&gt; lint_example.rs:6:5
  |
6 |     foo();
  |     ^^^
  |
  = note: `#[warn(deprecated)]` on by default

</code></pre>
<h3 id="explanation-23"><a class="header" href="#explanation-23">Explanation</a></h3>
<p>Items may be marked “deprecated” with the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code> attribute</a> to
indicate that they should no longer be used. Usually the attribute
should include a note on what to use instead, or check the
documentation.</p>
<h2 id="deprecated-where-clause-location"><a class="header" href="#deprecated-where-clause-location">deprecated-where-clause-location</a></h2>
<p>The <code>deprecated_where_clause_location</code> lint detects when a where clause in front of the equals
in an associated type.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><code class="language-rust">trait Trait {
  type Assoc&lt;'a&gt; where Self: 'a;
}

impl Trait for () {
  type Assoc&lt;'a&gt; where Self: 'a = ();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: where clause not allowed here
 --&gt; lint_example.rs:7:18
  |
7 |   type Assoc&lt;'a&gt; where Self: 'a = ();
  |                  ^^^^^^^^^^^^^^
  |
  = note: see issue #89122 &lt;https://github.com/rust-lang/rust/issues/89122&gt; for more information
  = note: `#[warn(deprecated_where_clause_location)]` on by default
help: move it to the end of the type declaration
  |
7 -   type Assoc&lt;'a&gt; where Self: 'a = ();
7 +   type Assoc&lt;'a&gt;  = () where Self: 'a;
  |

</code></pre>
<h3 id="explanation-24"><a class="header" href="#explanation-24">Explanation</a></h3>
<p>The preferred location for where clauses on associated types
is after the type. However, for most of generic associated types development,
it was only accepted before the equals. To provide a transition period and
further evaluate this change, both are currently accepted. At some point in
the future, this may be disallowed at an edition boundary; but, that is
undecided currently.</p>
<h2 id="double-negations"><a class="header" href="#double-negations">double-negations</a></h2>
<p>The <code>double_negations</code> lint detects expressions of the form <code>--x</code>.</p>
<h3 id="example-25"><a class="header" href="#example-25">Example</a></h3>
<pre><code class="language-rust">fn main() {
    let x = 1;
    let _b = --x;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of a double negation
 --&gt; lint_example.rs:3:14
  |
3 |     let _b = --x;
  |              ^^^
  |
  = note: the prefix `--` could be misinterpreted as a decrement operator which exists in other languages
  = note: use `-= 1` if you meant to decrement the value
  = note: `#[warn(double_negations)]` on by default
help: add parentheses for clarity
  |
3 |     let _b = -(-x);
  |               +  +

</code></pre>
<h3 id="explanation-25"><a class="header" href="#explanation-25">Explanation</a></h3>
<p>Negating something twice is usually the same as not negating it at all.
However, a double negation in Rust can easily be confused with the
prefix decrement operator that exists in many languages derived from C.
Use <code>-(-x)</code> if you really wanted to negate the value twice.</p>
<p>To decrement a value, use <code>x -= 1</code> instead.</p>
<h2 id="drop-bounds"><a class="header" href="#drop-bounds">drop-bounds</a></h2>
<p>The <code>drop_bounds</code> lint checks for generics with <code>std::ops::Drop</code> as
bounds.</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><code class="language-rust">fn foo&lt;T: Drop&gt;() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped
 --&gt; lint_example.rs:2:11
  |
2 | fn foo&lt;T: Drop&gt;() {}
  |           ^^^^
  |
  = note: `#[warn(drop_bounds)]` on by default

</code></pre>
<h3 id="explanation-26"><a class="header" href="#explanation-26">Explanation</a></h3>
<p>A generic trait bound of the form <code>T: Drop</code> is most likely misleading
and not what the programmer intended (they probably should have used
<code>std::mem::needs_drop</code> instead).</p>
<p><code>Drop</code> bounds do not actually indicate whether a type can be trivially
dropped or not, because a composite type containing <code>Drop</code> types does
not necessarily implement <code>Drop</code> itself. Naïvely, one might be tempted
to write an implementation that assumes that a type can be trivially
dropped while also supplying a specialization for <code>T: Drop</code> that
actually calls the destructor. However, this breaks down e.g. when <code>T</code>
is <code>String</code>, which does not implement <code>Drop</code> itself but contains a
<code>Vec</code>, which does implement <code>Drop</code>, so assuming <code>T</code> can be trivially
dropped would lead to a memory leak here.</p>
<p>Furthermore, the <code>Drop</code> trait only contains one method, <code>Drop::drop</code>,
which may not be called explicitly in user code (<code>E0040</code>), so there is
really no use case for using <code>Drop</code> in trait bounds, save perhaps for
some obscure corner cases, which can use <code>#[allow(drop_bounds)]</code>.</p>
<h2 id="dropping-copy-types"><a class="header" href="#dropping-copy-types">dropping-copy-types</a></h2>
<p>The <code>dropping_copy_types</code> lint checks for calls to <code>std::mem::drop</code> with a value
that derives the Copy trait.</p>
<h3 id="example-27"><a class="header" href="#example-27">Example</a></h3>
<pre><code class="language-rust">let x: i32 = 42; // i32 implements Copy
std::mem::drop(x); // A copy of x is passed to the function, leaving the
                   // original unaffected</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a value that implements `Copy` does nothing
 --&gt; lint_example.rs:3:1
  |
3 | std::mem::drop(x); // A copy of x is passed to the function, leaving the
  | ^^^^^^^^^^^^^^^-^
  |                |
  |                argument has type `i32`
  |
  = note: `#[warn(dropping_copy_types)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
3 - std::mem::drop(x); // A copy of x is passed to the function, leaving the
3 + let _ = x; // A copy of x is passed to the function, leaving the
  |

</code></pre>
<h3 id="explanation-27"><a class="header" href="#explanation-27">Explanation</a></h3>
<p>Calling <code>std::mem::drop</code> <a href="https://doc.rust-lang.org/std/mem/fn.drop.html">does nothing for types that
implement Copy</a>, since the
value will be copied and moved into the function on invocation.</p>
<h2 id="dropping-references"><a class="header" href="#dropping-references">dropping-references</a></h2>
<p>The <code>dropping_references</code> lint checks for calls to <code>std::mem::drop</code> with a reference
instead of an owned value.</p>
<h3 id="example-28"><a class="header" href="#example-28">Example</a></h3>
<pre><code class="language-rust"><span class="boring">fn operation_that_requires_mutex_to_be_unlocked() {} // just to make it compile
</span><span class="boring">let mutex = std::sync::Mutex::new(1); // just to make it compile
</span>let mut lock_guard = mutex.lock();
std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex
// still locked
operation_that_requires_mutex_to_be_unlocked();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a reference instead of an owned value does nothing
 --&gt; lint_example.rs:5:1
  |
5 | std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex
  | ^^^^^^^^^^^^^^^-----------^
  |                |
  |                argument has type `&amp;Result&lt;std::sync::MutexGuard&lt;'_, i32&gt;, PoisonError&lt;std::sync::MutexGuard&lt;'_, i32&gt;&gt;&gt;`
  |
  = note: `#[warn(dropping_references)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
5 - std::mem::drop(&amp;lock_guard); // Should have been drop(lock_guard), mutex
5 + let _ = &amp;lock_guard; // Should have been drop(lock_guard), mutex
  |

</code></pre>
<h3 id="explanation-28"><a class="header" href="#explanation-28">Explanation</a></h3>
<p>Calling <code>drop</code> on a reference will only drop the
reference itself, which is a no-op. It will not call the <code>drop</code> method (from
the <code>Drop</code> trait implementation) on the underlying referenced value, which
is likely what was intended.</p>
<h2 id="duplicate-macro-attributes"><a class="header" href="#duplicate-macro-attributes">duplicate-macro-attributes</a></h2>
<p>The <code>duplicate_macro_attributes</code> lint detects when a <code>#[test]</code>-like built-in macro
attribute is duplicated on an item. This lint may trigger on <code>bench</code>, <code>cfg_eval</code>, <code>test</code>
and <code>test_case</code>.</p>
<h3 id="example-29"><a class="header" href="#example-29">Example</a></h3>
<pre><code class="language-rust ignore (needs --test)">#[test]
#[test]
fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: duplicated attribute
 --&gt; src/lib.rs:2:1
  |
2 | #[test]
  | ^^^^^^^
  |
  = note: `#[warn(duplicate_macro_attributes)]` on by default
</code></pre>
<h3 id="explanation-29"><a class="header" href="#explanation-29">Explanation</a></h3>
<p>A duplicated attribute may erroneously originate from a copy-paste and the effect of it
being duplicated may not be obvious or desirable.</p>
<p>For instance, doubling the <code>#[test]</code> attributes registers the test to be run twice with no
change to its environment.</p>
<h2 id="dyn-drop"><a class="header" href="#dyn-drop">dyn-drop</a></h2>
<p>The <code>dyn_drop</code> lint checks for trait objects with <code>std::ops::Drop</code>.</p>
<h3 id="example-30"><a class="header" href="#example-30">Example</a></h3>
<pre><code class="language-rust">fn foo(_x: Box&lt;dyn Drop&gt;) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped
 --&gt; lint_example.rs:2:20
  |
2 | fn foo(_x: Box&lt;dyn Drop&gt;) {}
  |                    ^^^^
  |
  = note: `#[warn(dyn_drop)]` on by default

</code></pre>
<h3 id="explanation-30"><a class="header" href="#explanation-30">Explanation</a></h3>
<p>A trait object bound of the form <code>dyn Drop</code> is most likely misleading
and not what the programmer intended.</p>
<p><code>Drop</code> bounds do not actually indicate whether a type can be trivially
dropped or not, because a composite type containing <code>Drop</code> types does
not necessarily implement <code>Drop</code> itself. Naïvely, one might be tempted
to write a deferred drop system, to pull cleaning up memory out of a
latency-sensitive code path, using <code>dyn Drop</code> trait objects. However,
this breaks down e.g. when <code>T</code> is <code>String</code>, which does not implement
<code>Drop</code>, but should probably be accepted.</p>
<p>To write a trait object bound that accepts anything, use a placeholder
trait with a blanket implementation.</p>
<pre><code class="language-rust">trait Placeholder {}
impl&lt;T&gt; Placeholder for T {}
fn foo(_x: Box&lt;dyn Placeholder&gt;) {}</code></pre>
<h2 id="ellipsis-inclusive-range-patterns"><a class="header" href="#ellipsis-inclusive-range-patterns">ellipsis-inclusive-range-patterns</a></h2>
<p>The <code>ellipsis_inclusive_range_patterns</code> lint detects the <a href="https://doc.rust-lang.org/reference/patterns.html#range-patterns"><code>...</code> range
pattern</a>, which is deprecated.</p>
<h3 id="example-31"><a class="header" href="#example-31">Example</a></h3>
<pre><code class="language-rust edition2018">let x = 123;
match x {
    0...100 =&gt; {}
    _ =&gt; {}
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `...` range patterns are deprecated
 --&gt; lint_example.rs:4:6
  |
4 |     0...100 =&gt; {}
  |      ^^^ help: use `..=` for an inclusive range
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;
  = note: `#[warn(ellipsis_inclusive_range_patterns)]` (part of `#[warn(rust_2021_compatibility)]`) on by default

</code></pre>
<h3 id="explanation-31"><a class="header" href="#explanation-31">Explanation</a></h3>
<p>The <code>...</code> range pattern syntax was changed to <code>..=</code> to avoid potential
confusion with the <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html"><code>..</code> range expression</a>. Use the new form instead.</p>
<h2 id="exported-private-dependencies"><a class="header" href="#exported-private-dependencies">exported-private-dependencies</a></h2>
<p>The <code>exported_private_dependencies</code> lint detects private dependencies
that are exposed in a public interface.</p>
<h3 id="example-32"><a class="header" href="#example-32">Example</a></h3>
<pre><code class="language-rust ignore (needs-dependency)">pub fn foo() -&gt; Option&lt;some_private_dependency::Thing&gt; {
    None
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type `bar::Thing` from private dependency 'bar' in public interface
 --&gt; src/lib.rs:3:1
  |
3 | pub fn foo() -&gt; Option&lt;bar::Thing&gt; {
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(exported_private_dependencies)]` on by default
</code></pre>
<h3 id="explanation-32"><a class="header" href="#explanation-32">Explanation</a></h3>
<p>Dependencies can be marked as “private” to indicate that they are not
exposed in the public interface of a crate. This can be used by Cargo
to independently resolve those dependencies because it can assume it
does not need to unify them with other packages using that same
dependency. This lint is an indication of a violation of that
contract.</p>
<p>To fix this, avoid exposing the dependency in your public interface.
Or, switch the dependency to a public dependency.</p>
<p>Note that support for this is only available on the nightly channel.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/1977-public-private-dependencies.md">RFC 1977</a> for more details, as well as the <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#public-dependency">Cargo documentation</a>.</p>
<h2 id="for-loops-over-fallibles"><a class="header" href="#for-loops-over-fallibles">for-loops-over-fallibles</a></h2>
<p>The <code>for_loops_over_fallibles</code> lint checks for <code>for</code> loops over <code>Option</code> or <code>Result</code> values.</p>
<h3 id="example-33"><a class="header" href="#example-33">Example</a></h3>
<pre><code class="language-rust">let opt = Some(1);
for x in opt { /* ... */}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: for loop over an `Option`. This is more readably written as an `if let` statement
 --&gt; lint_example.rs:3:10
  |
3 | for x in opt { /* ... */}
  |          ^^^
  |
  = note: `#[warn(for_loops_over_fallibles)]` on by default
help: to check pattern in a loop use `while let`
  |
3 - for x in opt { /* ... */}
3 + while let Some(x) = opt { /* ... */}
  |
help: consider using `if let` to clear intent
  |
3 - for x in opt { /* ... */}
3 + if let Some(x) = opt { /* ... */}
  |

</code></pre>
<h3 id="explanation-33"><a class="header" href="#explanation-33">Explanation</a></h3>
<p>Both <code>Option</code> and <code>Result</code> implement <code>IntoIterator</code> trait, which allows using them in a <code>for</code> loop.
<code>for</code> loop over <code>Option</code> or <code>Result</code> will iterate either 0 (if the value is <code>None</code>/<code>Err(_)</code>)
or 1 time (if the value is <code>Some(_)</code>/<code>Ok(_)</code>). This is not very useful and is more clearly expressed
via <code>if let</code>.</p>
<p><code>for</code> loop can also be accidentally written with the intention to call a function multiple times,
while the function returns <code>Some(_)</code>, in these cases <code>while let</code> loop should be used instead.</p>
<p>The “intended” use of <code>IntoIterator</code> implementations for <code>Option</code> and <code>Result</code> is passing them to
generic code that expects something implementing <code>IntoIterator</code>. For example using <code>.chain(option)</code>
to optionally add a value to an iterator.</p>
<h2 id="forbidden-lint-groups"><a class="header" href="#forbidden-lint-groups">forbidden-lint-groups</a></h2>
<p>The <code>forbidden_lint_groups</code> lint detects violations of
<code>forbid</code> applied to a lint group. Due to a bug in the compiler,
these used to be overlooked entirely. They now generate a warning.</p>
<h3 id="example-34"><a class="header" href="#example-34">Example</a></h3>
<pre><code class="language-rust">#![forbid(warnings)]
#![warn(bad_style)]

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: warn(bad_style) incompatible with previous forbid
 --&gt; lint_example.rs:2:9
  |
1 | #![forbid(warnings)]
  |           -------- `forbid` level set here
2 | #![warn(bad_style)]
  |         ^^^^^^^^^ overruled by previous forbid
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #81670 &lt;https://github.com/rust-lang/rust/issues/81670&gt;
  = note: `#[warn(forbidden_lint_groups)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="recommended-fix"><a class="header" href="#recommended-fix">Recommended fix</a></h3>
<p>If your crate is using <code>#![forbid(warnings)]</code>,
we recommend that you change to <code>#![deny(warnings)]</code>.</p>
<h3 id="explanation-34"><a class="header" href="#explanation-34">Explanation</a></h3>
<p>Due to a compiler bug, applying <code>forbid</code> to lint groups
previously had no effect. The bug is now fixed but instead of
enforcing <code>forbid</code> we issue this future-compatibility warning
to avoid breaking existing crates.</p>
<h2 id="forgetting-copy-types"><a class="header" href="#forgetting-copy-types">forgetting-copy-types</a></h2>
<p>The <code>forgetting_copy_types</code> lint checks for calls to <code>std::mem::forget</code> with a value
that derives the Copy trait.</p>
<h3 id="example-35"><a class="header" href="#example-35">Example</a></h3>
<pre><code class="language-rust">let x: i32 = 42; // i32 implements Copy
std::mem::forget(x); // A copy of x is passed to the function, leaving the
                     // original unaffected</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::forget` with a value that implements `Copy` does nothing
 --&gt; lint_example.rs:3:1
  |
3 | std::mem::forget(x); // A copy of x is passed to the function, leaving the
  | ^^^^^^^^^^^^^^^^^-^
  |                  |
  |                  argument has type `i32`
  |
  = note: `#[warn(forgetting_copy_types)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
3 - std::mem::forget(x); // A copy of x is passed to the function, leaving the
3 + let _ = x; // A copy of x is passed to the function, leaving the
  |

</code></pre>
<h3 id="explanation-35"><a class="header" href="#explanation-35">Explanation</a></h3>
<p>Calling <code>std::mem::forget</code> <a href="https://doc.rust-lang.org/std/mem/fn.drop.html">does nothing for types that
implement Copy</a> since the
value will be copied and moved into the function on invocation.</p>
<p>An alternative, but also valid, explanation is that Copy types do not
implement the Drop trait, which means they have no destructors. Without a
destructor, there is nothing for <code>std::mem::forget</code> to ignore.</p>
<h2 id="forgetting-references"><a class="header" href="#forgetting-references">forgetting-references</a></h2>
<p>The <code>forgetting_references</code> lint checks for calls to <code>std::mem::forget</code> with a reference
instead of an owned value.</p>
<h3 id="example-36"><a class="header" href="#example-36">Example</a></h3>
<pre><code class="language-rust">let x = Box::new(1);
std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::mem::forget` with a reference instead of an owned value does nothing
 --&gt; lint_example.rs:3:1
  |
3 | std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped
  | ^^^^^^^^^^^^^^^^^--^
  |                  |
  |                  argument has type `&amp;Box&lt;i32&gt;`
  |
  = note: `#[warn(forgetting_references)]` on by default
help: use `let _ = ...` to ignore the expression or result
  |
3 - std::mem::forget(&amp;x); // Should have been forget(x), x will still be dropped
3 + let _ = &amp;x; // Should have been forget(x), x will still be dropped
  |

</code></pre>
<h3 id="explanation-36"><a class="header" href="#explanation-36">Explanation</a></h3>
<p>Calling <code>forget</code> on a reference will only forget the
reference itself, which is a no-op. It will not forget the underlying
referenced value, which is likely what was intended.</p>
<h2 id="function-casts-as-integer"><a class="header" href="#function-casts-as-integer">function-casts-as-integer</a></h2>
<p>The <code>function_casts_as_integer</code> lint detects cases where a function item is cast
to an integer.</p>
<h3 id="example-37"><a class="header" href="#example-37">Example</a></h3>
<pre><code class="language-rust">fn foo() {}
let x = foo as usize;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: direct cast of function item into an integer
 --&gt; lint_example.rs:3:13
  |
3 | let x = foo as usize;
  |             ^^^^^^^^
  |
  = note: `#[warn(function_casts_as_integer)]` on by default
help: first cast to a pointer `as *const ()`
  |
3 | let x = foo as *const () as usize;
  |             ++++++++++++

</code></pre>
<h3 id="explanation-37"><a class="header" href="#explanation-37">Explanation</a></h3>
<p>When casting a function item to an integer, it implicitly creates a
function pointer that will in turn be cast to an integer. By making
it explicit, it improves readability of the code and prevents bugs.</p>
<h2 id="function-item-references"><a class="header" href="#function-item-references">function-item-references</a></h2>
<p>The <code>function_item_references</code> lint detects function references that are
formatted with <a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> or transmuted.</p>
<h3 id="example-38"><a class="header" href="#example-38">Example</a></h3>
<pre><code class="language-rust">fn foo() { }

fn main() {
    println!("{:p}", &amp;foo);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: taking a reference to a function item does not give a function pointer
 --&gt; lint_example.rs:4:22
  |
4 |     println!("{:p}", &amp;foo);
  |                      ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn()`
  |
  = note: `#[warn(function_item_references)]` on by default

</code></pre>
<h3 id="explanation-38"><a class="header" href="#explanation-38">Explanation</a></h3>
<p>Taking a reference to a function may be mistaken as a way to obtain a
pointer to that function. This can give unexpected results when
formatting the reference as a pointer or transmuting it. This lint is
issued when function references are formatted as pointers, passed as
arguments bound by <a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> or transmuted.</p>
<h2 id="hidden-glob-reexports"><a class="header" href="#hidden-glob-reexports">hidden-glob-reexports</a></h2>
<p>The <code>hidden_glob_reexports</code> lint detects cases where glob re-export items are shadowed by
private items.</p>
<h3 id="example-39"><a class="header" href="#example-39">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(hidden_glob_reexports)]

pub mod upstream {
    mod inner { pub struct Foo {}; pub struct Bar {}; }
    pub use self::inner::*;
    struct Foo {} // private item shadows `inner::Foo`
}

// mod downstream {
//     fn test() {
//         let _ = crate::upstream::Foo; // inaccessible
//     }
// }

pub fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: private item shadows public glob re-export
 --&gt; lint_example.rs:6:5
  |
6 |     struct Foo {} // private item shadows `inner::Foo`
  |     ^^^^^^^^^^^^^
  |
note: the name `Foo` in the type namespace is supposed to be publicly re-exported here
 --&gt; lint_example.rs:5:13
  |
5 |     pub use self::inner::*;
  |             ^^^^^^^^^^^^^^
note: but the private item here shadows it
 --&gt; lint_example.rs:6:5
  |
6 |     struct Foo {} // private item shadows `inner::Foo`
  |     ^^^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(hidden_glob_reexports)]
  |         ^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-39"><a class="header" href="#explanation-39">Explanation</a></h3>
<p>This was previously accepted without any errors or warnings but it could silently break a
crate’s downstream user code. If the <code>struct Foo</code> was added, <code>dep::inner::Foo</code> would
silently become inaccessible and trigger a “<code>struct </code>Foo<code> is private</code>” visibility error at
the downstream use site.</p>
<h2 id="improper-ctypes"><a class="header" href="#improper-ctypes">improper-ctypes</a></h2>
<p>The <code>improper_ctypes</code> lint detects incorrect use of types in foreign
modules.</p>
<h3 id="example-40"><a class="header" href="#example-40">Example</a></h3>
<pre><code class="language-rust">unsafe extern "C" {
    static STATIC: String;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `extern` block uses type `String`, which is not FFI-safe
 --&gt; lint_example.rs:3:20
  |
3 |     static STATIC: String;
  |                    ^^^^^^ not FFI-safe
  |
  = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct
  = note: this struct has unspecified layout
  = note: `#[warn(improper_ctypes)]` on by default

</code></pre>
<h3 id="explanation-40"><a class="header" href="#explanation-40">Explanation</a></h3>
<p>The compiler has several checks to verify that types used in <code>extern</code>
blocks are safe and follow certain rules to ensure proper
compatibility with the foreign interfaces. This lint is issued when it
detects a probable mistake in a definition. The lint usually should
provide a description of the issue, along with possibly a hint on how
to resolve it.</p>
<h2 id="improper-ctypes-definitions"><a class="header" href="#improper-ctypes-definitions">improper-ctypes-definitions</a></h2>
<p>The <code>improper_ctypes_definitions</code> lint detects incorrect use of
<a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier"><code>extern</code> function</a> definitions.</p>
<h3 id="example-41"><a class="header" href="#example-41">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>pub extern "C" fn str_type(p: &amp;str) { }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `extern` fn uses type `str`, which is not FFI-safe
 --&gt; lint_example.rs:3:31
  |
3 | pub extern "C" fn str_type(p: &amp;str) { }
  |                               ^^^^ not FFI-safe
  |
  = help: consider using `*const u8` and a length instead
  = note: string slices have no C equivalent
  = note: `#[warn(improper_ctypes_definitions)]` on by default

</code></pre>
<h3 id="explanation-41"><a class="header" href="#explanation-41">Explanation</a></h3>
<p>There are many parameter and return types that may be specified in an
<code>extern</code> function that are not compatible with the given ABI. This
lint is an alert that these types should not be used. The lint usually
should provide a description of the issue, along with possibly a hint
on how to resolve it.</p>
<h2 id="improper-gpu-kernel-arg"><a class="header" href="#improper-gpu-kernel-arg">improper-gpu-kernel-arg</a></h2>
<p>The <code>improper_gpu_kernel_arg</code> lint detects incorrect use of types in <code>gpu-kernel</code>
arguments.</p>
<h3 id="example-42"><a class="header" href="#example-42">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-GPU targets)">#[unsafe(no_mangle)]
extern "gpu-kernel" fn kernel(_: [i32; 10]) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: passing type `[i32; 10]` to a function with "gpu-kernel" ABI may have unexpected behavior
 --&gt; t.rs:2:34
  |
2 | extern "gpu-kernel" fn kernel(_: [i32; 10]) {}
  |                                  ^^^^^^^^^
  |
  = help: use primitive types and raw pointers to get reliable behavior
  = note: `#[warn(improper_gpu_kernel_arg)]` on by default
</code></pre>
<h3 id="explanation-42"><a class="header" href="#explanation-42">Explanation</a></h3>
<p>The compiler has several checks to verify that types used as arguments in <code>gpu-kernel</code>
functions follow certain rules to ensure proper compatibility with the foreign interfaces.
This lint is issued when it detects a probable mistake in a signature.</p>
<h2 id="incomplete-features"><a class="header" href="#incomplete-features">incomplete-features</a></h2>
<p>The <code>incomplete_features</code> lint detects unstable features enabled with
the <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that may function improperly in some or all
cases.</p>
<h3 id="example-43"><a class="header" href="#example-43">Example</a></h3>
<pre><code class="language-rust">#![feature(generic_const_exprs)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(generic_const_exprs)]
  |            ^^^^^^^^^^^^^^^^^^^
  |
  = note: see issue #76560 &lt;https://github.com/rust-lang/rust/issues/76560&gt; for more information
  = note: `#[warn(incomplete_features)]` on by default

</code></pre>
<h3 id="explanation-43"><a class="header" href="#explanation-43">Explanation</a></h3>
<p>Although it is encouraged for people to experiment with unstable
features, some of them are known to be incomplete or faulty. This lint
is a signal that the feature has not yet been finished, and you may
experience problems with it.</p>
<h2 id="inline-always-mismatching-target-features"><a class="header" href="#inline-always-mismatching-target-features">inline-always-mismatching-target-features</a></h2>
<p>The <code>inline_always_mismatching_target_features</code> lint will trigger when a
function with the <code>#[inline(always)]</code> and <code>#[target_feature(enable = "...")]</code>
attributes is called and cannot be inlined due to missing target features in the caller.</p>
<h3 id="example-44"><a class="header" href="#example-44">Example</a></h3>
<pre><code class="language-rust ignore (fails on x86_64)">#[inline(always)]
#[target_feature(enable = "fp16")]
unsafe fn callee() {
    // operations using fp16 types
}

// Caller does not enable the required target feature
fn caller() {
    unsafe { callee(); }
}

fn main() {
    caller();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: call to `#[inline(always)]`-annotated `callee` requires the same target features. Function will not have `alwaysinline` attribute applied
  --&gt; $DIR/builtin.rs:5192:14
   |
10 |     unsafe { callee(); }
   |              ^^^^^^^^
   |
note: `fp16` target feature enabled in `callee` here but missing from `caller`
  --&gt; $DIR/builtin.rs:5185:1
   |
3  | #[target_feature(enable = "fp16")]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4  | unsafe fn callee() {
   | ------------------
   = note: `#[warn(inline_always_mismatching_target_features)]` on by default
warning: 1 warning emitted
</code></pre>
<h3 id="explanation-44"><a class="header" href="#explanation-44">Explanation</a></h3>
<p>Inlining a function with a target feature attribute into a caller that
lacks the corresponding target feature can lead to unsound behavior.
LLVM may select the wrong instructions or registers, or reorder
operations, potentially resulting in runtime errors.</p>
<h2 id="inline-no-sanitize"><a class="header" href="#inline-no-sanitize">inline-no-sanitize</a></h2>
<p>The <code>inline_no_sanitize</code> lint detects incompatible use of
<a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline(always)]</code></a> and <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[sanitize(xyz = "off")]</code></a>.</p>
<h3 id="example-45"><a class="header" href="#example-45">Example</a></h3>
<pre><code class="language-rust">#![feature(sanitize)]

#[inline(always)]
#[sanitize(address = "off")]
fn x() {}

fn main() {
    x()
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: non-default `sanitize` will have no effect after inlining
 --&gt; lint_example.rs:4:1
  |
4 | #[sanitize(address = "off")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: inlining requested here
 --&gt; lint_example.rs:3:1
  |
3 | #[inline(always)]
  | ^^^^^^^^^^^^^^^^^
  = note: `#[warn(inline_no_sanitize)]` on by default

</code></pre>
<h3 id="explanation-45"><a class="header" href="#explanation-45">Explanation</a></h3>
<p>The use of the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline(always)]</code></a> attribute prevents the
the <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[sanitize(xyz = "off")]</code></a> attribute from working.
Consider temporarily removing <code>inline</code> attribute.</p>
<h2 id="integer-to-ptr-transmutes"><a class="header" href="#integer-to-ptr-transmutes">integer-to-ptr-transmutes</a></h2>
<p>The <code>integer_to_ptr_transmutes</code> lint detects integer to pointer
transmutes where the resulting pointers are undefined behavior to dereference.</p>
<h3 id="example-46"><a class="header" href="#example-46">Example</a></h3>
<pre><code class="language-rust">fn foo(a: usize) -&gt; *const u8 {
   unsafe {
       std::mem::transmute::&lt;usize, *const u8&gt;(a)
   }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: transmuting an integer to a pointer creates a pointer without provenance
 --&gt; lint_example.rs:4:8
  |
4 |        std::mem::transmute::&lt;usize, *const u8&gt;(a)
  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
  = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
  = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
  = help: for more information about transmute, see &lt;https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers&gt;
  = help: for more information about exposed provenance, see &lt;https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance&gt;
  = note: `#[warn(integer_to_ptr_transmutes)]` on by default
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
  |
4 -        std::mem::transmute::&lt;usize, *const u8&gt;(a)
4 +        std::ptr::with_exposed_provenance::&lt;u8&gt;(a)
  |

</code></pre>
<h3 id="explanation-46"><a class="header" href="#explanation-46">Explanation</a></h3>
<p>Any attempt to use the resulting pointers are undefined behavior as the resulting
pointers won’t have any provenance.</p>
<p>Alternatively, <a href="https://doc.rust-lang.org/std/ptr/fn.with_exposed_provenance.html"><code>std::ptr::with_exposed_provenance</code></a> should be used, as they do not
carry the provenance requirement. If wanting to create pointers without provenance
<a href="https://doc.rust-lang.org/std/ptr/fn.without_provenance.html"><code>std::ptr::without_provenance</code></a> should be used instead.</p>
<p>See <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> in the reference for more details.</p>
<h2 id="internal-features"><a class="header" href="#internal-features">internal-features</a></h2>
<p>The <code>internal_features</code> lint detects unstable features enabled with
the <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that are internal to the compiler or standard
library.</p>
<h3 id="example-47"><a class="header" href="#example-47">Example</a></h3>
<pre><code class="language-rust">#![feature(rustc_attrs)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `rustc_attrs` is internal to the compiler or standard library
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(rustc_attrs)]
  |            ^^^^^^^^^^^
  |
  = note: using it is strongly discouraged
  = note: `#[warn(internal_features)]` on by default

</code></pre>
<h3 id="explanation-47"><a class="header" href="#explanation-47">Explanation</a></h3>
<p>These features are an implementation detail of the compiler and standard
library and are not supposed to be used in user code.</p>
<h2 id="invalid-from-utf8"><a class="header" href="#invalid-from-utf8">invalid-from-utf8</a></h2>
<p>The <code>invalid_from_utf8</code> lint checks for calls to
<code>std::str::from_utf8</code> and <code>std::str::from_utf8_mut</code>
with a known invalid UTF-8 value.</p>
<h3 id="example-48"><a class="header" href="#example-48">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#[allow(unused)]
</span>std::str::from_utf8(b"Ru\x82st");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: calls to `std::str::from_utf8` with an invalid literal always return an error
 --&gt; lint_example.rs:3:1
  |
3 | std::str::from_utf8(b"Ru\x82st");
  | ^^^^^^^^^^^^^^^^^^^^-----------^
  |                     |
  |                     the literal was valid UTF-8 up to the 2 bytes
  |
  = note: `#[warn(invalid_from_utf8)]` on by default

</code></pre>
<h3 id="explanation-48"><a class="header" href="#explanation-48">Explanation</a></h3>
<p>Trying to create such a <code>str</code> would always return an error as per documentation
for <code>std::str::from_utf8</code> and <code>std::str::from_utf8_mut</code>.</p>
<h2 id="invalid-nan-comparisons"><a class="header" href="#invalid-nan-comparisons">invalid-nan-comparisons</a></h2>
<p>The <code>invalid_nan_comparisons</code> lint checks comparison with <code>f32::NAN</code> or <code>f64::NAN</code>
as one of the operand.</p>
<h3 id="example-49"><a class="header" href="#example-49">Example</a></h3>
<pre><code class="language-rust">let a = 2.3f32;
if a == f32::NAN {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: incorrect NaN comparison, NaN cannot be directly compared to itself
 --&gt; lint_example.rs:3:4
  |
3 | if a == f32::NAN {}
  |    ^^^^^^^^^^^^^
  |
  = note: `#[warn(invalid_nan_comparisons)]` on by default
help: use `f32::is_nan()` or `f64::is_nan()` instead
  |
3 - if a == f32::NAN {}
3 + if a.is_nan() {}
  |

</code></pre>
<h3 id="explanation-49"><a class="header" href="#explanation-49">Explanation</a></h3>
<p>NaN does not compare meaningfully to anything – not
even itself – so those comparisons are always false.</p>
<h2 id="invalid-value"><a class="header" href="#invalid-value">invalid-value</a></h2>
<p>The <code>invalid_value</code> lint detects creating a value that is not valid,
such as a null reference.</p>
<h3 id="example-50"><a class="header" href="#example-50">Example</a></h3>
<pre><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>unsafe {
    let x: &amp;'static i32 = std::mem::zeroed();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the type `&amp;i32` does not permit zero-initialization
 --&gt; lint_example.rs:4:27
  |
4 |     let x: &amp;'static i32 = std::mem::zeroed();
  |                           ^^^^^^^^^^^^^^^^^^
  |                           |
  |                           this code causes undefined behavior when executed
  |                           help: use `MaybeUninit&lt;T&gt;` instead, and only call `assume_init` after initialization is done
  |
  = note: references must be non-null
  = note: `#[warn(invalid_value)]` on by default

</code></pre>
<h3 id="explanation-50"><a class="header" href="#explanation-50">Explanation</a></h3>
<p>In some situations the compiler can detect that the code is creating
an invalid value, which should be avoided.</p>
<p>In particular, this lint will check for improper use of
<a href="https://doc.rust-lang.org/std/mem/fn.zeroed.html"><code>mem::zeroed</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>mem::transmute</code></a>, and
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.assume_init"><code>MaybeUninit::assume_init</code></a> that can cause <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>. The
lint should provide extra information to indicate what the problem is
and a possible solution.</p>
<h2 id="irrefutable-let-patterns"><a class="header" href="#irrefutable-let-patterns">irrefutable-let-patterns</a></h2>
<p>The <code>irrefutable_let_patterns</code> lint detects <a href="https://doc.rust-lang.org/reference/patterns.html#refutability">irrefutable patterns</a>
in <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code></a>s, <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>s, and <code>if let</code> guards.</p>
<h3 id="example-51"><a class="header" href="#example-51">Example</a></h3>
<pre><code class="language-rust">if let _ = 123 {
    println!("always runs!");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: irrefutable `if let` pattern
 --&gt; lint_example.rs:2:4
  |
2 | if let _ = 123 {
  |    ^^^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

</code></pre>
<h3 id="explanation-51"><a class="header" href="#explanation-51">Explanation</a></h3>
<p>There usually isn’t a reason to have an irrefutable pattern in an
<code>if let</code> or <code>while let</code> statement, because the pattern will always match
successfully. A <a href="https://doc.rust-lang.org/reference/statements.html#let-statements"><code>let</code></a> or <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops"><code>loop</code></a> statement will suffice. However,
when generating code with a macro, forbidding irrefutable patterns
would require awkward workarounds in situations where the macro
doesn’t know if the pattern is refutable or not. This lint allows
macros to accept this form, while alerting for a possibly incorrect
use in normal code.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2086-allow-if-let-irrefutables.md">RFC 2086</a> for more details.</p>
<h2 id="large-assignments"><a class="header" href="#large-assignments">large-assignments</a></h2>
<p>The <code>large_assignments</code> lint detects when objects of large
types are being moved around.</p>
<h3 id="example-52"><a class="header" href="#example-52">Example</a></h3>
<pre><code class="language-rust ignore (can crash on some platforms)">let x = [0; 50000];
let y = x;</code></pre>
<p>produces:</p>
<pre><code class="language-text">warning: moving a large value
  --&gt; $DIR/move-large.rs:1:3
  let y = x;
          - Copied large value here
</code></pre>
<h3 id="explanation-52"><a class="header" href="#explanation-52">Explanation</a></h3>
<p>When using a large type in a plain assignment or in a function
argument, idiomatic code can be inefficient.
Ideally appropriate optimizations would resolve this, but such
optimizations are only done in a best-effort manner.
This lint will trigger on all sites of large moves and thus allow the
user to resolve them in code.</p>
<h2 id="late-bound-lifetime-arguments"><a class="header" href="#late-bound-lifetime-arguments">late-bound-lifetime-arguments</a></h2>
<p>The <code>late_bound_lifetime_arguments</code> lint detects generic lifetime
arguments in path segments with late bound lifetime parameters.</p>
<h3 id="example-53"><a class="header" href="#example-53">Example</a></h3>
<pre><code class="language-rust">struct S;

impl S {
    fn late(self, _: &amp;u8, _: &amp;u8) {}
}

fn main() {
    S.late::&lt;'static&gt;(&amp;0, &amp;0);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present
 --&gt; lint_example.rs:8:14
  |
4 |     fn late(self, _: &amp;u8, _: &amp;u8) {}
  |                      - the late bound lifetime parameter is introduced here
...
8 |     S.late::&lt;'static&gt;(&amp;0, &amp;0);
  |              ^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #42868 &lt;https://github.com/rust-lang/rust/issues/42868&gt;
  = note: `#[warn(late_bound_lifetime_arguments)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-53"><a class="header" href="#explanation-53">Explanation</a></h3>
<p>It is not clear how to provide arguments for early-bound lifetime
parameters if they are intermixed with late-bound parameters in the
same list. For now, providing any explicit arguments will trigger this
lint if late-bound parameters are present, so in the future a solution
can be adopted without hitting backward compatibility issues. This is
a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/42868">issue #42868</a> for more details, along with a description
of the difference between early and late-bound parameters.</p>
<h2 id="malformed-diagnostic-attributes"><a class="header" href="#malformed-diagnostic-attributes">malformed-diagnostic-attributes</a></h2>
<p>The <code>malformed_diagnostic_attributes</code> lint detects malformed diagnostic attributes.</p>
<h3 id="example-54"><a class="header" href="#example-54">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::do_not_recommend(message = "message")]
trait Trait {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[diagnostic::do_not_recommend]` does not expect any arguments
 --&gt; lint_example.rs:2:1
  |
2 | #[diagnostic::do_not_recommend(message = "message")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(malformed_diagnostic_attributes)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-54"><a class="header" href="#explanation-54">Explanation</a></h3>
<p>It is usually a mistake to use options or syntax that is not supported. Check the spelling,
and check the diagnostic attribute listing for the correct name and syntax. Also consider if
you are using an old version of the compiler; perhaps the option or syntax is only available
in a newer version. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for a list of diagnostic attributes and the syntax
of each.</p>
<h2 id="malformed-diagnostic-format-literals"><a class="header" href="#malformed-diagnostic-format-literals">malformed-diagnostic-format-literals</a></h2>
<p>The <code>malformed_diagnostic_format_literals</code> lint detects malformed diagnostic format
literals.</p>
<h3 id="example-55"><a class="header" href="#example-55">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::on_unimplemented(message = "{Self}} does not implement `Trait`")]
trait Trait {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unmatched `}` found
 --&gt; lint_example.rs:2:42
  |
2 | #[diagnostic::on_unimplemented(message = "{Self}} does not implement `Trait`")]
  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(malformed_diagnostic_format_literals)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-55"><a class="header" href="#explanation-55">Explanation</a></h3>
<p>The <code>#[diagnostic::on_unimplemented]</code> attribute accepts string literal values that are
similar to <code>format!</code>’s string literal. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for details on what is permitted
in this string literal.</p>
<h2 id="map-unit-fn"><a class="header" href="#map-unit-fn">map-unit-fn</a></h2>
<p>The <code>map_unit_fn</code> lint checks for <code>Iterator::map</code> receive
a callable that returns <code>()</code>.</p>
<h3 id="example-56"><a class="header" href="#example-56">Example</a></h3>
<pre><code class="language-rust">fn foo(items: &amp;mut Vec&lt;u8&gt;) {
    items.sort();
}

fn main() {
    let mut x: Vec&lt;Vec&lt;u8&gt;&gt; = vec![
        vec![0, 2, 1],
        vec![5, 4, 3],
    ];
    x.iter_mut().map(foo);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `Iterator::map` call that discard the iterator's values
  --&gt; lint_example.rs:10:18
   |
 1 | fn foo(items: &amp;mut Vec&lt;u8&gt;) {
   | --------------------------- this function returns `()`, which is likely not what you wanted
...
10 |     x.iter_mut().map(foo);
   |                  ^^^^---^
   |                  |   |
   |                  |   called `Iterator::map` with callable that returns `()`
   |                  after this call to map, the resulting iterator is `impl Iterator&lt;Item = ()&gt;`, which means the only information carried by the iterator is the number of items
   |
   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated
   = note: `#[warn(map_unit_fn)]` (part of `#[warn(unused)]`) on by default
help: you might have meant to use `Iterator::for_each`
   |
10 -     x.iter_mut().map(foo);
10 +     x.iter_mut().for_each(foo);
   |

</code></pre>
<h3 id="explanation-56"><a class="header" href="#explanation-56">Explanation</a></h3>
<p>Mapping to <code>()</code> is almost always a mistake.</p>
<h2 id="mismatched-lifetime-syntaxes"><a class="header" href="#mismatched-lifetime-syntaxes">mismatched-lifetime-syntaxes</a></h2>
<p>The <code>mismatched_lifetime_syntaxes</code> lint detects when the same
lifetime is referred to by different syntaxes between function
arguments and return values.</p>
<p>The three kinds of syntaxes are:</p>
<ol>
<li>
<p>Named lifetimes. These are references (<code>&amp;'a str</code>) or paths
(<code>Person&lt;'a&gt;</code>) that use a lifetime with a name, such as
<code>'static</code> or <code>'a</code>.</p>
</li>
<li>
<p>Elided lifetimes. These are references with no explicit
lifetime (<code>&amp;str</code>), references using the anonymous lifetime
(<code>&amp;'_ str</code>), and paths using the anonymous lifetime
(<code>Person&lt;'_&gt;</code>).</p>
</li>
<li>
<p>Hidden lifetimes. These are paths that do not contain any
visual indication that it contains a lifetime (<code>Person</code>).</p>
</li>
</ol>
<h3 id="example-57"><a class="header" href="#example-57">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(mismatched_lifetime_syntaxes)]

pub fn mixing_named_with_elided(v: &amp;'static u8) -&gt; &amp;u8 {
    v
}

struct Person&lt;'a&gt; {
    name: &amp;'a str,
}

pub fn mixing_hidden_with_elided(v: Person) -&gt; Person&lt;'_&gt; {
    v
}

struct Foo;

impl Foo {
    // Lifetime elision results in the output lifetime becoming
    // `'static`, which is not what was intended.
    pub fn get_mut(&amp;'static self, x: &amp;mut u8) -&gt; &amp;mut u8 {
        unsafe { &amp;mut *(x as *mut _) }
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: eliding a lifetime that's named elsewhere is confusing
 --&gt; lint_example.rs:4:52
  |
4 | pub fn mixing_named_with_elided(v: &amp;'static u8) -&gt; &amp;u8 {
  |                                     -------        ^^^ the same lifetime is elided here
  |                                     |
  |                                     the lifetime is named here
  |
  = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(mismatched_lifetime_syntaxes)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consistently use `'static`
  |
4 | pub fn mixing_named_with_elided(v: &amp;'static u8) -&gt; &amp;'static u8 {
  |                                                     +++++++


error: hiding a lifetime that's elided elsewhere is confusing
  --&gt; lint_example.rs:12:37
   |
12 | pub fn mixing_hidden_with_elided(v: Person) -&gt; Person&lt;'_&gt; {
   |                                     ^^^^^^            ^^ the same lifetime is elided here
   |                                     |
   |                                     the lifetime is hidden here
   |
   = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: consistently use `'_`
   |
12 | pub fn mixing_hidden_with_elided(v: Person&lt;'_&gt;) -&gt; Person&lt;'_&gt; {
   |                                           ++++


error: eliding a lifetime that's named elsewhere is confusing
  --&gt; lint_example.rs:21:50
   |
21 |     pub fn get_mut(&amp;'static self, x: &amp;mut u8) -&gt; &amp;mut u8 {
   |                     -------                      ^^^^^^^ the same lifetime is elided here
   |                     |
   |                     the lifetime is named here
   |
   = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
help: consistently use `'static`
   |
21 |     pub fn get_mut(&amp;'static self, x: &amp;mut u8) -&gt; &amp;'static mut u8 {
   |                                                   +++++++

</code></pre>
<h3 id="explanation-57"><a class="header" href="#explanation-57">Explanation</a></h3>
<p>Lifetime elision is useful because it frees you from having to
give each lifetime its own name and show the relation of input
and output lifetimes for common cases. However, a lifetime
that uses inconsistent syntax between related arguments and
return values is more confusing.</p>
<p>In certain <code>unsafe</code> code, lifetime elision combined with
inconsistent lifetime syntax may result in unsound code.</p>
<h2 id="misplaced-diagnostic-attributes"><a class="header" href="#misplaced-diagnostic-attributes">misplaced-diagnostic-attributes</a></h2>
<p>The <code>misplaced_diagnostic_attributes</code> lint detects wrongly placed diagnostic attributes.</p>
<h3 id="example-58"><a class="header" href="#example-58">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::do_not_recommend]
struct NotUserFacing;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[diagnostic::do_not_recommend]` can only be placed on trait implementations
 --&gt; lint_example.rs:2:1
  |
2 | #[diagnostic::do_not_recommend]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(misplaced_diagnostic_attributes)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-58"><a class="header" href="#explanation-58">Explanation</a></h3>
<p>It is usually a mistake to specify a diagnostic attribute on an item it is not meant for.
For example, <code>#[diagnostic::do_not_recommend]</code> can only be placed on trait implementations,
and does nothing if placed elsewhere. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for a list of diagnostic
attributes and their correct positions.</p>
<h2 id="missing-abi"><a class="header" href="#missing-abi">missing-abi</a></h2>
<p>The <code>missing_abi</code> lint detects cases where the ABI is omitted from
<code>extern</code> declarations.</p>
<h3 id="example-59"><a class="header" href="#example-59">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_abi)]

extern fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `extern` declarations without an explicit ABI are deprecated
 --&gt; lint_example.rs:4:1
  |
4 | extern fn foo() {}
  | ^^^^^^ help: explicitly specify the "C" ABI: `extern "C"`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_abi)]
  |         ^^^^^^^^^^^

</code></pre>
<h3 id="explanation-59"><a class="header" href="#explanation-59">Explanation</a></h3>
<p>For historic reasons, Rust implicitly selects <code>C</code> as the default ABI for
<code>extern</code> declarations. <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#abi">Other ABIs</a> like <code>C-unwind</code> and <code>system</code> have
been added since then, and especially with their addition seeing the ABI
easily makes code review easier.</p>
<h2 id="missing-gpu-kernel-export-name"><a class="header" href="#missing-gpu-kernel-export-name">missing-gpu-kernel-export-name</a></h2>
<p>The <code>missing_gpu_kernel_export_name</code> lint detects <code>gpu-kernel</code> functions that have a mangled name.</p>
<h3 id="example-60"><a class="header" href="#example-60">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-GPU targets)">extern "gpu-kernel" fn kernel() { }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function with the "gpu-kernel" ABI has a mangled name
 --&gt; t.rs:1:1
  |
1 | extern "gpu-kernel" fn kernel() {}
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: use `unsafe(no_mangle)` or `unsafe(export_name = "&lt;name&gt;")`
  = note: mangled names make it hard to find the kernel, this is usually not intended
  = note: `#[warn(missing_gpu_kernel_export_name)]` on by default
</code></pre>
<h3 id="explanation-60"><a class="header" href="#explanation-60">Explanation</a></h3>
<p><code>gpu-kernel</code> functions are usually searched by name in the compiled file.
A mangled name is usually unintentional as it would need to be searched by the mangled name.</p>
<p>To use an unmangled name for the kernel, either <code>no_mangle</code> or <code>export_name</code> can be used.</p>
<pre><code class="language-rust ignore (fails on non-GPU targets)">// Can be found by the name "kernel"
#[unsafe(no_mangle)]
extern "gpu-kernel" fn kernel() { }

// Can be found by the name "new_name"
#[unsafe(export_name = "new_name")]
extern "gpu-kernel" fn other_kernel() { }</code></pre>
<h2 id="mixed-script-confusables"><a class="header" href="#mixed-script-confusables">mixed-script-confusables</a></h2>
<p>The <code>mixed_script_confusables</code> lint detects visually confusable
characters in identifiers between different <a href="https://en.wikipedia.org/wiki/Script_(Unicode)">scripts</a>.</p>
<h3 id="example-61"><a class="header" href="#example-61">Example</a></h3>
<pre><code class="language-rust">// The Japanese katakana character エ can be confused with the Han character 工.
const エ: &amp;'static str = "アイウ";</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the usage of Script Group `Japanese, Katakana` in this crate consists solely of mixed script confusables
 --&gt; lint_example.rs:3:7
  |
3 | const エ: &amp;'static str = "アイウ";
  |       ^^
  |
  = note: the usage includes 'エ' (U+30A8)
  = note: please recheck to make sure their usages are indeed what you want
  = note: `#[warn(mixed_script_confusables)]` on by default

</code></pre>
<h3 id="explanation-61"><a class="header" href="#explanation-61">Explanation</a></h3>
<p>This lint warns when characters between different scripts may appear
visually similar, which can cause confusion.</p>
<p>If the crate contains other identifiers in the same script that have
non-confusable characters, then this lint will <em>not</em> be issued. For
example, if the example given above has another identifier with
katakana characters (such as <code>let カタカナ = 123;</code>), then this indicates
that you are intentionally using katakana, and it will not warn about
it.</p>
<p>Note that the set of confusable characters may change over time.
Beware that if you “forbid” this lint that existing code may fail in
the future.</p>
<h2 id="named-arguments-used-positionally"><a class="header" href="#named-arguments-used-positionally">named-arguments-used-positionally</a></h2>
<p>The <code>named_arguments_used_positionally</code> lint detects cases where named arguments are only
used positionally in format strings. This usage is valid but potentially very confusing.</p>
<h3 id="example-62"><a class="header" href="#example-62">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(named_arguments_used_positionally)]
fn main() {
    let _x = 5;
    println!("{}", _x = 1); // Prints 1, will trigger lint

    println!("{}", _x); // Prints 5, no lint emitted
    println!("{_x}", _x = _x); // Prints 5, no lint emitted
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: named argument `_x` is not used by name
 --&gt; lint_example.rs:4:20
  |
4 |     println!("{}", _x = 1); // Prints 1, will trigger lint
  |               --   ^^ this named argument is referred to by position in formatting string
  |               |
  |               this formatting argument uses named argument `_x` by position
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(named_arguments_used_positionally)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use the named argument by name to avoid ambiguity
  |
4 |     println!("{_x}", _x = 1); // Prints 1, will trigger lint
  |                ++

</code></pre>
<h3 id="explanation-62"><a class="header" href="#explanation-62">Explanation</a></h3>
<p>Rust formatting strings can refer to named arguments by their position, but this usage is
potentially confusing. In particular, readers can incorrectly assume that the declaration
of named arguments is an assignment (which would produce the unit type).
For backwards compatibility, this is not a hard error.</p>
<h2 id="no-mangle-generic-items"><a class="header" href="#no-mangle-generic-items">no-mangle-generic-items</a></h2>
<p>The <code>no_mangle_generic_items</code> lint detects generic items that must be
mangled.</p>
<h3 id="example-63"><a class="header" href="#example-63">Example</a></h3>
<pre><code class="language-rust">#[unsafe(no_mangle)]
fn foo&lt;T&gt;(t: T) {}

#[unsafe(export_name = "bar")]
fn bar&lt;T&gt;(t: T) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: functions generic over types or consts must be mangled
 --&gt; lint_example.rs:3:1
  |
2 | #[unsafe(no_mangle)]
  | -------------------- help: remove this attribute
3 | fn foo&lt;T&gt;(t: T) {}
  | ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(no_mangle_generic_items)]` on by default


warning: functions generic over types or consts must be mangled
 --&gt; lint_example.rs:6:1
  |
5 | #[unsafe(export_name = "bar")]
  | ------------------------------ help: remove this attribute
6 | fn bar&lt;T&gt;(t: T) {}
  | ^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-63"><a class="header" href="#explanation-63">Explanation</a></h3>
<p>A function with generics must have its symbol mangled to accommodate
the generic parameter. The <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> and <a href="https://doc.rust-lang.org/reference/abi.html#the-export_name-attribute"><code>export_name</code></a> attributes
have no effect in this situation, and should be removed.</p>
<h2 id="non-fmt-panic"><a class="header" href="#non-fmt-panic">non-fmt-panic</a></h2>
<p>The lint <code>non-fmt-panic</code> has been renamed to <a href="#non-fmt-panics"><code>non-fmt-panics</code></a>.</p>
<h2 id="non-camel-case-types"><a class="header" href="#non-camel-case-types">non-camel-case-types</a></h2>
<p>The <code>non_camel_case_types</code> lint detects types, variants, traits and
type parameters that don’t have camel case names.</p>
<h3 id="example-64"><a class="header" href="#example-64">Example</a></h3>
<pre><code class="language-rust">struct my_struct;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type `my_struct` should have an upper camel case name
 --&gt; lint_example.rs:2:8
  |
2 | struct my_struct;
  |        ^^^^^^^^^ help: convert the identifier to upper camel case: `MyStruct`
  |
  = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

</code></pre>
<h3 id="explanation-64"><a class="header" href="#explanation-64">Explanation</a></h3>
<p>The preferred style for these identifiers is to use “camel case”, such
as <code>MyStruct</code>, where the first letter should not be lowercase, and
should not use underscores between letters. Underscores are allowed at
the beginning and end of the identifier, as well as between
non-letters (such as <code>X86_64</code>).</p>
<h2 id="non-contiguous-range-endpoints"><a class="header" href="#non-contiguous-range-endpoints">non-contiguous-range-endpoints</a></h2>
<p>The <code>non_contiguous_range_endpoints</code> lint detects likely off-by-one errors when using
exclusive <a href="https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns">range patterns</a>.</p>
<h3 id="example-65"><a class="header" href="#example-65">Example</a></h3>
<pre><code class="language-rust">let x = 123u32;
match x {
    0..100 =&gt; { println!("small"); }
    101..1000 =&gt; { println!("large"); }
    _ =&gt; { println!("larger"); }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: multiple ranges are one apart
 --&gt; lint_example.rs:4:5
  |
4 |     0..100 =&gt; { println!("small"); }
  |     ^^^^^^
  |     |
  |     this range doesn't match `100_u32` because `..` is an exclusive range
  |     help: use an inclusive range instead: `0_u32..=100_u32`
5 |     101..1000 =&gt; { println!("large"); }
  |     --------- this could appear to continue range `0_u32..100_u32`, but `100_u32` isn't matched by either of them
  |
  = note: `#[warn(non_contiguous_range_endpoints)]` on by default

</code></pre>
<h3 id="explanation-65"><a class="header" href="#explanation-65">Explanation</a></h3>
<p>It is likely a mistake to have range patterns in a match expression that miss out a single
number. Check that the beginning and end values are what you expect, and keep in mind that
with <code>..=</code> the right bound is inclusive, and with <code>..</code> it is exclusive.</p>
<h2 id="non-fmt-panics"><a class="header" href="#non-fmt-panics">non-fmt-panics</a></h2>
<p>The <code>non_fmt_panics</code> lint detects <code>panic!(..)</code> invocations where the first
argument is not a formatting string.</p>
<h3 id="example-66"><a class="header" href="#example-66">Example</a></h3>
<pre><code class="language-rust no_run edition2018">panic!("{}");
panic!(123);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: panic message contains an unused formatting placeholder
 --&gt; lint_example.rs:2:9
  |
2 | panic!("{}");
  |         ^^
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&gt;
  = note: this message is not used as a format string when given without arguments, but will be in Rust 2021
  = note: `#[warn(non_fmt_panics)]` (part of `#[warn(rust_2021_compatibility)]`) on by default
help: add the missing argument
  |
2 | panic!("{}", ...);
  |            +++++
help: or add a "{}" format string to use the message literally
  |
2 | panic!("{}", "{}");
  |        +++++


warning: panic message is not a string literal
 --&gt; lint_example.rs:3:8
  |
3 | panic!(123);
  |        ^^^
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&gt;
  = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&gt;
help: add a "{}" format string to `Display` the message
  |
3 | panic!("{}", 123);
  |        +++++
help: or use std::panic::panic_any instead
  |
3 - panic!(123);
3 + std::panic::panic_any(123);
  |

</code></pre>
<h3 id="explanation-66"><a class="header" href="#explanation-66">Explanation</a></h3>
<p>In Rust 2018 and earlier, <code>panic!(x)</code> directly uses <code>x</code> as the message.
That means that <code>panic!("{}")</code> panics with the message <code>"{}"</code> instead
of using it as a formatting string, and <code>panic!(123)</code> will panic with
an <code>i32</code> as message.</p>
<p>Rust 2021 always interprets the first argument as format string.</p>
<h2 id="non-local-definitions"><a class="header" href="#non-local-definitions">non-local-definitions</a></h2>
<p>The <code>non_local_definitions</code> lint checks for <code>impl</code> blocks and <code>#[macro_export]</code>
macro inside bodies (functions, enum discriminant, …).</p>
<h3 id="example-67"><a class="header" href="#example-67">Example</a></h3>
<pre><code class="language-rust">#![warn(non_local_definitions)]
trait MyTrait {}
struct MyStruct;

fn foo() {
    impl MyTrait for MyStruct {}
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: non-local `impl` definition, `impl` blocks should be written at the same level as their item
 --&gt; lint_example.rs:7:5
  |
6 | fn foo() {
  | -------- move the `impl` block outside of this function `foo` and up 2 bodies
7 |     impl MyTrait for MyStruct {}
  |     ^^^^^-------^^^^^--------
  |          |           |
  |          |           `MyStruct` is not local
  |          `MyTrait` is not local
  |
  = note: an `impl` is never scoped, even when it is nested inside an item, as it may impact type checking outside of that item, which can be the case if neither the trait or the self type are at the same nesting level as the `impl`
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(non_local_definitions)]
  |         ^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-67"><a class="header" href="#explanation-67">Explanation</a></h3>
<p>Creating non-local definitions go against expectation and can create discrepancies
in tooling. It should be avoided. It may become deny-by-default in edition 2024
and higher, see the tracking issue <a href="https://github.com/rust-lang/rust/issues/120363">https://github.com/rust-lang/rust/issues/120363</a>.</p>
<p>An <code>impl</code> definition is non-local if it is nested inside an item and neither
the type nor the trait are at the same nesting level as the <code>impl</code> block.</p>
<p>All nested bodies (functions, enum discriminant, array length, consts) (expect for
<code>const _: Ty = { ... }</code> in top-level module, which is still undecided) are checked.</p>
<h2 id="non-shorthand-field-patterns"><a class="header" href="#non-shorthand-field-patterns">non-shorthand-field-patterns</a></h2>
<p>The <code>non_shorthand_field_patterns</code> lint detects using <code>Struct { x: x }</code>
instead of <code>Struct { x }</code> in a pattern.</p>
<h3 id="example-68"><a class="header" href="#example-68">Example</a></h3>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}


fn main() {
    let p = Point {
        x: 5,
        y: 5,
    };

    match p {
        Point { x: x, y: y } =&gt; (),
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the `x:` in this pattern is redundant
  --&gt; lint_example.rs:14:17
   |
14 |         Point { x: x, y: y } =&gt; (),
   |                 ^^^^ help: use shorthand field pattern: `x`
   |
   = note: `#[warn(non_shorthand_field_patterns)]` on by default


warning: the `y:` in this pattern is redundant
  --&gt; lint_example.rs:14:23
   |
14 |         Point { x: x, y: y } =&gt; (),
   |                       ^^^^ help: use shorthand field pattern: `y`

</code></pre>
<h3 id="explanation-68"><a class="header" href="#explanation-68">Explanation</a></h3>
<p>The preferred style is to avoid the repetition of specifying both the
field name and the binding name if both identifiers are the same.</p>
<h2 id="non-snake-case"><a class="header" href="#non-snake-case">non-snake-case</a></h2>
<p>The <code>non_snake_case</code> lint detects variables, methods, functions,
lifetime parameters and modules that don’t have snake case names.</p>
<h3 id="example-69"><a class="header" href="#example-69">Example</a></h3>
<pre><code class="language-rust">let MY_VALUE = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable `MY_VALUE` should have a snake case name
 --&gt; lint_example.rs:2:5
  |
2 | let MY_VALUE = 5;
  |     ^^^^^^^^ help: convert the identifier to snake case: `my_value`
  |
  = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

</code></pre>
<h3 id="explanation-69"><a class="header" href="#explanation-69">Explanation</a></h3>
<p>The preferred style for these identifiers is to use “snake case”,
where all the characters are in lowercase, with words separated with a
single underscore, such as <code>my_value</code>.</p>
<h2 id="non-upper-case-globals"><a class="header" href="#non-upper-case-globals">non-upper-case-globals</a></h2>
<p>The <code>non_upper_case_globals</code> lint detects static items that don’t have
uppercase identifiers.</p>
<h3 id="example-70"><a class="header" href="#example-70">Example</a></h3>
<pre><code class="language-rust">static max_points: i32 = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static variable `max_points` should have an upper case name
 --&gt; lint_example.rs:2:8
  |
2 | static max_points: i32 = 5;
  |        ^^^^^^^^^^ help: convert the identifier to upper case: `MAX_POINTS`
  |
  = note: `#[warn(non_upper_case_globals)]` (part of `#[warn(nonstandard_style)]`) on by default

</code></pre>
<h3 id="explanation-70"><a class="header" href="#explanation-70">Explanation</a></h3>
<p>The preferred style is for static item names to use all uppercase
letters such as <code>MAX_POINTS</code>.</p>
<h2 id="noop-method-call"><a class="header" href="#noop-method-call">noop-method-call</a></h2>
<p>The <code>noop_method_call</code> lint detects specific calls to noop methods
such as a calling <code>&lt;&amp;T as Clone&gt;::clone</code> where <code>T: !Clone</code>.</p>
<h3 id="example-71"><a class="header" href="#example-71">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>struct Foo;
let foo = &amp;Foo;
let clone: &amp;Foo = foo.clone();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: call to `.clone()` on a reference in this situation does nothing
 --&gt; lint_example.rs:5:22
  |
5 | let clone: &amp;Foo = foo.clone();
  |                      ^^^^^^^^
  |
  = note: the type `Foo` does not implement `Clone`, so calling `clone` on `&amp;Foo` copies the reference, which does not do anything and can be removed
  = note: `#[warn(noop_method_call)]` on by default
help: remove this redundant call
  |
5 - let clone: &amp;Foo = foo.clone();
5 + let clone: &amp;Foo = foo;
  |
help: if you meant to clone `Foo`, implement `Clone` for it
  |
3 + #[derive(Clone)]
4 | struct Foo;
  |

</code></pre>
<h3 id="explanation-71"><a class="header" href="#explanation-71">Explanation</a></h3>
<p>Some method calls are noops meaning that they do nothing. Usually such methods
are the result of blanket implementations that happen to create some method invocations
that end up not doing anything. For instance, <code>Clone</code> is implemented on all <code>&amp;T</code>, but
calling <code>clone</code> on a <code>&amp;T</code> where <code>T</code> does not implement clone, actually doesn’t do anything
as references are copy. This lint detects these calls and warns the user about them.</p>
<h2 id="opaque-hidden-inferred-bound"><a class="header" href="#opaque-hidden-inferred-bound">opaque-hidden-inferred-bound</a></h2>
<p>The <code>opaque_hidden_inferred_bound</code> lint detects cases in which nested
<code>impl Trait</code> in associated type bounds are not written generally enough
to satisfy the bounds of the associated type.</p>
<h3 id="explanation-72"><a class="header" href="#explanation-72">Explanation</a></h3>
<p>This functionality was removed in #97346, but then rolled back in #99860
because it caused regressions.</p>
<p>We plan on reintroducing this as a hard error, but in the meantime,
this lint serves to warn and suggest fixes for any use-cases which rely
on this behavior.</p>
<h3 id="example-72"><a class="header" href="#example-72">Example</a></h3>
<pre><code class="language-rust">#![feature(type_alias_impl_trait)]

trait Duh {}

impl Duh for i32 {}

trait Trait {
    type Assoc: Duh;
}

impl&lt;F: Duh&gt; Trait for F {
    type Assoc = F;
}

type Tait = impl Sized;

#[define_opaque(Tait)]
fn test() -&gt; impl Trait&lt;Assoc = Tait&gt; {
    42
}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: opaque type `impl Trait&lt;Assoc = Tait&gt;` does not satisfy its associated type bounds
  --&gt; lint_example.rs:18:25
   |
 8 |     type Assoc: Duh;
   |                 --- this associated type bound is unsatisfied for `Tait`
...
18 | fn test() -&gt; impl Trait&lt;Assoc = Tait&gt; {
   |                         ^^^^^^^^^^^^
   |
   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default

</code></pre>
<p>In this example, <code>test</code> declares that the associated type <code>Assoc</code> for
<code>impl Trait</code> is <code>impl Sized</code>, which does not satisfy the bound <code>Duh</code>
on the associated type.</p>
<p>Although the hidden type, <code>i32</code> does satisfy this bound, we do not
consider the return type to be well-formed with this lint. It can be
fixed by changing <code>Tait = impl Sized</code> into <code>Tait = impl Sized + Duh</code>.</p>
<h2 id="overlapping-patterns"><a class="header" href="#overlapping-patterns">overlapping-patterns</a></h2>
<p>The lint <code>overlapping-patterns</code> has been renamed to <a href="#overlapping-range-endpoints"><code>overlapping-range-endpoints</code></a>.</p>
<h2 id="overlapping-range-endpoints"><a class="header" href="#overlapping-range-endpoints">overlapping-range-endpoints</a></h2>
<p>The <code>overlapping_range_endpoints</code> lint detects <code>match</code> arms that have <a href="https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns">range patterns</a> that
overlap on their endpoints.</p>
<h3 id="example-73"><a class="header" href="#example-73">Example</a></h3>
<pre><code class="language-rust">let x = 123u8;
match x {
    0..=100 =&gt; { println!("small"); }
    100..=255 =&gt; { println!("large"); }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: multiple patterns overlap on their endpoints
 --&gt; lint_example.rs:5:5
  |
4 |     0..=100 =&gt; { println!("small"); }
  |     ------- this range overlaps on `100_u8`...
5 |     100..=255 =&gt; { println!("large"); }
  |     ^^^^^^^^^ ... with this range
  |
  = note: you likely meant to write mutually exclusive ranges
  = note: `#[warn(overlapping_range_endpoints)]` on by default

</code></pre>
<h3 id="explanation-73"><a class="header" href="#explanation-73">Explanation</a></h3>
<p>It is likely a mistake to have range patterns in a match expression that overlap in this
way. Check that the beginning and end values are what you expect, and keep in mind that
with <code>..=</code> the left and right bounds are inclusive.</p>
<h2 id="path-statements"><a class="header" href="#path-statements">path-statements</a></h2>
<p>The <code>path_statements</code> lint detects path statements with no effect.</p>
<h3 id="example-74"><a class="header" href="#example-74">Example</a></h3>
<pre><code class="language-rust">let x = 42;

x;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: path statement with no effect
 --&gt; lint_example.rs:4:1
  |
4 | x;
  | ^^
  |
  = note: `#[warn(path_statements)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-74"><a class="header" href="#explanation-74">Explanation</a></h3>
<p>It is usually a mistake to have a statement that has no effect.</p>
<h2 id="private-bounds"><a class="header" href="#private-bounds">private-bounds</a></h2>
<p>The <code>private_bounds</code> lint detects types in a secondary interface of an item,
that are more private than the item itself. Secondary interface of an item consists of
bounds on generic parameters and where clauses, including supertraits for trait items.</p>
<h3 id="example-75"><a class="header" href="#example-75">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(private_bounds)]

struct PrivTy;
pub struct S
    where PrivTy:
{}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type `PrivTy` is more private than the item `S`
 --&gt; lint_example.rs:5:1
  |
5 | pub struct S
  | ^^^^^^^^^^^^ struct `S` is reachable at visibility `pub`
  |
note: but type `PrivTy` is only usable at visibility `pub(crate)`
 --&gt; lint_example.rs:4:1
  |
4 | struct PrivTy;
  | ^^^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(private_bounds)]
  |         ^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-75"><a class="header" href="#explanation-75">Explanation</a></h3>
<p>Having private types or traits in item bounds makes it less clear what interface
the item actually provides.</p>
<h2 id="private-interfaces"><a class="header" href="#private-interfaces">private-interfaces</a></h2>
<p>The <code>private_interfaces</code> lint detects types in a primary interface of an item,
that are more private than the item itself. Primary interface of an item is all
its interface except for bounds on generic parameters and where clauses.</p>
<h3 id="example-76"><a class="header" href="#example-76">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(private_interfaces)]
struct SemiPriv;

mod m1 {
    struct Priv;
    impl crate::SemiPriv {
        pub fn f(_: Priv) {}
    }
}

<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type `Priv` is more private than the item `m1::&lt;impl SemiPriv&gt;::f`
 --&gt; lint_example.rs:8:9
  |
8 |         pub fn f(_: Priv) {}
  |         ^^^^^^^^^^^^^^^^^ associated function `m1::&lt;impl SemiPriv&gt;::f` is reachable at visibility `pub(crate)`
  |
note: but type `Priv` is only usable at visibility `pub(self)`
 --&gt; lint_example.rs:6:5
  |
6 |     struct Priv;
  |     ^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(private_interfaces)]
  |         ^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-76"><a class="header" href="#explanation-76">Explanation</a></h3>
<p>Having something private in primary interface guarantees that
the item will be unusable from outer modules due to type privacy.</p>
<h2 id="ptr-to-integer-transmute-in-consts"><a class="header" href="#ptr-to-integer-transmute-in-consts">ptr-to-integer-transmute-in-consts</a></h2>
<p>The <code>ptr_to_integer_transmute_in_consts</code> lint detects pointer to integer
transmute in const functions and associated constants.</p>
<h3 id="example-77"><a class="header" href="#example-77">Example</a></h3>
<pre><code class="language-rust">const fn foo(ptr: *const u8) -&gt; usize {
   unsafe {
       std::mem::transmute::&lt;*const u8, usize&gt;(ptr)
   }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: pointers cannot be transmuted to integers during const eval
 --&gt; lint_example.rs:4:8
  |
4 |        std::mem::transmute::&lt;*const u8, usize&gt;(ptr)
  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: at compile-time, pointers do not have an integer value
  = note: avoiding this restriction via `union` or raw pointers leads to compile-time undefined behavior
  = help: for more information, see https://doc.rust-lang.org/std/mem/fn.transmute.html
  = note: `#[warn(ptr_to_integer_transmute_in_consts)]` on by default

</code></pre>
<h3 id="explanation-77"><a class="header" href="#explanation-77">Explanation</a></h3>
<p>Transmuting pointers to integers in a <code>const</code> context is undefined behavior.
Any attempt to use the resulting integer will abort const-evaluation.</p>
<p>But sometimes the compiler might not emit an error for pointer to integer transmutes
inside const functions and associated consts because they are evaluated only when referenced.
Therefore, this lint serves as an extra layer of defense to prevent any undefined behavior
from compiling without any warnings or errors.</p>
<p>See <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html">std::mem::transmute</a> in the reference for more details.</p>
<h2 id="redundant-semicolon"><a class="header" href="#redundant-semicolon">redundant-semicolon</a></h2>
<p>The lint <code>redundant-semicolon</code> has been renamed to <a href="#redundant-semicolons"><code>redundant-semicolons</code></a>.</p>
<h2 id="redundant-semicolons"><a class="header" href="#redundant-semicolons">redundant-semicolons</a></h2>
<p>The <code>redundant_semicolons</code> lint detects unnecessary trailing
semicolons.</p>
<h3 id="example-78"><a class="header" href="#example-78">Example</a></h3>
<pre><code class="language-rust">let _ = 123;;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary trailing semicolon
 --&gt; lint_example.rs:2:13
  |
2 | let _ = 123;;
  |             ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-78"><a class="header" href="#explanation-78">Explanation</a></h3>
<p>Extra semicolons are not needed, and may be removed to avoid confusion
and visual clutter.</p>
<h2 id="refining-impl-trait-internal"><a class="header" href="#refining-impl-trait-internal">refining-impl-trait-internal</a></h2>
<p>The <code>refining_impl_trait_internal</code> lint detects <code>impl Trait</code> return
types in method signatures that are refined by a trait implementation,
meaning the implementation adds information about the return type that
is not present in the trait.</p>
<h3 id="example-79"><a class="header" href="#example-79">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(refining_impl_trait)]

use std::fmt::Display;

trait AsDisplay {
    fn as_display(&amp;self) -&gt; impl Display;
}

impl&lt;'s&gt; AsDisplay for &amp;'s str {
    fn as_display(&amp;self) -&gt; Self {
        *self
    }
}

fn main() {
    // users can observe that the return type of
    // `&lt;&amp;str as AsDisplay&gt;::as_display()` is `&amp;str`.
    let _x: &amp;str = "".as_display();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: impl trait in impl method signature does not match trait method signature
  --&gt; lint_example.rs:10:29
   |
 6 |     fn as_display(&amp;self) -&gt; impl Display;
   |                             ------------ return type from trait method defined here
...
10 |     fn as_display(&amp;self) -&gt; Self {
   |                             ^^^^
   |
   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate
   = note: we are soliciting feedback, see issue #121718 &lt;https://github.com/rust-lang/rust/issues/121718&gt; for more information
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(refining_impl_trait)]
   |         ^^^^^^^^^^^^^^^^^^^
   = note: `#[deny(refining_impl_trait_internal)]` implied by `#[deny(refining_impl_trait)]`
help: replace the return type so that it matches the trait
   |
10 -     fn as_display(&amp;self) -&gt; Self {
10 +     fn as_display(&amp;self) -&gt; impl std::fmt::Display {
   |

</code></pre>
<h3 id="explanation-79"><a class="header" href="#explanation-79">Explanation</a></h3>
<p>Callers of methods for types where the implementation is known are
able to observe the types written in the impl signature. This may be
intended behavior, but may also lead to implementation details being
revealed unintentionally. In particular, it may pose a semver hazard
for authors of libraries who do not wish to make stronger guarantees
about the types than what is written in the trait signature.</p>
<p><code>refining_impl_trait</code> is a lint group composed of two lints:</p>
<ul>
<li><code>refining_impl_trait_reachable</code>, for refinements that are publically
reachable outside a crate, and</li>
<li><code>refining_impl_trait_internal</code>, for refinements that are only visible
within a crate.</li>
</ul>
<p>We are seeking feedback on each of these lints; see issue
<a href="https://github.com/rust-lang/rust/issues/121718">#121718</a> for more
information.</p>
<h2 id="refining-impl-trait-reachable"><a class="header" href="#refining-impl-trait-reachable">refining-impl-trait-reachable</a></h2>
<p>The <code>refining_impl_trait_reachable</code> lint detects <code>impl Trait</code> return
types in method signatures that are refined by a publically reachable
trait implementation, meaning the implementation adds information about
the return type that is not present in the trait.</p>
<h3 id="example-80"><a class="header" href="#example-80">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(refining_impl_trait)]

use std::fmt::Display;

pub trait AsDisplay {
    fn as_display(&amp;self) -&gt; impl Display;
}

impl&lt;'s&gt; AsDisplay for &amp;'s str {
    fn as_display(&amp;self) -&gt; Self {
        *self
    }
}

fn main() {
    // users can observe that the return type of
    // `&lt;&amp;str as AsDisplay&gt;::as_display()` is `&amp;str`.
    let _x: &amp;str = "".as_display();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: impl trait in impl method signature does not match trait method signature
  --&gt; lint_example.rs:10:29
   |
 6 |     fn as_display(&amp;self) -&gt; impl Display;
   |                             ------------ return type from trait method defined here
...
10 |     fn as_display(&amp;self) -&gt; Self {
   |                             ^^^^
   |
   = note: add `#[allow(refining_impl_trait)]` if it is intended for this to be part of the public API of this crate
   = note: we are soliciting feedback, see issue #121718 &lt;https://github.com/rust-lang/rust/issues/121718&gt; for more information
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(refining_impl_trait)]
   |         ^^^^^^^^^^^^^^^^^^^
   = note: `#[deny(refining_impl_trait_reachable)]` implied by `#[deny(refining_impl_trait)]`
help: replace the return type so that it matches the trait
   |
10 -     fn as_display(&amp;self) -&gt; Self {
10 +     fn as_display(&amp;self) -&gt; impl std::fmt::Display {
   |

</code></pre>
<h3 id="explanation-80"><a class="header" href="#explanation-80">Explanation</a></h3>
<p>Callers of methods for types where the implementation is known are
able to observe the types written in the impl signature. This may be
intended behavior, but may also lead to implementation details being
revealed unintentionally. In particular, it may pose a semver hazard
for authors of libraries who do not wish to make stronger guarantees
about the types than what is written in the trait signature.</p>
<p><code>refining_impl_trait</code> is a lint group composed of two lints:</p>
<ul>
<li><code>refining_impl_trait_reachable</code>, for refinements that are publically
reachable outside a crate, and</li>
<li><code>refining_impl_trait_internal</code>, for refinements that are only visible
within a crate.</li>
</ul>
<p>We are seeking feedback on each of these lints; see issue
<a href="https://github.com/rust-lang/rust/issues/121718">#121718</a> for more
information.</p>
<h2 id="renamed-and-removed-lints"><a class="header" href="#renamed-and-removed-lints">renamed-and-removed-lints</a></h2>
<p>The <code>renamed_and_removed_lints</code> lint detects lints that have been
renamed or removed.</p>
<h3 id="example-81"><a class="header" href="#example-81">Example</a></h3>
<pre><code class="language-rust">#![deny(raw_pointer_derive)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: lint `raw_pointer_derive` has been removed: using derive with raw pointers is ok
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(raw_pointer_derive)]
  |         ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(renamed_and_removed_lints)]` on by default

</code></pre>
<h3 id="explanation-81"><a class="header" href="#explanation-81">Explanation</a></h3>
<p>To fix this, either remove the lint or use the new name. This can help
avoid confusion about lints that are no longer valid, and help
maintain consistency for renamed lints.</p>
<h2 id="repr-c-enums-larger-than-int"><a class="header" href="#repr-c-enums-larger-than-int">repr-c-enums-larger-than-int</a></h2>
<p>The <code>repr_c_enums_larger_than_int</code> lint detects <code>repr(C)</code> enums with discriminant
values that do not fit into a C <code>int</code> or <code>unsigned int</code>.</p>
<h3 id="example-82"><a class="header" href="#example-82">Example</a></h3>
<pre><code class="language-rust ignore (only errors on 64bit)">#[repr(C)]
enum E {
    V = 9223372036854775807, // i64::MAX
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `repr(C)` enum discriminant does not fit into C `int` nor into C `unsigned int`
  --&gt; $DIR/repr-c-big-discriminant1.rs:16:5
   |
LL |     A = 9223372036854775807, // i64::MAX
   |     ^
   |
   = note: `repr(C)` enums with big discriminants are non-portable, and their size in Rust might not match their size in C
   = help: use `repr($int_ty)` instead to explicitly set the size of this enum
</code></pre>
<h3 id="explanation-82"><a class="header" href="#explanation-82">Explanation</a></h3>
<p>In C, enums with discriminants that do not all fit into an <code>int</code> or all fit into an
<code>unsigned int</code> are a portability hazard: such enums are only permitted since C23, and not
supported e.g. by MSVC.</p>
<p>Furthermore, Rust interprets the discriminant values of <code>repr(C)</code> enums as expressions of
type <code>isize</code>. This makes it impossible to implement the C23 behavior of enums where the enum
discriminants have no predefined type and instead the enum uses a type large enough to hold
all discriminants.</p>
<p>Therefore, <code>repr(C)</code> enums in Rust require that either all discriminants to fit into a C
<code>int</code> or they all fit into an <code>unsigned int</code>.</p>
<h2 id="rtsan-nonblocking-async"><a class="header" href="#rtsan-nonblocking-async">rtsan-nonblocking-async</a></h2>
<p>The <code>rtsan_nonblocking_async</code> lint detects incompatible use of
<a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[sanitize(realtime = "nonblocking")]</code></a> on async functions.</p>
<h3 id="example-83"><a class="header" href="#example-83">Example</a></h3>
<pre><code class="language-rust no_run">#![feature(sanitize)]

#[sanitize(realtime = "nonblocking")]
async fn x() {}

fn main() {
    x();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the async executor can run blocking code, without realtime sanitizer catching it
 --&gt; lint_example.rs:3:1
  |
3 | #[sanitize(realtime = "nonblocking")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(rtsan_nonblocking_async)]` on by default

</code></pre>
<h3 id="explanation-83"><a class="header" href="#explanation-83">Explanation</a></h3>
<p>The sanitizer only considers the async function body nonblocking. The executor, which runs on
every <code>.await</code> point can run non-realtime code, without the sanitizer catching it.</p>
<h2 id="self-constructor-from-outer-item"><a class="header" href="#self-constructor-from-outer-item">self-constructor-from-outer-item</a></h2>
<p>The <code>self_constructor_from_outer_item</code> lint detects cases where the <code>Self</code> constructor
was silently allowed due to a bug in the resolver, and which may produce surprising
and unintended behavior.</p>
<p>Using a <code>Self</code> type alias from an outer item was never intended, but was silently allowed.
This is deprecated – and is a hard error when the <code>Self</code> type alias references generics
that are not in scope.</p>
<h3 id="example-84"><a class="header" href="#example-84">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(self_constructor_from_outer_item)]

struct S0(usize);

impl S0 {
    fn foo() {
        const C: S0 = Self(0);
        fn bar() -&gt; S0 {
            Self(0)
        }
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: can't reference `Self` constructor from outer item
 --&gt; lint_example.rs:8:23
  |
6 | impl S0 {
  | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference
7 |     fn foo() {
8 |         const C: S0 = Self(0);
  |               -       ^^^^ help: replace `Self` with the actual type: `S0`
  |               |
  |               `Self` used in this inner item
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #124186 &lt;https://github.com/rust-lang/rust/issues/124186&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(self_constructor_from_outer_item)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


error: can't reference `Self` constructor from outer item
  --&gt; lint_example.rs:10:13
   |
 6 | impl S0 {
   | ------- the inner item doesn't inherit generics from this impl, so `Self` is invalid to reference
...
 9 |         fn bar() -&gt; S0 {
   |            --- `Self` used in this inner item
10 |             Self(0)
   |             ^^^^ help: replace `Self` with the actual type: `S0`
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #124186 &lt;https://github.com/rust-lang/rust/issues/124186&gt;

</code></pre>
<h3 id="explanation-84"><a class="header" href="#explanation-84">Explanation</a></h3>
<p>The <code>Self</code> type alias should not be reachable because nested items are not associated with
the scope of the parameters from the parent item.</p>
<h2 id="special-module-name"><a class="header" href="#special-module-name">special-module-name</a></h2>
<p>The <code>special_module_name</code> lint detects module
declarations for files that have a special meaning.</p>
<h3 id="example-85"><a class="header" href="#example-85">Example</a></h3>
<pre><code class="language-rust compile_fail">mod lib;

fn main() {
    lib::run();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: found module declaration for lib.rs
 --&gt; lint_example.rs:1:1
  |
1 | mod lib;
  | ^^^^^^^^
  |
  = note: lib.rs is the root of this crate's library target
  = help: to refer to it from other targets, use the library's name as the path
  = note: `#[warn(special_module_name)]` on by default

</code></pre>
<h3 id="explanation-85"><a class="header" href="#explanation-85">Explanation</a></h3>
<p>Cargo recognizes <code>lib.rs</code> and <code>main.rs</code> as the root of a
library or binary crate, so declaring them as modules
will lead to miscompilation of the crate unless configured
explicitly.</p>
<p>To access a library from a binary target within the same crate,
use <code>your_crate_name::</code> as the path instead of <code>lib::</code>:</p>
<pre><code class="language-rust compile_fail">// bar/src/lib.rs
fn run() {
    // ...
}

// bar/src/main.rs
fn main() {
    bar::run();
}</code></pre>
<p>Binary targets cannot be used as libraries and so declaring
one as a module is not allowed.</p>
<h2 id="stable-features"><a class="header" href="#stable-features">stable-features</a></h2>
<p>The <code>stable_features</code> lint detects a <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that
has since been made stable.</p>
<h3 id="example-86"><a class="header" href="#example-86">Example</a></h3>
<pre><code class="language-rust">#![feature(test_accepted_feature)]
fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `test_accepted_feature` has been stable since 1.0.0 and no longer requires an attribute to enable
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(test_accepted_feature)]
  |            ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(stable_features)]` on by default

</code></pre>
<h3 id="explanation-86"><a class="header" href="#explanation-86">Explanation</a></h3>
<p>When a feature is stabilized, it is no longer necessary to include a
<code>#![feature]</code> attribute for it. To fix, simply remove the
<code>#![feature]</code> attribute.</p>
<h2 id="static-mut-ref"><a class="header" href="#static-mut-ref">static-mut-ref</a></h2>
<p>The lint <code>static-mut-ref</code> has been renamed to <a href="#static-mut-refs"><code>static-mut-refs</code></a>.</p>
<h2 id="static-mut-refs"><a class="header" href="#static-mut-refs">static-mut-refs</a></h2>
<p>The <code>static_mut_refs</code> lint checks for shared or mutable references
of mutable static inside <code>unsafe</code> blocks and <code>unsafe</code> functions.</p>
<h3 id="example-87"><a class="header" href="#example-87">Example</a></h3>
<pre><code class="language-rust edition2021">fn main() {
    static mut X: i32 = 23;
    static mut Y: i32 = 24;

    unsafe {
        let y = &amp;X;
        let ref x = X;
        let (x, y) = (&amp;X, &amp;Y);
        foo(&amp;X);
    }
}

unsafe fn _foo() {
    static mut X: i32 = 23;
    static mut Y: i32 = 24;

    let y = &amp;X;
    let ref x = X;
    let (x, y) = (&amp;X, &amp;Y);
    foo(&amp;X);
}

fn foo&lt;'a&gt;(_x: &amp;'a i32) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:6:17
  |
6 |         let y = &amp;X;
  |                 ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
  = note: `#[warn(static_mut_refs)]` (part of `#[warn(rust_2024_compatibility)]`) on by default
help: use `&amp;raw const` instead to create a raw pointer
  |
6 |         let y = &amp;raw const X;
  |                  +++++++++


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:7:21
  |
7 |         let ref x = X;
  |                     ^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:8:23
  |
8 |         let (x, y) = (&amp;X, &amp;Y);
  |                       ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
  |
8 |         let (x, y) = (&amp;raw const X, &amp;Y);
  |                        +++++++++


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:8:27
  |
8 |         let (x, y) = (&amp;X, &amp;Y);
  |                           ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
  |
8 |         let (x, y) = (&amp;X, &amp;raw const Y);
  |                            +++++++++


warning: creating a shared reference to mutable static
 --&gt; lint_example.rs:9:13
  |
9 |         foo(&amp;X);
  |             ^^ shared reference to mutable static
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
  = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
  |
9 |         foo(&amp;raw const X);
  |              +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:17:13
   |
17 |     let y = &amp;X;
   |             ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
17 |     let y = &amp;raw const X;
   |              +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:18:17
   |
18 |     let ref x = X;
   |                 ^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:19:19
   |
19 |     let (x, y) = (&amp;X, &amp;Y);
   |                   ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
19 |     let (x, y) = (&amp;raw const X, &amp;Y);
   |                    +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:19:23
   |
19 |     let (x, y) = (&amp;X, &amp;Y);
   |                       ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
19 |     let (x, y) = (&amp;X, &amp;raw const Y);
   |                        +++++++++


warning: creating a shared reference to mutable static
  --&gt; lint_example.rs:20:9
   |
20 |     foo(&amp;X);
   |         ^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
help: use `&amp;raw const` instead to create a raw pointer
   |
20 |     foo(&amp;raw const X);
   |          +++++++++

</code></pre>
<h3 id="explanation-87"><a class="header" href="#explanation-87">Explanation</a></h3>
<p>Shared or mutable references of mutable static are almost always a mistake and
can lead to undefined behavior and various other problems in your code.</p>
<p>This lint is “warn” by default on editions up to 2021, in 2024 is “deny”.</p>
<h2 id="suspicious-double-ref-op"><a class="header" href="#suspicious-double-ref-op">suspicious-double-ref-op</a></h2>
<p>The <code>suspicious_double_ref_op</code> lint checks for usage of <code>.clone()</code>/<code>.borrow()</code>/<code>.deref()</code>
on an <code>&amp;&amp;T</code> when <code>T: !Deref/Borrow/Clone</code>, which means the call will return the inner <code>&amp;T</code>,
instead of performing the operation on the underlying <code>T</code> and can be confusing.</p>
<h3 id="example-88"><a class="header" href="#example-88">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>struct Foo;
let foo = &amp;&amp;Foo;
let clone: &amp;Foo = foo.clone();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: using `.clone()` on a double reference, which returns `&amp;Foo` instead of cloning the inner type
 --&gt; lint_example.rs:5:22
  |
5 | let clone: &amp;Foo = foo.clone();
  |                      ^^^^^^^^
  |
  = note: `#[warn(suspicious_double_ref_op)]` on by default

</code></pre>
<h3 id="explanation-88"><a class="header" href="#explanation-88">Explanation</a></h3>
<p>Since <code>Foo</code> doesn’t implement <code>Clone</code>, running <code>.clone()</code> only dereferences the double
reference, instead of cloning the inner type which should be what was intended.</p>
<h2 id="tail-call-track-caller"><a class="header" href="#tail-call-track-caller">tail-call-track-caller</a></h2>
<p>The <code>tail_call_track_caller</code> lint detects usage of <code>become</code> attempting to tail call
a function marked with <code>#[track_caller]</code>.</p>
<h3 id="example-89"><a class="header" href="#example-89">Example</a></h3>
<pre><code class="language-rust">#![feature(explicit_tail_calls)]
#![expect(incomplete_features)]

#[track_caller]
fn f() {}

fn g() {
    become f();
}

g();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: tail calling a function marked with `#[track_caller]` has no special effect
 --&gt; lint_example.rs:9:12
  |
9 |     become f();
  |            ^^^
  |
  = note: `#[warn(tail_call_track_caller)]` on by default

</code></pre>
<h3 id="explanation-89"><a class="header" href="#explanation-89">Explanation</a></h3>
<p>Due to implementation details of tail calls and <code>#[track_caller]</code> attribute, calls to
functions marked with <code>#[track_caller]</code> cannot become tail calls. As such using <code>become</code>
is no different than a normal call (except for changes in drop order).</p>
<h2 id="trivial-bounds"><a class="header" href="#trivial-bounds">trivial-bounds</a></h2>
<p>The <code>trivial_bounds</code> lint detects trait bounds that don’t depend on
any type parameters.</p>
<h3 id="example-90"><a class="header" href="#example-90">Example</a></h3>
<pre><code class="language-rust">#![feature(trivial_bounds)]
pub struct A where i32: Copy;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: trait bound i32: Copy does not depend on any type or lifetime parameters
 --&gt; lint_example.rs:3:25
  |
3 | pub struct A where i32: Copy;
  |                         ^^^^
  |
  = note: `#[warn(trivial_bounds)]` on by default

</code></pre>
<h3 id="explanation-90"><a class="header" href="#explanation-90">Explanation</a></h3>
<p>Usually you would not write a trait bound that you know is always
true, or never true. However, when using macros, the macro may not
know whether or not the constraint would hold or not at the time when
generating the code. Currently, the compiler does not alert you if the
constraint is always true, and generates an error if it is never true.
The <code>trivial_bounds</code> feature changes this to be a warning in both
cases, giving macros more freedom and flexibility to generate code,
while still providing a signal when writing non-macro code that
something is amiss.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2056-allow-trivial-where-clause-constraints.md">RFC 2056</a> for more details. This feature is currently only
available on the nightly channel, see <a href="https://github.com/rust-lang/rust/issues/48214">tracking issue #48214</a>.</p>
<h2 id="type-alias-bounds"><a class="header" href="#type-alias-bounds">type-alias-bounds</a></h2>
<p>The <code>type_alias_bounds</code> lint detects bounds in type aliases.</p>
<h3 id="example-91"><a class="header" href="#example-91">Example</a></h3>
<pre><code class="language-rust">type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: bounds on generic parameters in type aliases are not enforced
 --&gt; lint_example.rs:2:17
  |
2 | type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;
  |               --^^^^
  |               | |
  |               | will not be checked at usage sites of the type alias
  |               help: remove this bound
  |
  = note: this is a known limitation of the type checker that may be lifted in a future edition.
          see issue #112792 &lt;https://github.com/rust-lang/rust/issues/112792&gt; for more information
  = help: add `#![feature(lazy_type_alias)]` to the crate attributes to enable the desired semantics
  = note: `#[warn(type_alias_bounds)]` on by default

</code></pre>
<h3 id="explanation-91"><a class="header" href="#explanation-91">Explanation</a></h3>
<p>Trait and lifetime bounds on generic parameters and in where clauses of
type aliases are not checked at usage sites of the type alias. Moreover,
they are not thoroughly checked for correctness at their definition site
either similar to the aliased type.</p>
<p>This is a known limitation of the type checker that may be lifted in a
future edition. Permitting such bounds in light of this was unintentional.</p>
<p>While these bounds may have secondary effects such as enabling the use of
“shorthand” associated type paths<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> and affecting the default trait
object lifetime<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> of trait object types passed to the type alias, this
should not have been allowed until the aforementioned restrictions of the
type checker have been lifted.</p>
<p>Using such bounds is highly discouraged as they are actively misleading.</p>
<h2 id="tyvar-behind-raw-pointer"><a class="header" href="#tyvar-behind-raw-pointer">tyvar-behind-raw-pointer</a></h2>
<p>The <code>tyvar_behind_raw_pointer</code> lint detects raw pointer to an
inference variable.</p>
<h3 id="example-92"><a class="header" href="#example-92">Example</a></h3>
<pre><code class="language-rust edition2015">// edition 2015
let data = std::ptr::null();
let _ = &amp;data as *const *const ();

if data.is_null() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type annotations needed
 --&gt; lint_example.rs:6:9
  |
6 | if data.is_null() {}
  |         ^^^^^^^
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/tyvar-behind-raw-pointer.html&gt;
  = note: `#[warn(tyvar_behind_raw_pointer)]` (part of `#[warn(rust_2018_compatibility)]`) on by default

</code></pre>
<h3 id="explanation-92"><a class="header" href="#explanation-92">Explanation</a></h3>
<p>This kind of inference was previously allowed, but with the future
arrival of <a href="https://github.com/rust-lang/rust/issues/44874">arbitrary self types</a>, this can introduce ambiguity. To
resolve this, use an explicit type instead of relying on type
inference.</p>
<p>This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the 2018 edition. See <a href="https://github.com/rust-lang/rust/issues/46906">issue #46906</a> for more details. This
is currently a hard-error on the 2018 edition, and is “warn” by
default in the 2015 edition.</p>
<h2 id="uncommon-codepoints"><a class="header" href="#uncommon-codepoints">uncommon-codepoints</a></h2>
<p>The <code>uncommon_codepoints</code> lint detects uncommon Unicode codepoints in
identifiers.</p>
<h3 id="example-93"><a class="header" href="#example-93">Example</a></h3>
<pre><code class="language-rust"><span class="boring">#![allow(unused)]
</span>const µ: f64 = 0.000001;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: identifier contains a non normalized (NFKC) character: 'µ'
 --&gt; lint_example.rs:3:7
  |
3 | const µ: f64 = 0.000001;
  |       ^
  |
  = note: this character is included in the Not_NFKC Unicode general security profile
  = note: `#[warn(uncommon_codepoints)]` on by default

</code></pre>
<h3 id="explanation-93"><a class="header" href="#explanation-93">Explanation</a></h3>
<p>This lint warns about using characters which are not commonly used, and may
cause visual confusion.</p>
<p>This lint is triggered by identifiers that contain a codepoint that is
not part of the set of “Allowed” codepoints as described by <a href="https://www.unicode.org/reports/tr39/#General_Security_Profile">Unicode®
Technical Standard #39 Unicode Security Mechanisms Section 3.1 General
Security Profile for Identifiers</a>.</p>
<p>Note that the set of uncommon codepoints may change over time. Beware
that if you “forbid” this lint that existing code may fail in the
future.</p>
<h2 id="unconditional-recursion"><a class="header" href="#unconditional-recursion">unconditional-recursion</a></h2>
<p>The <code>unconditional_recursion</code> lint detects functions that cannot
return without calling themselves.</p>
<h3 id="example-94"><a class="header" href="#example-94">Example</a></h3>
<pre><code class="language-rust">fn foo() {
    foo();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function cannot return without recursing
 --&gt; lint_example.rs:2:1
  |
2 | fn foo() {
  | ^^^^^^^^ cannot return without recursing
3 |     foo();
  |     ----- recursive call site
  |
  = help: a `loop` may express intention better if this is on purpose
  = note: `#[warn(unconditional_recursion)]` on by default

</code></pre>
<h3 id="explanation-94"><a class="header" href="#explanation-94">Explanation</a></h3>
<p>It is usually a mistake to have a recursive call that does not have
some condition to cause it to terminate. If you really intend to have
an infinite loop, using a <code>loop</code> expression is recommended.</p>
<h2 id="uncovered-param-in-projection"><a class="header" href="#uncovered-param-in-projection">uncovered-param-in-projection</a></h2>
<p>The <code>uncovered_param_in_projection</code> lint detects a violation of one of Rust’s orphan rules for
foreign trait implementations that concerns the use of type parameters inside trait associated
type paths (“projections”) whose output may not be a local type that is mistakenly considered
to “cover” said parameters which is <strong>unsound</strong> and which may be rejected by a future version
of the compiler.</p>
<p>Originally reported in <a href="https://github.com/rust-lang/rust/issues/99554">#99554</a>.</p>
<h3 id="example-95"><a class="header" href="#example-95">Example</a></h3>
<pre><code class="language-rust ignore (dependent)">// dependency.rs
#![crate_type = "lib"]

pub trait Trait&lt;T, U&gt; {}</code></pre>
<pre><code class="language-edition2021 ignore (needs dependency)">// dependent.rs
trait Identity {
    type Output;
}

impl&lt;T&gt; Identity for T {
    type Output = T;
}

struct Local;

impl&lt;T&gt; dependency::Trait&lt;Local, T&gt; for &lt;T as Identity&gt;::Output {}

fn main() {}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Local`)
  --&gt; dependent.rs:11:6
   |
11 | impl&lt;T&gt; dependency::Trait&lt;Local, T&gt; for &lt;T as Identity&gt;::Output {}
   |      ^ type parameter `T` must be covered by another type when it appears before the first local type (`Local`)
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #124559 &lt;https://github.com/rust-lang/rust/issues/124559&gt;
   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type
   = note: in this case, 'before' refers to the following order: `impl&lt;..&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0`, where `T0` is the first and `Tn` is the last
   = note: `#[warn(uncovered_param_in_projection)]` on by default
</code></pre>
<h3 id="explanation-95"><a class="header" href="#explanation-95">Explanation</a></h3>
<p>FIXME(fmease): Write explainer.</p>
<h2 id="unexpected-cfgs"><a class="header" href="#unexpected-cfgs">unexpected-cfgs</a></h2>
<p>The <code>unexpected_cfgs</code> lint detects unexpected conditional compilation conditions.</p>
<h3 id="example-96"><a class="header" href="#example-96">Example</a></h3>
<pre><code class="language-text">rustc --check-cfg 'cfg()'
</code></pre>
<pre><code class="language-rust ignore (needs command line option)">#[cfg(widnows)]
fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unexpected `cfg` condition name: `widnows`
 --&gt; lint_example.rs:1:7
  |
1 | #[cfg(widnows)]
  |       ^^^^^^^
  |
  = note: `#[warn(unexpected_cfgs)]` on by default
</code></pre>
<h3 id="explanation-96"><a class="header" href="#explanation-96">Explanation</a></h3>
<p>This lint is only active when <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html"><code>--check-cfg</code></a> arguments are being
passed to the compiler and triggers whenever an unexpected condition name or value is
used.</p>
<p>See the <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html">Checking Conditional Configurations</a> section for more
details.</p>
<p>See the <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html#check-cfg-in-lintsrust-table">Cargo Specifics</a> section for configuring this lint in
<code>Cargo.toml</code>.</p>
<h2 id="unfulfilled-lint-expectations"><a class="header" href="#unfulfilled-lint-expectations">unfulfilled-lint-expectations</a></h2>
<p>The <code>unfulfilled_lint_expectations</code> lint detects when a lint expectation is
unfulfilled.</p>
<h3 id="example-97"><a class="header" href="#example-97">Example</a></h3>
<pre><code class="language-rust">#[expect(unused_variables)]
let x = 10;
println!("{}", x);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this lint expectation is unfulfilled
 --&gt; lint_example.rs:2:10
  |
2 | #[expect(unused_variables)]
  |          ^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unfulfilled_lint_expectations)]` on by default

</code></pre>
<h3 id="explanation-97"><a class="header" href="#explanation-97">Explanation</a></h3>
<p>The <code>#[expect]</code> attribute can be used to create a lint expectation. The
expectation is fulfilled, if a <code>#[warn]</code> attribute at the same location
would result in a lint emission. If the expectation is unfulfilled,
because no lint was emitted, this lint will be emitted on the attribute.</p>
<h2 id="ungated-async-fn-track-caller"><a class="header" href="#ungated-async-fn-track-caller">ungated-async-fn-track-caller</a></h2>
<p>The <code>ungated_async_fn_track_caller</code> lint warns when the
<code>#[track_caller]</code> attribute is used on an async function
without enabling the corresponding unstable feature flag.</p>
<h3 id="example-98"><a class="header" href="#example-98">Example</a></h3>
<pre><code class="language-rust">#[track_caller]
async fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[track_caller]` on async functions is a no-op
 --&gt; lint_example.rs:2:1
  |
2 | #[track_caller]
  | ^^^^^^^^^^^^^^^
3 | async fn foo() {}
  | ----------------- this function will not propagate the caller location
  |
  = note: see issue #110011 &lt;https://github.com/rust-lang/rust/issues/110011&gt; for more information
  = help: add `#![feature(async_fn_track_caller)]` to the crate attributes to enable
  = note: this compiler was built on 2026-01-23; consider upgrading it if it is out of date
  = note: `#[warn(ungated_async_fn_track_caller)]` on by default

</code></pre>
<h3 id="explanation-98"><a class="header" href="#explanation-98">Explanation</a></h3>
<p>The attribute must be used in conjunction with the
<a href="https://doc.rust-lang.org/beta/unstable-book/language-features/async-fn-track-caller.html"><code>async_fn_track_caller</code> feature flag</a>. Otherwise, the <code>#[track_caller]</code>
annotation will function as a no-op.</p>
<h2 id="uninhabited-static"><a class="header" href="#uninhabited-static">uninhabited-static</a></h2>
<p>The <code>uninhabited_static</code> lint detects uninhabited statics.</p>
<h3 id="example-99"><a class="header" href="#example-99">Example</a></h3>
<pre><code class="language-rust">enum Void {}
unsafe extern {
    static EXTERN: Void;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static of uninhabited type
 --&gt; lint_example.rs:4:5
  |
4 |     static EXTERN: Void;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #74840 &lt;https://github.com/rust-lang/rust/issues/74840&gt;
  = note: uninhabited statics cannot be initialized, and any access would be an immediate error
  = note: `#[warn(uninhabited_static)]` (part of `#[warn(future_incompatible)]`) on by default

</code></pre>
<h3 id="explanation-99"><a class="header" href="#explanation-99">Explanation</a></h3>
<p>Statics with an uninhabited type can never be initialized, so they are impossible to define.
However, this can be side-stepped with an <code>extern static</code>, leading to problems later in the
compiler which assumes that there are no initialized uninhabited places (such as locals or
statics). This was accidentally allowed, but is being phased out.</p>
<h2 id="unknown-diagnostic-attributes"><a class="header" href="#unknown-diagnostic-attributes">unknown-diagnostic-attributes</a></h2>
<p>The <code>unknown_diagnostic_attributes</code> lint detects unknown diagnostic attributes.</p>
<h3 id="example-100"><a class="header" href="#example-100">Example</a></h3>
<pre><code class="language-rust">#[diagnostic::does_not_exist]
struct Thing;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unknown diagnostic attribute
 --&gt; lint_example.rs:2:15
  |
2 | #[diagnostic::does_not_exist]
  |               ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unknown_diagnostic_attributes)]` (part of `#[warn(unknown_or_malformed_diagnostic_attributes)]`) on by default

</code></pre>
<h3 id="explanation-100"><a class="header" href="#explanation-100">Explanation</a></h3>
<p>It is usually a mistake to specify a diagnostic attribute that does not exist. Check the
spelling, and check the diagnostic attribute listing for the correct name. Also consider if
you are using an old version of the compiler and the attribute is only available in a newer
version. See the <a href="https://doc.rust-lang.org/nightly/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace">reference</a> for the list of diagnostic attributes.</p>
<h2 id="unknown-lints"><a class="header" href="#unknown-lints">unknown-lints</a></h2>
<p>The <code>unknown_lints</code> lint detects unrecognized lint attributes.</p>
<h3 id="example-101"><a class="header" href="#example-101">Example</a></h3>
<pre><code class="language-rust">#![allow(not_a_real_lint)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unknown lint: `not_a_real_lint`
 --&gt; lint_example.rs:1:10
  |
1 | #![allow(not_a_real_lint)]
  |          ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unknown_lints)]` on by default

</code></pre>
<h3 id="explanation-101"><a class="header" href="#explanation-101">Explanation</a></h3>
<p>It is usually a mistake to specify a lint that does not exist. Check
the spelling, and check the lint listing for the correct name. Also
consider if you are using an old version of the compiler, and the lint
is only available in a newer version.</p>
<h2 id="unnameable-test-items"><a class="header" href="#unnameable-test-items">unnameable-test-items</a></h2>
<p>The <code>unnameable_test_items</code> lint detects <a href="https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> functions
that are not able to be run by the test harness because they are in a
position where they are not nameable.</p>
<h3 id="example-102"><a class="header" href="#example-102">Example</a></h3>
<pre><code class="language-rust test">fn main() {
    #[test]
    fn foo() {
        // This test will not fail because it does not run.
        assert_eq!(1, 2);
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot test inner items
 --&gt; lint_example.rs:2:5
  |
2 |     #[test]
  |     ^^^^^^^
  |
  = note: `#[warn(unnameable_test_items)]` on by default

</code></pre>
<h3 id="explanation-102"><a class="header" href="#explanation-102">Explanation</a></h3>
<p>In order for the test harness to run a test, the test function must be
located in a position where it can be accessed from the crate root.
This generally means it must be defined in a module, and not anywhere
else such as inside another function. The compiler previously allowed
this without an error, so a lint was added as an alert that a test is
not being used. Whether or not this should be allowed has not yet been
decided, see <a href="https://github.com/rust-lang/rfcs/pull/2471#issuecomment-397414443">RFC 2471</a> and <a href="https://github.com/rust-lang/rust/issues/36629">issue #36629</a>.</p>
<h2 id="unnecessary-transmutes"><a class="header" href="#unnecessary-transmutes">unnecessary-transmutes</a></h2>
<p>The <code>unnecessary_transmutes</code> lint detects transmutations that have safer alternatives.</p>
<h3 id="example-103"><a class="header" href="#example-103">Example</a></h3>
<pre><code class="language-rust">fn bytes_at_home(x: [u8; 4]) -&gt; u32 {
  unsafe { std::mem::transmute(x) }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary transmute
 --&gt; lint_example.rs:3:12
  |
3 |   unsafe { std::mem::transmute(x) }
  |            -------------------^^^
  |            |
  |            help: replace this with: `u32::from_ne_bytes`
  |
  = help: there's also `from_le_bytes` and `from_be_bytes` if you expect a particular byte order
  = note: `#[warn(unnecessary_transmutes)]` on by default

</code></pre>
<h3 id="explanation-103"><a class="header" href="#explanation-103">Explanation</a></h3>
<p>Using an explicit method is preferable over calls to
<a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>transmute</code></a> as
they more clearly communicate the intent, are easier to review, and
are less likely to accidentally result in unsoundness.</p>
<h2 id="unpredictable-function-pointer-comparisons"><a class="header" href="#unpredictable-function-pointer-comparisons">unpredictable-function-pointer-comparisons</a></h2>
<p>The <code>unpredictable_function_pointer_comparisons</code> lint checks comparison
of function pointer as the operands.</p>
<h3 id="example-104"><a class="header" href="#example-104">Example</a></h3>
<pre><code class="language-rust">fn a() {}
fn b() {}

let f: fn() = a;
let g: fn() = b;

let _ = f == g;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique
 --&gt; lint_example.rs:8:9
  |
8 | let _ = f == g;
  |         ^^^^^^
  |
  = note: the address of the same function can vary between different codegen units
  = note: furthermore, different functions could have the same address after being merged together
  = note: for more information visit &lt;https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html&gt;
  = note: `#[warn(unpredictable_function_pointer_comparisons)]` on by default
help: refactor your code, or use `std::ptr::fn_addr_eq` to suppress the lint
  |
8 - let _ = f == g;
8 + let _ = std::ptr::fn_addr_eq(f, g);
  |

</code></pre>
<h3 id="explanation-104"><a class="header" href="#explanation-104">Explanation</a></h3>
<p>Function pointers comparisons do not produce meaningful result since
they are never guaranteed to be unique and could vary between different
code generation units. Furthermore, different functions could have the
same address after being merged together.</p>
<h2 id="unreachable-code"><a class="header" href="#unreachable-code">unreachable-code</a></h2>
<p>The <code>unreachable_code</code> lint detects unreachable code paths.</p>
<h3 id="example-105"><a class="header" href="#example-105">Example</a></h3>
<pre><code class="language-rust no_run">panic!("we never go past here!");

let x = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable statement
 --&gt; lint_example.rs:4:1
  |
2 | panic!("we never go past here!");
  | -------------------------------- any code following this expression is unreachable
3 |
4 | let x = 5;
  | ^^^^^^^^^^ unreachable statement
  |
  = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-105"><a class="header" href="#explanation-105">Explanation</a></h3>
<p>Unreachable code may signal a mistake or unfinished code. If the code
is no longer in use, consider removing it.</p>
<h2 id="unreachable-patterns"><a class="header" href="#unreachable-patterns">unreachable-patterns</a></h2>
<p>The <code>unreachable_patterns</code> lint detects unreachable patterns.</p>
<h3 id="example-106"><a class="header" href="#example-106">Example</a></h3>
<pre><code class="language-rust">let x = 5;
match x {
    y =&gt; (),
    5 =&gt; (),
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; lint_example.rs:5:5
  |
4 |     y =&gt; (),
  |     - matches any value
5 |     5 =&gt; (),
  |     ^ no value can reach this
  |
  = note: `#[warn(unreachable_patterns)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-106"><a class="header" href="#explanation-106">Explanation</a></h3>
<p>This usually indicates a mistake in how the patterns are specified or
ordered. In this example, the <code>y</code> pattern will always match, so the
five is impossible to reach. Remember, match arms match in order, you
probably wanted to put the <code>5</code> case above the <code>y</code> case.</p>
<h2 id="unstable-name-collision"><a class="header" href="#unstable-name-collision">unstable-name-collision</a></h2>
<p>The lint <code>unstable-name-collision</code> has been renamed to <a href="#unstable-name-collisions"><code>unstable-name-collisions</code></a>.</p>
<h2 id="unstable-name-collisions"><a class="header" href="#unstable-name-collisions">unstable-name-collisions</a></h2>
<p>The <code>unstable_name_collisions</code> lint detects that you have used a name
that the standard library plans to add in the future.</p>
<h3 id="example-107"><a class="header" href="#example-107">Example</a></h3>
<pre><code class="language-rust">trait MyIterator : Iterator {
    // is_partitioned is an unstable method that already exists on the Iterator trait
    fn is_partitioned&lt;P&gt;(self, predicate: P) -&gt; bool
    where
        Self: Sized,
        P: FnMut(Self::Item) -&gt; bool,
    {true}
}

impl&lt;T: ?Sized&gt; MyIterator for T where T: Iterator { }

let x = vec![1, 2, 3];
let _ = x.iter().is_partitioned(|_| true);</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: a method with this name may be added to the standard library in the future
  --&gt; lint_example.rs:14:18
   |
14 | let _ = x.iter().is_partitioned(|_| true);
   |                  ^^^^^^^^^^^^^^
   |
   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!
   = note: for more information, see issue #48919 &lt;https://github.com/rust-lang/rust/issues/48919&gt;
   = help: call with fully qualified syntax `MyIterator::is_partitioned(...)` to keep using the current method
   = note: `#[warn(unstable_name_collisions)]` (part of `#[warn(future_incompatible)]`) on by default
help: add `#![feature(iter_is_partitioned)]` to the crate attributes to enable `is_partitioned`
   |
 1 + #![feature(iter_is_partitioned)]
   |

</code></pre>
<h3 id="explanation-107"><a class="header" href="#explanation-107">Explanation</a></h3>
<p>When new methods are added to traits in the standard library, they are
usually added in an “unstable” form which is only available on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a> with a <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a>. If there is any
preexisting code which extends a trait to have a method with the same
name, then the names will collide. In the future, when the method is
stabilized, this will cause an error due to the ambiguity. This lint
is an early-warning to let you know that there may be a collision in
the future. This can be avoided by adding type annotations to
disambiguate which trait method you intend to call, such as
<code>MyIterator::is_partitioned(my_iter, my_predicate)</code> or renaming or removing the method.</p>
<h2 id="unstable-syntax-pre-expansion"><a class="header" href="#unstable-syntax-pre-expansion">unstable-syntax-pre-expansion</a></h2>
<p>The <code>unstable_syntax_pre_expansion</code> lint detects the use of unstable
syntax that is discarded during attribute expansion.</p>
<h3 id="example-108"><a class="header" href="#example-108">Example</a></h3>
<pre><code class="language-rust">#[cfg(FALSE)]
macro foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `macro` is experimental
 --&gt; lint_example.rs:3:1
  |
3 | macro foo() {}
  | ^^^^^^^^^^^^^^
  |
  = note: see issue #39412 &lt;https://github.com/rust-lang/rust/issues/39412&gt; for more information
  = help: add `#![feature(decl_macro)]` to the crate attributes to enable
  = note: this compiler was built on 2026-01-23; consider upgrading it if it is out of date
  = warning: unstable syntax can change at any point in the future, causing a hard error!
  = note: for more information, see issue #65860 &lt;https://github.com/rust-lang/rust/issues/65860&gt;

</code></pre>
<h3 id="explanation-108"><a class="header" href="#explanation-108">Explanation</a></h3>
<p>The input to active attributes such as <code>#[cfg]</code> or procedural macro
attributes is required to be valid syntax. Previously, the compiler only
gated the use of unstable syntax features after resolving <code>#[cfg]</code> gates
and expanding procedural macros.</p>
<p>To avoid relying on unstable syntax, move the use of unstable syntax
into a position where the compiler does not parse the syntax, such as a
functionlike macro.</p>
<pre><code class="language-rust"><span class="boring">#![deny(unstable_syntax_pre_expansion)]
</span>
macro_rules! identity {
   ( $($tokens:tt)* ) =&gt; { $($tokens)* }
}

#[cfg(FALSE)]
identity! {
   macro foo() {}
}</code></pre>
<p>This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/65860">issue #65860</a> for more details.</p>
<h2 id="unsupported-calling-conventions"><a class="header" href="#unsupported-calling-conventions">unsupported-calling-conventions</a></h2>
<p>The <code>unsupported_calling_conventions</code> lint is output whenever there is a use of the
<code>stdcall</code>, <code>fastcall</code>, and <code>cdecl</code> calling conventions (or their unwind
variants) on targets that cannot meaningfully be supported for the requested target.</p>
<p>For example <code>stdcall</code> does not make much sense for a x86_64 or, more apparently, powerpc
code, because this calling convention was never specified for those targets.</p>
<p>Historically MSVC toolchains have fallen back to the regular C calling convention for
targets other than x86, but Rust doesn’t really see a similar need to introduce a similar
hack across many more targets.</p>
<h3 id="example-109"><a class="header" href="#example-109">Example</a></h3>
<pre><code class="language-rust ignore (needs specific targets)">extern "stdcall" fn stdcall() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of calling convention not supported on this target
  --&gt; $DIR/unsupported.rs:39:1
   |
LL | extern "stdcall" fn stdcall() {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unsupported_calling_conventions)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out;
              it will become a hard error in a future release!
   = note: for more information, see issue ...
</code></pre>
<h3 id="explanation-109"><a class="header" href="#explanation-109">Explanation</a></h3>
<p>On most of the targets the behaviour of <code>stdcall</code> and similar calling conventions is not
defined at all, but was previously accepted due to a bug in the implementation of the
compiler.</p>
<h2 id="unsupported-fn-ptr-calling-conventions"><a class="header" href="#unsupported-fn-ptr-calling-conventions">unsupported-fn-ptr-calling-conventions</a></h2>
<p>The <code>unsupported_fn_ptr_calling_conventions</code> lint is output whenever there is a use of
a target dependent calling convention on a target that does not support this calling
convention on a function pointer.</p>
<p>For example <code>stdcall</code> does not make much sense for a x86_64 or, more apparently, powerpc
code, because this calling convention was never specified for those targets.</p>
<h3 id="example-110"><a class="header" href="#example-110">Example</a></h3>
<pre><code class="language-rust ignore (needs specific targets)">fn stdcall_ptr(f: extern "stdcall" fn ()) {
    f()
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the calling convention `"stdcall"` is not supported on this target
  --&gt; $DIR/unsupported.rs:34:15
   |
LL | fn stdcall_ptr(f: extern "stdcall" fn()) {
   |               ^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #130260 &lt;https://github.com/rust-lang/rust/issues/130260&gt;
   = note: `#[warn(unsupported_fn_ptr_calling_conventions)]` on by default
</code></pre>
<h3 id="explanation-110"><a class="header" href="#explanation-110">Explanation</a></h3>
<p>On most of the targets the behaviour of <code>stdcall</code> and similar calling conventions is not
defined at all, but was previously accepted due to a bug in the implementation of the
compiler.</p>
<h2 id="unused-doc-comment"><a class="header" href="#unused-doc-comment">unused-doc-comment</a></h2>
<p>The lint <code>unused-doc-comment</code> has been renamed to <a href="#unused-doc-comments"><code>unused-doc-comments</code></a>.</p>
<h2 id="unused-tuple-struct-fields"><a class="header" href="#unused-tuple-struct-fields">unused-tuple-struct-fields</a></h2>
<p>The lint <code>unused-tuple-struct-fields</code> has been renamed to <a href="#dead-code"><code>dead-code</code></a>.</p>
<h2 id="unused-allocation"><a class="header" href="#unused-allocation">unused-allocation</a></h2>
<p>The <code>unused_allocation</code> lint detects unnecessary allocations that can
be eliminated.</p>
<h3 id="example-111"><a class="header" href="#example-111">Example</a></h3>
<pre><code class="language-rust">fn main() {
    let a = Box::new([1, 2, 3]).len();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary allocation, use `&amp;` instead
 --&gt; lint_example.rs:2:13
  |
2 |     let a = Box::new([1, 2, 3]).len();
  |             ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_allocation)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-111"><a class="header" href="#explanation-111">Explanation</a></h3>
<p>When a <code>box</code> expression is immediately coerced to a reference, then
the allocation is unnecessary, and a reference (using <code>&amp;</code> or <code>&amp;mut</code>)
should be used instead to avoid the allocation.</p>
<h2 id="unused-assignments"><a class="header" href="#unused-assignments">unused-assignments</a></h2>
<p>The <code>unused_assignments</code> lint detects assignments that will never be read.</p>
<h3 id="example-112"><a class="header" href="#example-112">Example</a></h3>
<pre><code class="language-rust">let mut x = 5;
x = 6;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: value assigned to `x` is never read
 --&gt; lint_example.rs:3:1
  |
3 | x = 6;
  | ^^^^^
  |
  = help: maybe it is overwritten before being read?
  = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-112"><a class="header" href="#explanation-112">Explanation</a></h3>
<p>Unused assignments may signal a mistake or unfinished code. If the
variable is never used after being assigned, then the assignment can
be removed. Variables with an underscore prefix such as <code>_x</code> will not
trigger this lint.</p>
<h2 id="unused-associated-type-bounds"><a class="header" href="#unused-associated-type-bounds">unused-associated-type-bounds</a></h2>
<p>The <code>unused_associated_type_bounds</code> lint is emitted when an
associated type bound is added to a trait object, but the associated
type has a <code>where Self: Sized</code> bound, and is thus unavailable on the
trait object anyway.</p>
<h3 id="example-113"><a class="header" href="#example-113">Example</a></h3>
<pre><code class="language-rust">trait Foo {
    type Bar where Self: Sized;
}
type Mop = dyn Foo&lt;Bar = ()&gt;;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary associated type bound for dyn-incompatible associated type
 --&gt; lint_example.rs:5:20
  |
5 | type Mop = dyn Foo&lt;Bar = ()&gt;;
  |                    ^^^^^^^^ help: remove this bound
  |
  = note: this associated type has a `where Self: Sized` bound, and while the associated type can be specified, it cannot be used because trait objects are never `Sized`
  = note: `#[warn(unused_associated_type_bounds)]` on by default

</code></pre>
<h3 id="explanation-113"><a class="header" href="#explanation-113">Explanation</a></h3>
<p>Just like methods with <code>Self: Sized</code> bounds are unavailable on trait
objects, associated types can be removed from the trait object.</p>
<h2 id="unused-attributes"><a class="header" href="#unused-attributes">unused-attributes</a></h2>
<p>The <code>unused_attributes</code> lint detects attributes that were not used by
the compiler.</p>
<h3 id="example-114"><a class="header" href="#example-114">Example</a></h3>
<pre><code class="language-rust">#![ignore]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[ignore]` attribute cannot be used on crates
 --&gt; lint_example.rs:1:1
  |
1 | #![ignore]
  | ^^^^^^^^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = help: `#[ignore]` can only be applied to functions
  = note: `#[warn(unused_attributes)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-114"><a class="header" href="#explanation-114">Explanation</a></h3>
<p>Unused <a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a> may indicate the attribute is placed in the wrong
position. Consider removing it, or placing it in the correct position.
Also consider if you intended to use an <em>inner attribute</em> (with a <code>!</code>
such as <code>#![allow(unused)]</code>) which applies to the item the attribute
is within, or an <em>outer attribute</em> (without a <code>!</code> such as
<code>#[allow(unused)]</code>) which applies to the item <em>following</em> the
attribute.</p>
<h2 id="unused-braces"><a class="header" href="#unused-braces">unused-braces</a></h2>
<p>The <code>unused_braces</code> lint detects unnecessary braces around an
expression.</p>
<h3 id="example-115"><a class="header" href="#example-115">Example</a></h3>
<pre><code class="language-rust">if { true } {
    // ...
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary braces around `if` condition
 --&gt; lint_example.rs:2:4
  |
2 | if { true } {
  |    ^^    ^^
  |
  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default
help: remove these braces
  |
2 - if { true } {
2 + if true  {
  |

</code></pre>
<h3 id="explanation-115"><a class="header" href="#explanation-115">Explanation</a></h3>
<p>The braces are not needed, and should be removed. This is the
preferred style for writing these expressions.</p>
<h2 id="unused-comparisons"><a class="header" href="#unused-comparisons">unused-comparisons</a></h2>
<p>The <code>unused_comparisons</code> lint detects comparisons made useless by
limits of the types involved.</p>
<h3 id="example-116"><a class="header" href="#example-116">Example</a></h3>
<pre><code class="language-rust">fn foo(x: u8) {
    x &gt;= 0;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: comparison is useless due to type limits
 --&gt; lint_example.rs:3:5
  |
3 |     x &gt;= 0;
  |     ^^^^^^
  |
  = note: `#[warn(unused_comparisons)]` on by default

</code></pre>
<h3 id="explanation-116"><a class="header" href="#explanation-116">Explanation</a></h3>
<p>A useless comparison may indicate a mistake, and should be fixed or
removed.</p>
<h2 id="unused-doc-comments"><a class="header" href="#unused-doc-comments">unused-doc-comments</a></h2>
<p>The <code>unused_doc_comments</code> lint detects doc comments that aren’t used
by <code>rustdoc</code>.</p>
<h3 id="example-117"><a class="header" href="#example-117">Example</a></h3>
<pre><code class="language-rust">/// docs for x
let x = 12;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused doc comment
 --&gt; lint_example.rs:2:1
  |
2 | /// docs for x
  | ^^^^^^^^^^^^^^
3 | let x = 12;
  | ----------- rustdoc does not generate documentation for statements
  |
  = help: use `//` for a plain comment
  = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-117"><a class="header" href="#explanation-117">Explanation</a></h3>
<p><code>rustdoc</code> does not use doc comments in all positions, and so the doc
comment will be ignored. Try changing it to a normal comment with <code>//</code>
to avoid the warning.</p>
<h2 id="unused-features"><a class="header" href="#unused-features">unused-features</a></h2>
<p>The <code>unused_features</code> lint detects unused or unknown features found in
crate-level <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attributes</a>.</p>
<p>Note: This lint is currently not functional, see <a href="https://github.com/rust-lang/rust/issues/44232">issue #44232</a> for
more details.</p>
<h2 id="unused-imports"><a class="header" href="#unused-imports">unused-imports</a></h2>
<p>The <code>unused_imports</code> lint detects imports that are never used.</p>
<h3 id="example-118"><a class="header" href="#example-118">Example</a></h3>
<pre><code class="language-rust">use std::collections::HashMap;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused import: `std::collections::HashMap`
 --&gt; lint_example.rs:2:5
  |
2 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-118"><a class="header" href="#explanation-118">Explanation</a></h3>
<p>Unused imports may signal a mistake or unfinished code, and clutter
the code, and should be removed. If you intended to re-export the item
to make it available outside of the module, add a visibility modifier
like <code>pub</code>.</p>
<h2 id="unused-labels"><a class="header" href="#unused-labels">unused-labels</a></h2>
<p>The <code>unused_labels</code> lint detects <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#loop-labels">labels</a> that are never used.</p>
<h3 id="example-119"><a class="header" href="#example-119">Example</a></h3>
<pre><code class="language-rust no_run">'unused_label: loop {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused label
 --&gt; lint_example.rs:2:1
  |
2 | 'unused_label: loop {}
  | ^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_labels)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-119"><a class="header" href="#explanation-119">Explanation</a></h3>
<p>Unused labels may signal a mistake or unfinished code. To silence the
warning for the individual label, prefix it with an underscore such as
<code>'_my_label:</code>.</p>
<h2 id="unused-macros"><a class="header" href="#unused-macros">unused-macros</a></h2>
<p>The <code>unused_macros</code> lint detects macros that were not used.</p>
<p>Note that this lint is distinct from the <code>unused_macro_rules</code> lint,
which checks for single rules that never match of an otherwise used
macro, and thus never expand.</p>
<h3 id="example-120"><a class="header" href="#example-120">Example</a></h3>
<pre><code class="language-rust">macro_rules! unused {
    () =&gt; {};
}

fn main() {
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused macro definition: `unused`
 --&gt; lint_example.rs:1:14
  |
1 | macro_rules! unused {
  |              ^^^^^^
  |
  = note: `#[warn(unused_macros)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-120"><a class="header" href="#explanation-120">Explanation</a></h3>
<p>Unused macros may signal a mistake or unfinished code. To silence the
warning for the individual macro, prefix the name with an underscore
such as <code>_my_macro</code>. If you intended to export the macro to make it
available outside of the crate, use the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope"><code>macro_export</code> attribute</a>.</p>
<h2 id="unused-must-use"><a class="header" href="#unused-must-use">unused-must-use</a></h2>
<p>The <code>unused_must_use</code> lint detects unused result of a type flagged as
<code>#[must_use]</code>.</p>
<h3 id="example-121"><a class="header" href="#example-121">Example</a></h3>
<pre><code class="language-rust">fn returns_result() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    returns_result();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused `Result` that must be used
 --&gt; lint_example.rs:6:5
  |
6 |     returns_result();
  |     ^^^^^^^^^^^^^^^^
  |
  = note: this `Result` may be an `Err` variant, which should be handled
  = note: `#[warn(unused_must_use)]` (part of `#[warn(unused)]`) on by default
help: use `let _ = ...` to ignore the resulting value
  |
6 |     let _ = returns_result();
  |     +++++++

</code></pre>
<h3 id="explanation-121"><a class="header" href="#explanation-121">Explanation</a></h3>
<p>The <code>#[must_use]</code> attribute is an indicator that it is a mistake to
ignore the value. See <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute">the reference</a> for more details.</p>
<h2 id="unused-mut"><a class="header" href="#unused-mut">unused-mut</a></h2>
<p>The <code>unused_mut</code> lint detects mut variables which don’t need to be
mutable.</p>
<h3 id="example-122"><a class="header" href="#example-122">Example</a></h3>
<pre><code class="language-rust">let mut x = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable does not need to be mutable
 --&gt; lint_example.rs:2:5
  |
2 | let mut x = 5;
  |     ----^
  |     |
  |     help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-122"><a class="header" href="#explanation-122">Explanation</a></h3>
<p>The preferred style is to only mark variables as <code>mut</code> if it is
required.</p>
<h2 id="unused-parens"><a class="header" href="#unused-parens">unused-parens</a></h2>
<p>The <code>unused_parens</code> lint detects <code>if</code>, <code>match</code>, <code>while</code> and <code>return</code>
with parentheses; they do not need them.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-rust">if(true) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary parentheses around `if` condition
 --&gt; lint_example.rs:2:3
  |
2 | if(true) {}
  |   ^    ^
  |
  = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
  |
2 - if(true) {}
2 + if true  {}
  |

</code></pre>
<h3 id="explanation-123"><a class="header" href="#explanation-123">Explanation</a></h3>
<p>The parentheses are not needed, and should be removed. This is the
preferred style for writing these expressions.</p>
<h2 id="unused-unsafe"><a class="header" href="#unused-unsafe">unused-unsafe</a></h2>
<p>The <code>unused_unsafe</code> lint detects unnecessary use of an <code>unsafe</code> block.</p>
<h3 id="example-123"><a class="header" href="#example-123">Example</a></h3>
<pre><code class="language-rust">unsafe {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary `unsafe` block
 --&gt; lint_example.rs:2:1
  |
2 | unsafe {}
  | ^^^^^^ unnecessary `unsafe` block
  |
  = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-124"><a class="header" href="#explanation-124">Explanation</a></h3>
<p>If nothing within the block requires <code>unsafe</code>, then remove the
<code>unsafe</code> marker because it is not required and may cause confusion.</p>
<h2 id="unused-variables"><a class="header" href="#unused-variables">unused-variables</a></h2>
<p>The <code>unused_variables</code> lint detects variables which are not used in
any way.</p>
<h3 id="example-124"><a class="header" href="#example-124">Example</a></h3>
<pre><code class="language-rust">let x = 5;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused variable: `x`
 --&gt; lint_example.rs:2:5
  |
2 | let x = 5;
  |     ^ help: if this is intentional, prefix it with an underscore: `_x`
  |
  = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-125"><a class="header" href="#explanation-125">Explanation</a></h3>
<p>Unused variables may signal a mistake or unfinished code. To silence
the warning for the individual variable, prefix it with an underscore
such as <code>_x</code>.</p>
<h2 id="unused-visibilities"><a class="header" href="#unused-visibilities">unused-visibilities</a></h2>
<p>The <code>unused_visibilities</code> lint detects visibility qualifiers (like <code>pub</code>)
on a <code>const _</code> item.</p>
<h3 id="example-125"><a class="header" href="#example-125">Example</a></h3>
<pre><code class="language-rust">pub const _: () = {};</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: visibility qualifiers have no effect on `const _` declarations
 --&gt; lint_example.rs:2:1
  |
2 | pub const _: () = {};
  | ^^^ help: remove the qualifier
  |
  = note: `const _` does not declare a name, so there is nothing for the qualifier to apply to
  = note: `#[warn(unused_visibilities)]` (part of `#[warn(unused)]`) on by default

</code></pre>
<h3 id="explanation-126"><a class="header" href="#explanation-126">Explanation</a></h3>
<p>These qualifiers have no effect, as <code>const _</code> items are unnameable.</p>
<h2 id="useless-ptr-null-checks"><a class="header" href="#useless-ptr-null-checks">useless-ptr-null-checks</a></h2>
<p>The <code>useless_ptr_null_checks</code> lint checks for useless null checks against pointers
obtained from non-null types.</p>
<h3 id="example-126"><a class="header" href="#example-126">Example</a></h3>
<pre><code class="language-rust"><span class="boring">fn test() {}
</span>let fn_ptr: fn() = /* somehow obtained nullable function pointer */
<span class="boring">  test;
</span>
if (fn_ptr as *const ()).is_null() { /* ... */ }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function pointers are not nullable, so checking them for null will always return false
 --&gt; lint_example.rs:6:4
  |
6 | if (fn_ptr as *const ()).is_null() { /* ... */ }
  |    ^------^^^^^^^^^^^^^^^^^^^^^^^^
  |     |
  |     expression has type `fn()`
  |
  = help: wrap the function pointer inside an `Option` and use `Option::is_none` to check for null pointer value
  = note: `#[warn(useless_ptr_null_checks)]` on by default

</code></pre>
<h3 id="explanation-127"><a class="header" href="#explanation-127">Explanation</a></h3>
<p>Function pointers and references are assumed to be non-null, checking them for null
will always return false.</p>
<h2 id="uses-power-alignment"><a class="header" href="#uses-power-alignment">uses-power-alignment</a></h2>
<p>The <code>uses_power_alignment</code> lint detects specific <code>repr(C)</code>
aggregates on AIX.
In its platform C ABI, AIX uses the “power” (as in PowerPC) alignment
rule (detailed in https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1?topic=data-using-alignment-modes#alignment),
which can also be set for XLC by <code>#pragma align(power)</code> or
<code>-qalign=power</code>. Aggregates with a floating-point type as the
recursively first field (as in “at offset 0”) modify the layout of
<em>subsequent</em> fields of the associated structs to use an alignment value
where the floating-point type is aligned on a 4-byte boundary.</p>
<p>Effectively, subsequent floating-point fields act as-if they are <code>repr(packed(4))</code>. This
would be unsound to do in a <code>repr(C)</code> type without all the restrictions that come with
<code>repr(packed)</code>. Rust instead chooses a layout that maintains soundness of Rust code, at the
expense of incompatibility with C code.</p>
<h3 id="example-127"><a class="header" href="#example-127">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-powerpc64-ibm-aix)">#[repr(C)]
pub struct Floats {
    a: f64,
    b: u8,
    c: f64,
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: repr(C) does not follow the power alignment rule. This may affect platform C ABI compatibility for this type
 --&gt; &lt;source&gt;:5:3
  |
5 |   c: f64,
  |   ^^^^^^
  |
  = note: `#[warn(uses_power_alignment)]` on by default
</code></pre>
<h3 id="explanation-128"><a class="header" href="#explanation-128">Explanation</a></h3>
<p>The power alignment rule specifies that the above struct has the
following alignment:</p>
<ul>
<li>offset_of!(Floats, a) == 0</li>
<li>offset_of!(Floats, b) == 8</li>
<li>offset_of!(Floats, c) == 12</li>
</ul>
<p>However, Rust currently aligns <code>c</code> at <code>offset_of!(Floats, c) == 16</code>.
Using offset 12 would be unsound since <code>f64</code> generally must be 8-aligned on this target.
Thus, a warning is produced for the above struct.</p>
<h2 id="varargs-without-pattern"><a class="header" href="#varargs-without-pattern">varargs-without-pattern</a></h2>
<p>The <code>varargs_without_pattern</code> lint detects when <code>...</code> is used as an argument to a
non-foreign function without any pattern being specified.</p>
<h3 id="example-128"><a class="header" href="#example-128">Example</a></h3>
<pre><code class="language-rust">// Using `...` in non-foreign function definitions is unstable, however stability is
// currently only checked after attributes are expanded, so using `#[cfg(false)]` here will
// allow this to compile on stable Rust.
#[cfg(false)]
fn foo(...) {

}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: missing pattern for `...` argument
 --&gt; lint_example.rs:6:8
  |
6 | fn foo(...) {
  |        ^^^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #145544 &lt;https://github.com/rust-lang/rust/issues/145544&gt;
  = note: `#[warn(varargs_without_pattern)]` (part of `#[warn(future_incompatible)]`) on by default
help: name the argument, or use `_` to continue ignoring it
  |
6 | fn foo(_: ...) {
  |        ++

</code></pre>
<h3 id="explanation-129"><a class="header" href="#explanation-129">Explanation</a></h3>
<p>Patterns are currently required for all non-<code>...</code> arguments in function definitions (with
some exceptions in the 2015 edition). Requiring <code>...</code> arguments to have patterns in
non-foreign function definitions makes the language more consistent, and removes a source of
confusion for the unstable C variadic feature. <code>...</code> arguments without a pattern are already
stable and widely used in foreign function definitions; this lint only affects non-foreign
function definitions.</p>
<p>Using <code>...</code> (C varargs) in a non-foreign function definition is currently unstable. However,
stability checking for the <code>...</code> syntax in non-foreign function definitions is currently
implemented after attributes have been expanded, meaning that if the attribute removes the
use of the unstable syntax (e.g. <code>#[cfg(false)]</code>, or a procedural macro), the code will
compile on stable Rust; this is the only situation where this lint affects code that
compiles on stable Rust.</p>
<p>This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the future.</p>
<h2 id="warnings"><a class="header" href="#warnings">warnings</a></h2>
<p>The <code>warnings</code> lint allows you to change the level of other
lints which produce warnings.</p>
<h3 id="example-129"><a class="header" href="#example-129">Example</a></h3>
<pre><code class="language-rust">#![deny(warnings)]
fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: function `foo` is never used
 --&gt; lint_example.rs:3:4
  |
3 | fn foo() {}
  |    ^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(warnings)]
  |         ^^^^^^^^
  = note: `#[deny(dead_code)]` implied by `#[deny(warnings)]`

</code></pre>
<h3 id="explanation-130"><a class="header" href="#explanation-130">Explanation</a></h3>
<p>The <code>warnings</code> lint is a bit special; by changing its level, you
change every other warning that would produce a warning to whatever
value you’d like. As such, you won’t ever trigger this lint in your
code directly.</p>
<h2 id="while-true"><a class="header" href="#while-true">while-true</a></h2>
<p>The <code>while_true</code> lint detects <code>while true { }</code>.</p>
<h3 id="example-130"><a class="header" href="#example-130">Example</a></h3>
<pre><code class="language-rust no_run">while true {

}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: denote infinite loops with `loop { ... }`
 --&gt; lint_example.rs:2:1
  |
2 | while true {
  | ^^^^^^^^^^ help: use `loop`
  |
  = note: `#[warn(while_true)]` on by default

</code></pre>
<h3 id="explanation-131"><a class="header" href="#explanation-131">Explanation</a></h3>
<p><code>while true</code> should be replaced with <code>loop</code>. A <code>loop</code> expression is
the preferred way to write an infinite loop because it more directly
expresses the intent of the loop.</p>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
    var fragments = {
        "#bare-trait-object": "warn-by-default.html#bare-trait-objects",
        "#unstable-name-collision": "warn-by-default.html#unstable-name-collisions",
        "#unused-doc-comment": "warn-by-default.html#unused-doc-comments",
        "#redundant-semicolon": "warn-by-default.html#redundant-semicolons",
        "#overlapping-patterns": "warn-by-default.html#overlapping-range-endpoints",
        "#non-fmt-panic": "warn-by-default.html#non-fmt-panics",
        "#unused-tuple-struct-fields": "warn-by-default.html#dead-code",
        "#static-mut-ref": "warn-by-default.html#static-mut-refs",
};
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
});
</script>
<hr>
<ol class="footnote-definition">
<li id="footnote-1">
<p>I.e., paths of the form <code>T::Assoc</code> where <code>T</code> is a type parameter
bounded by trait <code>Trait</code> which defines an associated type called <code>Assoc</code>
as opposed to a fully qualified path of the form <code>&lt;T as Trait&gt;::Assoc</code>. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p><a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes</a> <a href="#fr-2-1">↩</a></p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../lints/listing/allowed-by-default.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../../lints/listing/deny-by-default.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../lints/listing/allowed-by-default.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../../lints/listing/deny-by-default.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../../mark-09e88c2c.min.js"></script>
        <script src="../../searcher-c2a407aa.js"></script>

        <script src="../../clipboard-1626706a.min.js"></script>
        <script src="../../highlight-abc7f01d.js"></script>
        <script src="../../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
