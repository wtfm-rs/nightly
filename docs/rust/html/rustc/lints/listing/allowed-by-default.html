<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Allowed-by-default Lints - The rustc book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../../css/general-2459343d.css">
        <link rel="stylesheet" href="../../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex-87c53738.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc-699d0b49.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The rustc book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/rustc" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/edit/main/src/doc/rustc/src/lints/listing/allowed-by-default.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="allowed-by-default-lints"><a class="header" href="#allowed-by-default-lints">Allowed-by-default Lints</a></h1>
<p>These lints are all set to the ‘allow’ level by default. As such, they won’t show up
unless you set them to a higher lint level with a flag or attribute.</p>
<ul>
<li><a href="#absolute-paths-not-starting-with-crate"><code>absolute_paths_not_starting_with_crate</code></a></li>
<li><a href="#ambiguous-negative-literals"><code>ambiguous_negative_literals</code></a></li>
<li><a href="#async-idents"><code>async-idents</code></a></li>
<li><a href="#closure-returning-async-block"><code>closure_returning_async_block</code></a></li>
<li><a href="#deprecated-safe-2024"><code>deprecated_safe_2024</code></a></li>
<li><a href="#deref-into-dyn-supertrait"><code>deref_into_dyn_supertrait</code></a></li>
<li><a href="#disjoint-capture-migration"><code>disjoint-capture-migration</code></a></li>
<li><a href="#edition-2024-expr-fragment-specifier"><code>edition_2024_expr_fragment_specifier</code></a></li>
<li><a href="#elided-lifetime-in-path"><code>elided-lifetime-in-path</code></a></li>
<li><a href="#elided-lifetimes-in-paths"><code>elided_lifetimes_in_paths</code></a></li>
<li><a href="#explicit-outlives-requirements"><code>explicit_outlives_requirements</code></a></li>
<li><a href="#ffi-unwind-calls"><code>ffi_unwind_calls</code></a></li>
<li><a href="#fuzzy-provenance-casts"><code>fuzzy_provenance_casts</code></a></li>
<li><a href="#if-let-rescope"><code>if_let_rescope</code></a></li>
<li><a href="#impl-trait-overcaptures"><code>impl_trait_overcaptures</code></a></li>
<li><a href="#impl-trait-redundant-captures"><code>impl_trait_redundant_captures</code></a></li>
<li><a href="#keyword-idents"><code>keyword-idents</code></a></li>
<li><a href="#keyword-idents-2018"><code>keyword_idents_2018</code></a></li>
<li><a href="#keyword-idents-2024"><code>keyword_idents_2024</code></a></li>
<li><a href="#let-underscore-drop"><code>let_underscore_drop</code></a></li>
<li><a href="#linker-messages"><code>linker_messages</code></a></li>
<li><a href="#lossy-provenance-casts"><code>lossy_provenance_casts</code></a></li>
<li><a href="#macro-use-extern-crate"><code>macro_use_extern_crate</code></a></li>
<li><a href="#meta-variable-misuse"><code>meta_variable_misuse</code></a></li>
<li><a href="#missing-copy-implementations"><code>missing_copy_implementations</code></a></li>
<li><a href="#missing-debug-implementations"><code>missing_debug_implementations</code></a></li>
<li><a href="#missing-docs"><code>missing_docs</code></a></li>
<li><a href="#missing-unsafe-on-extern"><code>missing_unsafe_on_extern</code></a></li>
<li><a href="#multiple-supertrait-upcastable"><code>multiple_supertrait_upcastable</code></a></li>
<li><a href="#must-not-suspend"><code>must_not_suspend</code></a></li>
<li><a href="#non-ascii-idents"><code>non_ascii_idents</code></a></li>
<li><a href="#non-exhaustive-omitted-patterns"><code>non_exhaustive_omitted_patterns</code></a></li>
<li><a href="#or-patterns-back-compat"><code>or-patterns-back-compat</code></a></li>
<li><a href="#redundant-imports"><code>redundant_imports</code></a></li>
<li><a href="#redundant-lifetimes"><code>redundant_lifetimes</code></a></li>
<li><a href="#resolving-to-items-shadowing-supertrait-items"><code>resolving_to_items_shadowing_supertrait_items</code></a></li>
<li><a href="#rust-2021-incompatible-closure-captures"><code>rust_2021_incompatible_closure_captures</code></a></li>
<li><a href="#rust-2021-incompatible-or-patterns"><code>rust_2021_incompatible_or_patterns</code></a></li>
<li><a href="#rust-2021-prefixes-incompatible-syntax"><code>rust_2021_prefixes_incompatible_syntax</code></a></li>
<li><a href="#rust-2021-prelude-collisions"><code>rust_2021_prelude_collisions</code></a></li>
<li><a href="#rust-2024-guarded-string-incompatible-syntax"><code>rust_2024_guarded_string_incompatible_syntax</code></a></li>
<li><a href="#rust-2024-incompatible-pat"><code>rust_2024_incompatible_pat</code></a></li>
<li><a href="#rust-2024-prelude-collisions"><code>rust_2024_prelude_collisions</code></a></li>
<li><a href="#shadowing-supertrait-items"><code>shadowing_supertrait_items</code></a></li>
<li><a href="#single-use-lifetime"><code>single-use-lifetime</code></a></li>
<li><a href="#single-use-lifetimes"><code>single_use_lifetimes</code></a></li>
<li><a href="#tail-expr-drop-order"><code>tail_expr_drop_order</code></a></li>
<li><a href="#trivial-casts"><code>trivial_casts</code></a></li>
<li><a href="#trivial-numeric-casts"><code>trivial_numeric_casts</code></a></li>
<li><a href="#unit-bindings"><code>unit_bindings</code></a></li>
<li><a href="#unnameable-types"><code>unnameable_types</code></a></li>
<li><a href="#unqualified-local-imports"><code>unqualified_local_imports</code></a></li>
<li><a href="#unreachable-pub"><code>unreachable_pub</code></a></li>
<li><a href="#unsafe-attr-outside-unsafe"><code>unsafe_attr_outside_unsafe</code></a></li>
<li><a href="#unsafe-code"><code>unsafe_code</code></a></li>
<li><a href="#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a></li>
<li><a href="#unstable-features"><code>unstable_features</code></a></li>
<li><a href="#unused-crate-dependencies"><code>unused_crate_dependencies</code></a></li>
<li><a href="#unused-extern-crates"><code>unused_extern_crates</code></a></li>
<li><a href="#unused-import-braces"><code>unused_import_braces</code></a></li>
<li><a href="#unused-lifetimes"><code>unused_lifetimes</code></a></li>
<li><a href="#unused-macro-rules"><code>unused_macro_rules</code></a></li>
<li><a href="#unused-qualifications"><code>unused_qualifications</code></a></li>
<li><a href="#unused-results"><code>unused_results</code></a></li>
<li><a href="#variant-size-differences"><code>variant_size_differences</code></a></li>
</ul>
<h2 id="absolute-paths-not-starting-with-crate"><a class="header" href="#absolute-paths-not-starting-with-crate">absolute-paths-not-starting-with-crate</a></h2>
<p>The <code>absolute_paths_not_starting_with_crate</code> lint detects fully
qualified paths that start with a module name instead of <code>crate</code>,
<code>self</code>, or an extern crate name</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(absolute_paths_not_starting_with_crate)]

mod foo {
    pub fn bar() {}
}

fn main() {
    ::foo::bar();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition
 --&gt; lint_example.rs:8:5
  |
8 |     ::foo::bar();
  |     ^^^^^^^^^^ help: use `crate`: `crate::foo::bar`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(absolute_paths_not_starting_with_crate)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses absolute
paths in the style of the 2015 edition. In the 2015 edition, absolute
paths (those starting with <code>::</code>) refer to either the crate root or an
external crate. In the 2018 edition it was changed so that they only
refer to external crates. The path prefix <code>crate::</code> should be used
instead to reference items from the crate root.</p>
<p>If you switch the compiler from the 2015 to 2018 edition without
updating the code, then it will fail to compile if the old style paths
are used. You can manually change the paths to use the <code>crate::</code>
prefix to transition to the 2018 edition.</p>
<p>This lint solves the problem automatically. It is “allow” by default
because the code is perfectly valid in the 2015 edition. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to “warn”
and automatically apply the suggested fix from the compiler. This
provides a completely automated way to update old code to the 2018
edition.</p>
<h2 id="ambiguous-negative-literals"><a class="header" href="#ambiguous-negative-literals">ambiguous-negative-literals</a></h2>
<p>The <code>ambiguous_negative_literals</code> lint checks for cases that are
confusing between a negative literal and a negation that’s not part
of the literal.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![deny(ambiguous_negative_literals)]
</span><span class="boring">#![allow(unused)]
</span>-1i32.abs(); // equals -1, while `(-1i32).abs()` equals 1</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `-` has lower precedence than method calls, which might be unexpected
 --&gt; lint_example.rs:4:1
  |
4 | -1i32.abs(); // equals -1, while `(-1i32).abs()` equals 1
  | ^^^^^^^^^^^
  |
  = note: e.g. `-4.abs()` equals `-4`; while `(-4).abs()` equals `4`
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(ambiguous_negative_literals)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: add parentheses around the `-` and the literal to call the method on a negative literal
  |
4 | (-1i32).abs(); // equals -1, while `(-1i32).abs()` equals 1
  | +     +
help: add parentheses around the literal and the method call to keep the current behavior
  |
4 | -(1i32.abs()); // equals -1, while `(-1i32).abs()` equals 1
  |  +          +

</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h3>
<p>Method calls take precedence over unary precedence. Setting the
precedence explicitly makes the code clearer and avoid potential bugs.</p>
<h2 id="async-idents"><a class="header" href="#async-idents">async-idents</a></h2>
<p>The lint <code>async-idents</code> has been renamed to <a href="#keyword-idents"><code>keyword-idents</code></a>.</p>
<h2 id="closure-returning-async-block"><a class="header" href="#closure-returning-async-block">closure-returning-async-block</a></h2>
<p>The <code>closure_returning_async_block</code> lint detects cases where users
write a closure that returns an async block.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-rust">#![warn(closure_returning_async_block)]
let c = |x: &amp;str| async {};</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: closure returning async block can be made into an async closure
 --&gt; lint_example.rs:3:9
  |
3 | let c = |x: &amp;str| async {};
  |         ^^^^^^^^^ ----- this async block can be removed, and the closure can be turned into an async closure
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(closure_returning_async_block)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: turn this into an async closure
  |
3 - let c = |x: &amp;str| async {};
3 + let c = async |x: &amp;str| {};
  |

</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<p>Using an async closure is preferable over a closure that returns an
async block, since async closures are less restrictive in how its
captures are allowed to be used.</p>
<p>For example, this code does not work with a closure returning an async
block:</p>
<pre><code class="language-rust compile_fail">async fn callback(x: &amp;str) {}

let captured_str = String::new();
let c = move || async {
    callback(&amp;captured_str).await;
};</code></pre>
<p>But it does work with async closures:</p>
<pre><code class="language-rust">async fn callback(x: &amp;str) {}

let captured_str = String::new();
let c = async move || {
    callback(&amp;captured_str).await;
};</code></pre>
<h2 id="deprecated-safe-2024"><a class="header" href="#deprecated-safe-2024">deprecated-safe-2024</a></h2>
<p>The <code>deprecated_safe_2024</code> lint detects unsafe functions being used as
safe functions.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(deprecated_safe)]
// edition 2021
use std::env;
fn enable_backtrace() {
    env::set_var("RUST_BACKTRACE", "1");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: call to deprecated safe function `std::env::set_var` is unsafe and requires unsafe block
 --&gt; lint_example.rs:6:5
  |
6 |     env::set_var("RUST_BACKTRACE", "1");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/newly-unsafe-functions.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(deprecated_safe)]
  |         ^^^^^^^^^^^^^^^
  = note: `#[deny(deprecated_safe_2024)]` implied by `#[deny(deprecated_safe)]`
help: you can wrap the call in an `unsafe` block if you can guarantee that the environment access only happens in single-threaded code
  |
6 +     // TODO: Audit that the environment access only happens in single-threaded code.
7 ~     unsafe { env::set_var("RUST_BACKTRACE", "1") };
  |

</code></pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking backward
compatibility. This lint catches code that uses <code>unsafe</code> functions that
were declared as safe (non-<code>unsafe</code>) in editions prior to Rust 2024. If
you switch the compiler to Rust 2024 without updating the code, then it
will fail to compile if you are using a function previously marked as
safe.</p>
<p>You can audit the code to see if it suffices the preconditions of the
<code>unsafe</code> code, and if it does, you can wrap it in an <code>unsafe</code> block. If
you can’t fulfill the preconditions, you probably need to switch to a
different way of doing what you want to achieve.</p>
<p>This lint can automatically wrap the calls in <code>unsafe</code> blocks, but this
obviously cannot verify that the preconditions of the <code>unsafe</code>
functions are fulfilled, so that is still up to the user.</p>
<p>The lint is currently “allow” by default, but that might change in the
future.</p>
<h2 id="deref-into-dyn-supertrait"><a class="header" href="#deref-into-dyn-supertrait">deref-into-dyn-supertrait</a></h2>
<p>The <code>deref_into_dyn_supertrait</code> lint is emitted whenever there is a <code>Deref</code> implementation
for <code>dyn SubTrait</code> with a <code>dyn SuperTrait</code> type as the <code>Output</code> type.</p>
<p>These implementations are “shadowed” by trait upcasting (stabilized since
1.86.0). The <code>deref</code> functions is no longer called implicitly, which might
change behavior compared to previous rustc versions.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(deref_into_dyn_supertrait)]
#![allow(dead_code)]

use core::ops::Deref;

trait A {}
trait B: A {}
impl&lt;'a&gt; Deref for dyn 'a + B {
    type Target = dyn A;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        todo!()
    }
}

fn take_a(_: &amp;dyn A) { }

fn take_b(b: &amp;dyn B) {
    take_a(b);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this `Deref` implementation is covered by an implicit supertrait coercion
  --&gt; lint_example.rs:9:1
   |
 9 | impl&lt;'a&gt; Deref for dyn 'a + B {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `dyn B` implements `Deref&lt;Target = dyn A&gt;` which conflicts with supertrait `A`
10 |     type Target = dyn A;
   |     ----------- target type is a supertrait of `dyn B`
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(deref_into_dyn_supertrait)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h3>
<p>The trait upcasting coercion added a new coercion rule, taking priority over certain other
coercion rules, which causes some behavior change compared to older <code>rustc</code> versions.</p>
<p><code>deref</code> can be still called explicitly, it just isn’t called as part of a deref coercion
(since trait upcasting coercion takes priority).</p>
<h2 id="disjoint-capture-migration"><a class="header" href="#disjoint-capture-migration">disjoint-capture-migration</a></h2>
<p>The lint <code>disjoint-capture-migration</code> has been renamed to <a href="#rust-2021-incompatible-closure-captures"><code>rust-2021-incompatible-closure-captures</code></a>.</p>
<h2 id="edition-2024-expr-fragment-specifier"><a class="header" href="#edition-2024-expr-fragment-specifier">edition-2024-expr-fragment-specifier</a></h2>
<p>The <code>edition_2024_expr_fragment_specifier</code> lint detects the use of
<code>expr</code> fragments in macros during migration to the 2024 edition.</p>
<p>The <code>expr</code> fragment specifier will accept more expressions in the 2024
edition. To maintain the behavior from the 2021 edition and earlier, use
the <code>expr_2021</code> fragment specifier.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(edition_2024_expr_fragment_specifier)]
macro_rules! m {
  ($e:expr) =&gt; {
      $e
  }
}

fn main() {
   m!(1);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the `expr` fragment specifier will accept more expressions in the 2024 edition
 --&gt; lint_example.rs:3:7
  |
3 |   ($e:expr) =&gt; {
  |       ^^^^
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/macro-fragment-specifiers.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(edition_2024_expr_fragment_specifier)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to keep the existing behavior, use the `expr_2021` fragment specifier
  |
3 |   ($e:expr_2021) =&gt; {
  |           +++++

</code></pre>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking backwards
compatibility. This lint catches code that uses <a href="https://doc.rust-lang.org/edition-guide/rust-2024/macro-fragment-specifiers.html">macro matcher fragment
specifiers</a> that have changed meaning in the 2024 edition. If you switch
to the new edition without updating the code, your macros may behave
differently.</p>
<p>In the 2024 edition, the <code>expr</code> fragment specifier <code>expr</code> will also
match <code>const { ... }</code> blocks. This means if a macro had a pattern that
matched <code>$e:expr</code> and another that matches <code>const { $e: expr }</code>, for
example, that under the 2024 edition the first pattern would match while
in the 2021 and earlier editions the second pattern would match. To keep
the old behavior, use the <code>expr_2021</code> fragment specifier.</p>
<p>This lint detects macros whose behavior might change due to the changing
meaning of the <code>expr</code> fragment specifier. It is “allow” by default
because the code is perfectly valid in older editions. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a>
tool with the <code>--edition</code> flag will switch this lint to “warn” and
automatically apply the suggested fix from the compiler. This provides a
completely automated way to update old code for a new edition.</p>
<p>Using <code>cargo fix --edition</code> with this lint will ensure that your code
retains the same behavior. This may not be the desired, as macro authors
often will want their macros to use the latest grammar for matching
expressions. Be sure to carefully review changes introduced by this lint
to ensure the macros implement the desired behavior.</p>
<h2 id="elided-lifetime-in-path"><a class="header" href="#elided-lifetime-in-path">elided-lifetime-in-path</a></h2>
<p>The lint <code>elided-lifetime-in-path</code> has been renamed to <a href="#elided-lifetimes-in-paths"><code>elided-lifetimes-in-paths</code></a>.</p>
<h2 id="elided-lifetimes-in-paths"><a class="header" href="#elided-lifetimes-in-paths">elided-lifetimes-in-paths</a></h2>
<p>The <code>elided_lifetimes_in_paths</code> lint detects the use of hidden
lifetime parameters.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(elided_lifetimes_in_paths)]
#![deny(warnings)]
struct Foo&lt;'a&gt; {
    x: &amp;'a u32
}

fn foo(x: &amp;Foo) {
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: hidden lifetime parameters in types are deprecated
 --&gt; lint_example.rs:8:12
  |
8 | fn foo(x: &amp;Foo) {
  |            ^^^ expected lifetime parameter
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(elided_lifetimes_in_paths)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
help: indicate the anonymous lifetime
  |
8 | fn foo(x: &amp;Foo&lt;'_&gt;) {
  |               ++++

</code></pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation</a></h3>
<p>Elided lifetime parameters can make it difficult to see at a glance
that borrowing is occurring. This lint ensures that lifetime
parameters are always explicitly stated, even if it is the <code>'_</code>
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html#lifetime-elision-in-functions">placeholder lifetime</a>.</p>
<p>This lint is “allow” by default because it has some known issues, and
may require a significant transition for old code.</p>
<h2 id="explicit-outlives-requirements"><a class="header" href="#explicit-outlives-requirements">explicit-outlives-requirements</a></h2>
<p>The <code>explicit_outlives_requirements</code> lint detects unnecessary
lifetime bounds that can be inferred.</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(explicit_outlives_requirements)]
#![deny(warnings)]

struct SharedRef&lt;'a, T&gt;
where
    T: 'a,
{
    data: &amp;'a T,
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: outlives requirements can be inferred
 --&gt; lint_example.rs:6:24
  |
6 |   struct SharedRef&lt;'a, T&gt;
  |  ________________________^
7 | | where
8 | |     T: 'a,
  | |__________^ help: remove this bound
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(explicit_outlives_requirements)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation</a></h3>
<p>If a <code>struct</code> contains a reference, such as <code>&amp;'a T</code>, the compiler
requires that <code>T</code> outlives the lifetime <code>'a</code>. This historically
required writing an explicit lifetime bound to indicate this
requirement. However, this can be overly explicit, causing clutter and
unnecessary complexity. The language was changed to automatically
infer the bound if it is not specified. Specifically, if the struct
contains a reference, directly or indirectly, to <code>T</code> with lifetime
<code>'x</code>, then it will infer that <code>T: 'x</code> is a requirement.</p>
<p>This lint is “allow” by default because it can be noisy for existing
code that already had these requirements. This is a stylistic choice,
as it is still valid to explicitly state the bound. It also has some
false positives that can cause confusion.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md">RFC 2093</a> for more details.</p>
<h2 id="ffi-unwind-calls"><a class="header" href="#ffi-unwind-calls">ffi-unwind-calls</a></h2>
<p>The <code>ffi_unwind_calls</code> lint detects calls to foreign functions or function pointers with
<code>C-unwind</code> or other FFI-unwind ABIs.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-rust">#![warn(ffi_unwind_calls)]

unsafe extern "C-unwind" {
    fn foo();
}

fn bar() {
    unsafe { foo(); }
    let ptr: unsafe extern "C-unwind" fn() = foo;
    unsafe { ptr(); }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: call to foreign function with FFI-unwind ABI
 --&gt; lint_example.rs:9:14
  |
9 |     unsafe { foo(); }
  |              ^^^^^ call to foreign function with FFI-unwind ABI
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(ffi_unwind_calls)]
  |         ^^^^^^^^^^^^^^^^


warning: call to function pointer with FFI-unwind ABI
  --&gt; lint_example.rs:11:14
   |
11 |     unsafe { ptr(); }
   |              ^^^^^ call to function pointer with FFI-unwind ABI

</code></pre>
<h3 id="explanation-8"><a class="header" href="#explanation-8">Explanation</a></h3>
<p>For crates containing such calls, if they are compiled with <code>-C panic=unwind</code> then the
produced library cannot be linked with crates compiled with <code>-C panic=abort</code>. For crates
that desire this ability it is therefore necessary to avoid such calls.</p>
<h2 id="fuzzy-provenance-casts"><a class="header" href="#fuzzy-provenance-casts">fuzzy-provenance-casts</a></h2>
<p>The <code>fuzzy_provenance_casts</code> lint detects an <code>as</code> cast between an integer
and a pointer.</p>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><code class="language-rust">#![feature(strict_provenance_lints)]
#![warn(fuzzy_provenance_casts)]

fn main() {
    let _dangling = 16_usize as *const u8;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: strict provenance disallows casting integer `usize` to pointer `*const u8`
 --&gt; lint_example.rs:5:21
  |
5 |     let _dangling = 16_usize as *const u8;
  |                     ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: if you can't comply with strict provenance and don't have a pointer with the correct provenance you can use `std::ptr::with_exposed_provenance()` instead
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![warn(fuzzy_provenance_casts)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
help: use `.with_addr()` to adjust a valid pointer in the same allocation, to this address
  |
5 -     let _dangling = 16_usize as *const u8;
5 +     let _dangling = (...).with_addr(16_usize);
  |

</code></pre>
<h3 id="explanation-9"><a class="header" href="#explanation-9">Explanation</a></h3>
<p>This lint is part of the strict provenance effort, see <a href="https://github.com/rust-lang/rust/issues/95228">issue #95228</a>.
Casting an integer to a pointer is considered bad style, as a pointer
contains, besides the <em>address</em> also a <em>provenance</em>, indicating what
memory the pointer is allowed to read/write. Casting an integer, which
doesn’t have provenance, to a pointer requires the compiler to assign
(guess) provenance. The compiler assigns “all exposed valid” (see the
docs of <a href="https://doc.rust-lang.org/core/ptr/fn.with_exposed_provenance.html"><code>ptr::with_exposed_provenance</code></a> for more information about this
“exposing”). This penalizes the optimiser and is not well suited for
dynamic analysis/dynamic program verification (e.g. Miri or CHERI
platforms).</p>
<p>It is much better to use <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.with_addr"><code>ptr::with_addr</code></a> instead to specify the
provenance you want. If using this function is not possible because the
code relies on exposed provenance then there is as an escape hatch
<a href="https://doc.rust-lang.org/core/ptr/fn.with_exposed_provenance.html"><code>ptr::with_exposed_provenance</code></a>.</p>
<h2 id="if-let-rescope"><a class="header" href="#if-let-rescope">if-let-rescope</a></h2>
<p>The <code>if_let_rescope</code> lint detects cases where a temporary value with
significant drop is generated on the right hand side of <code>if let</code>
and suggests a rewrite into <code>match</code> when possible.</p>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(if_let_rescope)]
#![allow(unused_variables)]

struct Droppy;
impl Drop for Droppy {
    fn drop(&amp;mut self) {
        // Custom destructor, including this `drop` implementation, is considered
        // significant.
        // Rust does not check whether this destructor emits side-effects that can
        // lead to observable change in program semantics, when the drop order changes.
        // Rust biases to be on the safe side, so that you can apply discretion whether
        // this change indeed breaches any contract or specification that your code needs
        // to honour.
        println!("dropped");
    }
}
impl Droppy {
    fn get(&amp;self) -&gt; Option&lt;u8&gt; {
        None
    }
}

fn main() {
    if let Some(value) = Droppy.get() {
        // do something
    } else {
        // do something else
    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `if let` assigns a shorter lifetime since Edition 2024
  --&gt; lint_example.rs:24:8
   |
24 |     if let Some(value) = Droppy.get() {
   |        ^^^^^^^^^^^^^^^^^^------^^^^^^
   |                          |
   |                          this value has a significant drop implementation which may observe a major change in drop order and requires your discretion
   |
   = warning: this changes meaning in Rust 2024
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html&gt;
note: value invokes this custom destructor
  --&gt; lint_example.rs:5:1
   |
 5 | impl Drop for Droppy {
   | ^^^^^^^^^^^^^^^^^^^^
help: the value is now dropped here in Edition 2024
  --&gt; lint_example.rs:26:5
   |
26 |     } else {
   |     ^
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![warn(if_let_rescope)]
   |         ^^^^^^^^^^^^^^
help: a `match` with a single arm can preserve the drop order up to Edition 2021
   |
24 ~     match Droppy.get() { Some(value) =&gt; {
25 |         // do something
26 ~     } _ =&gt; {
27 |         // do something else
28 ~     }}
   |

</code></pre>
<h3 id="explanation-10"><a class="header" href="#explanation-10">Explanation</a></h3>
<p>With Edition 2024, temporaries generated while evaluating <code>if let</code>s
will be dropped before the <code>else</code> block.
This lint captures a possible change in runtime behaviour due to
a change in sequence of calls to significant <code>Drop::drop</code> destructors.</p>
<p>A significant <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop::drop</code></a>
destructor here refers to an explicit, arbitrary implementation of the <code>Drop</code> trait on the type
with exceptions including <code>Vec</code>, <code>Box</code>, <code>Rc</code>, <code>BTreeMap</code> and <code>HashMap</code>
that are marked by the compiler otherwise so long that the generic types have
no significant destructor recursively.
In other words, a type has a significant drop destructor when it has a <code>Drop</code> implementation
or its destructor invokes a significant destructor on a type.
Since we cannot completely reason about the change by just inspecting the existence of
a significant destructor, this lint remains only a suggestion and is set to <code>allow</code> by default.</p>
<p>Whenever possible, a rewrite into an equivalent <code>match</code> expression that
observe the same order of calls to such destructors is proposed by this lint.
Authors may take their own discretion whether the rewrite suggestion shall be
accepted, or rejected to continue the use of the <code>if let</code> expression.</p>
<h2 id="impl-trait-overcaptures"><a class="header" href="#impl-trait-overcaptures">impl-trait-overcaptures</a></h2>
<p>The <code>impl_trait_overcaptures</code> lint warns against cases where lifetime
capture behavior will differ in edition 2024.</p>
<p>In the 2024 edition, <code>impl Trait</code>s will capture all lifetimes in scope,
rather than just the lifetimes that are mentioned in the bounds of the type.
Often these sets are equal, but if not, it means that the <code>impl Trait</code> may
cause erroneous borrow-checker errors.</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><code class="language-rust compile_fail edition2021"><span class="boring">#![deny(impl_trait_overcaptures)]
</span><span class="boring">use std::fmt::Display;
</span>let mut x = vec![];
x.push(1);

fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display {
    x[0]
}

let element = test(&amp;x);
x.push(2);
println!("{element}");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `impl std::fmt::Display` will capture more lifetimes than possibly intended in edition 2024
 --&gt; lint_example.rs:7:26
  |
7 | fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display {
  |                          ^^^^^^^^^^^^
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/rpit-lifetime-capture.html&gt;
note: specifically, this lifetime is in scope but not mentioned in the type's bounds
 --&gt; lint_example.rs:7:12
  |
7 | fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display {
  |            ^
  = note: all lifetimes in scope will be captured by `impl Trait`s in edition 2024
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(impl_trait_overcaptures)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^
help: use the precise capturing `use&lt;...&gt;` syntax to make the captures explicit
  |
7 | fn test(x: &amp;Vec&lt;i32&gt;) -&gt; impl Display + use&lt;&gt; {
  |                                       +++++++

</code></pre>
<h3 id="explanation-11"><a class="header" href="#explanation-11">Explanation</a></h3>
<p>In edition &lt; 2024, the returned <code>impl Display</code> doesn’t capture the
lifetime from the <code>&amp;Vec&lt;i32&gt;</code>, so the vector can be mutably borrowed
while the <code>impl Display</code> is live.</p>
<p>To fix this, we can explicitly state that the <code>impl Display</code> doesn’t
capture any lifetimes, using <code>impl Display + use&lt;&gt;</code>.</p>
<h2 id="impl-trait-redundant-captures"><a class="header" href="#impl-trait-redundant-captures">impl-trait-redundant-captures</a></h2>
<p>The <code>impl_trait_redundant_captures</code> lint warns against cases where use of the
precise capturing <code>use&lt;...&gt;</code> syntax is not needed.</p>
<p>In the 2024 edition, <code>impl Trait</code>s will capture all lifetimes in scope.
If precise-capturing <code>use&lt;...&gt;</code> syntax is used, and the set of parameters
that are captures are <em>equal</em> to the set of parameters in scope, then
the syntax is redundant, and can be removed.</p>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<pre><code class="language-rust edition2024 compile_fail"><span class="boring">#![deny(impl_trait_redundant_captures)]
</span>fn test&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Sized + use&lt;'a&gt; { x }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: all possible in-scope parameters are already captured, so `use&lt;...&gt;` syntax is redundant
 --&gt; lint_example.rs:3:28
  |
3 | fn test&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Sized + use&lt;'a&gt; { x }
  |                            ^^^^^^^^^^^^^-------
  |                                         |
  |                                         help: remove the `use&lt;...&gt;` syntax
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(impl_trait_redundant_captures)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-12"><a class="header" href="#explanation-12">Explanation</a></h3>
<p>To fix this, remove the <code>use&lt;'a&gt;</code>, since the lifetime is already captured
since it is in scope.</p>
<h2 id="keyword-idents"><a class="header" href="#keyword-idents">keyword-idents</a></h2>
<p>The lint <code>keyword-idents</code> has been renamed to <a href="#keyword-idents-2018"><code>keyword-idents-2018</code></a>.</p>
<h2 id="keyword-idents-2018"><a class="header" href="#keyword-idents-2018">keyword-idents-2018</a></h2>
<p>The <code>keyword_idents_2018</code> lint detects edition keywords being used as an
identifier.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(keyword_idents_2018)]
// edition 2015
fn dyn() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `dyn` is a keyword in the 2018 edition
 --&gt; lint_example.rs:4:4
  |
4 | fn dyn() {}
  |    ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(keyword_idents_2018)]
  |         ^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-13"><a class="header" href="#explanation-13">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses new keywords
that are added to the language that are used as identifiers (such as a
variable name, function name, etc.). If you switch the compiler to a
new edition without updating the code, then it will fail to compile if
you are using a new keyword as an identifier.</p>
<p>You can manually change the identifiers to a non-keyword, or use a
<a href="https://doc.rust-lang.org/reference/identifiers.html">raw identifier</a>, for example <code>r#dyn</code>, to transition to a new edition.</p>
<p>This lint solves the problem automatically. It is “allow” by default
because the code is perfectly valid in older editions. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to “warn”
and automatically apply the suggested fix from the compiler (which is
to use a raw identifier). This provides a completely automated way to
update old code for a new edition.</p>
<h2 id="keyword-idents-2024"><a class="header" href="#keyword-idents-2024">keyword-idents-2024</a></h2>
<p>The <code>keyword_idents_2024</code> lint detects edition keywords being used as an
identifier.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<pre><code class="language-rust edition2015 compile_fail">#![deny(keyword_idents_2024)]
// edition 2015
fn gen() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `gen` is a keyword in the 2024 edition
 --&gt; lint_example.rs:4:4
  |
4 | fn gen() {}
  |    ^^^ help: you can use a raw identifier to stay compatible: `r#gen`
  |
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/gen-keyword.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(keyword_idents_2024)]
  |         ^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-14"><a class="header" href="#explanation-14">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses new keywords
that are added to the language that are used as identifiers (such as a
variable name, function name, etc.). If you switch the compiler to a
new edition without updating the code, then it will fail to compile if
you are using a new keyword as an identifier.</p>
<p>You can manually change the identifiers to a non-keyword, or use a
<a href="https://doc.rust-lang.org/reference/identifiers.html">raw identifier</a>, for example <code>r#gen</code>, to transition to a new edition.</p>
<p>This lint solves the problem automatically. It is “allow” by default
because the code is perfectly valid in older editions. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to “warn”
and automatically apply the suggested fix from the compiler (which is
to use a raw identifier). This provides a completely automated way to
update old code for a new edition.</p>
<h2 id="let-underscore-drop"><a class="header" href="#let-underscore-drop">let-underscore-drop</a></h2>
<p>The <code>let_underscore_drop</code> lint checks for statements which don’t bind
an expression which has a non-trivial Drop implementation to anything,
causing the expression to be dropped immediately instead of at end of
scope.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<pre><code class="language-rust">struct SomeStruct;
impl Drop for SomeStruct {
    fn drop(&amp;mut self) {
        println!("Dropping SomeStruct");
    }
}

fn main() {
   #[warn(let_underscore_drop)]
    // SomeStruct is dropped immediately instead of at end of scope,
    // so "Dropping SomeStruct" is printed before "end of main".
    // The order of prints would be reversed if SomeStruct was bound to
    // a name (such as "_foo").
    let _ = SomeStruct;
    println!("end of main");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: non-binding let on a type that has a destructor
  --&gt; lint_example.rs:14:5
   |
14 |     let _ = SomeStruct;
   |     ^^^^^^^^^^^^^^^^^^^
   |
note: the lint level is defined here
  --&gt; lint_example.rs:9:11
   |
 9 |    #[warn(let_underscore_drop)]
   |           ^^^^^^^^^^^^^^^^^^^
help: consider binding to an unused variable to avoid immediately dropping the value
   |
14 |     let _unused = SomeStruct;
   |          ++++++
help: consider immediately dropping the value
   |
14 -     let _ = SomeStruct;
14 +     drop(SomeStruct);
   |

</code></pre>
<h3 id="explanation-15"><a class="header" href="#explanation-15">Explanation</a></h3>
<p>Statements which assign an expression to an underscore causes the
expression to immediately drop instead of extending the expression’s
lifetime to the end of the scope. This is usually unintended,
especially for types like <code>MutexGuard</code>, which are typically used to
lock a mutex for the duration of an entire scope.</p>
<p>If you want to extend the expression’s lifetime to the end of the scope,
assign an underscore-prefixed name (such as <code>_foo</code>) to the expression.
If you do actually want to drop the expression immediately, then
calling <code>std::mem::drop</code> on the expression is clearer and helps convey
intent.</p>
<h2 id="linker-messages"><a class="header" href="#linker-messages">linker-messages</a></h2>
<p>The <code>linker_messages</code> lint forwards warnings from the linker.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<pre><code class="language-rust ignore (needs CLI args platform-specific)">#[warn(linker_messages)]
extern "C" {
  fn foo();
}
fn main () { unsafe { foo(); } }</code></pre>
<p>On Linux, using <code>gcc -Wl,--warn-unresolved-symbols</code> as a linker, this will produce</p>
<pre><code class="language-text">warning: linker stderr: rust-lld: undefined symbol: foo
         &gt;&gt;&gt; referenced by rust_out.69edbd30df4ae57d-cgu.0
         &gt;&gt;&gt;               rust_out.rust_out.69edbd30df4ae57d-cgu.0.rcgu.o:(rust_out::main::h3a90094b06757803)
  |
note: the lint level is defined here
 --&gt; warn.rs:1:9
  |
1 | #![warn(linker_messages)]
  |         ^^^^^^^^^^^^^^^
warning: 1 warning emitted
</code></pre>
<h3 id="explanation-16"><a class="header" href="#explanation-16">Explanation</a></h3>
<p>Linkers emit platform-specific and program-specific warnings that cannot be predicted in
advance by the Rust compiler. Such messages are ignored by default for now. While linker
warnings could be very useful they have been ignored for many years by essentially all
users, so we need to do a bit more work than just surfacing their text to produce a clear
and actionable warning of similar quality to our other diagnostics. See this tracking
issue for more details: <a href="https://github.com/rust-lang/rust/issues/136096">https://github.com/rust-lang/rust/issues/136096</a>.</p>
<h2 id="lossy-provenance-casts"><a class="header" href="#lossy-provenance-casts">lossy-provenance-casts</a></h2>
<p>The <code>lossy_provenance_casts</code> lint detects an <code>as</code> cast between a pointer
and an integer.</p>
<h3 id="example-17"><a class="header" href="#example-17">Example</a></h3>
<pre><code class="language-rust">#![feature(strict_provenance_lints)]
#![warn(lossy_provenance_casts)]

fn main() {
    let x: u8 = 37;
    let _addr: usize = &amp;x as *const u8 as usize;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: under strict provenance it is considered bad style to cast pointer `*const u8` to integer `usize`
 --&gt; lint_example.rs:6:24
  |
6 |     let _addr: usize = &amp;x as *const u8 as usize;
  |                        ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: if you can't comply with strict provenance and need to expose the pointer provenance you can use `.expose_provenance()` instead
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![warn(lossy_provenance_casts)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
help: use `.addr()` to obtain the address of a pointer
  |
6 -     let _addr: usize = &amp;x as *const u8 as usize;
6 +     let _addr: usize = (&amp;x as *const u8).addr();
  |

</code></pre>
<h3 id="explanation-17"><a class="header" href="#explanation-17">Explanation</a></h3>
<p>This lint is part of the strict provenance effort, see <a href="https://github.com/rust-lang/rust/issues/95228">issue #95228</a>.
Casting a pointer to an integer is a lossy operation, because beyond
just an <em>address</em> a pointer may be associated with a particular
<em>provenance</em>. This information is used by the optimiser and for dynamic
analysis/dynamic program verification (e.g. Miri or CHERI platforms).</p>
<p>Since this cast is lossy, it is considered good style to use the
<a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.addr"><code>ptr::addr</code></a> method instead, which has a similar effect, but doesn’t
“expose” the pointer provenance. This improves optimisation potential.
See the docs of <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.addr"><code>ptr::addr</code></a> and <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.expose_provenance"><code>ptr::expose_provenance</code></a> for more information
about exposing pointer provenance.</p>
<p>If your code can’t comply with strict provenance and needs to expose
the provenance, then there is <a href="https://doc.rust-lang.org/core/primitive.pointer.html#method.expose_provenance"><code>ptr::expose_provenance</code></a> as an escape hatch,
which preserves the behaviour of <code>as usize</code> casts while being explicit
about the semantics.</p>
<h2 id="macro-use-extern-crate"><a class="header" href="#macro-use-extern-crate">macro-use-extern-crate</a></h2>
<p>The <code>macro_use_extern_crate</code> lint detects the use of the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a>.</p>
<h3 id="example-18"><a class="header" href="#example-18">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#![deny(macro_use_extern_crate)]

#[macro_use]
extern crate serde_json;

fn main() {
    let _ = json!{{}};
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: applying the `#[macro_use]` attribute to an `extern crate` item is deprecated
 --&gt; src/main.rs:3:1
  |
3 | #[macro_use]
  | ^^^^^^^^^^^^
  |
  = help: remove it and import macros at use sites with a `use` item instead
note: the lint level is defined here
 --&gt; src/main.rs:1:9
  |
1 | #![deny(macro_use_extern_crate)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<h3 id="explanation-18"><a class="header" href="#explanation-18">Explanation</a></h3>
<p>The <a href="https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a> on an <a href="https://doc.rust-lang.org/reference/items/extern-crates.html"><code>extern crate</code></a> item causes
macros in that external crate to be brought into the prelude of the
crate, making the macros in scope everywhere. As part of the efforts
to simplify handling of dependencies in the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate">2018 edition</a>, the use of
<code>extern crate</code> is being phased out. To bring macros from extern crates
into scope, it is recommended to use a <a href="https://doc.rust-lang.org/reference/items/use-declarations.html"><code>use</code> import</a>.</p>
<p>This lint is “allow” by default because this is a stylistic choice
that has not been settled, see <a href="https://github.com/rust-lang/rust/issues/52043">issue #52043</a> for more information.</p>
<h2 id="meta-variable-misuse"><a class="header" href="#meta-variable-misuse">meta-variable-misuse</a></h2>
<p>The <code>meta_variable_misuse</code> lint detects possible meta-variable misuse
in macro definitions.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(meta_variable_misuse)]

macro_rules! foo {
    () =&gt; {};
    ($( $i:ident = $($j:ident),+ );*) =&gt; { $( $( $i = $k; )+ )* };
}

fn main() {
    foo!();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unknown macro variable `k`
 --&gt; lint_example.rs:5:55
  |
5 |     ($( $i:ident = $($j:ident),+ );*) =&gt; { $( $( $i = $k; )+ )* };
  |                                                       ^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(meta_variable_misuse)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-19"><a class="header" href="#explanation-19">Explanation</a></h3>
<p>There are quite a few different ways a <a href="https://doc.rust-lang.org/reference/macros-by-example.html"><code>macro_rules</code></a> macro can be
improperly defined. Many of these errors were previously only detected
when the macro was expanded or not at all. This lint is an attempt to
catch some of these problems when the macro is <em>defined</em>.</p>
<p>This lint is “allow” by default because it may have false positives
and other issues. See <a href="https://github.com/rust-lang/rust/issues/61053">issue #61053</a> for more details.</p>
<h2 id="missing-copy-implementations"><a class="header" href="#missing-copy-implementations">missing-copy-implementations</a></h2>
<p>The <code>missing_copy_implementations</code> lint detects potentially-forgotten
implementations of <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> for public types.</p>
<h3 id="example-20"><a class="header" href="#example-20">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_copy_implementations)]
pub struct Foo {
    pub field: i32
}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type could implement `Copy`; consider adding `impl Copy`
 --&gt; lint_example.rs:2:1
  |
2 | / pub struct Foo {
3 | |     pub field: i32
4 | | }
  | |_^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_copy_implementations)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-20"><a class="header" href="#explanation-20">Explanation</a></h3>
<p>Historically (before 1.0), types were automatically marked as <code>Copy</code>
if possible. This was changed so that it required an explicit opt-in
by implementing the <code>Copy</code> trait. As part of this change, a lint was
added to alert if a copyable type was not marked <code>Copy</code>.</p>
<p>This lint is “allow” by default because this code isn’t bad; it is
common to write newtypes like this specifically so that a <code>Copy</code> type
is no longer <code>Copy</code>. <code>Copy</code> types can result in unintended copies of
large data which can impact performance.</p>
<h2 id="missing-debug-implementations"><a class="header" href="#missing-debug-implementations">missing-debug-implementations</a></h2>
<p>The <code>missing_debug_implementations</code> lint detects missing
implementations of <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>fmt::Debug</code></a> for public types.</p>
<h3 id="example-21"><a class="header" href="#example-21">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_debug_implementations)]
pub struct Foo;
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type does not implement `Debug`; consider adding `#[derive(Debug)]` or a manual implementation
 --&gt; lint_example.rs:2:1
  |
2 | pub struct Foo;
  | ^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_debug_implementations)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-21"><a class="header" href="#explanation-21">Explanation</a></h3>
<p>Having a <code>Debug</code> implementation on all types can assist with
debugging, as it provides a convenient way to format and display a
value. Using the <code>#[derive(Debug)]</code> attribute will automatically
generate a typical implementation, or a custom implementation can be
added by manually implementing the <code>Debug</code> trait.</p>
<p>This lint is “allow” by default because adding <code>Debug</code> to all types can
have a negative impact on compile time and code size. It also requires
boilerplate to be added to every type, which can be an impediment.</p>
<h2 id="missing-docs"><a class="header" href="#missing-docs">missing-docs</a></h2>
<p>The <code>missing_docs</code> lint detects missing documentation for public items.</p>
<h3 id="example-22"><a class="header" href="#example-22">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(missing_docs)]
pub fn foo() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: missing documentation for the crate
 --&gt; lint_example.rs:1:1
  |
1 | / #![deny(missing_docs)]
2 | | fn main() {
3 | | pub fn foo() {}
4 | | }
  | |_^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_docs)]
  |         ^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-22"><a class="header" href="#explanation-22">Explanation</a></h3>
<p>This lint is intended to ensure that a library is well-documented.
Items without documentation can be difficult for users to understand
how to use properly.</p>
<p>This lint is “allow” by default because it can be noisy, and not all
projects may want to enforce everything to be documented.</p>
<h2 id="missing-unsafe-on-extern"><a class="header" href="#missing-unsafe-on-extern">missing-unsafe-on-extern</a></h2>
<p>The <code>missing_unsafe_on_extern</code> lint detects missing unsafe keyword on extern declarations.</p>
<h3 id="example-23"><a class="header" href="#example-23">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(missing_unsafe_on_extern)]
#![allow(dead_code)]

extern "C" {
    fn foo(_: i32);
}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: extern blocks should be unsafe
 --&gt; lint_example.rs:4:1
  |
4 |   extern "C" {
  |   ^
  |   |
  |  _help: needs `unsafe` before the extern keyword: `unsafe`
  | |
5 | |     fn foo(_: i32);
6 | | }
  | |_^
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-extern.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(missing_unsafe_on_extern)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-23"><a class="header" href="#explanation-23">Explanation</a></h3>
<p>Declaring extern items, even without ever using them, can cause Undefined Behavior. We
should consider all sources of Undefined Behavior to be unsafe.</p>
<p>This is a <a href="../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future.</p>
<h2 id="multiple-supertrait-upcastable"><a class="header" href="#multiple-supertrait-upcastable">multiple-supertrait-upcastable</a></h2>
<p>The <code>multiple_supertrait_upcastable</code> lint detects when a dyn-compatible trait has multiple
supertraits.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><code class="language-rust">#![feature(multiple_supertrait_upcastable)]
trait A {}
trait B {}

#[warn(multiple_supertrait_upcastable)]
trait C: A + B {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `C` is dyn-compatible and has multiple supertraits
 --&gt; lint_example.rs:7:1
  |
7 | trait C: A + B {}
  | ^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:6:8
  |
6 | #[warn(multiple_supertrait_upcastable)]
  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-24"><a class="header" href="#explanation-24">Explanation</a></h3>
<p>To support upcasting with multiple supertraits, we need to store multiple vtables and this
can result in extra space overhead, even if no code actually uses upcasting.
This lint allows users to identify when such scenarios occur and to decide whether the
additional overhead is justified.</p>
<h2 id="must-not-suspend"><a class="header" href="#must-not-suspend">must-not-suspend</a></h2>
<p>The <code>must_not_suspend</code> lint guards against values that shouldn’t be held across suspend points
(<code>.await</code>)</p>
<h3 id="example-25"><a class="header" href="#example-25">Example</a></h3>
<pre><code class="language-rust">#![feature(must_not_suspend)]
#![warn(must_not_suspend)]

#[must_not_suspend]
struct SyncThing {}

async fn yield_now() {}

pub async fn uhoh() {
    let guard = SyncThing {};
    yield_now().await;
    let _guard = guard;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `SyncThing` held across a suspend point, but should not be
  --&gt; lint_example.rs:11:9
   |
11 |     let guard = SyncThing {};
   |         ^^^^^
12 |     yield_now().await;
   |                 ----- the value is held across this suspend point
   |
help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point
  --&gt; lint_example.rs:11:9
   |
11 |     let guard = SyncThing {};
   |         ^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:2:9
   |
 2 | #![warn(must_not_suspend)]
   |         ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-25"><a class="header" href="#explanation-25">Explanation</a></h3>
<p>The <code>must_not_suspend</code> lint detects values that are marked with the <code>#[must_not_suspend]</code>
attribute being held across suspend points. A “suspend” point is usually a <code>.await</code> in an async
function.</p>
<p>This attribute can be used to mark values that are semantically incorrect across suspends
(like certain types of timers), values that have async alternatives, and values that
regularly cause problems with the <code>Send</code>-ness of async fn’s returned futures (like
<code>MutexGuard</code>’s)</p>
<h2 id="non-ascii-idents"><a class="header" href="#non-ascii-idents">non-ascii-idents</a></h2>
<p>The <code>non_ascii_idents</code> lint detects non-ASCII identifiers.</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(non_ascii_idents)]
fn main() {
    let föö = 1;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: identifier contains non-ASCII characters
 --&gt; lint_example.rs:4:9
  |
4 |     let föö = 1;
  |         ^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(non_ascii_idents)]
  |         ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-26"><a class="header" href="#explanation-26">Explanation</a></h3>
<p>This lint allows projects that wish to retain the limit of only using
ASCII characters to switch this lint to “forbid” (for example to ease
collaboration or for security reasons).
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md">RFC 2457</a> for more details.</p>
<h2 id="non-exhaustive-omitted-patterns"><a class="header" href="#non-exhaustive-omitted-patterns">non-exhaustive-omitted-patterns</a></h2>
<p>The <code>non_exhaustive_omitted_patterns</code> lint aims to help consumers of a <code>#[non_exhaustive]</code>
struct or enum who want to match all of its fields/variants explicitly.</p>
<p>The <code>#[non_exhaustive]</code> annotation forces matches to use wildcards, so exhaustiveness
checking cannot be used to ensure that all fields/variants are matched explicitly. To remedy
this, this allow-by-default lint warns the user when a match mentions some but not all of
the fields/variants of a <code>#[non_exhaustive]</code> struct or enum.</p>
<h3 id="example-27"><a class="header" href="#example-27">Example</a></h3>
<pre><code class="language-rust ignore (needs separate crate)">// crate A
#[non_exhaustive]
pub enum Bar {
    A,
    B, // added variant in non breaking change
}

// in crate B
#![feature(non_exhaustive_omitted_patterns_lint)]
#[warn(non_exhaustive_omitted_patterns)]
match Bar::A {
    Bar::A =&gt; {},
    _ =&gt; {},
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: some variants are not matched explicitly
   --&gt; $DIR/reachable-patterns.rs:70:9
   |
LL |         match Bar::A {
   |               ^ pattern `Bar::B` not covered
   |
 note: the lint level is defined here
  --&gt; $DIR/reachable-patterns.rs:69:16
   |
LL |         #[warn(non_exhaustive_omitted_patterns)]
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: ensure that all variants are matched explicitly by adding the suggested match arms
   = note: the matched value is of type `Bar` and the `non_exhaustive_omitted_patterns` attribute was found
</code></pre>
<p>Warning: setting this to <code>deny</code> will make upstream non-breaking changes (adding fields or
variants to a <code>#[non_exhaustive]</code> struct or enum) break your crate. This goes against
expected semver behavior.</p>
<h3 id="explanation-27"><a class="header" href="#explanation-27">Explanation</a></h3>
<p>Structs and enums tagged with <code>#[non_exhaustive]</code> force the user to add a (potentially
redundant) wildcard when pattern-matching, to allow for future addition of fields or
variants. The <code>non_exhaustive_omitted_patterns</code> lint detects when such a wildcard happens to
actually catch some fields/variants. In other words, when the match without the wildcard
would not be exhaustive. This lets the user be informed if new fields/variants were added.</p>
<h2 id="or-patterns-back-compat"><a class="header" href="#or-patterns-back-compat">or-patterns-back-compat</a></h2>
<p>The lint <code>or-patterns-back-compat</code> has been renamed to <a href="#rust-2021-incompatible-or-patterns"><code>rust-2021-incompatible-or-patterns</code></a>.</p>
<h2 id="redundant-imports"><a class="header" href="#redundant-imports">redundant-imports</a></h2>
<p>The <code>redundant_imports</code> lint detects imports that are redundant due to being
imported already; either through a previous import, or being present in
the prelude.</p>
<h3 id="example-28"><a class="header" href="#example-28">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(redundant_imports)]
use std::option::Option::None;
fn foo() -&gt; Option&lt;i32&gt; { None }</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the item `None` is imported redundantly
   --&gt; lint_example.rs:3:5
    |
  3 | use std::option::Option::None;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: /Users/runner/work/rust/rust/library/std/src/prelude/mod.rs:166:13
    |
166 |     pub use core::prelude::rust_2024::*;
    |             ------------------------ the item `None` is already defined here
    |
note: the lint level is defined here
   --&gt; lint_example.rs:1:9
    |
  1 | #![deny(redundant_imports)]
    |         ^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-28"><a class="header" href="#explanation-28">Explanation</a></h3>
<p>Redundant imports are unnecessary and can be removed to simplify code.
If you intended to re-export the item to make it available outside of the
module, add a visibility modifier like <code>pub</code>.</p>
<h2 id="redundant-lifetimes"><a class="header" href="#redundant-lifetimes">redundant-lifetimes</a></h2>
<p>The <code>redundant_lifetimes</code> lint detects lifetime parameters that are
redundant because they are equal to another named lifetime.</p>
<h3 id="example-29"><a class="header" href="#example-29">Example</a></h3>
<pre><code class="language-rust compile_fail">#[deny(redundant_lifetimes)]

// `'a = 'static`, so all usages of `'a` can be replaced with `'static`
pub fn bar&lt;'a: 'static&gt;() {}

// `'a = 'b`, so all usages of `'b` can be replaced with `'a`
pub fn bar&lt;'a: 'b, 'b: 'a&gt;() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unnecessary lifetime parameter `'a`
 --&gt; lint_example.rs:5:12
  |
5 | pub fn bar&lt;'a: 'static&gt;() {}
  |            ^^
  |
  = note: you can use the `'static` lifetime directly, in place of `'a`
note: the lint level is defined here
 --&gt; lint_example.rs:2:8
  |
2 | #[deny(redundant_lifetimes)]
  |        ^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-29"><a class="header" href="#explanation-29">Explanation</a></h3>
<p>Unused lifetime parameters may signal a mistake or unfinished code.
Consider removing the parameter.</p>
<h2 id="resolving-to-items-shadowing-supertrait-items"><a class="header" href="#resolving-to-items-shadowing-supertrait-items">resolving-to-items-shadowing-supertrait-items</a></h2>
<p>The <code>resolving_to_items_shadowing_supertrait_items</code> lint detects when the
usage of an item that is provided by both a subtrait and supertrait
is shadowed, preferring the subtrait.</p>
<h3 id="example-30"><a class="header" href="#example-30">Example</a></h3>
<pre><code class="language-rust compile_fail">#![feature(supertrait_item_shadowing)]
#![deny(resolving_to_items_shadowing_supertrait_items)]

trait Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Upstream for T {}

trait Downstream: Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Downstream for T {}

struct MyType;
MyType.hello();</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait item `hello` from `Downstream` shadows identically named item from supertrait
  --&gt; lint_example.rs:16:8
   |
16 | MyType.hello();
   |        ^^^^^
   |
note: item from `Downstream` shadows a supertrait item
  --&gt; lint_example.rs:11:5
   |
11 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
note: item from `Upstream` is shadowed by a subtrait item
  --&gt; lint_example.rs:6:5
   |
 6 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:2:9
   |
 2 | #![deny(resolving_to_items_shadowing_supertrait_items)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-30"><a class="header" href="#explanation-30">Explanation</a></h3>
<p>RFC 3624 specified a heuristic in which a supertrait item would be
shadowed by a subtrait item when ambiguity occurs during item
selection. In order to mitigate side-effects of this happening
silently, this lint detects these cases when users want to deny them
or fix the call sites.</p>
<h2 id="rust-2021-incompatible-closure-captures"><a class="header" href="#rust-2021-incompatible-closure-captures">rust-2021-incompatible-closure-captures</a></h2>
<p>The <code>rust_2021_incompatible_closure_captures</code> lint detects variables that aren’t completely
captured in Rust 2021, such that the <code>Drop</code> order of their fields may differ between
Rust 2018 and 2021.</p>
<p>It can also detect when a variable implements a trait like <code>Send</code>, but one of its fields does not,
and the field is captured by a closure and used with the assumption that said field implements
the same trait as the root variable.</p>
<h3 id="example-of-drop-reorder"><a class="header" href="#example-of-drop-reorder">Example of drop reorder</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_incompatible_closure_captures)]
<span class="boring">#![allow(unused)]
</span>
struct FancyInteger(i32);

impl Drop for FancyInteger {
    fn drop(&amp;mut self) {
        println!("Just dropped {}", self.0);
    }
}

struct Point { x: FancyInteger, y: FancyInteger }

fn main() {
  let p = Point { x: FancyInteger(10), y: FancyInteger(20) };

  let c = || {
     let x = p.x;
  };

  c();

  // ... More code ...
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: changes to closure capture in Rust 2021 will affect drop order
  --&gt; lint_example.rs:17:11
   |
17 |   let c = || {
   |           ^^
18 |      let x = p.x;
   |              --- in Rust 2018, this closure captures all of `p`, but in Rust 2021, it will only capture `p.x`
...
24 | }
   | - in Rust 2018, `p` is dropped here, but in Rust 2021, only `p.x` will be dropped here as part of the closure
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html&gt;
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(rust_2021_incompatible_closure_captures)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: add a dummy let to cause `p` to be fully captured
   |
17 ~   let c = || {
18 +      let _ = &amp;p;
   |

</code></pre>
<h3 id="explanation-31"><a class="header" href="#explanation-31">Explanation</a></h3>
<p>In the above example, <code>p.y</code> will be dropped at the end of <code>f</code> instead of
with <code>c</code> in Rust 2021.</p>
<h3 id="example-of-auto-trait"><a class="header" href="#example-of-auto-trait">Example of auto-trait</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_incompatible_closure_captures)]
use std::thread;

struct Pointer(*mut i32);
unsafe impl Send for Pointer {}

fn main() {
    let mut f = 10;
    let fptr = Pointer(&amp;mut f as *mut i32);
    thread::spawn(move || unsafe {
        *fptr.0 = 20;
    });
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: changes to closure capture in Rust 2021 will affect which traits the closure implements
  --&gt; lint_example.rs:10:19
   |
10 |     thread::spawn(move || unsafe {
   |                   ^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0` does not implement `Send`
11 |         *fptr.0 = 20;
   |         ------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html&gt;
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(rust_2021_incompatible_closure_captures)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: add a dummy let to cause `fptr` to be fully captured
   |
10 ~     thread::spawn(move || { let _ = &amp;fptr; unsafe {
11 |         *fptr.0 = 20;
12 ~     } });
   |

</code></pre>
<h3 id="explanation-32"><a class="header" href="#explanation-32">Explanation</a></h3>
<p>In the above example, only <code>fptr.0</code> is captured in Rust 2021.
The field is of type <code>*mut i32</code>, which doesn’t implement <code>Send</code>,
making the code invalid as the field cannot be sent between threads safely.</p>
<h2 id="rust-2021-incompatible-or-patterns"><a class="header" href="#rust-2021-incompatible-or-patterns">rust-2021-incompatible-or-patterns</a></h2>
<p>The <code>rust_2021_incompatible_or_patterns</code> lint detects usage of old versions of or-patterns.</p>
<h3 id="example-31"><a class="header" href="#example-31">Example</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_incompatible_or_patterns)]

macro_rules! match_any {
    ( $expr:expr , $( $( $pat:pat )|+ =&gt; $expr_arm:expr ),+ ) =&gt; {
        match $expr {
            $(
                $( $pat =&gt; $expr_arm, )+
            )+
        }
    };
}

fn main() {
    let result: Result&lt;i64, i32&gt; = Err(42);
    let int: i64 = match_any!(result, Ok(i) | Err(i) =&gt; i.into());
    assert_eq!(int, 42);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro
 --&gt; lint_example.rs:4:26
  |
4 |     ( $expr:expr , $( $( $pat:pat )|+ =&gt; $expr_arm:expr ),+ ) =&gt; {
  |                          ^^^^^^^^ help: use pat_param to preserve semantics: `$pat:pat_param`
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2021_incompatible_or_patterns)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-33"><a class="header" href="#explanation-33">Explanation</a></h3>
<p>In Rust 2021, the <code>pat</code> matcher will match additional patterns, which include the <code>|</code> character.</p>
<h2 id="rust-2021-prefixes-incompatible-syntax"><a class="header" href="#rust-2021-prefixes-incompatible-syntax">rust-2021-prefixes-incompatible-syntax</a></h2>
<p>The <code>rust_2021_prefixes_incompatible_syntax</code> lint detects identifiers that will be parsed as a
prefix instead in Rust 2021.</p>
<h3 id="example-32"><a class="header" href="#example-32">Example</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_prefixes_incompatible_syntax)]

macro_rules! m {
    (z $x:expr) =&gt; ();
}

m!(z"hey");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: prefix `z` is unknown
 --&gt; lint_example.rs:8:4
  |
8 | m!(z"hey");
  |    ^ unknown prefix
  |
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/reserving-syntax.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2021_prefixes_incompatible_syntax)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: insert whitespace here to avoid this being parsed as a prefix in Rust 2021
  |
8 | m!(z "hey");
  |     +

</code></pre>
<h3 id="explanation-34"><a class="header" href="#explanation-34">Explanation</a></h3>
<p>In Rust 2015 and 2018, <code>z"hey"</code> is two tokens: the identifier <code>z</code>
followed by the string literal <code>"hey"</code>. In Rust 2021, the <code>z</code> is
considered a prefix for <code>"hey"</code>.</p>
<p>This lint suggests to add whitespace between the <code>z</code> and <code>"hey"</code> tokens
to keep them separated in Rust 2021.</p>
<h2 id="rust-2021-prelude-collisions"><a class="header" href="#rust-2021-prelude-collisions">rust-2021-prelude-collisions</a></h2>
<p>The <code>rust_2021_prelude_collisions</code> lint detects the usage of trait methods which are ambiguous
with traits added to the prelude in future editions.</p>
<h3 id="example-33"><a class="header" href="#example-33">Example</a></h3>
<pre><code class="language-rust edition2018 compile_fail">#![deny(rust_2021_prelude_collisions)]

trait Foo {
    fn try_into(self) -&gt; Result&lt;String, !&gt;;
}

impl Foo for &amp;str {
    fn try_into(self) -&gt; Result&lt;String, !&gt; {
        Ok(String::from(self))
    }
}

fn main() {
    let x: String = "3".try_into().unwrap();
    //                  ^^^^^^^^
    // This call to try_into matches both Foo::try_into and TryInto::try_into as
    // `TryInto` has been added to the Rust prelude in 2021 edition.
    println!("{x}");
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait method `try_into` will become ambiguous in Rust 2021
  --&gt; lint_example.rs:14:21
   |
14 |     let x: String = "3".try_into().unwrap();
   |                     ^^^^^^^^^^^^^^ help: disambiguate the associated function: `Foo::try_into(&amp;*"3")`
   |
   = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2021/prelude.html&gt;
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![deny(rust_2021_prelude_collisions)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-35"><a class="header" href="#explanation-35">Explanation</a></h3>
<p>In Rust 2021, one of the important introductions is the <a href="https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html#prelude-changes">prelude changes</a>, which add
<code>TryFrom</code>, <code>TryInto</code>, and <code>FromIterator</code> into the standard library’s prelude. Since this
results in an ambiguity as to which method/function to call when an existing <code>try_into</code>
method is called via dot-call syntax or a <code>try_from</code>/<code>from_iter</code> associated function
is called directly on a type.</p>
<h2 id="rust-2024-guarded-string-incompatible-syntax"><a class="header" href="#rust-2024-guarded-string-incompatible-syntax">rust-2024-guarded-string-incompatible-syntax</a></h2>
<p>The <code>rust_2024_guarded_string_incompatible_syntax</code> lint detects <code>#</code> tokens
that will be parsed as part of a guarded string literal in Rust 2024.</p>
<h3 id="example-34"><a class="header" href="#example-34">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(rust_2024_guarded_string_incompatible_syntax)]

macro_rules! m {
    (# $x:expr #) =&gt; ();
    (# $x:expr) =&gt; ();
}

m!(#"hey"#);
m!(#"hello");</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: will be parsed as a guarded string in Rust 2024
 --&gt; lint_example.rs:9:4
  |
9 | m!(#"hey"#);
  |    ^^^^^^^
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2024_guarded_string_incompatible_syntax)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: insert whitespace here to avoid this being parsed as a guarded string in Rust 2024
  |
9 | m!(# "hey"#);
  |     +


error: will be parsed as a guarded string in Rust 2024
  --&gt; lint_example.rs:10:4
   |
10 | m!(#"hello");
   |    ^^^^^^^^
   |
   = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/reserved-syntax.html&gt;
help: insert whitespace here to avoid this being parsed as a guarded string in Rust 2024
   |
10 | m!(# "hello");
   |     +

</code></pre>
<h3 id="explanation-36"><a class="header" href="#explanation-36">Explanation</a></h3>
<p>Prior to Rust 2024, <code>#"hey"#</code> is three tokens: the first <code>#</code>
followed by the string literal <code>"hey"</code> then the final <code>#</code>.
In Rust 2024, the whole sequence is considered a single token.</p>
<p>This lint suggests to add whitespace between the leading <code>#</code>
and the string to keep them separated in Rust 2024.</p>
<h2 id="rust-2024-incompatible-pat"><a class="header" href="#rust-2024-incompatible-pat">rust-2024-incompatible-pat</a></h2>
<p>The <code>rust_2024_incompatible_pat</code> lint
detects patterns whose meaning will change in the Rust 2024 edition.</p>
<h3 id="example-35"><a class="header" href="#example-35">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(rust_2024_incompatible_pat)]

if let Some(&amp;a) = &amp;Some(&amp;0u8) {
    let _: u8 = a;
}
if let Some(mut _a) = &amp;mut Some(0u8) {
    _a = 7u8;
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot explicitly dereference within an implicitly-borrowing pattern in Rust 2024
 --&gt; lint_example.rs:4:13
  |
4 | if let Some(&amp;a) = &amp;Some(&amp;0u8) {
  |             ^ reference pattern not allowed when implicitly borrowing
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html&gt;
note: matching on a reference type with a non-reference pattern implicitly borrows the contents
 --&gt; lint_example.rs:4:8
  |
4 | if let Some(&amp;a) = &amp;Some(&amp;0u8) {
  |        ^^^^^^^^ this non-reference pattern matches on a reference type `&amp;_`
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(rust_2024_incompatible_pat)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
help: match on the reference with a reference pattern to avoid implicitly borrowing
  |
4 | if let &amp;Some(&amp;a) = &amp;Some(&amp;0u8) {
  |        +


warning: cannot mutably bind by value within an implicitly-borrowing pattern in Rust 2024
 --&gt; lint_example.rs:7:13
  |
7 | if let Some(mut _a) = &amp;mut Some(0u8) {
  |             ^^^ `mut` binding modifier not allowed when implicitly borrowing
  |
  = warning: this changes meaning in Rust 2024
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html&gt;
note: matching on a reference type with a non-reference pattern implicitly borrows the contents
 --&gt; lint_example.rs:7:8
  |
7 | if let Some(mut _a) = &amp;mut Some(0u8) {
  |        ^^^^^^^^^^^^ this non-reference pattern matches on a reference type `&amp;mut _`
help: match on the reference with a reference pattern to avoid implicitly borrowing
  |
7 | if let &amp;mut Some(mut _a) = &amp;mut Some(0u8) {
  |        ++++

</code></pre>
<h3 id="explanation-37"><a class="header" href="#explanation-37">Explanation</a></h3>
<p>In Rust 2024 and above, the <code>mut</code> keyword does not reset the pattern binding mode,
and nor do <code>&amp;</code> or <code>&amp;mut</code> patterns. The lint will suggest code that
has the same meaning in all editions.</p>
<h2 id="rust-2024-prelude-collisions"><a class="header" href="#rust-2024-prelude-collisions">rust-2024-prelude-collisions</a></h2>
<p>The <code>rust_2024_prelude_collisions</code> lint detects the usage of trait methods which are ambiguous
with traits added to the prelude in future editions.</p>
<h3 id="example-36"><a class="header" href="#example-36">Example</a></h3>
<pre><code class="language-rust edition2021 compile_fail">#![deny(rust_2024_prelude_collisions)]
trait Meow {
    fn poll(&amp;self) {}
}
impl&lt;T&gt; Meow for T {}

fn main() {
    core::pin::pin!(async {}).poll();
    //                        ^^^^^^
    // This call to try_into matches both Future::poll and Meow::poll as
    // `Future` has been added to the Rust prelude in 2024 edition.
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait method `poll` will become ambiguous in Rust 2024
 --&gt; lint_example.rs:8:5
  |
8 |     core::pin::pin!(async {}).poll();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `Meow::poll(&amp;core::pin::pin!(async {}))`
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/prelude.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2024_prelude_collisions)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-38"><a class="header" href="#explanation-38">Explanation</a></h3>
<p>Rust 2024, introduces two new additions to the standard library’s prelude:
<code>Future</code> and <code>IntoFuture</code>. This results in an ambiguity as to which method/function
to call when an existing <code>poll</code>/<code>into_future</code> method is called via dot-call syntax or
a <code>poll</code>/<code>into_future</code> associated function is called directly on a type.</p>
<h2 id="shadowing-supertrait-items"><a class="header" href="#shadowing-supertrait-items">shadowing-supertrait-items</a></h2>
<p>The <code>shadowing_supertrait_items</code> lint detects when the
definition of an item that is provided by both a subtrait and
supertrait is shadowed, preferring the subtrait.</p>
<h3 id="example-37"><a class="header" href="#example-37">Example</a></h3>
<pre><code class="language-rust compile_fail">#![feature(supertrait_item_shadowing)]
#![deny(shadowing_supertrait_items)]

trait Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Upstream for T {}

trait Downstream: Upstream {
    fn hello(&amp;self) {}
}
impl&lt;T&gt; Downstream for T {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait item `hello` from `Downstream` shadows identically named item from supertrait
  --&gt; lint_example.rs:11:5
   |
11 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
   |
note: item from `Upstream` is shadowed by a subtrait item
  --&gt; lint_example.rs:6:5
   |
 6 |     fn hello(&amp;self) {}
   |     ^^^^^^^^^^^^^^^
note: the lint level is defined here
  --&gt; lint_example.rs:2:9
   |
 2 | #![deny(shadowing_supertrait_items)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-39"><a class="header" href="#explanation-39">Explanation</a></h3>
<p>RFC 3624 specified a heuristic in which a supertrait item would be
shadowed by a subtrait item when ambiguity occurs during item
selection. In order to mitigate side-effects of this happening
silently, this lint detects these cases when users want to deny them
or fix their trait definitions.</p>
<h2 id="single-use-lifetime"><a class="header" href="#single-use-lifetime">single-use-lifetime</a></h2>
<p>The lint <code>single-use-lifetime</code> has been renamed to <a href="#single-use-lifetimes"><code>single-use-lifetimes</code></a>.</p>
<h2 id="single-use-lifetimes"><a class="header" href="#single-use-lifetimes">single-use-lifetimes</a></h2>
<p>The <code>single_use_lifetimes</code> lint detects lifetimes that are only used
once.</p>
<h3 id="example-38"><a class="header" href="#example-38">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(single_use_lifetimes)]

fn foo&lt;'a&gt;(x: &amp;'a u32) {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: lifetime parameter `'a` only used once
 --&gt; lint_example.rs:4:8
  |
4 | fn foo&lt;'a&gt;(x: &amp;'a u32) {}
  |        ^^      -- ...is used only here
  |        |
  |        this lifetime...
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(single_use_lifetimes)]
  |         ^^^^^^^^^^^^^^^^^^^^
help: elide the single-use lifetime
  |
4 - fn foo&lt;'a&gt;(x: &amp;'a u32) {}
4 + fn foo(x: &amp;u32) {}
  |

</code></pre>
<h3 id="explanation-40"><a class="header" href="#explanation-40">Explanation</a></h3>
<p>Specifying an explicit lifetime like <code>'a</code> in a function or <code>impl</code>
should only be used to link together two things. Otherwise, you should
just use <code>'_</code> to indicate that the lifetime is not linked to anything,
or elide the lifetime altogether if possible.</p>
<p>This lint is “allow” by default because it was introduced at a time
when <code>'_</code> and elided lifetimes were first being introduced, and this
lint would be too noisy. Also, there are some known false positives
that it produces. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2115-argument-lifetimes.md">RFC 2115</a> for historical context, and <a href="https://github.com/rust-lang/rust/issues/44752">issue
#44752</a> for more details.</p>
<h2 id="tail-expr-drop-order"><a class="header" href="#tail-expr-drop-order">tail-expr-drop-order</a></h2>
<p>The <code>tail_expr_drop_order</code> lint looks for those values generated at the tail expression location,
that runs a custom <code>Drop</code> destructor.
Some of them may be dropped earlier in Edition 2024 that they used to in Edition 2021 and prior.
This lint detects those cases and provides you information on those values and their custom destructor implementations.
Your discretion on this information is required.</p>
<h3 id="example-39"><a class="header" href="#example-39">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(tail_expr_drop_order)]
struct Droppy(i32);
impl Droppy {
    fn get(&amp;self) -&gt; i32 {
        self.0
    }
}
impl Drop for Droppy {
    fn drop(&amp;mut self) {
        // This is a custom destructor and it induces side-effects that is observable
        // especially when the drop order at a tail expression changes.
        println!("loud drop {}", self.0);
    }
}
fn edition_2021() -&gt; i32 {
    let another_droppy = Droppy(0);
    Droppy(1).get()
}
fn main() {
    edition_2021();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: relative drop order changing in Rust 2024
  --&gt; lint_example.rs:17:5
   |
16 |     let another_droppy = Droppy(0);
   |         --------------
   |         |
   |         `another_droppy` calls a custom destructor
   |         `another_droppy` will be dropped later as of Edition 2024
17 |     Droppy(1).get()
   |     ^^^^^^^^^
   |     |
   |     this value will be stored in a temporary; let us call it `#1`
   |     up until Edition 2021 `#1` is dropped last but will be dropped earlier in Edition 2024
18 | }
   | - now the temporary value is dropped here, before the local variables in the block or statement
   |
   = warning: this changes meaning in Rust 2024
   = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/temporary-tail-expr-scope.html&gt;
note: `#1` invokes this custom destructor
  --&gt; lint_example.rs:8:1
   |
 8 | impl Drop for Droppy {
   | ^^^^^^^^^^^^^^^^^^^^
note: `another_droppy` invokes this custom destructor
  --&gt; lint_example.rs:8:1
   |
 8 | impl Drop for Droppy {
   | ^^^^^^^^^^^^^^^^^^^^
   = note: most of the time, changing drop order is harmless; inspect the `impl Drop`s for side effects like releasing locks or sending messages
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
 1 | #![warn(tail_expr_drop_order)]
   |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-41"><a class="header" href="#explanation-41">Explanation</a></h3>
<p>In tail expression of blocks or function bodies,
values of type with significant <code>Drop</code> implementation has an ill-specified drop order
before Edition 2024 so that they are dropped only after dropping local variables.
Edition 2024 introduces a new rule with drop orders for them,
so that they are dropped first before dropping local variables.</p>
<p>A significant <code>Drop::drop</code> destructor here refers to an explicit, arbitrary
implementation of the <code>Drop</code> trait on the type, with exceptions including <code>Vec</code>,
<code>Box</code>, <code>Rc</code>, <code>BTreeMap</code> and <code>HashMap</code> that are marked by the compiler otherwise
so long that the generic types have no significant destructor recursively.
In other words, a type has a significant drop destructor when it has a <code>Drop</code> implementation
or its destructor invokes a significant destructor on a type.
Since we cannot completely reason about the change by just inspecting the existence of
a significant destructor, this lint remains only a suggestion and is set to <code>allow</code> by default.</p>
<p>This lint only points out the issue with <code>Droppy</code>, which will be dropped before <code>another_droppy</code>
does in Edition 2024.
No fix will be proposed by this lint.
However, the most probable fix is to hoist <code>Droppy</code> into its own local variable binding.</p>
<pre><code class="language-rust">struct Droppy(i32);
impl Droppy {
    fn get(&amp;self) -&gt; i32 {
        self.0
    }
}
fn edition_2024() -&gt; i32 {
    let value = Droppy(0);
    let another_droppy = Droppy(1);
    value.get()
}</code></pre>
<h2 id="trivial-casts"><a class="header" href="#trivial-casts">trivial-casts</a></h2>
<p>The <code>trivial_casts</code> lint detects trivial casts which could be replaced
with coercion, which may require a temporary variable.</p>
<h3 id="example-40"><a class="header" href="#example-40">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(trivial_casts)]
let x: &amp;u32 = &amp;42;
let y = x as *const u32;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trivial cast: `&amp;u32` as `*const u32`
 --&gt; lint_example.rs:4:9
  |
4 | let y = x as *const u32;
  |         ^^^^^^^^^^^^^^^
  |
  = help: cast can be replaced by coercion; this might require a temporary variable
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(trivial_casts)]
  |         ^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-42"><a class="header" href="#explanation-42">Explanation</a></h3>
<p>A trivial cast is a cast <code>e as T</code> where <code>e</code> has type <code>U</code> and <code>U</code> is a
subtype of <code>T</code>. This type of cast is usually unnecessary, as it can be
usually be inferred.</p>
<p>This lint is “allow” by default because there are situations, such as
with FFI interfaces or complex type aliases, where it triggers
incorrectly, or in situations where it will be more difficult to
clearly express the intent. It may be possible that this will become a
warning in the future, possibly with an explicit syntax for coercions
providing a convenient way to work around the current issues.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401 (coercions)</a>, <a href="https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md">RFC 803 (type ascription)</a> and
<a href="https://github.com/rust-lang/rfcs/blob/master/text/3307-de-rfc-type-ascription.md">RFC 3307 (remove type ascription)</a> for historical context.</p>
<h2 id="trivial-numeric-casts"><a class="header" href="#trivial-numeric-casts">trivial-numeric-casts</a></h2>
<p>The <code>trivial_numeric_casts</code> lint detects trivial numeric casts of types
which could be removed.</p>
<h3 id="example-41"><a class="header" href="#example-41">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(trivial_numeric_casts)]
let x = 42_i32 as i32;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trivial numeric cast: `i32` as `i32`
 --&gt; lint_example.rs:3:9
  |
3 | let x = 42_i32 as i32;
  |         ^^^^^^^^^^^^^
  |
  = help: cast can be replaced by coercion; this might require a temporary variable
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(trivial_numeric_casts)]
  |         ^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-43"><a class="header" href="#explanation-43">Explanation</a></h3>
<p>A trivial numeric cast is a cast of a numeric type to the same numeric
type. This type of cast is usually unnecessary.</p>
<p>This lint is “allow” by default because there are situations, such as
with FFI interfaces or complex type aliases, where it triggers
incorrectly, or in situations where it will be more difficult to
clearly express the intent. It may be possible that this will become a
warning in the future, possibly with an explicit syntax for coercions
providing a convenient way to work around the current issues.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401 (coercions)</a>, <a href="https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md">RFC 803 (type ascription)</a> and
<a href="https://github.com/rust-lang/rfcs/blob/master/text/3307-de-rfc-type-ascription.md">RFC 3307 (remove type ascription)</a> for historical context.</p>
<h2 id="unit-bindings"><a class="header" href="#unit-bindings">unit-bindings</a></h2>
<p>The <code>unit_bindings</code> lint detects cases where bindings are useless because they have
the unit type <code>()</code> as their inferred type. The lint is suppressed if the user explicitly
annotates the let binding with the unit type <code>()</code>, or if the let binding uses an underscore
wildcard pattern, i.e. <code>let _ = expr</code>, or if the binding is produced from macro expansions.</p>
<h3 id="example-42"><a class="header" href="#example-42">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unit_bindings)]

fn foo() {
    println!("do work");
}

pub fn main() {
    let x = foo(); // useless binding
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: binding has unit type `()`
 --&gt; lint_example.rs:8:5
  |
8 |     let x = foo(); // useless binding
  |     ^^^^-^^^^^^^^^
  |         |
  |         this pattern is inferred to be the unit type `()`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unit_bindings)]
  |         ^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-44"><a class="header" href="#explanation-44">Explanation</a></h3>
<p>Creating a local binding with the unit type <code>()</code> does not do much and can be a sign of a
user error, such as in this example:</p>
<pre><code class="language-rust no_run">fn main() {
    let mut x = [1, 2, 3];
    x[0] = 5;
    let y = x.sort(); // useless binding as `sort` returns `()` and not the sorted array.
    println!("{:?}", y); // prints "()"
}</code></pre>
<h2 id="unnameable-types"><a class="header" href="#unnameable-types">unnameable-types</a></h2>
<p>The <code>unnameable_types</code> lint detects types for which you can get objects of that type,
but cannot name the type itself.</p>
<h3 id="example-43"><a class="header" href="#example-43">Example</a></h3>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(unnameable_types)]
mod m {
    pub struct S;
}

pub fn get_unnameable() -&gt; m::S { m::S }
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: struct `S` is reachable but cannot be named
 --&gt; lint_example.rs:4:5
  |
4 |     pub struct S;
  |     ^^^^^^^^^^^^ reachable at visibility `pub`, but can only be named at visibility `pub(crate)`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(unnameable_types)]
  |         ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-45"><a class="header" href="#explanation-45">Explanation</a></h3>
<p>It is often expected that if you can obtain an object of type <code>T</code>, then
you can name the type <code>T</code> as well; this lint attempts to enforce this rule.
The recommended action is to either reexport the type properly to make it nameable,
or document that users are not supposed to be able to name it for one reason or another.</p>
<p>Besides types, this lint applies to traits because traits can also leak through signatures,
and you may obtain objects of their <code>dyn Trait</code> or <code>impl Trait</code> types.</p>
<h2 id="unqualified-local-imports"><a class="header" href="#unqualified-local-imports">unqualified-local-imports</a></h2>
<p>The <code>unqualified_local_imports</code> lint checks for <code>use</code> items that import a local item using a
path that does not start with <code>self::</code>, <code>super::</code>, or <code>crate::</code>.</p>
<h3 id="example-44"><a class="header" href="#example-44">Example</a></h3>
<pre><code class="language-rust edition2018">#![feature(unqualified_local_imports)]
#![warn(unqualified_local_imports)]

mod localmod {
    pub struct S;
}

use localmod::S;
<span class="boring">// We have to actually use `S`, or else the `unused` warnings suppress the lint we care about.
</span><span class="boring">pub fn main() {
</span><span class="boring">    let _x = S;
</span><span class="boring">}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `use` of a local item without leading `self::`, `super::`, or `crate::`
 --&gt; lint_example.rs:8:5
  |
8 | use localmod::S;
  |     ^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![warn(unqualified_local_imports)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-46"><a class="header" href="#explanation-46">Explanation</a></h3>
<p>This lint is meant to be used with the (unstable) rustfmt setting <code>group_imports = "StdExternalCrate"</code>.
That setting makes rustfmt group <code>self::</code>, <code>super::</code>, and <code>crate::</code> imports separately from those
referring to other crates. However, rustfmt cannot know whether <code>use c::S;</code> refers to a local module <code>c</code>
or an external crate <code>c</code>, so it always gets categorized as an import from another crate.
To ensure consistent grouping of imports from the local crate, all local imports must
start with <code>self::</code>, <code>super::</code>, or <code>crate::</code>. This lint can be used to enforce that style.</p>
<h2 id="unreachable-pub"><a class="header" href="#unreachable-pub">unreachable-pub</a></h2>
<p>The <code>unreachable_pub</code> lint triggers for <code>pub</code> items not reachable from other crates - that
means neither directly accessible, nor reexported (with <code>pub use</code>), nor leaked through
things like return types (which the <a href="#unnameable-types"><code>unnameable_types</code></a> lint can detect if desired).</p>
<h3 id="example-45"><a class="header" href="#example-45">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unreachable_pub)]
mod foo {
    pub mod bar {

    }
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unreachable `pub` item
 --&gt; lint_example.rs:4:5
  |
4 |     pub mod bar {
  |     ---^^^^^^^^
  |     |
  |     help: consider restricting its visibility: `pub(crate)`
  |
  = help: or consider exporting it for use by other crates
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unreachable_pub)]
  |         ^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-47"><a class="header" href="#explanation-47">Explanation</a></h3>
<p>The <code>pub</code> keyword both expresses an intent for an item to be publicly available, and also
signals to the compiler to make the item publicly accessible. The intent can only be
satisfied, however, if all items which contain this item are <em>also</em> publicly accessible.
Thus, this lint serves to identify situations where the intent does not match the reality.</p>
<p>If you wish the item to be accessible elsewhere within the crate, but not outside it, the
<code>pub(crate)</code> visibility is recommended to be used instead. This more clearly expresses the
intent that the item is only visible within its own crate.</p>
<p>This lint is “allow” by default because it will trigger for a large amount of existing Rust code.
Eventually it is desired for this to become warn-by-default.</p>
<h2 id="unsafe-attr-outside-unsafe"><a class="header" href="#unsafe-attr-outside-unsafe">unsafe-attr-outside-unsafe</a></h2>
<p>The <code>unsafe_attr_outside_unsafe</code> lint detects a missing unsafe keyword
on attributes considered unsafe.</p>
<h3 id="example-46"><a class="header" href="#example-46">Example</a></h3>
<pre><code class="language-rust edition2021">#![warn(unsafe_attr_outside_unsafe)]

#[no_mangle]
extern "C" fn foo() {}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unsafe attribute used without unsafe
 --&gt; lint_example.rs:3:3
  |
3 | #[no_mangle]
  |   ^^^^^^^^^ usage of unsafe attribute
  |
  = warning: this is accepted in the current edition (Rust 2021) but is a hard error in Rust 2024!
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-attributes.html&gt;
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![warn(unsafe_attr_outside_unsafe)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
help: wrap the attribute in `unsafe(...)`
  |
3 | #[unsafe(no_mangle)]
  |   +++++++         +

</code></pre>
<h3 id="explanation-48"><a class="header" href="#explanation-48">Explanation</a></h3>
<p>Some attributes (e.g. <code>no_mangle</code>, <code>export_name</code>, <code>link_section</code> – see
<a href="https://github.com/rust-lang/rust/issues/82499">issue #82499</a> for a more complete list) are considered “unsafe” attributes.
An unsafe attribute must only be used inside unsafe(…).</p>
<p>This lint can automatically wrap the attributes in <code>unsafe(...)</code> , but this
obviously cannot verify that the preconditions of the <code>unsafe</code>
attributes are fulfilled, so that is still up to the user.</p>
<p>The lint is currently “allow” by default, but that might change in the
future.</p>
<h2 id="unsafe-code"><a class="header" href="#unsafe-code">unsafe-code</a></h2>
<p>The <code>unsafe_code</code> lint catches usage of <code>unsafe</code> code and other
potentially unsound constructs like <code>no_mangle</code>, <code>export_name</code>,
and <code>link_section</code>.</p>
<h3 id="example-47"><a class="header" href="#example-47">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unsafe_code)]
fn main() {
    unsafe {

    }
}

#[no_mangle]
fn func_0() { }

#[export_name = "exported_symbol_name"]
pub fn name_in_rust() { }

#[no_mangle]
#[link_section = ".example_section"]
pub static VAR1: u32 = 1;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: usage of an `unsafe` block
 --&gt; lint_example.rs:3:5
  |
3 | /     unsafe {
4 | |
5 | |     }
  | |_____^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unsafe_code)]
  |         ^^^^^^^^^^^


error: declaration of a `no_mangle` function
 --&gt; lint_example.rs:8:1
  |
8 | #[no_mangle]
  | ^^^^^^^^^^^^
  |
  = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them


error: declaration of a function with `export_name`
  --&gt; lint_example.rs:11:1
   |
11 | #[export_name = "exported_symbol_name"]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them


error: declaration of a `no_mangle` static
  --&gt; lint_example.rs:14:1
   |
14 | #[no_mangle]
   | ^^^^^^^^^^^^
   |
   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them


error: declaration of a static with `link_section`
  --&gt; lint_example.rs:15:1
   |
15 | #[link_section = ".example_section"]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them

</code></pre>
<h3 id="explanation-49"><a class="header" href="#explanation-49">Explanation</a></h3>
<p>This lint is intended to restrict the usage of <code>unsafe</code> blocks and other
constructs (including, but not limited to <code>no_mangle</code>, <code>link_section</code>
and <code>export_name</code> attributes) wrong usage of which causes undefined
behavior.</p>
<h2 id="unsafe-op-in-unsafe-fn"><a class="header" href="#unsafe-op-in-unsafe-fn">unsafe-op-in-unsafe-fn</a></h2>
<p>The <code>unsafe_op_in_unsafe_fn</code> lint detects unsafe operations in unsafe
functions without an explicit unsafe block.</p>
<h3 id="example-48"><a class="header" href="#example-48">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unsafe_op_in_unsafe_fn)]

unsafe fn foo() {}

unsafe fn bar() {
    foo();
}

fn main() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function `foo` is unsafe and requires unsafe block
 --&gt; lint_example.rs:6:5
  |
6 |     foo();
  |     ^^^^^ call to unsafe function
  |
  = note: for more information, see &lt;https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html&gt;
  = note: consult the function's documentation for information on how to avoid undefined behavior
note: an unsafe function restricts its caller, but its body is safe by default
 --&gt; lint_example.rs:5:1
  |
5 | unsafe fn bar() {
  | ^^^^^^^^^^^^^^^
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unsafe_op_in_unsafe_fn)]
  |         ^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-50"><a class="header" href="#explanation-50">Explanation</a></h3>
<p>Currently, an <a href="https://doc.rust-lang.org/reference/unsafe-functions.html"><code>unsafe fn</code></a> allows any <a href="https://doc.rust-lang.org/reference/unsafety.html">unsafe</a> operation within its
body. However, this can increase the surface area of code that needs
to be scrutinized for proper behavior. The <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks"><code>unsafe</code> block</a> provides a
convenient way to make it clear exactly which parts of the code are
performing unsafe operations. In the future, it is desired to change
it so that unsafe operations cannot be performed in an <code>unsafe fn</code>
without an <code>unsafe</code> block.</p>
<p>The fix to this is to wrap the unsafe code in an <code>unsafe</code> block.</p>
<p>This lint is “allow” by default on editions up to 2021, from 2024 it is
“warn” by default; the plan for increasing severity further is
still being considered. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2585-unsafe-block-in-unsafe-fn.md">RFC #2585</a> and <a href="https://github.com/rust-lang/rust/issues/71668">issue #71668</a> for more
details.</p>
<h2 id="unstable-features"><a class="header" href="#unstable-features">unstable-features</a></h2>
<p>The <code>unstable_features</code> lint detects uses of <code>#![feature]</code>.</p>
<h3 id="example-49"><a class="header" href="#example-49">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unstable_features)]
#![feature(test)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: use of an unstable feature
 --&gt; lint_example.rs:2:12
  |
2 | #![feature(test)]
  |            ^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unstable_features)]
  |         ^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-51"><a class="header" href="#explanation-51">Explanation</a></h3>
<p>In larger nightly-based projects which</p>
<ul>
<li>consist of a multitude of crates where a subset of crates has to compile on
stable either unconditionally or depending on a <code>cfg</code> flag to for example
allow stable users to depend on them,</li>
<li>don’t use nightly for experimental features but for, e.g., unstable options only,</li>
</ul>
<p>this lint may come in handy to enforce policies of these kinds.</p>
<h2 id="unused-crate-dependencies"><a class="header" href="#unused-crate-dependencies">unused-crate-dependencies</a></h2>
<p>The <code>unused_crate_dependencies</code> lint detects crate dependencies that
are never used.</p>
<h3 id="example-50"><a class="header" href="#example-50">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#![deny(unused_crate_dependencies)]</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: extern crate `regex` is unused in crate `lint_example`
  |
  = help: remove the dependency or add `use regex as _;` to the crate root
note: the lint level is defined here
 --&gt; src/lib.rs:1:9
  |
1 | #![deny(unused_crate_dependencies)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<h3 id="explanation-52"><a class="header" href="#explanation-52">Explanation</a></h3>
<p>After removing the code that uses a dependency, this usually also
requires removing the dependency from the build configuration.
However, sometimes that step can be missed, which leads to time wasted
building dependencies that are no longer used. This lint can be
enabled to detect dependencies that are never used (more specifically,
any dependency passed with the <code>--extern</code> command-line flag that is
never referenced via <a href="https://doc.rust-lang.org/reference/items/use-declarations.html"><code>use</code></a>, <a href="https://doc.rust-lang.org/reference/items/extern-crates.html"><code>extern crate</code></a>, or in any <a href="https://doc.rust-lang.org/reference/paths.html">path</a>).</p>
<p>This lint is “allow” by default because it can provide false positives
depending on how the build system is configured. For example, when
using Cargo, a “package” consists of multiple crates (such as a
library and a binary), but the dependencies are defined for the
package as a whole. If there is a dependency that is only used in the
binary, but not the library, then the lint will be incorrectly issued
in the library.</p>
<h2 id="unused-extern-crates"><a class="header" href="#unused-extern-crates">unused-extern-crates</a></h2>
<p>The <code>unused_extern_crates</code> lint guards against <code>extern crate</code> items
that are never used.</p>
<h3 id="example-51"><a class="header" href="#example-51">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_extern_crates)]
#![deny(warnings)]
extern crate proc_macro;</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unused extern crate
 --&gt; lint_example.rs:4:1
  |
4 | extern crate proc_macro;
  | ^^^^^^^^^^^^^^^^^^^^^^^^ unused
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_extern_crates)]
  |         ^^^^^^^^^^^^^^^^^^^^
help: remove the unused `extern crate`
  |
4 - extern crate proc_macro;
  |

</code></pre>
<h3 id="explanation-53"><a class="header" href="#explanation-53">Explanation</a></h3>
<p><code>extern crate</code> items that are unused have no effect and should be
removed. Note that there are some cases where specifying an <code>extern crate</code> is desired for the side effect of ensuring the given crate is
linked, even though it is not otherwise directly referenced. The lint
can be silenced by aliasing the crate to an underscore, such as
<code>extern crate foo as _</code>. Also note that it is no longer idiomatic to
use <code>extern crate</code> in the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate">2018 edition</a>, as extern crates are now
automatically added in scope.</p>
<p>This lint is “allow” by default because it can be noisy, and produce
false-positives. If a dependency is being removed from a project, it
is recommended to remove it from the build configuration (such as
<code>Cargo.toml</code>) to ensure stale build entries aren’t left behind.</p>
<h2 id="unused-import-braces"><a class="header" href="#unused-import-braces">unused-import-braces</a></h2>
<p>The <code>unused_import_braces</code> lint catches unnecessary braces around an
imported item.</p>
<h3 id="example-52"><a class="header" href="#example-52">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_import_braces)]
use test::{A};

pub mod test {
    pub struct A;
}
<span class="boring">fn main() {}</span></code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: braces around A is unnecessary
 --&gt; lint_example.rs:2:1
  |
2 | use test::{A};
  | ^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_import_braces)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-54"><a class="header" href="#explanation-54">Explanation</a></h3>
<p>If there is only a single item, then remove the braces (<code>use test::A;</code>
for example).</p>
<p>This lint is “allow” by default because it is only enforcing a
stylistic choice.</p>
<h2 id="unused-lifetimes"><a class="header" href="#unused-lifetimes">unused-lifetimes</a></h2>
<p>The <code>unused_lifetimes</code> lint detects lifetime parameters that are never
used.</p>
<h3 id="example-53"><a class="header" href="#example-53">Example</a></h3>
<pre><code class="language-rust compile_fail">#[deny(unused_lifetimes)]

pub fn foo&lt;'a&gt;() {}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: lifetime parameter `'a` never used
 --&gt; lint_example.rs:4:12
  |
4 | pub fn foo&lt;'a&gt;() {}
  |           -^^- help: elide the unused lifetime
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:8
  |
2 | #[deny(unused_lifetimes)]
  |        ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-55"><a class="header" href="#explanation-55">Explanation</a></h3>
<p>Unused lifetime parameters may signal a mistake or unfinished code.
Consider removing the parameter.</p>
<h2 id="unused-macro-rules"><a class="header" href="#unused-macro-rules">unused-macro-rules</a></h2>
<p>The <code>unused_macro_rules</code> lint detects macro rules that were not used.</p>
<p>Note that the lint is distinct from the <code>unused_macros</code> lint, which
fires if the entire macro is never called, while this lint fires for
single unused rules of the macro that is otherwise used.
<code>unused_macro_rules</code> fires only if <code>unused_macros</code> wouldn’t fire.</p>
<h3 id="example-54"><a class="header" href="#example-54">Example</a></h3>
<pre><code class="language-rust">#[warn(unused_macro_rules)]
macro_rules! unused_empty {
    (hello) =&gt; { println!("Hello, world!") }; // This rule is unused
    () =&gt; { println!("empty") }; // This rule is used
}

fn main() {
    unused_empty!(hello);
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: rule #2 of macro `unused_empty` is never used
 --&gt; lint_example.rs:4:5
  |
4 |     () =&gt; { println!("empty") }; // This rule is used
  |     ^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:8
  |
1 | #[warn(unused_macro_rules)]
  |        ^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-56"><a class="header" href="#explanation-56">Explanation</a></h3>
<p>Unused macro rules may signal a mistake or unfinished code. Furthermore,
they slow down compilation. Right now, silencing the warning is not
supported on a single rule level, so you have to add an allow to the
entire macro definition.</p>
<p>If you intended to export the macro to make it
available outside of the crate, use the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope"><code>macro_export</code> attribute</a>.</p>
<h2 id="unused-qualifications"><a class="header" href="#unused-qualifications">unused-qualifications</a></h2>
<p>The <code>unused_qualifications</code> lint detects unnecessarily qualified
names.</p>
<h3 id="example-55"><a class="header" href="#example-55">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_qualifications)]
mod foo {
    pub fn bar() {}
}

fn main() {
    use foo::bar;
    foo::bar();
    bar();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unnecessary qualification
 --&gt; lint_example.rs:8:5
  |
8 |     foo::bar();
  |     ^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_qualifications)]
  |         ^^^^^^^^^^^^^^^^^^^^^
help: remove the unnecessary path segments
  |
8 -     foo::bar();
8 +     bar();
  |

</code></pre>
<h3 id="explanation-57"><a class="header" href="#explanation-57">Explanation</a></h3>
<p>If an item from another module is already brought into scope, then
there is no need to qualify it in this case. You can call <code>bar()</code>
directly, without the <code>foo::</code>.</p>
<p>This lint is “allow” by default because it is somewhat pedantic, and
doesn’t indicate an actual problem, but rather a stylistic choice, and
can be noisy when refactoring or moving around code.</p>
<h2 id="unused-results"><a class="header" href="#unused-results">unused-results</a></h2>
<p>The <code>unused_results</code> lint checks for the unused result of an
expression in a statement.</p>
<h3 id="example-56"><a class="header" href="#example-56">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(unused_results)]
fn foo&lt;T&gt;() -&gt; T { panic!() }

fn main() {
    foo::&lt;usize&gt;();
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unused result of type `usize`
 --&gt; lint_example.rs:5:5
  |
5 |     foo::&lt;usize&gt;();
  |     ^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_results)]
  |         ^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-58"><a class="header" href="#explanation-58">Explanation</a></h3>
<p>Ignoring the return value of a function may indicate a mistake. In
cases were it is almost certain that the result should be used, it is
recommended to annotate the function with the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code> attribute</a>.
Failure to use such a return value will trigger the <a href="warn-by-default.html#unused-must-use"><code>unused_must_use</code>
lint</a> which is warn-by-default. The <code>unused_results</code> lint is
essentially the same, but triggers for <em>all</em> return values.</p>
<p>This lint is “allow” by default because it can be noisy, and may not be
an actual problem. For example, calling the <code>remove</code> method of a <code>Vec</code>
or <code>HashMap</code> returns the previous value, which you may not care about.
Using this lint would require explicitly ignoring or discarding such
values.</p>
<h2 id="variant-size-differences"><a class="header" href="#variant-size-differences">variant-size-differences</a></h2>
<p>The <code>variant_size_differences</code> lint detects enums with widely varying
variant sizes.</p>
<h3 id="example-57"><a class="header" href="#example-57">Example</a></h3>
<pre><code class="language-rust compile_fail">#![deny(variant_size_differences)]
enum En {
    V0(u8),
    VBig([u8; 1024]),
}</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: enum variant is more than three times larger (1024 bytes) than the next largest
 --&gt; lint_example.rs:5:5
  |
5 |     VBig([u8; 1024]),
  |     ^^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(variant_size_differences)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-59"><a class="header" href="#explanation-59">Explanation</a></h3>
<p>It can be a mistake to add a variant to an enum that is much larger
than the other variants, bloating the overall size required for all
variants. This can impact performance and memory usage. This is
triggered if one variant is more than 3 times larger than the
second-largest variant.</p>
<p>Consider placing the large variant’s contents on the heap (for example
via <a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box</code></a>) to keep the overall size of the enum itself down.</p>
<p>This lint is “allow” by default because it can be noisy, and may not be
an actual problem. Decisions about this should be guided with
profiling and benchmarking.</p>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
    var fragments = {
        "#single-use-lifetime": "allowed-by-default.html#single-use-lifetimes",
        "#elided-lifetime-in-path": "allowed-by-default.html#elided-lifetimes-in-paths",
        "#async-idents": "allowed-by-default.html#keyword-idents",
        "#disjoint-capture-migration": "allowed-by-default.html#rust-2021-incompatible-closure-captures",
        "#keyword-idents": "allowed-by-default.html#keyword-idents-2018",
        "#or-patterns-back-compat": "allowed-by-default.html#rust-2021-incompatible-or-patterns",
};
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
});
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../lints/listing/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../../lints/listing/warn-by-default.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../lints/listing/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../../lints/listing/warn-by-default.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../../mark-09e88c2c.min.js"></script>
        <script src="../../searcher-c2a407aa.js"></script>

        <script src="../../clipboard-1626706a.min.js"></script>
        <script src="../../highlight-abc7f01d.js"></script>
        <script src="../../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
