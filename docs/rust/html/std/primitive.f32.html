<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A 32-bit floating-point type (specifically, the “binary32” type defined in IEEE 754-2008)."><title>f32 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-0bd2dfd4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.95.0" data-rustdoc-version="1.95.0-nightly (e96bb7e44 2026-01-27)" data-channel="nightly" data-search-js="search-86d08462.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items1.95.0.js"></script><script defer src="../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc primitive"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">f32</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../std/index.html"><img class="rust-logo" src="../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../std/index.html">std</a><span class="version">1.95.0-nightly</span></h2></div><div class="version">(e96bb7e44	2026-01-27)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">f32</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#nan-bit-patterns" title="NaN bit patterns">NaN bit patterns</a><ul><li><a href="#target-specific-extra-nan-values" title="Target-specific “extra” NaN values">Target-specific “extra” NaN values</a></li></ul></li><li><a href="#algebraic-operators" title="Algebraic operators">Algebraic operators</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.DIGITS" title="DIGITS">DIGITS</a></li><li><a href="#associatedconstant.EPSILON" title="EPSILON">EPSILON</a></li><li><a href="#associatedconstant.INFINITY" title="INFINITY">INFINITY</a></li><li><a href="#associatedconstant.MANTISSA_DIGITS" title="MANTISSA_DIGITS">MANTISSA_DIGITS</a></li><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MAX_10_EXP" title="MAX_10_EXP">MAX_10_EXP</a></li><li><a href="#associatedconstant.MAX_EXP" title="MAX_EXP">MAX_EXP</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li><li><a href="#associatedconstant.MIN_10_EXP" title="MIN_10_EXP">MIN_10_EXP</a></li><li><a href="#associatedconstant.MIN_EXP" title="MIN_EXP">MIN_EXP</a></li><li><a href="#associatedconstant.MIN_POSITIVE" title="MIN_POSITIVE">MIN_POSITIVE</a></li><li><a href="#associatedconstant.NAN" title="NAN">NAN</a></li><li><a href="#associatedconstant.NEG_INFINITY" title="NEG_INFINITY">NEG_INFINITY</a></li><li><a href="#associatedconstant.RADIX" title="RADIX">RADIX</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.abs" title="abs">abs</a></li><li><a href="#method.abs_sub" title="abs_sub">abs_sub</a></li><li><a href="#method.acos" title="acos">acos</a></li><li><a href="#method.acosh" title="acosh">acosh</a></li><li><a href="#method.algebraic_add" title="algebraic_add">algebraic_add</a></li><li><a href="#method.algebraic_div" title="algebraic_div">algebraic_div</a></li><li><a href="#method.algebraic_mul" title="algebraic_mul">algebraic_mul</a></li><li><a href="#method.algebraic_rem" title="algebraic_rem">algebraic_rem</a></li><li><a href="#method.algebraic_sub" title="algebraic_sub">algebraic_sub</a></li><li><a href="#method.asin" title="asin">asin</a></li><li><a href="#method.asinh" title="asinh">asinh</a></li><li><a href="#method.atan" title="atan">atan</a></li><li><a href="#method.atan2" title="atan2">atan2</a></li><li><a href="#method.atanh" title="atanh">atanh</a></li><li><a href="#method.cbrt" title="cbrt">cbrt</a></li><li><a href="#method.ceil" title="ceil">ceil</a></li><li><a href="#method.clamp" title="clamp">clamp</a></li><li><a href="#method.clamp_magnitude" title="clamp_magnitude">clamp_magnitude</a></li><li><a href="#method.classify" title="classify">classify</a></li><li><a href="#method.copysign" title="copysign">copysign</a></li><li><a href="#method.cos" title="cos">cos</a></li><li><a href="#method.cosh" title="cosh">cosh</a></li><li><a href="#method.div_euclid" title="div_euclid">div_euclid</a></li><li><a href="#method.erf" title="erf">erf</a></li><li><a href="#method.erfc" title="erfc">erfc</a></li><li><a href="#method.exp" title="exp">exp</a></li><li><a href="#method.exp2" title="exp2">exp2</a></li><li><a href="#method.exp_m1" title="exp_m1">exp_m1</a></li><li><a href="#method.floor" title="floor">floor</a></li><li><a href="#method.fract" title="fract">fract</a></li><li><a href="#method.from_be_bytes" title="from_be_bytes">from_be_bytes</a></li><li><a href="#method.from_bits" title="from_bits">from_bits</a></li><li><a href="#method.from_le_bytes" title="from_le_bytes">from_le_bytes</a></li><li><a href="#method.from_ne_bytes" title="from_ne_bytes">from_ne_bytes</a></li><li><a href="#method.gamma" title="gamma">gamma</a></li><li><a href="#method.hypot" title="hypot">hypot</a></li><li><a href="#method.is_finite" title="is_finite">is_finite</a></li><li><a href="#method.is_infinite" title="is_infinite">is_infinite</a></li><li><a href="#method.is_nan" title="is_nan">is_nan</a></li><li><a href="#method.is_normal" title="is_normal">is_normal</a></li><li><a href="#method.is_sign_negative" title="is_sign_negative">is_sign_negative</a></li><li><a href="#method.is_sign_positive" title="is_sign_positive">is_sign_positive</a></li><li><a href="#method.is_subnormal" title="is_subnormal">is_subnormal</a></li><li><a href="#method.ln" title="ln">ln</a></li><li><a href="#method.ln_1p" title="ln_1p">ln_1p</a></li><li><a href="#method.ln_gamma" title="ln_gamma">ln_gamma</a></li><li><a href="#method.log" title="log">log</a></li><li><a href="#method.log2" title="log2">log2</a></li><li><a href="#method.log10" title="log10">log10</a></li><li><a href="#method.max" title="max">max</a></li><li><a href="#method.maximum" title="maximum">maximum</a></li><li><a href="#method.midpoint" title="midpoint">midpoint</a></li><li><a href="#method.min" title="min">min</a></li><li><a href="#method.minimum" title="minimum">minimum</a></li><li><a href="#method.mul_add" title="mul_add">mul_add</a></li><li><a href="#method.next_down" title="next_down">next_down</a></li><li><a href="#method.next_up" title="next_up">next_up</a></li><li><a href="#method.powf" title="powf">powf</a></li><li><a href="#method.powi" title="powi">powi</a></li><li><a href="#method.recip" title="recip">recip</a></li><li><a href="#method.rem_euclid" title="rem_euclid">rem_euclid</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.round_ties_even" title="round_ties_even">round_ties_even</a></li><li><a href="#method.signum" title="signum">signum</a></li><li><a href="#method.sin" title="sin">sin</a></li><li><a href="#method.sin_cos" title="sin_cos">sin_cos</a></li><li><a href="#method.sinh" title="sinh">sinh</a></li><li><a href="#method.sqrt" title="sqrt">sqrt</a></li><li><a href="#method.tan" title="tan">tan</a></li><li><a href="#method.tanh" title="tanh">tanh</a></li><li><a href="#method.to_be_bytes" title="to_be_bytes">to_be_bytes</a></li><li><a href="#method.to_bits" title="to_bits">to_bits</a></li><li><a href="#method.to_degrees" title="to_degrees">to_degrees</a></li><li><a href="#method.to_int_unchecked" title="to_int_unchecked">to_int_unchecked</a></li><li><a href="#method.to_le_bytes" title="to_le_bytes">to_le_bytes</a></li><li><a href="#method.to_ne_bytes" title="to_ne_bytes">to_ne_bytes</a></li><li><a href="#method.to_radians" title="to_radians">to_radians</a></li><li><a href="#method.total_cmp" title="total_cmp">total_cmp</a></li><li><a href="#method.trunc" title="trunc">trunc</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add-for-f32" title="Add">Add</a></li><li><a href="#impl-Add%3C%26f32%3E-for-%26f32" title="Add&#60;&#38;f32&#62;">Add&#60;&#38;f32&#62;</a></li><li><a href="#impl-Add%3C%26f32%3E-for-f32" title="Add&#60;&#38;f32&#62;">Add&#60;&#38;f32&#62;</a></li><li><a href="#impl-Add%3Cf32%3E-for-%26f32" title="Add&#60;f32&#62;">Add&#60;f32&#62;</a></li><li><a href="#impl-AddAssign-for-f32" title="AddAssign">AddAssign</a></li><li><a href="#impl-AddAssign%3C%26f32%3E-for-f32" title="AddAssign&#60;&#38;f32&#62;">AddAssign&#60;&#38;f32&#62;</a></li><li><a href="#impl-Clone-for-f32" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-f32" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-f32" title="Debug">Debug</a></li><li><a href="#impl-Default-for-f32" title="Default">Default</a></li><li><a href="#impl-Display-for-f32" title="Display">Display</a></li><li><a href="#impl-Div-for-f32" title="Div">Div</a></li><li><a href="#impl-Div%3C%26f32%3E-for-%26f32" title="Div&#60;&#38;f32&#62;">Div&#60;&#38;f32&#62;</a></li><li><a href="#impl-Div%3C%26f32%3E-for-f32" title="Div&#60;&#38;f32&#62;">Div&#60;&#38;f32&#62;</a></li><li><a href="#impl-Div%3Cf32%3E-for-%26f32" title="Div&#60;f32&#62;">Div&#60;f32&#62;</a></li><li><a href="#impl-DivAssign-for-f32" title="DivAssign">DivAssign</a></li><li><a href="#impl-DivAssign%3C%26f32%3E-for-f32" title="DivAssign&#60;&#38;f32&#62;">DivAssign&#60;&#38;f32&#62;</a></li><li><a href="#impl-FloatToInt%3Ci8%3E-for-f32" title="FloatToInt&#60;i8&#62;">FloatToInt&#60;i8&#62;</a></li><li><a href="#impl-FloatToInt%3Ci16%3E-for-f32" title="FloatToInt&#60;i16&#62;">FloatToInt&#60;i16&#62;</a></li><li><a href="#impl-FloatToInt%3Ci32%3E-for-f32" title="FloatToInt&#60;i32&#62;">FloatToInt&#60;i32&#62;</a></li><li><a href="#impl-FloatToInt%3Ci64%3E-for-f32" title="FloatToInt&#60;i64&#62;">FloatToInt&#60;i64&#62;</a></li><li><a href="#impl-FloatToInt%3Ci128%3E-for-f32" title="FloatToInt&#60;i128&#62;">FloatToInt&#60;i128&#62;</a></li><li><a href="#impl-FloatToInt%3Cisize%3E-for-f32" title="FloatToInt&#60;isize&#62;">FloatToInt&#60;isize&#62;</a></li><li><a href="#impl-FloatToInt%3Cu8%3E-for-f32" title="FloatToInt&#60;u8&#62;">FloatToInt&#60;u8&#62;</a></li><li><a href="#impl-FloatToInt%3Cu16%3E-for-f32" title="FloatToInt&#60;u16&#62;">FloatToInt&#60;u16&#62;</a></li><li><a href="#impl-FloatToInt%3Cu32%3E-for-f32" title="FloatToInt&#60;u32&#62;">FloatToInt&#60;u32&#62;</a></li><li><a href="#impl-FloatToInt%3Cu64%3E-for-f32" title="FloatToInt&#60;u64&#62;">FloatToInt&#60;u64&#62;</a></li><li><a href="#impl-FloatToInt%3Cu128%3E-for-f32" title="FloatToInt&#60;u128&#62;">FloatToInt&#60;u128&#62;</a></li><li><a href="#impl-FloatToInt%3Cusize%3E-for-f32" title="FloatToInt&#60;usize&#62;">FloatToInt&#60;usize&#62;</a></li><li><a href="#impl-From%3Cbool%3E-for-f32" title="From&#60;bool&#62;">From&#60;bool&#62;</a></li><li><a href="#impl-From%3Cf32%3E-for-f128" title="From&#60;f32&#62;">From&#60;f32&#62;</a></li><li><a href="#impl-From%3Cf32%3E-for-f64" title="From&#60;f32&#62;">From&#60;f32&#62;</a></li><li><a href="#impl-From%3Ci8%3E-for-f32" title="From&#60;i8&#62;">From&#60;i8&#62;</a></li><li><a href="#impl-From%3Ci16%3E-for-f32" title="From&#60;i16&#62;">From&#60;i16&#62;</a></li><li><a href="#impl-From%3Cu8%3E-for-f32" title="From&#60;u8&#62;">From&#60;u8&#62;</a></li><li><a href="#impl-From%3Cu16%3E-for-f32" title="From&#60;u16&#62;">From&#60;u16&#62;</a></li><li><a href="#impl-FromStr-for-f32" title="FromStr">FromStr</a></li><li><a href="#impl-LowerExp-for-f32" title="LowerExp">LowerExp</a></li><li><a href="#impl-Mul-for-f32" title="Mul">Mul</a></li><li><a href="#impl-Mul%3C%26f32%3E-for-%26f32" title="Mul&#60;&#38;f32&#62;">Mul&#60;&#38;f32&#62;</a></li><li><a href="#impl-Mul%3C%26f32%3E-for-f32" title="Mul&#60;&#38;f32&#62;">Mul&#60;&#38;f32&#62;</a></li><li><a href="#impl-Mul%3Cf32%3E-for-%26f32" title="Mul&#60;f32&#62;">Mul&#60;f32&#62;</a></li><li><a href="#impl-MulAssign-for-f32" title="MulAssign">MulAssign</a></li><li><a href="#impl-MulAssign%3C%26f32%3E-for-f32" title="MulAssign&#60;&#38;f32&#62;">MulAssign&#60;&#38;f32&#62;</a></li><li><a href="#impl-Neg-for-%26f32" title="Neg">Neg</a></li><li><a href="#impl-Neg-for-f32" title="Neg">Neg</a></li><li><a href="#impl-PartialEq-for-f32" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-f32" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-Product-for-f32" title="Product">Product</a></li><li><a href="#impl-Product%3C%26f32%3E-for-f32" title="Product&#60;&#38;&#39;a f32&#62;">Product&#60;&#38;&#39;a f32&#62;</a></li><li><a href="#impl-Rem-for-f32" title="Rem">Rem</a></li><li><a href="#impl-Rem%3C%26f32%3E-for-%26f32" title="Rem&#60;&#38;f32&#62;">Rem&#60;&#38;f32&#62;</a></li><li><a href="#impl-Rem%3C%26f32%3E-for-f32" title="Rem&#60;&#38;f32&#62;">Rem&#60;&#38;f32&#62;</a></li><li><a href="#impl-Rem%3Cf32%3E-for-%26f32" title="Rem&#60;f32&#62;">Rem&#60;f32&#62;</a></li><li><a href="#impl-RemAssign-for-f32" title="RemAssign">RemAssign</a></li><li><a href="#impl-RemAssign%3C%26f32%3E-for-f32" title="RemAssign&#60;&#38;f32&#62;">RemAssign&#60;&#38;f32&#62;</a></li><li><a href="#impl-SimdCast-for-f32" title="SimdCast">SimdCast</a></li><li><a href="#impl-SimdElement-for-f32" title="SimdElement">SimdElement</a></li><li><a href="#impl-Sub-for-f32" title="Sub">Sub</a></li><li><a href="#impl-Sub%3C%26f32%3E-for-%26f32" title="Sub&#60;&#38;f32&#62;">Sub&#60;&#38;f32&#62;</a></li><li><a href="#impl-Sub%3C%26f32%3E-for-f32" title="Sub&#60;&#38;f32&#62;">Sub&#60;&#38;f32&#62;</a></li><li><a href="#impl-Sub%3Cf32%3E-for-%26f32" title="Sub&#60;f32&#62;">Sub&#60;f32&#62;</a></li><li><a href="#impl-SubAssign-for-f32" title="SubAssign">SubAssign</a></li><li><a href="#impl-SubAssign%3C%26f32%3E-for-f32" title="SubAssign&#60;&#38;f32&#62;">SubAssign&#60;&#38;f32&#62;</a></li><li><a href="#impl-Sum-for-f32" title="Sum">Sum</a></li><li><a href="#impl-Sum%3C%26f32%3E-for-f32" title="Sum&#60;&#38;&#39;a f32&#62;">Sum&#60;&#38;&#39;a f32&#62;</a></li><li><a href="#impl-UpperExp-for-f32" title="UpperExp">UpperExp</a></li><li><a href="#impl-UseCloned-for-f32" title="UseCloned">UseCloned</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-f32" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-f32" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-f32" title="Send">Send</a></li><li><a href="#impl-Sync-for-f32" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-f32" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-f32" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate std</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><h1>Primitive Type <span class="primitive">f32</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A 32-bit floating-point type (specifically, the “binary32” type defined in IEEE 754-2008).</p>
<p>This type can represent a wide range of decimal numbers, like <code>3.5</code>, <code>27</code>,
<code>-113.75</code>, <code>0.0078125</code>, <code>34359738368</code>, <code>0</code>, <code>-1</code>. So unlike integer types
(such as <code>i32</code>), floating-point types can represent non-integer numbers,
too.</p>
<p>However, being able to represent this wide range of numbers comes at the
cost of precision: floats can only represent some of the real numbers and
calculation with floats round to a nearby representable number. For example,
<code>5.0</code> and <code>1.0</code> can be exactly represented as <code>f32</code>, but <code>1.0 / 5.0</code> results
in <code>0.20000000298023223876953125</code> since <code>0.2</code> cannot be exactly represented
as <code>f32</code>. Note, however, that printing floats with <code>println</code> and friends will
often discard insignificant digits: <code>println!("{}", 1.0f32 / 5.0f32)</code> will
print <code>0.2</code>.</p>
<p>Additionally, <code>f32</code> can represent some special values:</p>
<ul>
<li>−0.0: IEEE 754 floating-point numbers have a bit that indicates their sign, so −0.0 is a
possible value. For comparison −0.0 = +0.0, but floating-point operations can carry
the sign bit through arithmetic operations. This means −0.0 × +0.0 produces −0.0 and
a negative number rounded to a value smaller than a float can represent also produces −0.0.</li>
<li><a href="#associatedconstant.INFINITY">∞</a> and
<a href="#associatedconstant.NEG_INFINITY">−∞</a>: these result from calculations
like <code>1.0 / 0.0</code>.</li>
<li><a href="#associatedconstant.NAN">NaN (not a number)</a>: this value results from
calculations like <code>(-1.0).sqrt()</code>. NaN has some potentially unexpected
behavior:
<ul>
<li>It is not equal to any float, including itself! This is the reason <code>f32</code>
doesn’t implement the <code>Eq</code> trait.</li>
<li>It is also neither smaller nor greater than any float, making it
impossible to sort by the default comparison operation, which is the
reason <code>f32</code> doesn’t implement the <code>Ord</code> trait.</li>
<li>It is also considered <em>infectious</em> as almost all calculations where one
of the operands is NaN will also result in NaN. The explanations on this
page only explicitly document behavior on NaN operands if this default
is deviated from.</li>
<li>Lastly, there are multiple bit patterns that are considered NaN.
Rust does not currently guarantee that the bit patterns of NaN are
preserved over arithmetic operations, and they are not guaranteed to be
portable or even fully deterministic! This means that there may be some
surprising results upon inspecting the bit patterns,
as the same calculations might produce NaNs with different bit patterns.
This also affects the sign of the NaN: checking <code>is_sign_positive</code> or <code>is_sign_negative</code> on
a NaN is the most common way to run into these surprising results.
(Checking <code>x &gt;= 0.0</code> or <code>x &lt;= 0.0</code> avoids those surprises, but also how negative/positive
zero are treated.)
See the section below for what exactly is guaranteed about the bit pattern of a NaN.</li>
</ul>
</li>
</ul>
<p>When a primitive operation (addition, subtraction, multiplication, or
division) is performed on this type, the result is rounded according to the
roundTiesToEven direction defined in IEEE 754-2008. That means:</p>
<ul>
<li>The result is the representable value closest to the true value, if there
is a unique closest representable value.</li>
<li>If the true value is exactly half-way between two representable values,
the result is the one with an even least-significant binary digit.</li>
<li>If the true value’s magnitude is ≥ <code>f32::MAX</code> + 2<sup>(<code>f32::MAX_EXP</code> −
<code>f32::MANTISSA_DIGITS</code> − 1)</sup>, the result is ∞ or −∞ (preserving the
true value’s sign).</li>
<li>If the result of a sum exactly equals zero, the outcome is +0.0 unless
both arguments were negative, then it is -0.0. Subtraction <code>a - b</code> is
regarded as a sum <code>a + (-b)</code>.</li>
</ul>
<p>For more information on floating-point numbers, see <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">Wikipedia</a>.</p>
<p><em><a href="f32/consts/index.html" title="mod std::f32::consts">See also the <code>std::f32::consts</code> module</a>.</em></p>
<h2 id="nan-bit-patterns"><a class="doc-anchor" href="#nan-bit-patterns">§</a>NaN bit patterns</h2>
<p>This section defines the possible NaN bit patterns returned by floating-point operations.</p>
<p>The bit pattern of a floating-point NaN value is defined by:</p>
<ul>
<li>a sign bit.</li>
<li>a quiet/signaling bit. Rust assumes that the quiet/signaling bit being set to <code>1</code> indicates a
quiet NaN (QNaN), and a value of <code>0</code> indicates a signaling NaN (SNaN). In the following we
will hence just call it the “quiet bit”.</li>
<li>a payload, which makes up the rest of the significand (i.e., the mantissa) except for the
quiet bit.</li>
</ul>
<p>The rules for NaN values differ between <em>arithmetic</em> and <em>non-arithmetic</em> (or “bitwise”)
operations. The non-arithmetic operations are unary <code>-</code>, <code>abs</code>, <code>copysign</code>, <code>signum</code>,
<code>{to,from}_bits</code>, <code>{to,from}_{be,le,ne}_bytes</code> and <code>is_sign_{positive,negative}</code>. These
operations are guaranteed to exactly preserve the bit pattern of their input except for possibly
changing the sign bit.</p>
<p>The following rules apply when a NaN value is returned from an arithmetic operation:</p>
<ul>
<li>
<p>The result has a non-deterministic sign.</p>
</li>
<li>
<p>The quiet bit and payload are non-deterministically chosen from
the following set of options:</p>
<ul>
<li><strong>Preferred NaN</strong>: The quiet bit is set and the payload is all-zero.</li>
<li><strong>Quieting NaN propagation</strong>: The quiet bit is set and the payload is copied from any input
operand that is a NaN. If the inputs and outputs do not have the same payload size (i.e., for
<code>as</code> casts), then
<ul>
<li>If the output is smaller than the input, low-order bits of the payload get dropped.</li>
<li>If the output is larger than the input, the payload gets filled up with 0s in the low-order
bits.</li>
</ul>
</li>
<li><strong>Unchanged NaN propagation</strong>: The quiet bit and payload are copied from any input operand
that is a NaN. If the inputs and outputs do not have the same size (i.e., for <code>as</code> casts), the
same rules as for “quieting NaN propagation” apply, with one caveat: if the output is smaller
than the input, dropping the low-order bits may result in a payload of 0; a payload of 0 is not
possible with a signaling NaN (the all-0 significand encodes an infinity) so unchanged NaN
propagation cannot occur with some inputs.</li>
<li><strong>Target-specific NaN</strong>: The quiet bit is set and the payload is picked from a target-specific
set of “extra” possible NaN payloads. The set can depend on the input operand values.
See the table below for the concrete NaNs this set contains on various targets.</li>
</ul>
</li>
</ul>
<p>In particular, if all input NaNs are quiet (or if there are no input NaNs), then the output NaN
is definitely quiet. Signaling NaN outputs can only occur if they are provided as an input
value. Similarly, if all input NaNs are preferred (or if there are no input NaNs) and the target
does not have any “extra” NaN payloads, then the output NaN is guaranteed to be preferred.</p>
<p>The non-deterministic choice happens when the operation is executed; i.e., the result of a
NaN-producing floating-point operation is a stable bit pattern (looking at these bits multiple
times will yield consistent results), but running the same operation twice with the same inputs
can produce different results.</p>
<p>These guarantees are neither stronger nor weaker than those of IEEE 754: IEEE 754 guarantees
that an operation never returns a signaling NaN, whereas it is possible for operations like
<code>SNAN * 1.0</code> to return a signaling NaN in Rust. Conversely, IEEE 754 makes no statement at all
about which quiet NaN is returned, whereas Rust restricts the set of possible results to the
ones listed above.</p>
<p>Unless noted otherwise, the same rules also apply to NaNs returned by other library functions
(e.g. <code>min</code>, <code>minimum</code>, <code>max</code>, <code>maximum</code>); other aspects of their semantics and which IEEE 754
operation they correspond to are documented with the respective functions.</p>
<p>When an arithmetic floating-point operation is executed in <code>const</code> context, the same rules
apply: no guarantee is made about which of the NaN bit patterns described above will be
returned. The result does not have to match what happens when executing the same code at
runtime, and the result can vary depending on factors such as compiler version and flags.</p>
<h4 id="target-specific-extra-nan-values"><a class="doc-anchor" href="#target-specific-extra-nan-values">§</a>Target-specific “extra” NaN values</h4><div><table><thead><tr><th><code>target_arch</code></th><th>Extra payloads possible on this platform</th></tr></thead><tbody>
<tr><td><code>aarch64</code>, <code>arm</code>, <code>arm64ec</code>, <code>loongarch64</code>, <code>powerpc</code> (except when <code>target_abi = "spe"</code>), <code>powerpc64</code>, <code>riscv32</code>, <code>riscv64</code>, <code>s390x</code>, <code>x86</code>, <code>x86_64</code></td><td>None</td></tr>
<tr><td><code>nvptx64</code></td><td>All payloads</td></tr>
<tr><td><code>sparc</code>, <code>sparc64</code></td><td>The all-one payload</td></tr>
<tr><td><code>wasm32</code>, <code>wasm64</code></td><td>If all input NaNs are quiet with all-zero payload: None.<br> Otherwise: all payloads.</td></tr>
</tbody></table>
</div>
<p>For targets not in this table, all payloads are possible.</p>
<h2 id="algebraic-operators"><a class="doc-anchor" href="#algebraic-operators">§</a>Algebraic operators</h2>
<p>Algebraic operators of the form <code>a.algebraic_*(b)</code> allow the compiler to optimize
floating point operations using all the usual algebraic properties of real numbers –
despite the fact that those properties do <em>not</em> hold on floating point numbers.
This can give a great performance boost since it may unlock vectorization.</p>
<p>The exact set of optimizations is unspecified but typically allows combining operations,
rearranging series of operations based on mathematical properties, converting between division
and reciprocal multiplication, and disregarding the sign of zero. This means that the results of
elementary operations may have undefined precision, and “non-mathematical” values
such as NaN, +/-Inf, or -0.0 may behave in unexpected ways, but these operations
will never cause undefined behavior.</p>
<p>Because of the unpredictable nature of compiler optimizations, the same inputs may produce
different results even within a single program run. <strong>Unsafe code must not rely on any property
of the return value for soundness.</strong> However, implementations will generally do their best to
pick a reasonable tradeoff between performance and accuracy of the result.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>x = a.algebraic_add(b).algebraic_add(c).algebraic_add(d);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_algebraic)%5D%0A%0A%23!%5Ballow(unused_assignments)%5D%0A%0Afn+main()+%7B%0A++++let+mut+x:+f32+=+0.0;%0A++++let+a:+f32+=+1.0;%0A++++let+b:+f32+=+2.0;%0A++++let+c:+f32+=+3.0;%0A++++let+d:+f32+=+4.0;%0A++++x+=+a.algebraic_add(b).algebraic_add(c).algebraic_add(d);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div>
<p>May be rewritten as:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>x = a + b + c + d; <span class="comment">// As written
</span>x = (a + c) + (b + d); <span class="comment">// Reordered to shorten critical path and enable vectorization</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_assignments)%5D%0A%0Afn+main()+%7B%0A++++let+mut+x:+f32+=+0.0;%0A++++let+a:+f32+=+1.0;%0A++++let+b:+f32+=+2.0;%0A++++let+c:+f32+=+3.0;%0A++++let+d:+f32+=+4.0;%0A++++x+=+a+%2B+b+%2B+c+%2B+d;+//+As+written%0A++++x+=+(a+%2B+c)+%2B+(b+%2B+d);%0A%7D&amp;edition=2024"></a></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-f32" class="impl"><a class="src rightside" href="../src/std/num/f32.rs.html#28-1276">Source</a><a href="#impl-f32" class="anchor">§</a><h3 class="code-header">impl <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.floor" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.90.0">1.0.0 (const: 1.90.0)</span> · <a class="src" href="../src/std/num/f32.rs.html#49-51">Source</a></span><h4 class="code-header">pub const fn <a href="#method.floor" class="fn">floor</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the largest integer less than or equal to <code>self</code>.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">3.7_f32</span>;
<span class="kw">let </span>g = <span class="number">3.0_f32</span>;
<span class="kw">let </span>h = -<span class="number">3.7_f32</span>;

<span class="macro">assert_eq!</span>(f.floor(), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(g.floor(), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(h.floor(), -<span class="number">4.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.7_f32;%0A++++let+g+=+3.0_f32;%0A++++let+h+=+-3.7_f32;%0A++++%0A++++assert_eq!(f.floor(),+3.0);%0A++++assert_eq!(g.floor(),+3.0);%0A++++assert_eq!(h.floor(),+-4.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ceil" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.90.0">1.0.0 (const: 1.90.0)</span> · <a class="src" href="../src/std/num/f32.rs.html#72-74">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ceil" class="fn">ceil</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the smallest integer greater than or equal to <code>self</code>.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">3.01_f32</span>;
<span class="kw">let </span>g = <span class="number">4.0_f32</span>;

<span class="macro">assert_eq!</span>(f.ceil(), <span class="number">4.0</span>);
<span class="macro">assert_eq!</span>(g.ceil(), <span class="number">4.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.01_f32;%0A++++let+g+=+4.0_f32;%0A++++%0A++++assert_eq!(f.ceil(),+4.0);%0A++++assert_eq!(g.ceil(),+4.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.90.0">1.0.0 (const: 1.90.0)</span> · <a class="src" href="../src/std/num/f32.rs.html#101-103">Source</a></span><h4 class="code-header">pub const fn <a href="#method.round" class="fn">round</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the nearest integer to <code>self</code>. If a value is half-way between two
integers, round away from <code>0.0</code>.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">3.3_f32</span>;
<span class="kw">let </span>g = -<span class="number">3.3_f32</span>;
<span class="kw">let </span>h = -<span class="number">3.7_f32</span>;
<span class="kw">let </span>i = <span class="number">3.5_f32</span>;
<span class="kw">let </span>j = <span class="number">4.5_f32</span>;

<span class="macro">assert_eq!</span>(f.round(), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(g.round(), -<span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(h.round(), -<span class="number">4.0</span>);
<span class="macro">assert_eq!</span>(i.round(), <span class="number">4.0</span>);
<span class="macro">assert_eq!</span>(j.round(), <span class="number">5.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.3_f32;%0A++++let+g+=+-3.3_f32;%0A++++let+h+=+-3.7_f32;%0A++++let+i+=+3.5_f32;%0A++++let+j+=+4.5_f32;%0A++++%0A++++assert_eq!(f.round(),+3.0);%0A++++assert_eq!(g.round(),+-3.0);%0A++++assert_eq!(h.round(),+-4.0);%0A++++assert_eq!(i.round(),+4.0);%0A++++assert_eq!(j.round(),+5.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.round_ties_even" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.77.0, const since 1.90.0">1.77.0 (const: 1.90.0)</span> · <a class="src" href="../src/std/num/f32.rs.html#128-130">Source</a></span><h4 class="code-header">pub const fn <a href="#method.round_ties_even" class="fn">round_ties_even</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the nearest integer to a number. Rounds half-way cases to the number
with an even least significant digit.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">3.3_f32</span>;
<span class="kw">let </span>g = -<span class="number">3.3_f32</span>;
<span class="kw">let </span>h = <span class="number">3.5_f32</span>;
<span class="kw">let </span>i = <span class="number">4.5_f32</span>;

<span class="macro">assert_eq!</span>(f.round_ties_even(), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(g.round_ties_even(), -<span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(h.round_ties_even(), <span class="number">4.0</span>);
<span class="macro">assert_eq!</span>(i.round_ties_even(), <span class="number">4.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.3_f32;%0A++++let+g+=+-3.3_f32;%0A++++let+h+=+3.5_f32;%0A++++let+i+=+4.5_f32;%0A++++%0A++++assert_eq!(f.round_ties_even(),+3.0);%0A++++assert_eq!(g.round_ties_even(),+-3.0);%0A++++assert_eq!(h.round_ties_even(),+4.0);%0A++++assert_eq!(i.round_ties_even(),+4.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trunc" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.90.0">1.0.0 (const: 1.90.0)</span> · <a class="src" href="../src/std/num/f32.rs.html#154-156">Source</a></span><h4 class="code-header">pub const fn <a href="#method.trunc" class="fn">trunc</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the integer part of <code>self</code>.
This means that non-integer numbers are always truncated towards zero.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">3.7_f32</span>;
<span class="kw">let </span>g = <span class="number">3.0_f32</span>;
<span class="kw">let </span>h = -<span class="number">3.7_f32</span>;

<span class="macro">assert_eq!</span>(f.trunc(), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(g.trunc(), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(h.trunc(), -<span class="number">3.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.7_f32;%0A++++let+g+=+3.0_f32;%0A++++let+h+=+-3.7_f32;%0A++++%0A++++assert_eq!(f.trunc(),+3.0);%0A++++assert_eq!(g.trunc(),+3.0);%0A++++assert_eq!(h.trunc(),+-3.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fract" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.90.0">1.0.0 (const: 1.90.0)</span> · <a class="src" href="../src/std/num/f32.rs.html#178-180">Source</a></span><h4 class="code-header">pub const fn <a href="#method.fract" class="fn">fract</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the fractional part of <code>self</code>.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">3.6_f32</span>;
<span class="kw">let </span>y = -<span class="number">3.6_f32</span>;
<span class="kw">let </span>abs_difference_x = (x.fract() - <span class="number">0.6</span>).abs();
<span class="kw">let </span>abs_difference_y = (y.fract() - (-<span class="number">0.6</span>)).abs();

<span class="macro">assert!</span>(abs_difference_x &lt;= f32::EPSILON);
<span class="macro">assert!</span>(abs_difference_y &lt;= f32::EPSILON);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.6_f32;%0A++++let+y+=+-3.6_f32;%0A++++let+abs_difference_x+=+(x.fract()+-+0.6).abs();%0A++++let+abs_difference_y+=+(y.fract()+-+(-0.6)).abs();%0A++++%0A++++assert!(abs_difference_x+%3C=+f32::EPSILON);%0A++++assert!(abs_difference_y+%3C=+f32::EPSILON);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.mul_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.94.0">1.0.0 (const: 1.94.0)</span> · <a class="src" href="../src/std/num/f32.rs.html#221-223">Source</a></span><h4 class="code-header">pub const fn <a href="#method.mul_add" class="fn">mul_add</a>(self, a: <a class="primitive" href="primitive.f32.html">f32</a>, b: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Fused multiply-add. Computes <code>(self * a) + b</code> with only one rounding
error, yielding a more accurate result than an unfused multiply-add.</p>
<p>Using <code>mul_add</code> <em>may</em> be more performant than an unfused multiply-add if
the target architecture has a dedicated <code>fma</code> CPU instruction. However,
this is not always true, and will be heavily dependant on designing
algorithms with specific target hardware in mind.</p>
<h5 id="precision"><a class="doc-anchor" href="#precision">§</a>Precision</h5>
<p>The result of this operation is guaranteed to be the rounded
infinite-precision result. It is specified by IEEE 754 as
<code>fusedMultiplyAdd</code> and guaranteed not to change.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>m = <span class="number">10.0_f32</span>;
<span class="kw">let </span>x = <span class="number">4.0_f32</span>;
<span class="kw">let </span>b = <span class="number">60.0_f32</span>;

<span class="macro">assert_eq!</span>(m.mul_add(x, b), <span class="number">100.0</span>);
<span class="macro">assert_eq!</span>(m * x + b, <span class="number">100.0</span>);

<span class="kw">let </span>one_plus_eps = <span class="number">1.0_f32 </span>+ f32::EPSILON;
<span class="kw">let </span>one_minus_eps = <span class="number">1.0_f32 </span>- f32::EPSILON;
<span class="kw">let </span>minus_one = -<span class="number">1.0_f32</span>;

<span class="comment">// The exact result (1 + eps) * (1 - eps) = 1 - eps * eps.
</span><span class="macro">assert_eq!</span>(one_plus_eps.mul_add(one_minus_eps, minus_one), -f32::EPSILON * f32::EPSILON);
<span class="comment">// Different rounding with the non-fused multiply and add.
</span><span class="macro">assert_eq!</span>(one_plus_eps * one_minus_eps + minus_one, <span class="number">0.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+m+=+10.0_f32;%0A++++let+x+=+4.0_f32;%0A++++let+b+=+60.0_f32;%0A++++%0A++++assert_eq!(m.mul_add(x,+b),+100.0);%0A++++assert_eq!(m+*+x+%2B+b,+100.0);%0A++++%0A++++let+one_plus_eps+=+1.0_f32+%2B+f32::EPSILON;%0A++++let+one_minus_eps+=+1.0_f32+-+f32::EPSILON;%0A++++let+minus_one+=+-1.0_f32;%0A++++%0A++++//+The+exact+result+(1+%2B+eps)+*+(1+-+eps)+=+1+-+eps+*+eps.%0A++++assert_eq!(one_plus_eps.mul_add(one_minus_eps,+minus_one),+-f32::EPSILON+*+f32::EPSILON);%0A++++//+Different+rounding+with+the+non-fused+multiply+and+add.%0A++++assert_eq!(one_plus_eps+*+one_minus_eps+%2B+minus_one,+0.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.div_euclid" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span> · <a class="src" href="../src/std/num/f32.rs.html#251-253">Source</a></span><h4 class="code-header">pub fn <a href="#method.div_euclid" class="fn">div_euclid</a>(self, rhs: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Calculates Euclidean division, the matching method for <code>rem_euclid</code>.</p>
<p>This computes the integer <code>n</code> such that
<code>self = n * rhs + self.rem_euclid(rhs)</code>.
In other words, the result is <code>self / rhs</code> rounded to the integer <code>n</code>
such that <code>self &gt;= n * rhs</code>.</p>
<h5 id="precision-1"><a class="doc-anchor" href="#precision-1">§</a>Precision</h5>
<p>The result of this operation is guaranteed to be the rounded
infinite-precision result.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a: f32 = <span class="number">7.0</span>;
<span class="kw">let </span>b = <span class="number">4.0</span>;
<span class="macro">assert_eq!</span>(a.div_euclid(b), <span class="number">1.0</span>); <span class="comment">// 7.0 &gt; 4.0 * 1.0
</span><span class="macro">assert_eq!</span>((-a).div_euclid(b), -<span class="number">2.0</span>); <span class="comment">// -7.0 &gt;= 4.0 * -2.0
</span><span class="macro">assert_eq!</span>(a.div_euclid(-b), -<span class="number">1.0</span>); <span class="comment">// 7.0 &gt;= -4.0 * -1.0
</span><span class="macro">assert_eq!</span>((-a).div_euclid(-b), <span class="number">2.0</span>); <span class="comment">// -7.0 &gt;= -4.0 * 2.0</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a:+f32+=+7.0;%0A++++let+b+=+4.0;%0A++++assert_eq!(a.div_euclid(b),+1.0);+//+7.0+%3E+4.0+*+1.0%0A++++assert_eq!((-a).div_euclid(b),+-2.0);+//+-7.0+%3E=+4.0+*+-2.0%0A++++assert_eq!(a.div_euclid(-b),+-1.0);+//+7.0+%3E=+-4.0+*+-1.0%0A++++assert_eq!((-a).div_euclid(-b),+2.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rem_euclid" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span> · <a class="src" href="../src/std/num/f32.rs.html#289-291">Source</a></span><h4 class="code-header">pub fn <a href="#method.rem_euclid" class="fn">rem_euclid</a>(self, rhs: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Calculates the least nonnegative remainder of <code>self</code> when divided by
<code>rhs</code>.</p>
<p>In particular, the return value <code>r</code> satisfies <code>0.0 &lt;= r &lt; rhs.abs()</code> in
most cases. However, due to a floating point round-off error it can
result in <code>r == rhs.abs()</code>, violating the mathematical definition, if
<code>self</code> is much smaller than <code>rhs.abs()</code> in magnitude and <code>self &lt; 0.0</code>.
This result is not an element of the function’s codomain, but it is the
closest floating point number in the real numbers and thus fulfills the
property <code>self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)</code>
approximately.</p>
<h5 id="precision-2"><a class="doc-anchor" href="#precision-2">§</a>Precision</h5>
<p>The result of this operation is guaranteed to be the rounded
infinite-precision result.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a: f32 = <span class="number">7.0</span>;
<span class="kw">let </span>b = <span class="number">4.0</span>;
<span class="macro">assert_eq!</span>(a.rem_euclid(b), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>((-a).rem_euclid(b), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(a.rem_euclid(-b), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>((-a).rem_euclid(-b), <span class="number">1.0</span>);
<span class="comment">// limitation due to round-off error
</span><span class="macro">assert!</span>((-f32::EPSILON).rem_euclid(<span class="number">3.0</span>) != <span class="number">0.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a:+f32+=+7.0;%0A++++let+b+=+4.0;%0A++++assert_eq!(a.rem_euclid(b),+3.0);%0A++++assert_eq!((-a).rem_euclid(b),+1.0);%0A++++assert_eq!(a.rem_euclid(-b),+3.0);%0A++++assert_eq!((-a).rem_euclid(-b),+1.0);%0A++++//+limitation+due+to+round-off+error%0A++++assert!((-f32::EPSILON).rem_euclid(3.0)+!=+0.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.powi" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#323-325">Source</a></span><h4 class="code-header">pub fn <a href="#method.powi" class="fn">powi</a>(self, n: <a class="primitive" href="primitive.i32.html">i32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Raises a number to an integer power.</p>
<p>Using this function is generally faster than using <code>powf</code>.
It might have a different sequence of rounding operations than <code>powf</code>,
so the results are not guaranteed to agree.</p>
<p>Note that this function is special in that it can return non-NaN results for NaN inputs. For
example, <code>f32::powi(f32::NAN, 0)</code> returns <code>1.0</code>. However, if an input is a <em>signaling</em>
NaN, then the result is non-deterministically either a NaN or the result that the
corresponding quiet NaN would produce.</p>
<h5 id="unspecified-precision"><a class="doc-anchor" href="#unspecified-precision">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">2.0_f32</span>;
<span class="kw">let </span>abs_difference = (x.powi(<span class="number">2</span>) - (x * x)).abs();
<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-5</span>);

<span class="macro">assert_eq!</span>(f32::powi(f32::NAN, <span class="number">0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f32::powi(<span class="number">0.0</span>, <span class="number">0</span>), <span class="number">1.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.powi(2)+-+(x+*+x)).abs();%0A++++assert!(abs_difference+%3C=+1e-5);%0A++++%0A++++assert_eq!(f32::powi(f32::NAN,+0),+1.0);%0A++++assert_eq!(f32::powi(0.0,+0),+1.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.powf" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#354-356">Source</a></span><h4 class="code-header">pub fn <a href="#method.powf" class="fn">powf</a>(self, n: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Raises a number to a floating point power.</p>
<p>Note that this function is special in that it can return non-NaN results for NaN inputs. For
example, <code>f32::powf(f32::NAN, 0.0)</code> returns <code>1.0</code>. However, if an input is a <em>signaling</em>
NaN, then the result is non-deterministically either a NaN or the result that the
corresponding quiet NaN would produce.</p>
<h5 id="unspecified-precision-1"><a class="doc-anchor" href="#unspecified-precision-1">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">2.0_f32</span>;
<span class="kw">let </span>abs_difference = (x.powf(<span class="number">2.0</span>) - (x * x)).abs();
<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-5</span>);

<span class="macro">assert_eq!</span>(f32::powf(<span class="number">1.0</span>, f32::NAN), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f32::powf(f32::NAN, <span class="number">0.0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f32::powf(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">1.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.powf(2.0)+-+(x+*+x)).abs();%0A++++assert!(abs_difference+%3C=+1e-5);%0A++++%0A++++assert_eq!(f32::powf(1.0,+f32::NAN),+1.0);%0A++++assert_eq!(f32::powf(f32::NAN,+0.0),+1.0);%0A++++assert_eq!(f32::powf(0.0,+0.0),+1.0);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.sqrt" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#384-386">Source</a></span><h4 class="code-header">pub fn <a href="#method.sqrt" class="fn">sqrt</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the square root of a number.</p>
<p>Returns NaN if <code>self</code> is a negative number other than <code>-0.0</code>.</p>
<h5 id="precision-3"><a class="doc-anchor" href="#precision-3">§</a>Precision</h5>
<p>The result of this operation is guaranteed to be the rounded
infinite-precision result. It is specified by IEEE 754 as <code>squareRoot</code>
and guaranteed not to change.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>positive = <span class="number">4.0_f32</span>;
<span class="kw">let </span>negative = -<span class="number">4.0_f32</span>;
<span class="kw">let </span>negative_zero = -<span class="number">0.0_f32</span>;

<span class="macro">assert_eq!</span>(positive.sqrt(), <span class="number">2.0</span>);
<span class="macro">assert!</span>(negative.sqrt().is_nan());
<span class="macro">assert!</span>(negative_zero.sqrt() == negative_zero);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+positive+=+4.0_f32;%0A++++let+negative+=+-4.0_f32;%0A++++let+negative_zero+=+-0.0_f32;%0A++++%0A++++assert_eq!(positive.sqrt(),+2.0);%0A++++assert!(negative.sqrt().is_nan());%0A++++assert!(negative_zero.sqrt()+==+negative_zero);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.exp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#411-413">Source</a></span><h4 class="code-header">pub fn <a href="#method.exp" class="fn">exp</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns <code>e^(self)</code>, (the exponential function).</p>
<h5 id="unspecified-precision-2"><a class="doc-anchor" href="#unspecified-precision-2">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = <span class="number">1.0f32</span>;
<span class="comment">// e^1
</span><span class="kw">let </span>e = one.exp();

<span class="comment">// ln(e) - 1 == 0
</span><span class="kw">let </span>abs_difference = (e.ln() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+one+=+1.0f32;%0A++++//+e%5E1%0A++++let+e+=+one.exp();%0A++++%0A++++//+ln(e)+-+1+==+0%0A++++let+abs_difference+=+(e.ln()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.exp2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#436-438">Source</a></span><h4 class="code-header">pub fn <a href="#method.exp2" class="fn">exp2</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns <code>2^(self)</code>.</p>
<h5 id="unspecified-precision-3"><a class="doc-anchor" href="#unspecified-precision-3">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">2.0f32</span>;

<span class="comment">// 2^2 - 4 == 0
</span><span class="kw">let </span>abs_difference = (f.exp2() - <span class="number">4.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+2.0f32;%0A++++%0A++++//+2%5E2+-+4+==+0%0A++++let+abs_difference+=+(f.exp2()+-+4.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ln" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#471-473">Source</a></span><h4 class="code-header">pub fn <a href="#method.ln" class="fn">ln</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the natural logarithm of the number.</p>
<p>This returns NaN when the number is negative, and negative infinity when number is zero.</p>
<h5 id="unspecified-precision-4"><a class="doc-anchor" href="#unspecified-precision-4">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>one = <span class="number">1.0f32</span>;
<span class="comment">// e^1
</span><span class="kw">let </span>e = one.exp();

<span class="comment">// ln(e) - 1 == 0
</span><span class="kw">let </span>abs_difference = (e.ln() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+one+=+1.0f32;%0A++++//+e%5E1%0A++++let+e+=+one.exp();%0A++++%0A++++//+ln(e)+-+1+==+0%0A++++let+abs_difference+=+(e.ln()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div>
<p>Non-positive values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.ln(), f32::NEG_INFINITY);
<span class="macro">assert!</span>((-<span class="number">42_f32</span>).ln().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(0_f32.ln(),+f32::NEG_INFINITY);%0A++++assert!((-42_f32).ln().is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.log" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#508-510">Source</a></span><h4 class="code-header">pub fn <a href="#method.log" class="fn">log</a>(self, base: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the logarithm of the number with respect to an arbitrary base.</p>
<p>This returns NaN when the number is negative, and negative infinity when number is zero.</p>
<p>The result might not be correctly rounded owing to implementation details;
<code>self.log2()</code> can produce more accurate results for base 2, and
<code>self.log10()</code> can produce more accurate results for base 10.</p>
<h5 id="unspecified-precision-5"><a class="doc-anchor" href="#unspecified-precision-5">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>five = <span class="number">5.0f32</span>;

<span class="comment">// log5(5) - 1 == 0
</span><span class="kw">let </span>abs_difference = (five.log(<span class="number">5.0</span>) - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+five+=+5.0f32;%0A++++%0A++++//+log5(5)+-+1+==+0%0A++++let+abs_difference+=+(five.log(5.0)+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div>
<p>Non-positive values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.log(<span class="number">10.0</span>), f32::NEG_INFINITY);
<span class="macro">assert!</span>((-<span class="number">42_f32</span>).log(<span class="number">10.0</span>).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(0_f32.log(10.0),+f32::NEG_INFINITY);%0A++++assert!((-42_f32).log(10.0).is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.log2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#541-543">Source</a></span><h4 class="code-header">pub fn <a href="#method.log2" class="fn">log2</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the base 2 logarithm of the number.</p>
<p>This returns NaN when the number is negative, and negative infinity when number is zero.</p>
<h5 id="unspecified-precision-6"><a class="doc-anchor" href="#unspecified-precision-6">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>two = <span class="number">2.0f32</span>;

<span class="comment">// log2(2) - 1 == 0
</span><span class="kw">let </span>abs_difference = (two.log2() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+two+=+2.0f32;%0A++++%0A++++//+log2(2)+-+1+==+0%0A++++let+abs_difference+=+(two.log2()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div>
<p>Non-positive values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.log2(), f32::NEG_INFINITY);
<span class="macro">assert!</span>((-<span class="number">42_f32</span>).log2().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(0_f32.log2(),+f32::NEG_INFINITY);%0A++++assert!((-42_f32).log2().is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.log10" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#574-576">Source</a></span><h4 class="code-header">pub fn <a href="#method.log10" class="fn">log10</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the base 10 logarithm of the number.</p>
<p>This returns NaN when the number is negative, and negative infinity when number is zero.</p>
<h5 id="unspecified-precision-7"><a class="doc-anchor" href="#unspecified-precision-7">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ten = <span class="number">10.0f32</span>;

<span class="comment">// log10(10) - 1 == 0
</span><span class="kw">let </span>abs_difference = (ten.log10() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ten+=+10.0f32;%0A++++%0A++++//+log10(10)+-+1+==+0%0A++++let+abs_difference+=+(ten.log10()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div>
<p>Non-positive values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.log10(), f32::NEG_INFINITY);
<span class="macro">assert!</span>((-<span class="number">42_f32</span>).log10().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(0_f32.log10(),+f32::NEG_INFINITY);%0A++++assert!((-42_f32).log10().is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.abs_sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#616-619">Source</a></span><h4 class="code-header">pub fn <a href="#method.abs_sub" class="fn">abs_sub</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.10.0: you probably meant <code>(self - other).abs()</code>: this operation is <code>(self - other).max(0.0)</code> except that <code>abs_sub</code> also propagates NaNs (also known as <code>fdimf</code> in C). If you truly need the positive difference, consider using that expression or the C function <code>fdimf</code>, depending on how you wish to handle NaN (please consider filing an issue describing your use-case too).</span></div></span></summary><div class="docblock"><p>The positive difference of two numbers.</p>
<ul>
<li>If <code>self &lt;= other</code>: <code>0.0</code></li>
<li>Else: <code>self - other</code></li>
</ul>
<h5 id="unspecified-precision-8"><a class="doc-anchor" href="#unspecified-precision-8">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>fdimf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">3.0f32</span>;
<span class="kw">let </span>y = -<span class="number">3.0f32</span>;

<span class="kw">let </span>abs_difference_x = (x.abs_sub(<span class="number">1.0</span>) - <span class="number">2.0</span>).abs();
<span class="kw">let </span>abs_difference_y = (y.abs_sub(<span class="number">1.0</span>) - <span class="number">0.0</span>).abs();

<span class="macro">assert!</span>(abs_difference_x &lt;= <span class="number">1e-6</span>);
<span class="macro">assert!</span>(abs_difference_y &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.0f32;%0A++++let+y+=+-3.0f32;%0A++++%0A++++let+abs_difference_x+=+(x.abs_sub(1.0)+-+2.0).abs();%0A++++let+abs_difference_y+=+(y.abs_sub(1.0)+-+0.0).abs();%0A++++%0A++++assert!(abs_difference_x+%3C=+1e-6);%0A++++assert!(abs_difference_y+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cbrt" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#644-646">Source</a></span><h4 class="code-header">pub fn <a href="#method.cbrt" class="fn">cbrt</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the cube root of a number.</p>
<h5 id="unspecified-precision-9"><a class="doc-anchor" href="#unspecified-precision-9">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>cbrtf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">8.0f32</span>;

<span class="comment">// x^(1/3) - 2 == 0
</span><span class="kw">let </span>abs_difference = (x.cbrt() - <span class="number">2.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+8.0f32;%0A++++%0A++++//+x%5E(1/3)+-+2+==+0%0A++++let+abs_difference+=+(x.cbrt()+-+2.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.hypot" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#675-677">Source</a></span><h4 class="code-header">pub fn <a href="#method.hypot" class="fn">hypot</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Compute the distance between the origin and a point (<code>x</code>, <code>y</code>) on the
Euclidean plane. Equivalently, compute the length of the hypotenuse of a
right-angle triangle with other sides having length <code>x.abs()</code> and
<code>y.abs()</code>.</p>
<h5 id="unspecified-precision-10"><a class="doc-anchor" href="#unspecified-precision-10">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>hypotf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">2.0f32</span>;
<span class="kw">let </span>y = <span class="number">3.0f32</span>;

<span class="comment">// sqrt(x^2 + y^2)
</span><span class="kw">let </span>abs_difference = (x.hypot(y) - (x.powi(<span class="number">2</span>) + y.powi(<span class="number">2</span>)).sqrt()).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0f32;%0A++++let+y+=+3.0f32;%0A++++%0A++++//+sqrt(x%5E2+%2B+y%5E2)%0A++++let+abs_difference+=+(x.hypot(y)+-+(x.powi(2)+%2B+y.powi(2)).sqrt()).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.sin" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#699-701">Source</a></span><h4 class="code-header">pub fn <a href="#method.sin" class="fn">sin</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the sine of a number (in radians).</p>
<h5 id="unspecified-precision-11"><a class="doc-anchor" href="#unspecified-precision-11">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = std::f32::consts::FRAC_PI_2;

<span class="kw">let </span>abs_difference = (x.sin() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_2;%0A++++%0A++++let+abs_difference+=+(x.sin()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cos" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#723-725">Source</a></span><h4 class="code-header">pub fn <a href="#method.cos" class="fn">cos</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the cosine of a number (in radians).</p>
<h5 id="unspecified-precision-12"><a class="doc-anchor" href="#unspecified-precision-12">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">2.0 </span>* std::f32::consts::PI;

<span class="kw">let </span>abs_difference = (x.cos() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0+*+std::f32::consts::PI;%0A++++%0A++++let+abs_difference+=+(x.cos()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.tan" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#748-750">Source</a></span><h4 class="code-header">pub fn <a href="#method.tan" class="fn">tan</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the tangent of a number (in radians).</p>
<h5 id="unspecified-precision-13"><a class="doc-anchor" href="#unspecified-precision-13">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>tanf</code> from libc on Unix and
Windows. Note that this might change in the future.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = std::f32::consts::FRAC_PI_4;
<span class="kw">let </span>abs_difference = (x.tan() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_4;%0A++++let+abs_difference+=+(x.tan()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.asin" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#778-780">Source</a></span><h4 class="code-header">pub fn <a href="#method.asin" class="fn">asin</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the arcsine of a number. Return value is in radians in
the range [-pi/2, pi/2] or NaN if the number is outside the range
[-1, 1].</p>
<h5 id="unspecified-precision-14"><a class="doc-anchor" href="#unspecified-precision-14">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>asinf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = std::f32::consts::FRAC_PI_4;

<span class="comment">// asin(sin(pi/2))
</span><span class="kw">let </span>abs_difference = (f.sin().asin() - f).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+std::f32::consts::FRAC_PI_4;%0A++++%0A++++//+asin(sin(pi/2))%0A++++let+abs_difference+=+(f.sin().asin()+-+f).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.acos" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#808-810">Source</a></span><h4 class="code-header">pub fn <a href="#method.acos" class="fn">acos</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the arccosine of a number. Return value is in radians in
the range [0, pi] or NaN if the number is outside the range
[-1, 1].</p>
<h5 id="unspecified-precision-15"><a class="doc-anchor" href="#unspecified-precision-15">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>acosf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = std::f32::consts::FRAC_PI_4;

<span class="comment">// acos(cos(pi/4))
</span><span class="kw">let </span>abs_difference = (f.cos().acos() - std::f32::consts::FRAC_PI_4).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+std::f32::consts::FRAC_PI_4;%0A++++%0A++++//+acos(cos(pi/4))%0A++++let+abs_difference+=+(f.cos().acos()+-+std::f32::consts::FRAC_PI_4).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.atan" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#837-839">Source</a></span><h4 class="code-header">pub fn <a href="#method.atan" class="fn">atan</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the arctangent of a number. Return value is in radians in the
range [-pi/2, pi/2];</p>
<h5 id="unspecified-precision-16"><a class="doc-anchor" href="#unspecified-precision-16">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>atanf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">1.0f32</span>;

<span class="comment">// atan(tan(1))
</span><span class="kw">let </span>abs_difference = (f.tan().atan() - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+1.0f32;%0A++++%0A++++//+atan(tan(1))%0A++++let+abs_difference+=+(f.tan().atan()+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.atan2" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#880-882">Source</a></span><h4 class="code-header">pub fn <a href="#method.atan2" class="fn">atan2</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the four quadrant arctangent of <code>self</code> (<code>y</code>) and <code>other</code> (<code>x</code>) in radians.</p>
<div><table><thead><tr><th><code>x</code></th><th><code>y</code></th><th>Piecewise Definition</th><th>Range</th></tr></thead><tbody>
<tr><td><code>&gt;= +0</code></td><td><code>&gt;= +0</code></td><td><code>arctan(y/x)</code></td><td><code>[+0, +pi/2]</code></td></tr>
<tr><td><code>&gt;= +0</code></td><td><code>&lt;= -0</code></td><td><code>arctan(y/x)</code></td><td><code>[-pi/2, -0]</code></td></tr>
<tr><td><code>&lt;= -0</code></td><td><code>&gt;= +0</code></td><td><code>arctan(y/x) + pi</code></td><td><code>[+pi/2, +pi]</code></td></tr>
<tr><td><code>&lt;= -0</code></td><td><code>&lt;= -0</code></td><td><code>arctan(y/x) - pi</code></td><td><code>[-pi, -pi/2]</code></td></tr>
</tbody></table>
</div><h5 id="unspecified-precision-17"><a class="doc-anchor" href="#unspecified-precision-17">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>atan2f</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Positive angles measured counter-clockwise
// from positive x axis
// -pi/4 radians (45 deg clockwise)
</span><span class="kw">let </span>x1 = <span class="number">3.0f32</span>;
<span class="kw">let </span>y1 = -<span class="number">3.0f32</span>;

<span class="comment">// 3pi/4 radians (135 deg counter-clockwise)
</span><span class="kw">let </span>x2 = -<span class="number">3.0f32</span>;
<span class="kw">let </span>y2 = <span class="number">3.0f32</span>;

<span class="kw">let </span>abs_difference_1 = (y1.atan2(x1) - (-std::f32::consts::FRAC_PI_4)).abs();
<span class="kw">let </span>abs_difference_2 = (y2.atan2(x2) - (<span class="number">3.0 </span>* std::f32::consts::FRAC_PI_4)).abs();

<span class="macro">assert!</span>(abs_difference_1 &lt;= <span class="number">1e-5</span>);
<span class="macro">assert!</span>(abs_difference_2 &lt;= <span class="number">1e-5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+Positive+angles+measured+counter-clockwise%0A++++//+from+positive+x+axis%0A++++//+-pi/4+radians+(45+deg+clockwise)%0A++++let+x1+=+3.0f32;%0A++++let+y1+=+-3.0f32;%0A++++%0A++++//+3pi/4+radians+(135+deg+counter-clockwise)%0A++++let+x2+=+-3.0f32;%0A++++let+y2+=+3.0f32;%0A++++%0A++++let+abs_difference_1+=+(y1.atan2(x1)+-+(-std::f32::consts::FRAC_PI_4)).abs();%0A++++let+abs_difference_2+=+(y2.atan2(x2)+-+(3.0+*+std::f32::consts::FRAC_PI_4)).abs();%0A++++%0A++++assert!(abs_difference_1+%3C=+1e-5);%0A++++assert!(abs_difference_2+%3C=+1e-5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.sin_cos" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#910-912">Source</a></span><h4 class="code-header">pub fn <a href="#method.sin_cos" class="fn">sin_cos</a>(self) -&gt; (<a class="primitive" href="primitive.f32.html">f32</a>, <a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class="docblock"><p>Simultaneously computes the sine and cosine of the number, <code>x</code>. Returns
<code>(sin(x), cos(x))</code>.</p>
<h5 id="unspecified-precision-18"><a class="doc-anchor" href="#unspecified-precision-18">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>(f32::sin(x), f32::cos(x))</code>. Note that this might change in the future.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = std::f32::consts::FRAC_PI_4;
<span class="kw">let </span>f = x.sin_cos();

<span class="kw">let </span>abs_difference_0 = (f.<span class="number">0 </span>- x.sin()).abs();
<span class="kw">let </span>abs_difference_1 = (f.<span class="number">1 </span>- x.cos()).abs();

<span class="macro">assert!</span>(abs_difference_0 &lt;= <span class="number">1e-4</span>);
<span class="macro">assert!</span>(abs_difference_1 &lt;= <span class="number">1e-4</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_4;%0A++++let+f+=+x.sin_cos();%0A++++%0A++++let+abs_difference_0+=+(f.0+-+x.sin()).abs();%0A++++let+abs_difference_1+=+(f.1+-+x.cos()).abs();%0A++++%0A++++assert!(abs_difference_0+%3C=+1e-4);%0A++++assert!(abs_difference_1+%3C=+1e-4);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.exp_m1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#939-941">Source</a></span><h4 class="code-header">pub fn <a href="#method.exp_m1" class="fn">exp_m1</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns <code>e^(self) - 1</code> in a way that is accurate even if the
number is close to zero.</p>
<h5 id="unspecified-precision-19"><a class="doc-anchor" href="#unspecified-precision-19">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>expm1f</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">1e-8_f32</span>;

<span class="comment">// for very small x, e^x is approximately 1 + x + x^2 / 2
</span><span class="kw">let </span>approx = x + x * x / <span class="number">2.0</span>;
<span class="kw">let </span>abs_difference = (x.exp_m1() - approx).abs();

<span class="macro">assert!</span>(abs_difference &lt; <span class="number">1e-10</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1e-8_f32;%0A++++%0A++++//+for+very+small+x,+e%5Ex+is+approximately+1+%2B+x+%2B+x%5E2+/+2%0A++++let+approx+=+x+%2B+x+*+x+/+2.0;%0A++++let+abs_difference+=+(x.exp_m1()+-+approx).abs();%0A++++%0A++++assert!(abs_difference+%3C+1e-10);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ln_1p" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#977-979">Source</a></span><h4 class="code-header">pub fn <a href="#method.ln_1p" class="fn">ln_1p</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns <code>ln(1+n)</code> (natural logarithm) more accurately than if
the operations were performed separately.</p>
<p>This returns NaN when <code>n &lt; -1.0</code>, and negative infinity when <code>n == -1.0</code>.</p>
<h5 id="unspecified-precision-20"><a class="doc-anchor" href="#unspecified-precision-20">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>log1pf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">1e-8_f32</span>;

<span class="comment">// for very small x, ln(1 + x) is approximately x - x^2 / 2
</span><span class="kw">let </span>approx = x - x * x / <span class="number">2.0</span>;
<span class="kw">let </span>abs_difference = (x.ln_1p() - approx).abs();

<span class="macro">assert!</span>(abs_difference &lt; <span class="number">1e-10</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1e-8_f32;%0A++++%0A++++//+for+very+small+x,+ln(1+%2B+x)+is+approximately+x+-+x%5E2+/+2%0A++++let+approx+=+x+-+x+*+x+/+2.0;%0A++++let+abs_difference+=+(x.ln_1p()+-+approx).abs();%0A++++%0A++++assert!(abs_difference+%3C+1e-10);%0A%7D&amp;edition=2024"></a></div>
<p>Out-of-range values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>((-<span class="number">1.0_f32</span>).ln_1p(), f32::NEG_INFINITY);
<span class="macro">assert!</span>((-<span class="number">2.0_f32</span>).ln_1p().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!((-1.0_f32).ln_1p(),+f32::NEG_INFINITY);%0A++++assert!((-2.0_f32).ln_1p().is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.sinh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#1007-1009">Source</a></span><h4 class="code-header">pub fn <a href="#method.sinh" class="fn">sinh</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Hyperbolic sine function.</p>
<h5 id="unspecified-precision-21"><a class="doc-anchor" href="#unspecified-precision-21">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>sinhf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>e = std::f32::consts::E;
<span class="kw">let </span>x = <span class="number">1.0f32</span>;

<span class="kw">let </span>f = x.sinh();
<span class="comment">// Solving sinh() at 1 gives `(e^2-1)/(2e)`
</span><span class="kw">let </span>g = ((e * e) - <span class="number">1.0</span>) / (<span class="number">2.0 </span>* e);
<span class="kw">let </span>abs_difference = (f - g).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++%0A++++let+f+=+x.sinh();%0A++++//+Solving+sinh()+at+1+gives+%60(e%5E2-1)/(2e)%60%0A++++let+g+=+((e+*+e)+-+1.0)+/+(2.0+*+e);%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cosh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#1037-1039">Source</a></span><h4 class="code-header">pub fn <a href="#method.cosh" class="fn">cosh</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Hyperbolic cosine function.</p>
<h5 id="unspecified-precision-22"><a class="doc-anchor" href="#unspecified-precision-22">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>coshf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>e = std::f32::consts::E;
<span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="kw">let </span>f = x.cosh();
<span class="comment">// Solving cosh() at 1 gives this result
</span><span class="kw">let </span>g = ((e * e) + <span class="number">1.0</span>) / (<span class="number">2.0 </span>* e);
<span class="kw">let </span>abs_difference = (f - g).abs();

<span class="comment">// Same result
</span><span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.cosh();%0A++++//+Solving+cosh()+at+1+gives+this+result%0A++++let+g+=+((e+*+e)+%2B+1.0)+/+(2.0+*+e);%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++//+Same+result%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.tanh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#1067-1069">Source</a></span><h4 class="code-header">pub fn <a href="#method.tanh" class="fn">tanh</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Hyperbolic tangent function.</p>
<h5 id="unspecified-precision-23"><a class="doc-anchor" href="#unspecified-precision-23">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>tanhf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>e = std::f32::consts::E;
<span class="kw">let </span>x = <span class="number">1.0f32</span>;

<span class="kw">let </span>f = x.tanh();
<span class="comment">// Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`
</span><span class="kw">let </span>g = (<span class="number">1.0 </span>- e.powi(-<span class="number">2</span>)) / (<span class="number">1.0 </span>+ e.powi(-<span class="number">2</span>));
<span class="kw">let </span>abs_difference = (f - g).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+e+=+std::f32::consts::E;%0A++++let+x+=+1.0f32;%0A++++%0A++++let+f+=+x.tanh();%0A++++//+Solving+tanh()+at+1+gives+%60(1+-+e%5E(-2))/(1+%2B+e%5E(-2))%60%0A++++let+g+=+(1.0+-+e.powi(-2))+/+(1.0+%2B+e.powi(-2));%0A++++let+abs_difference+=+(f+-+g).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.asinh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#1093-1097">Source</a></span><h4 class="code-header">pub fn <a href="#method.asinh" class="fn">asinh</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Inverse hyperbolic sine function.</p>
<h5 id="unspecified-precision-24"><a class="doc-anchor" href="#unspecified-precision-24">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="kw">let </span>f = x.sinh().asinh();

<span class="kw">let </span>abs_difference = (f - x).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.sinh().asinh();%0A++++%0A++++let+abs_difference+=+(f+-+x).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.acosh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#1121-1127">Source</a></span><h4 class="code-header">pub fn <a href="#method.acosh" class="fn">acosh</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Inverse hyperbolic cosine function.</p>
<h5 id="unspecified-precision-25"><a class="doc-anchor" href="#unspecified-precision-25">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="kw">let </span>f = x.cosh().acosh();

<span class="kw">let </span>abs_difference = (f - x).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+f+=+x.cosh().acosh();%0A++++%0A++++let+abs_difference+=+(f+-+x).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.atanh" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/std/num/f32.rs.html#1151-1153">Source</a></span><h4 class="code-header">pub fn <a href="#method.atanh" class="fn">atanh</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Inverse hyperbolic tangent function.</p>
<h5 id="unspecified-precision-26"><a class="doc-anchor" href="#unspecified-precision-26">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = std::f32::consts::FRAC_PI_6;
<span class="kw">let </span>f = x.tanh().atanh();

<span class="kw">let </span>abs_difference = (f - x).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+std::f32::consts::FRAC_PI_6;%0A++++let+f+=+x.tanh().atanh();%0A++++%0A++++let+abs_difference+=+(f+-+x).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.gamma" class="method"><a class="src rightside" href="../src/std/num/f32.rs.html#1178-1180">Source</a><h4 class="code-header">pub fn <a href="#method.gamma" class="fn">gamma</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_gamma</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/99842">#99842</a>)</span></div></span></summary><div class="docblock"><p>Gamma function.</p>
<h5 id="unspecified-precision-27"><a class="doc-anchor" href="#unspecified-precision-27">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>tgammaf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(float_gamma)]
</span><span class="kw">let </span>x = <span class="number">5.0f32</span>;

<span class="kw">let </span>abs_difference = (x.gamma() - <span class="number">24.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_gamma)%5D%0A%0Afn+main()+%7B%0A++++let+x+=+5.0f32;%0A++++%0A++++let+abs_difference+=+(x.gamma()+-+24.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-5);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ln_gamma" class="method"><a class="src rightside" href="../src/std/num/f32.rs.html#1207-1211">Source</a><h4 class="code-header">pub fn <a href="#method.ln_gamma" class="fn">ln_gamma</a>(self) -&gt; (<a class="primitive" href="primitive.f32.html">f32</a>, <a class="primitive" href="primitive.i32.html">i32</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_gamma</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/99842">#99842</a>)</span></div></span></summary><div class="docblock"><p>Natural logarithm of the absolute value of the gamma function</p>
<p>The integer part of the tuple indicates the sign of the gamma function.</p>
<h5 id="unspecified-precision-28"><a class="doc-anchor" href="#unspecified-precision-28">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform, Rust version, and
can even differ within the same execution from one invocation to the next.
This function currently corresponds to the <code>lgamma_r</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(float_gamma)]
</span><span class="kw">let </span>x = <span class="number">2.0f32</span>;

<span class="kw">let </span>abs_difference = (x.ln_gamma().<span class="number">0 </span>- <span class="number">0.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_gamma)%5D%0A%0Afn+main()+%7B%0A++++let+x+=+2.0f32;%0A++++%0A++++let+abs_difference+=+(x.ln_gamma().0+-+0.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.erf" class="method"><a class="src rightside" href="../src/std/num/f32.rs.html#1244-1246">Source</a><h4 class="code-header">pub fn <a href="#method.erf" class="fn">erf</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_erf</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136321">#136321</a>)</span></div></span></summary><div class="docblock"><p>Error function.</p>
<h5 id="unspecified-precision-29"><a class="doc-anchor" href="#unspecified-precision-29">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform,
Rust version, and can even differ within the same execution from one invocation to the next.</p>
<p>This function currently corresponds to the <code>erff</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(float_erf)]
</span><span class="doccomment">/// The error function relates what percent of a normal distribution lies
/// within `x` standard deviations (scaled by `1/sqrt(2)`).
</span><span class="kw">fn </span>within_standard_deviations(x: f32) -&gt; f32 {
    (x * std::f32::consts::FRAC_1_SQRT_2).erf() * <span class="number">100.0
</span>}

<span class="comment">// 68% of a normal distribution is within one standard deviation
</span><span class="macro">assert!</span>((within_standard_deviations(<span class="number">1.0</span>) - <span class="number">68.269</span>).abs() &lt; <span class="number">0.01</span>);
<span class="comment">// 95% of a normal distribution is within two standard deviations
</span><span class="macro">assert!</span>((within_standard_deviations(<span class="number">2.0</span>) - <span class="number">95.450</span>).abs() &lt; <span class="number">0.01</span>);
<span class="comment">// 99.7% of a normal distribution is within three standard deviations
</span><span class="macro">assert!</span>((within_standard_deviations(<span class="number">3.0</span>) - <span class="number">99.730</span>).abs() &lt; <span class="number">0.01</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_erf)%5D%0A%0Afn+main()+%7B%0A++++///+The+error+function+relates+what+percent+of+a+normal+distribution+lies%0A++++///+within+%60x%60+standard+deviations+(scaled+by+%601/sqrt(2)%60).%0A++++fn+within_standard_deviations(x:+f32)+-%3E+f32+%7B%0A++++++++(x+*+std::f32::consts::FRAC_1_SQRT_2).erf()+*+100.0%0A++++%7D%0A++++%0A++++//+68%25+of+a+normal+distribution+is+within+one+standard+deviation%0A++++assert!((within_standard_deviations(1.0)+-+68.269).abs()+%3C+0.01);%0A++++//+95%25+of+a+normal+distribution+is+within+two+standard+deviations%0A++++assert!((within_standard_deviations(2.0)+-+95.450).abs()+%3C+0.01);%0A++++//+99.7%25+of+a+normal+distribution+is+within+three+standard+deviations%0A++++assert!((within_standard_deviations(3.0)+-+99.730).abs()+%3C+0.01);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.erfc" class="method"><a class="src rightside" href="../src/std/num/f32.rs.html#1273-1275">Source</a><h4 class="code-header">pub fn <a href="#method.erfc" class="fn">erfc</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_erf</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136321">#136321</a>)</span></div></span></summary><div class="docblock"><p>Complementary error function.</p>
<h5 id="unspecified-precision-30"><a class="doc-anchor" href="#unspecified-precision-30">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform,
Rust version, and can even differ within the same execution from one invocation to the next.</p>
<p>This function currently corresponds to the <code>erfcf</code> from libc on Unix
and Windows. Note that this might change in the future.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(float_erf)]
</span><span class="kw">let </span>x: f32 = <span class="number">0.123</span>;

<span class="kw">let </span>one = x.erf() + x.erfc();
<span class="kw">let </span>abs_difference = (one - <span class="number">1.0</span>).abs();

<span class="macro">assert!</span>(abs_difference &lt;= <span class="number">1e-6</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_erf)%5D%0A%0Afn+main()+%7B%0A++++let+x:+f32+=+0.123;%0A++++%0A++++let+one+=+x.erf()+%2B+x.erfc();%0A++++let+abs_difference+=+(one+-+1.0).abs();%0A++++%0A++++assert!(abs_difference+%3C=+1e-6);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-f32-1" class="impl"><a class="src rightside" href="../src/core/num/f32.rs.html#388">Source</a><a href="#impl-f32-1" class="anchor">§</a><h3 class="code-header">impl <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.RADIX" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#391">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.RADIX" class="constant">RADIX</a>: <a class="primitive" href="primitive.u32.html">u32</a> = 2</h4></section></summary><div class="docblock"><p>The radix or base of the internal representation of <code>f32</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MANTISSA_DIGITS" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#398">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MANTISSA_DIGITS" class="constant">MANTISSA_DIGITS</a>: <a class="primitive" href="primitive.u32.html">u32</a> = 24</h4></section></summary><div class="docblock"><p>Number of significant digits in base 2.</p>
<p>Note that the size of the mantissa in the bitwise representation is one
smaller than this since the leading 1 is not stored explicitly.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.DIGITS" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#409">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.DIGITS" class="constant">DIGITS</a>: <a class="primitive" href="primitive.u32.html">u32</a> = 6</h4></section></summary><div class="docblock"><p>Approximate number of significant digits in base 10.</p>
<p>This is the maximum <i>x</i> such that any decimal number with <i>x</i>
significant digits can be converted to <code>f32</code> and back without loss.</p>
<p>Equal to floor(log<sub>10</sub> 2<sup><a href="primitive.f32.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f32::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a> − 1</sup>).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.EPSILON" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#421">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.EPSILON" class="constant">EPSILON</a>: <a class="primitive" href="primitive.f32.html">f32</a> = 1.19209290e-07_f32</h4></section></summary><div class="docblock"><p><a href="https://en.wikipedia.org/wiki/Machine_epsilon">Machine epsilon</a> value for <code>f32</code>.</p>
<p>This is the difference between <code>1.0</code> and the next larger representable number.</p>
<p>Equal to 2<sup>1 − <a href="primitive.f32.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f32::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#429">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: <a class="primitive" href="primitive.f32.html">f32</a> = -3.40282347e+38_f32</h4></section></summary><div class="docblock"><p>Smallest finite <code>f32</code> value.</p>
<p>Equal to −<a href="primitive.f32.html#associatedconstant.MAX" title="associated constant f32::MAX"><code>MAX</code></a>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN_POSITIVE" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#436">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MIN_POSITIVE" class="constant">MIN_POSITIVE</a>: <a class="primitive" href="primitive.f32.html">f32</a> = 1.17549435e-38_f32</h4></section></summary><div class="docblock"><p>Smallest positive normal <code>f32</code> value.</p>
<p>Equal to 2<sup><a href="primitive.f32.html#associatedconstant.MIN_EXP" title="associated constant f32::MIN_EXP"><code>MIN_EXP</code></a> − 1</sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#445">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: <a class="primitive" href="primitive.f32.html">f32</a> = 3.40282347e+38_f32</h4></section></summary><div class="docblock"><p>Largest finite <code>f32</code> value.</p>
<p>Equal to
(1 − 2<sup>−<a href="primitive.f32.html#associatedconstant.MANTISSA_DIGITS" title="associated constant f32::MANTISSA_DIGITS"><code>MANTISSA_DIGITS</code></a></sup>) 2<sup><a href="primitive.f32.html#associatedconstant.MAX_EXP" title="associated constant f32::MAX_EXP"><code>MAX_EXP</code></a></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#455">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MIN_EXP" class="constant">MIN_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = -125</h4></section></summary><div class="docblock"><p>One greater than the minimum possible <em>normal</em> power of 2 exponent
for a significand bounded by 1 ≤ x &lt; 2 (i.e. the IEEE definition).</p>
<p>This corresponds to the exact minimum possible <em>normal</em> power of 2 exponent
for a significand bounded by 0.5 ≤ x &lt; 1 (i.e. the C definition).
In other words, all normal numbers representable by this type are
greater than or equal to 0.5 × 2<sup><i>MIN_EXP</i></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#464">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MAX_EXP" class="constant">MAX_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = 128</h4></section></summary><div class="docblock"><p>One greater than the maximum possible power of 2 exponent
for a significand bounded by 1 ≤ x &lt; 2 (i.e. the IEEE definition).</p>
<p>This corresponds to the exact maximum possible power of 2 exponent
for a significand bounded by 0.5 ≤ x &lt; 1 (i.e. the C definition).
In other words, all numbers representable by this type are
strictly less than 2<sup><i>MAX_EXP</i></sup>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MIN_10_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#472">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MIN_10_EXP" class="constant">MIN_10_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = -37</h4></section></summary><div class="docblock"><p>Minimum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p>
<p>Equal to ceil(log<sub>10</sub> <a href="primitive.f32.html#associatedconstant.MIN_POSITIVE" title="associated constant f32::MIN_POSITIVE"><code>MIN_POSITIVE</code></a>).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX_10_EXP" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#479">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.MAX_10_EXP" class="constant">MAX_10_EXP</a>: <a class="primitive" href="primitive.i32.html">i32</a> = 38</h4></section></summary><div class="docblock"><p>Maximum <i>x</i> for which 10<sup><i>x</i></sup> is normal.</p>
<p>Equal to floor(log<sub>10</sub> <a href="primitive.f32.html#associatedconstant.MAX" title="associated constant f32::MAX"><code>MAX</code></a>).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.NAN" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#496">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.NAN" class="constant">NAN</a>: <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Not a Number (NaN).</p>
<p>Note that IEEE 754 doesn’t define just a single NaN value; a plethora of bit patterns are
considered to be NaN. Furthermore, the standard makes a difference between a “signaling” and
a “quiet” NaN, and allows inspecting its “payload” (the unspecified bits in the bit pattern)
and its sign. See the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification of NaN bit patterns</a> for more
info.</p>
<p>This constant is guaranteed to be a quiet NaN (on targets that follow the Rust assumptions
that the quiet/signaling bit being set to 1 indicates a quiet NaN). Beyond that, nothing is
guaranteed about the specific bit pattern chosen here: both payload and sign are arbitrary.
The concrete bit pattern may change across Rust versions and target platforms.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.INFINITY" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#499">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.INFINITY" class="constant">INFINITY</a>: <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Infinity (∞).</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.NEG_INFINITY" class="associatedconstant"><span class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> · <a class="src" href="../src/core/num/f32.rs.html#502">Source</a></span><h4 class="code-header">pub const <a href="#associatedconstant.NEG_INFINITY" class="constant">NEG_INFINITY</a>: <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Negative infinity (−∞).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_nan" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.83.0">1.0.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#533">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_nan" class="fn">is_nan</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if this value is NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nan = f32::NAN;
<span class="kw">let </span>f = <span class="number">7.0_f32</span>;

<span class="macro">assert!</span>(nan.is_nan());
<span class="macro">assert!</span>(!f.is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+nan+=+f32::NAN;%0A++++let+f+=+7.0_f32;%0A++++%0A++++assert!(nan.is_nan());%0A++++assert!(!f.is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_infinite" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.83.0">1.0.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#556">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_infinite" class="fn">is_infinite</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if this value is positive infinity or negative infinity, and
<code>false</code> otherwise.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">7.0f32</span>;
<span class="kw">let </span>inf = f32::INFINITY;
<span class="kw">let </span>neg_inf = f32::NEG_INFINITY;
<span class="kw">let </span>nan = f32::NAN;

<span class="macro">assert!</span>(!f.is_infinite());
<span class="macro">assert!</span>(!nan.is_infinite());

<span class="macro">assert!</span>(inf.is_infinite());
<span class="macro">assert!</span>(neg_inf.is_infinite());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+inf+=+f32::INFINITY;%0A++++let+neg_inf+=+f32::NEG_INFINITY;%0A++++let+nan+=+f32::NAN;%0A++++%0A++++assert!(!f.is_infinite());%0A++++assert!(!nan.is_infinite());%0A++++%0A++++assert!(inf.is_infinite());%0A++++assert!(neg_inf.is_infinite());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_finite" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.83.0">1.0.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#581">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_finite" class="fn">is_finite</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if this number is neither infinite nor NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">7.0f32</span>;
<span class="kw">let </span>inf = f32::INFINITY;
<span class="kw">let </span>neg_inf = f32::NEG_INFINITY;
<span class="kw">let </span>nan = f32::NAN;

<span class="macro">assert!</span>(f.is_finite());

<span class="macro">assert!</span>(!nan.is_finite());
<span class="macro">assert!</span>(!inf.is_finite());
<span class="macro">assert!</span>(!neg_inf.is_finite());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+inf+=+f32::INFINITY;%0A++++let+neg_inf+=+f32::NEG_INFINITY;%0A++++let+nan+=+f32::NAN;%0A++++%0A++++assert!(f.is_finite());%0A++++%0A++++assert!(!nan.is_finite());%0A++++assert!(!inf.is_finite());%0A++++assert!(!neg_inf.is_finite());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_subnormal" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.53.0, const since 1.83.0">1.53.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#609">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_subnormal" class="fn">is_subnormal</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the number is <a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>min = f32::MIN_POSITIVE; <span class="comment">// 1.17549435e-38f32
</span><span class="kw">let </span>max = f32::MAX;
<span class="kw">let </span>lower_than_min = <span class="number">1.0e-40_f32</span>;
<span class="kw">let </span>zero = <span class="number">0.0_f32</span>;

<span class="macro">assert!</span>(!min.is_subnormal());
<span class="macro">assert!</span>(!max.is_subnormal());

<span class="macro">assert!</span>(!zero.is_subnormal());
<span class="macro">assert!</span>(!f32::NAN.is_subnormal());
<span class="macro">assert!</span>(!f32::INFINITY.is_subnormal());
<span class="comment">// Values between `0` and `min` are Subnormal.
</span><span class="macro">assert!</span>(lower_than_min.is_subnormal());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+min+=+f32::MIN_POSITIVE;+//+1.17549435e-38f32%0A++++let+max+=+f32::MAX;%0A++++let+lower_than_min+=+1.0e-40_f32;%0A++++let+zero+=+0.0_f32;%0A++++%0A++++assert!(!min.is_subnormal());%0A++++assert!(!max.is_subnormal());%0A++++%0A++++assert!(!zero.is_subnormal());%0A++++assert!(!f32::NAN.is_subnormal());%0A++++assert!(!f32::INFINITY.is_subnormal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(lower_than_min.is_subnormal());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_normal" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.83.0">1.0.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#636">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_normal" class="fn">is_normal</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the number is neither zero, infinite,
<a href="https://en.wikipedia.org/wiki/Denormal_number">subnormal</a>, or NaN.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>min = f32::MIN_POSITIVE; <span class="comment">// 1.17549435e-38f32
</span><span class="kw">let </span>max = f32::MAX;
<span class="kw">let </span>lower_than_min = <span class="number">1.0e-40_f32</span>;
<span class="kw">let </span>zero = <span class="number">0.0_f32</span>;

<span class="macro">assert!</span>(min.is_normal());
<span class="macro">assert!</span>(max.is_normal());

<span class="macro">assert!</span>(!zero.is_normal());
<span class="macro">assert!</span>(!f32::NAN.is_normal());
<span class="macro">assert!</span>(!f32::INFINITY.is_normal());
<span class="comment">// Values between `0` and `min` are Subnormal.
</span><span class="macro">assert!</span>(!lower_than_min.is_normal());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+min+=+f32::MIN_POSITIVE;+//+1.17549435e-38f32%0A++++let+max+=+f32::MAX;%0A++++let+lower_than_min+=+1.0e-40_f32;%0A++++let+zero+=+0.0_f32;%0A++++%0A++++assert!(min.is_normal());%0A++++assert!(max.is_normal());%0A++++%0A++++assert!(!zero.is_normal());%0A++++assert!(!f32::NAN.is_normal());%0A++++assert!(!f32::INFINITY.is_normal());%0A++++//+Values+between+%600%60+and+%60min%60+are+Subnormal.%0A++++assert!(!lower_than_min.is_normal());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.classify" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.83.0">1.0.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#655">Source</a></span><h4 class="code-header">pub const fn <a href="#method.classify" class="fn">classify</a>(self) -&gt; <a class="enum" href="num/enum.FpCategory.html" title="enum std::num::FpCategory">FpCategory</a></h4></section></summary><div class="docblock"><p>Returns the floating point category of the number. If only one property
is going to be tested, it is generally faster to use the specific
predicate instead.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::num::FpCategory;

<span class="kw">let </span>num = <span class="number">12.4_f32</span>;
<span class="kw">let </span>inf = f32::INFINITY;

<span class="macro">assert_eq!</span>(num.classify(), FpCategory::Normal);
<span class="macro">assert_eq!</span>(inf.classify(), FpCategory::Infinite);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::num::FpCategory;%0A++++%0A++++let+num+=+12.4_f32;%0A++++let+inf+=+f32::INFINITY;%0A++++%0A++++assert_eq!(num.classify(),+FpCategory::Normal);%0A++++assert_eq!(inf.classify(),+FpCategory::Infinite);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_sign_positive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.83.0">1.0.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#692">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_sign_positive" class="fn">is_sign_positive</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, NaNs with
positive sign bit and positive infinity.</p>
<p>Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of
a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are
conserved over arithmetic operations, the result of <code>is_sign_positive</code> on
a NaN might produce an unexpected or non-portable result. See the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification
of NaN bit patterns</a> for more info. Use <code>self.signum() == 1.0</code>
if you need fully portable behavior (will return <code>false</code> for all NaNs).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">7.0_f32</span>;
<span class="kw">let </span>g = -<span class="number">7.0_f32</span>;

<span class="macro">assert!</span>(f.is_sign_positive());
<span class="macro">assert!</span>(!g.is_sign_positive());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0_f32;%0A++++let+g+=+-7.0_f32;%0A++++%0A++++assert!(f.is_sign_positive());%0A++++assert!(!g.is_sign_positive());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_sign_negative" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.83.0">1.0.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#717">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_sign_negative" class="fn">is_sign_negative</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, NaNs with
negative sign bit and negative infinity.</p>
<p>Note that IEEE 754 doesn’t assign any meaning to the sign bit in case of
a NaN, and as Rust doesn’t guarantee that the bit pattern of NaNs are
conserved over arithmetic operations, the result of <code>is_sign_negative</code> on
a NaN might produce an unexpected or non-portable result. See the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification
of NaN bit patterns</a> for more info. Use <code>self.signum() == -1.0</code>
if you need fully portable behavior (will return <code>false</code> for all NaNs).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">7.0f32</span>;
<span class="kw">let </span>g = -<span class="number">7.0f32</span>;

<span class="macro">assert!</span>(!f.is_sign_negative());
<span class="macro">assert!</span>(g.is_sign_negative());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+7.0f32;%0A++++let+g+=+-7.0f32;%0A++++%0A++++assert!(!f.is_sign_negative());%0A++++assert!(g.is_sign_negative());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.next_up" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.86.0, const since 1.86.0">1.86.0 (const: 1.86.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#754">Source</a></span><h4 class="code-header">pub const fn <a href="#method.next_up" class="fn">next_up</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the least number greater than <code>self</code>.</p>
<p>Let <code>TINY</code> be the smallest representable positive <code>f32</code>. Then,</p>
<ul>
<li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li>
<li>if <code>self</code> is <a href="primitive.f32.html#associatedconstant.NEG_INFINITY" title="associated constant f32::NEG_INFINITY"><code>NEG_INFINITY</code></a>, this returns <a href="primitive.f32.html#associatedconstant.MIN" title="associated constant f32::MIN"><code>MIN</code></a>;</li>
<li>if <code>self</code> is <code>-TINY</code>, this returns -0.0;</li>
<li>if <code>self</code> is -0.0 or +0.0, this returns <code>TINY</code>;</li>
<li>if <code>self</code> is <a href="primitive.f32.html#associatedconstant.MAX" title="associated constant f32::MAX"><code>MAX</code></a> or <a href="primitive.f32.html#associatedconstant.INFINITY" title="associated constant f32::INFINITY"><code>INFINITY</code></a>, this returns <a href="primitive.f32.html#associatedconstant.INFINITY" title="associated constant f32::INFINITY"><code>INFINITY</code></a>;</li>
<li>otherwise the unique least value greater than <code>self</code> is returned.</li>
</ul>
<p>The identity <code>x.next_up() == -(-x).next_down()</code> holds for all non-NaN <code>x</code>. When <code>x</code>
is finite <code>x == x.next_up().next_down()</code> also holds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// f32::EPSILON is the difference between 1.0 and the next number up.
</span><span class="macro">assert_eq!</span>(<span class="number">1.0f32</span>.next_up(), <span class="number">1.0 </span>+ f32::EPSILON);
<span class="comment">// But not for most numbers.
</span><span class="macro">assert!</span>(<span class="number">0.1f32</span>.next_up() &lt; <span class="number">0.1 </span>+ f32::EPSILON);
<span class="macro">assert_eq!</span>(<span class="number">16777216f32</span>.next_up(), <span class="number">16777218.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+f32::EPSILON+is+the+difference+between+1.0+and+the+next+number+up.%0A++++assert_eq!(1.0f32.next_up(),+1.0+%2B+f32::EPSILON);%0A++++//+But+not+for+most+numbers.%0A++++assert!(0.1f32.next_up()+%3C+0.1+%2B+f32::EPSILON);%0A++++assert_eq!(16777216f32.next_up(),+16777218.0);%0A%7D&amp;edition=2024"></a></div>
<p>This operation corresponds to IEEE-754 <code>nextUp</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_down" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.86.0, const since 1.86.0">1.86.0 (const: 1.86.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#805">Source</a></span><h4 class="code-header">pub const fn <a href="#method.next_down" class="fn">next_down</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the greatest number less than <code>self</code>.</p>
<p>Let <code>TINY</code> be the smallest representable positive <code>f32</code>. Then,</p>
<ul>
<li>if <code>self.is_nan()</code>, this returns <code>self</code>;</li>
<li>if <code>self</code> is <a href="primitive.f32.html#associatedconstant.INFINITY" title="associated constant f32::INFINITY"><code>INFINITY</code></a>, this returns <a href="primitive.f32.html#associatedconstant.MAX" title="associated constant f32::MAX"><code>MAX</code></a>;</li>
<li>if <code>self</code> is <code>TINY</code>, this returns 0.0;</li>
<li>if <code>self</code> is -0.0 or +0.0, this returns <code>-TINY</code>;</li>
<li>if <code>self</code> is <a href="primitive.f32.html#associatedconstant.MIN" title="associated constant f32::MIN"><code>MIN</code></a> or <a href="primitive.f32.html#associatedconstant.NEG_INFINITY" title="associated constant f32::NEG_INFINITY"><code>NEG_INFINITY</code></a>, this returns <a href="primitive.f32.html#associatedconstant.NEG_INFINITY" title="associated constant f32::NEG_INFINITY"><code>NEG_INFINITY</code></a>;</li>
<li>otherwise the unique greatest value less than <code>self</code> is returned.</li>
</ul>
<p>The identity <code>x.next_down() == -(-x).next_up()</code> holds for all non-NaN <code>x</code>. When <code>x</code>
is finite <code>x == x.next_down().next_up()</code> also holds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="comment">// Clamp value into range [0, 1).
</span><span class="kw">let </span>clamped = x.clamp(<span class="number">0.0</span>, <span class="number">1.0f32</span>.next_down());
<span class="macro">assert!</span>(clamped &lt; <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(clamped.next_up(), <span class="number">1.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++//+Clamp+value+into+range+%5B0,+1).%0A++++let+clamped+=+x.clamp(0.0,+1.0f32.next_down());%0A++++assert!(clamped+%3C+1.0);%0A++++assert_eq!(clamped.next_up(),+1.0);%0A%7D&amp;edition=2024"></a></div>
<p>This operation corresponds to IEEE-754 <code>nextDown</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.recip" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.85.0">1.0.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#837">Source</a></span><h4 class="code-header">pub const fn <a href="#method.recip" class="fn">recip</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Takes the reciprocal (inverse) of a number, <code>1/x</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">2.0_f32</span>;
<span class="kw">let </span>abs_difference = (x.recip() - (<span class="number">1.0 </span>/ x)).abs();

<span class="macro">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+2.0_f32;%0A++++let+abs_difference+=+(x.recip()+-+(1.0+/+x)).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_degrees" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.7.0, const since 1.85.0">1.7.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#862">Source</a></span><h4 class="code-header">pub const fn <a href="#method.to_degrees" class="fn">to_degrees</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Converts radians to degrees.</p>
<h5 id="unspecified-precision-31"><a class="doc-anchor" href="#unspecified-precision-31">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform,
Rust version, and can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>angle = std::f32::consts::PI;

<span class="kw">let </span>abs_difference = (angle.to_degrees() - <span class="number">180.0</span>).abs();
<span class="macro">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+angle+=+std::f32::consts::PI;%0A++++%0A++++let+abs_difference+=+(angle.to_degrees()+-+180.0).abs();%0A++++%23%5Bcfg(any(not(target_arch+=+%22x86%22),+target_feature+=+%22sse2%22))%5D%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_radians" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.7.0, const since 1.85.0">1.7.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#890">Source</a></span><h4 class="code-header">pub const fn <a href="#method.to_radians" class="fn">to_radians</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Converts degrees to radians.</p>
<h5 id="unspecified-precision-32"><a class="doc-anchor" href="#unspecified-precision-32">§</a>Unspecified precision</h5>
<p>The precision of this function is non-deterministic. This means it varies by platform,
Rust version, and can even differ within the same execution from one invocation to the next.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>angle = <span class="number">180.0f32</span>;

<span class="kw">let </span>abs_difference = (angle.to_radians() - std::f32::consts::PI).abs();

<span class="macro">assert!</span>(abs_difference &lt;= f32::EPSILON);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+angle+=+180.0f32;%0A++++%0A++++let+abs_difference+=+(angle.to_radians()+-+std::f32::consts::PI).abs();%0A++++%0A++++assert!(abs_difference+%3C=+f32::EPSILON);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.85.0">1.0.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#921">Source</a></span><h4 class="code-header">pub const fn <a href="#method.max" class="fn">max</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the maximum of the two numbers, ignoring NaN.</p>
<p>If exactly one of the arguments is NaN (quiet or signaling), then the other argument is
returned. If both arguments are NaN, the return value is NaN, with the bit pattern picked
using the usual <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">rules for arithmetic operations</a>. If the inputs
compare equal (such as for the case of <code>+0.0</code> and <code>-0.0</code>), either input may be returned
non-deterministically.</p>
<p>The handling of NaNs follows the IEEE 754-2019 semantics for <code>maximumNumber</code>, treating all
NaNs the same way to ensure the operation is associative. The handling of signed zeros
follows the IEEE 754-2008 semantics for <code>maxNum</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="kw">let </span>y = <span class="number">2.0f32</span>;

<span class="macro">assert_eq!</span>(x.max(y), y);
<span class="macro">assert_eq!</span>(x.max(f32::NAN), x);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.max(y),+y);%0A++++assert_eq!(x.max(f32::NAN),+x);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.85.0">1.0.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#948">Source</a></span><h4 class="code-header">pub const fn <a href="#method.min" class="fn">min</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the minimum of the two numbers, ignoring NaN.</p>
<p>If exactly one of the arguments is NaN (quiet or signaling), then the other argument is
returned. If both arguments are NaN, the return value is NaN, with the bit pattern picked
using the usual <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">rules for arithmetic operations</a>. If the inputs
compare equal (such as for the case of <code>+0.0</code> and <code>-0.0</code>), either input may be returned
non-deterministically.</p>
<p>The handling of NaNs follows the IEEE 754-2019 semantics for <code>minimumNumber</code>, treating all
NaNs the same way to ensure the operation is associative. The handling of signed zeros
follows the IEEE 754-2008 semantics for <code>minNum</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="kw">let </span>y = <span class="number">2.0f32</span>;

<span class="macro">assert_eq!</span>(x.min(y), x);
<span class="macro">assert_eq!</span>(x.min(f32::NAN), x);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.min(y),+x);%0A++++assert_eq!(x.min(f32::NAN),+x);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.maximum" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#975">Source</a><h4 class="code-header">pub const fn <a href="#method.maximum" class="fn">maximum</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_minimum_maximum</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/91079">#91079</a>)</span></div></span></summary><div class="docblock"><p>Returns the maximum of the two numbers, propagating NaN.</p>
<p>If at least one of the arguments is NaN, the return value is NaN, with the bit pattern
picked using the usual <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">rules for arithmetic operations</a>. Furthermore,
<code>-0.0</code> is considered to be less than <code>+0.0</code>, making this function fully deterministic for
non-NaN inputs.</p>
<p>This is in contrast to <a href="primitive.f32.html#method.max" title="method f32::max"><code>f32::max</code></a> which only returns NaN when <em>both</em> arguments are NaN,
and which does not reliably order <code>-0.0</code> and <code>+0.0</code>.</p>
<p>This follows the IEEE 754-2019 semantics for <code>maximum</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(float_minimum_maximum)]
</span><span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="kw">let </span>y = <span class="number">2.0f32</span>;

<span class="macro">assert_eq!</span>(x.maximum(y), y);
<span class="macro">assert!</span>(x.maximum(f32::NAN).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0A%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.maximum(y),+y);%0A++++assert!(x.maximum(f32::NAN).is_nan());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.minimum" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#1002">Source</a><h4 class="code-header">pub const fn <a href="#method.minimum" class="fn">minimum</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_minimum_maximum</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/91079">#91079</a>)</span></div></span></summary><div class="docblock"><p>Returns the minimum of the two numbers, propagating NaN.</p>
<p>If at least one of the arguments is NaN, the return value is NaN, with the bit pattern
picked using the usual <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">rules for arithmetic operations</a>. Furthermore,
<code>-0.0</code> is considered to be less than <code>+0.0</code>, making this function fully deterministic for
non-NaN inputs.</p>
<p>This is in contrast to <a href="primitive.f32.html#method.min" title="method f32::min"><code>f32::min</code></a> which only returns NaN when <em>both</em> arguments are NaN,
and which does not reliably order <code>-0.0</code> and <code>+0.0</code>.</p>
<p>This follows the IEEE 754-2019 semantics for <code>minimum</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(float_minimum_maximum)]
</span><span class="kw">let </span>x = <span class="number">1.0f32</span>;
<span class="kw">let </span>y = <span class="number">2.0f32</span>;

<span class="macro">assert_eq!</span>(x.minimum(y), x);
<span class="macro">assert!</span>(x.minimum(f32::NAN).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(float_minimum_maximum)%5D%0A%0Afn+main()+%7B%0A++++let+x+=+1.0f32;%0A++++let+y+=+2.0f32;%0A++++%0A++++assert_eq!(x.minimum(y),+x);%0A++++assert!(x.minimum(f32::NAN).is_nan());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.midpoint" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.85.0, const since 1.85.0">1.85.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1021">Source</a></span><h4 class="code-header">pub const fn <a href="#method.midpoint" class="fn">midpoint</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Calculates the midpoint (average) between <code>self</code> and <code>rhs</code>.</p>
<p>This returns NaN when <em>either</em> argument is NaN or if a combination of
+inf and -inf is provided as arguments.</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="number">1f32</span>.midpoint(<span class="number">4.0</span>), <span class="number">2.5</span>);
<span class="macro">assert_eq!</span>((-<span class="number">5.5f32</span>).midpoint(<span class="number">8.0</span>), <span class="number">1.25</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(1f32.midpoint(4.0),+2.5);%0A++++assert_eq!((-5.5f32).midpoint(8.0),+1.25);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_int_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span> · <a class="src" href="../src/core/num/f32.rs.html#1079-1081">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.to_int_unchecked" class="fn">to_int_unchecked</a>&lt;Int&gt;(self) -&gt; Int<div class="where">where
    <a class="primitive" href="primitive.f32.html">f32</a>: <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;Int&gt;,</div></h4></section></summary><div class="docblock"><p>Rounds toward zero and converts to any primitive integer type,
assuming that the value is finite and fits in that type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>value = <span class="number">4.6_f32</span>;
<span class="kw">let </span>rounded = <span class="kw">unsafe </span>{ value.to_int_unchecked::&lt;u16&gt;() };
<span class="macro">assert_eq!</span>(rounded, <span class="number">4</span>);

<span class="kw">let </span>value = -<span class="number">128.9_f32</span>;
<span class="kw">let </span>rounded = <span class="kw">unsafe </span>{ value.to_int_unchecked::&lt;i8&gt;() };
<span class="macro">assert_eq!</span>(rounded, i8::MIN);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+4.6_f32;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Cu16%3E()+%7D;%0A++++assert_eq!(rounded,+4);%0A++++%0A++++let+value+=+-128.9_f32;%0A++++let+rounded+=+unsafe+%7B+value.to_int_unchecked::%3Ci8%3E()+%7D;%0A++++assert_eq!(rounded,+i8::MIN);%0A%7D&amp;edition=2024"></a></div><h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>The value must:</p>
<ul>
<li>Not be <code>NaN</code></li>
<li>Not be infinite</li>
<li>Be representable in the return type <code>Int</code>, after truncating off its fractional part</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_bits" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const since 1.83.0">1.20.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1111">Source</a></span><h4 class="code-header">pub const fn <a href="#method.to_bits" class="fn">to_bits</a>(self) -&gt; <a class="primitive" href="primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Raw transmutation to <code>u32</code>.</p>
<p>This is currently identical to <code>transmute::&lt;f32, u32&gt;(self)</code> on all platforms.</p>
<p>See <a href="primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<p>Note that this function is distinct from <code>as</code> casting, which attempts to
preserve the <em>numeric</em> value, and not the bitwise value.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_ne!</span>((<span class="number">1f32</span>).to_bits(), <span class="number">1f32 </span><span class="kw">as </span>u32); <span class="comment">// to_bits() is not casting!
</span><span class="macro">assert_eq!</span>((<span class="number">12.5f32</span>).to_bits(), <span class="number">0x41480000</span>);
</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_ne!((1f32).to_bits(),+1f32+as+u32);+//+to_bits()+is+not+casting!%0A++++assert_eq!((12.5f32).to_bits(),+0x41480000);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_bits" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const since 1.83.0">1.20.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1157">Source</a></span><h4 class="code-header">pub const fn <a href="#method.from_bits" class="fn">from_bits</a>(v: <a class="primitive" href="primitive.u32.html">u32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Raw transmutation from <code>u32</code>.</p>
<p>This is currently identical to <code>transmute::&lt;u32, f32&gt;(v)</code> on all platforms.
It turns out this is incredibly portable, for two reasons:</p>
<ul>
<li>Floats and Ints have the same endianness on all supported platforms.</li>
<li>IEEE 754 very precisely specifies the bit layout of floats.</li>
</ul>
<p>However there is one caveat: prior to the 2008 version of IEEE 754, how
to interpret the NaN signaling bit wasn’t actually specified. Most platforms
(notably x86 and ARM) picked the interpretation that was ultimately
standardized in 2008, but some didn’t (notably MIPS). As a result, all
signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</p>
<p>Rather than trying to preserve signaling-ness cross-platform, this
implementation favors preserving the exact bits. This means that
any payloads encoded in NaNs will be preserved even if the result of
this method is sent over the network from an x86 machine to a MIPS one.</p>
<p>If the results of this method are only manipulated by the same
architecture that produced them, then there is no portability concern.</p>
<p>If the input isn’t NaN, then there is no portability concern.</p>
<p>If you don’t care about signalingness (very likely), then there is no
portability concern.</p>
<p>Note that this function is distinct from <code>as</code> casting, which attempts to
preserve the <em>numeric</em> value, and not the bitwise value.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = f32::from_bits(<span class="number">0x41480000</span>);
<span class="macro">assert_eq!</span>(v, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+f32::from_bits(0x41480000);%0A++++assert_eq!(v,+12.5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_be_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const since 1.83.0">1.40.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1180">Source</a></span><h4 class="code-header">pub const fn <a href="#method.to_be_bytes" class="fn">to_be_bytes</a>(self) -&gt; [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">4</a>]</h4></section></summary><div class="docblock"><p>Returns the memory representation of this floating point number as a byte array in
big-endian (network) byte order.</p>
<p>See <a href="primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="number">12.5f32</span>.to_be_bytes();
<span class="macro">assert_eq!</span>(bytes, [<span class="number">0x41</span>, <span class="number">0x48</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_be_bytes();%0A++++assert_eq!(bytes,+%5B0x41,+0x48,+0x00,+0x00%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_le_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const since 1.83.0">1.40.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1201">Source</a></span><h4 class="code-header">pub const fn <a href="#method.to_le_bytes" class="fn">to_le_bytes</a>(self) -&gt; [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">4</a>]</h4></section></summary><div class="docblock"><p>Returns the memory representation of this floating point number as a byte array in
little-endian byte order.</p>
<p>See <a href="primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="number">12.5f32</span>.to_le_bytes();
<span class="macro">assert_eq!</span>(bytes, [<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x41</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_le_bytes();%0A++++assert_eq!(bytes,+%5B0x00,+0x00,+0x48,+0x41%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_ne_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const since 1.83.0">1.40.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1235">Source</a></span><h4 class="code-header">pub const fn <a href="#method.to_ne_bytes" class="fn">to_ne_bytes</a>(self) -&gt; [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">4</a>]</h4></section></summary><div class="docblock"><p>Returns the memory representation of this floating point number as a byte array in
native byte order.</p>
<p>As the target platform’s native endianness is used, portable code
should use <a href="primitive.f32.html#method.to_be_bytes" title="method f32::to_be_bytes"><code>to_be_bytes</code></a> or <a href="primitive.f32.html#method.to_le_bytes" title="method f32::to_le_bytes"><code>to_le_bytes</code></a>, as appropriate, instead.</p>
<p>See <a href="primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="number">12.5f32</span>.to_ne_bytes();
<span class="macro">assert_eq!</span>(
    bytes,
    <span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
        [<span class="number">0x41</span>, <span class="number">0x48</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]
    } <span class="kw">else </span>{
        [<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x41</span>]
    }
);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+12.5f32.to_ne_bytes();%0A++++assert_eq!(%0A++++++++bytes,%0A++++++++if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++++++%5B0x41,+0x48,+0x00,+0x00%5D%0A++++++++%7D+else+%7B%0A++++++++++++%5B0x00,+0x00,+0x48,+0x41%5D%0A++++++++%7D%0A++++);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_be_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const since 1.83.0">1.40.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1254">Source</a></span><h4 class="code-header">pub const fn <a href="#method.from_be_bytes" class="fn">from_be_bytes</a>(bytes: [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">4</a>]) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Creates a floating point value from its representation as a byte array in big endian.</p>
<p>See <a href="primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>value = f32::from_be_bytes([<span class="number">0x41</span>, <span class="number">0x48</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]);
<span class="macro">assert_eq!</span>(value, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_be_bytes(%5B0x41,+0x48,+0x00,+0x00%5D);%0A++++assert_eq!(value,+12.5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_le_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const since 1.83.0">1.40.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1273">Source</a></span><h4 class="code-header">pub const fn <a href="#method.from_le_bytes" class="fn">from_le_bytes</a>(bytes: [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">4</a>]) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Creates a floating point value from its representation as a byte array in little endian.</p>
<p>See <a href="primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>value = f32::from_le_bytes([<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x41</span>]);
<span class="macro">assert_eq!</span>(value, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_le_bytes(%5B0x00,+0x00,+0x48,+0x41%5D);%0A++++assert_eq!(value,+12.5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_ne_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.40.0, const since 1.83.0">1.40.0 (const: 1.83.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1303">Source</a></span><h4 class="code-header">pub const fn <a href="#method.from_ne_bytes" class="fn">from_ne_bytes</a>(bytes: [<a class="primitive" href="primitive.u8.html">u8</a>; <a class="primitive" href="primitive.array.html">4</a>]) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Creates a floating point value from its representation as a byte array in native endian.</p>
<p>As the target platform’s native endianness is used, portable code
likely wants to use <a href="primitive.f32.html#method.from_be_bytes" title="associated function f32::from_be_bytes"><code>from_be_bytes</code></a> or <a href="primitive.f32.html#method.from_le_bytes" title="associated function f32::from_le_bytes"><code>from_le_bytes</code></a>, as
appropriate instead.</p>
<p>See <a href="primitive.f32.html#method.from_bits" title="associated function f32::from_bits"><code>from_bits</code></a> for some discussion of the
portability of this operation (there are almost no issues).</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>value = f32::from_ne_bytes(<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"big"</span>) {
    [<span class="number">0x41</span>, <span class="number">0x48</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]
} <span class="kw">else </span>{
    [<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x41</span>]
});
<span class="macro">assert_eq!</span>(value, <span class="number">12.5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+value+=+f32::from_ne_bytes(if+cfg!(target_endian+=+%22big%22)+%7B%0A++++++++%5B0x41,+0x48,+0x00,+0x00%5D%0A++++%7D+else+%7B%0A++++++++%5B0x00,+0x00,+0x48,+0x41%5D%0A++++%7D);%0A++++assert_eq!(value,+12.5);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.total_cmp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.62.0, const unstable">1.62.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/num/f32.rs.html#1370">Source</a></span><h4 class="code-header">pub fn <a href="#method.total_cmp" class="fn">total_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4></section></summary><div class="docblock"><p>Returns the ordering between <code>self</code> and <code>other</code>.</p>
<p>Unlike the standard partial comparison between floating point numbers,
this comparison always produces an ordering in accordance to
the <code>totalOrder</code> predicate as defined in the IEEE 754 (2008 revision)
floating point standard. The values are ordered in the following sequence:</p>
<ul>
<li>negative quiet NaN</li>
<li>negative signaling NaN</li>
<li>negative infinity</li>
<li>negative numbers</li>
<li>negative subnormal numbers</li>
<li>negative zero</li>
<li>positive zero</li>
<li>positive subnormal numbers</li>
<li>positive numbers</li>
<li>positive infinity</li>
<li>positive signaling NaN</li>
<li>positive quiet NaN.</li>
</ul>
<p>The ordering established by this function does not always agree with the
<a href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd"><code>PartialOrd</code></a> and <a href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq"><code>PartialEq</code></a> implementations of <code>f32</code>. For example,
they consider negative and positive zero equal, while <code>total_cmp</code>
doesn’t.</p>
<p>The interpretation of the signaling NaN bit follows the definition in
the IEEE 754 standard, which may not match the interpretation by some of
the older, non-conformant (e.g. MIPS) hardware implementations.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>GoodBoy {
    name: String,
    weight: f32,
}

<span class="kw">let </span><span class="kw-2">mut </span>bois = <span class="macro">vec!</span>[
    GoodBoy { name: <span class="string">"Pucci"</span>.to_owned(), weight: <span class="number">0.1 </span>},
    GoodBoy { name: <span class="string">"Woofer"</span>.to_owned(), weight: <span class="number">99.0 </span>},
    GoodBoy { name: <span class="string">"Yapper"</span>.to_owned(), weight: <span class="number">10.0 </span>},
    GoodBoy { name: <span class="string">"Chonk"</span>.to_owned(), weight: f32::INFINITY },
    GoodBoy { name: <span class="string">"Abs. Unit"</span>.to_owned(), weight: f32::NAN },
    GoodBoy { name: <span class="string">"Floaty"</span>.to_owned(), weight: -<span class="number">5.0 </span>},
];

bois.sort_by(|a, b| a.weight.total_cmp(<span class="kw-2">&amp;</span>b.weight));

<span class="comment">// `f32::NAN` could be positive or negative, which will affect the sort order.
</span><span class="kw">if </span>f32::NAN.is_sign_negative() {
    <span class="macro">assert!</span>(bois.into_iter().map(|b| b.weight)
        .zip([f32::NAN, -<span class="number">5.0</span>, <span class="number">0.1</span>, <span class="number">10.0</span>, <span class="number">99.0</span>, f32::INFINITY].iter())
        .all(|(a, b)| a.to_bits() == b.to_bits()))
} <span class="kw">else </span>{
    <span class="macro">assert!</span>(bois.into_iter().map(|b| b.weight)
        .zip([-<span class="number">5.0</span>, <span class="number">0.1</span>, <span class="number">10.0</span>, <span class="number">99.0</span>, f32::INFINITY, f32::NAN].iter())
        .all(|(a, b)| a.to_bits() == b.to_bits()))
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++struct+GoodBoy+%7B%0A++++++++name:+String,%0A++++++++weight:+f32,%0A++++%7D%0A++++%0A++++let+mut+bois+=+vec!%5B%0A++++++++GoodBoy+%7B+name:+%22Pucci%22.to_owned(),+weight:+0.1+%7D,%0A++++++++GoodBoy+%7B+name:+%22Woofer%22.to_owned(),+weight:+99.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Yapper%22.to_owned(),+weight:+10.0+%7D,%0A++++++++GoodBoy+%7B+name:+%22Chonk%22.to_owned(),+weight:+f32::INFINITY+%7D,%0A++++++++GoodBoy+%7B+name:+%22Abs.+Unit%22.to_owned(),+weight:+f32::NAN+%7D,%0A++++++++GoodBoy+%7B+name:+%22Floaty%22.to_owned(),+weight:+-5.0+%7D,%0A++++%5D;%0A++++%0A++++bois.sort_by(%7Ca,+b%7C+a.weight.total_cmp(%26b.weight));%0A++++%0A++++//+%60f32::NAN%60+could+be+positive+or+negative,+which+will+affect+the+sort+order.%0A++++if+f32::NAN.is_sign_negative()+%7B%0A++++++++assert!(bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5Bf32::NAN,+-5.0,+0.1,+10.0,+99.0,+f32::INFINITY%5D.iter())%0A++++++++++++.all(%7C(a,+b)%7C+a.to_bits()+==+b.to_bits()))%0A++++%7D+else+%7B%0A++++++++assert!(bois.into_iter().map(%7Cb%7C+b.weight)%0A++++++++++++.zip(%5B-5.0,+0.1,+10.0,+99.0,+f32::INFINITY,+f32::NAN%5D.iter())%0A++++++++++++.all(%7C(a,+b)%7C+a.to_bits()+==+b.to_bits()))%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0, const since 1.85.0">1.50.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1433">Source</a></span><h4 class="code-header">pub const fn <a href="#method.clamp" class="fn">clamp</a>(self, min: <a class="primitive" href="primitive.f32.html">f32</a>, max: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Restrict a value to a certain interval unless it is NaN.</p>
<p>Returns <code>max</code> if <code>self</code> is greater than <code>max</code>, and <code>min</code> if <code>self</code> is
less than <code>min</code>. Otherwise this returns <code>self</code>.</p>
<p>Note that this function returns NaN if the initial value was NaN as
well. If the result is zero and among the three inputs <code>self</code>, <code>min</code>, and <code>max</code> there are
zeros with different sign, either <code>0.0</code> or <code>-0.0</code> is returned non-deterministically.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if <code>min &gt; max</code>, <code>min</code> is NaN, or <code>max</code> is NaN.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>((-<span class="number">3.0f32</span>).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>) == -<span class="number">2.0</span>);
<span class="macro">assert!</span>((<span class="number">0.0f32</span>).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>) == <span class="number">0.0</span>);
<span class="macro">assert!</span>((<span class="number">2.0f32</span>).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>) == <span class="number">1.0</span>);
<span class="macro">assert!</span>((f32::NAN).clamp(-<span class="number">2.0</span>, <span class="number">1.0</span>).is_nan());

<span class="comment">// These always returns zero, but the sign (which is ignored by `==`) is non-deterministic.
</span><span class="macro">assert!</span>((<span class="number">0.0f32</span>).clamp(-<span class="number">0.0</span>, -<span class="number">0.0</span>) == <span class="number">0.0</span>);
<span class="macro">assert!</span>((<span class="number">1.0f32</span>).clamp(-<span class="number">0.0</span>, <span class="number">0.0</span>) == <span class="number">0.0</span>);
<span class="comment">// This is definitely a negative zero.
</span><span class="macro">assert!</span>((-<span class="number">1.0f32</span>).clamp(-<span class="number">0.0</span>, <span class="number">1.0</span>).is_sign_negative());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!((-3.0f32).clamp(-2.0,+1.0)+==+-2.0);%0A++++assert!((0.0f32).clamp(-2.0,+1.0)+==+0.0);%0A++++assert!((2.0f32).clamp(-2.0,+1.0)+==+1.0);%0A++++assert!((f32::NAN).clamp(-2.0,+1.0).is_nan());%0A++++%0A++++//+These+always+returns+zero,+but+the+sign+(which+is+ignored+by+%60==%60)+is+non-deterministic.%0A++++assert!((0.0f32).clamp(-0.0,+-0.0)+==+0.0);%0A++++assert!((1.0f32).clamp(-0.0,+0.0)+==+0.0);%0A++++//+This+is+definitely+a+negative+zero.%0A++++assert!((-1.0f32).clamp(-0.0,+1.0).is_sign_negative());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp_magnitude" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#1474">Source</a><h4 class="code-header">pub fn <a href="#method.clamp_magnitude" class="fn">clamp_magnitude</a>(self, limit: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clamp_magnitude</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/148519">#148519</a>)</span></div></span></summary><div class="docblock"><p>Clamps this number to a symmetric range centered around zero.</p>
<p>The method clamps the number’s magnitude (absolute value) to be at most <code>limit</code>.</p>
<p>This is functionally equivalent to <code>self.clamp(-limit, limit)</code>, but is more
explicit about the intent.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>Panics if <code>limit</code> is negative or NaN, as this indicates a logic error.</p>
<h5 id="examples-53"><a class="doc-anchor" href="#examples-53">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(clamp_magnitude)]
</span><span class="macro">assert_eq!</span>(<span class="number">5.0f32</span>.clamp_magnitude(<span class="number">3.0</span>), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">5.0f32</span>).clamp_magnitude(<span class="number">3.0</span>), -<span class="number">3.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">2.0f32</span>.clamp_magnitude(<span class="number">3.0</span>), <span class="number">2.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">2.0f32</span>).clamp_magnitude(<span class="number">3.0</span>), -<span class="number">2.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(clamp_magnitude)%5D%0A%0Afn+main()+%7B%0A++++assert_eq!(5.0f32.clamp_magnitude(3.0),+3.0);%0A++++assert_eq!((-5.0f32).clamp_magnitude(3.0),+-3.0);%0A++++assert_eq!(2.0f32.clamp_magnitude(3.0),+2.0);%0A++++assert_eq!((-2.0f32).clamp_magnitude(3.0),+-2.0);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.abs" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.85.0">1.0.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1499">Source</a></span><h4 class="code-header">pub const fn <a href="#method.abs" class="fn">abs</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Computes the absolute value of <code>self</code>.</p>
<p>This function always returns the precise result.</p>
<h5 id="examples-54"><a class="doc-anchor" href="#examples-54">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">3.5_f32</span>;
<span class="kw">let </span>y = -<span class="number">3.5_f32</span>;

<span class="macro">assert_eq!</span>(x.abs(), x);
<span class="macro">assert_eq!</span>(y.abs(), -y);

<span class="macro">assert!</span>(f32::NAN.abs().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+3.5_f32;%0A++++let+y+=+-3.5_f32;%0A++++%0A++++assert_eq!(x.abs(),+x);%0A++++assert_eq!(y.abs(),+-y);%0A++++%0A++++assert!(f32::NAN.abs().is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.signum" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.85.0">1.0.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1523">Source</a></span><h4 class="code-header">pub const fn <a href="#method.signum" class="fn">signum</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns a number that represents the sign of <code>self</code>.</p>
<ul>
<li><code>1.0</code> if the number is positive, <code>+0.0</code> or <code>INFINITY</code></li>
<li><code>-1.0</code> if the number is negative, <code>-0.0</code> or <code>NEG_INFINITY</code></li>
<li>NaN if the number is NaN</li>
</ul>
<h5 id="examples-55"><a class="doc-anchor" href="#examples-55">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">3.5_f32</span>;

<span class="macro">assert_eq!</span>(f.signum(), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f32::NEG_INFINITY.signum(), -<span class="number">1.0</span>);

<span class="macro">assert!</span>(f32::NAN.signum().is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.5_f32;%0A++++%0A++++assert_eq!(f.signum(),+1.0);%0A++++assert_eq!(f32::NEG_INFINITY.signum(),+-1.0);%0A++++%0A++++assert!(f32::NAN.signum().is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.copysign" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.35.0, const since 1.85.0">1.35.0 (const: 1.85.0)</span> · <a class="src" href="../src/core/num/f32.rs.html#1557">Source</a></span><h4 class="code-header">pub const fn <a href="#method.copysign" class="fn">copysign</a>(self, sign: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns a number composed of the magnitude of <code>self</code> and the sign of
<code>sign</code>.</p>
<p>Equal to <code>self</code> if the sign of <code>self</code> and <code>sign</code> are the same, otherwise equal to <code>-self</code>.
If <code>self</code> is a NaN, then a NaN with the same payload as <code>self</code> and the sign bit of <code>sign</code> is
returned.</p>
<p>If <code>sign</code> is a NaN, then this operation will still carry over its sign into the result. Note
that IEEE 754 doesn’t assign any meaning to the sign bit in case of a NaN, and as Rust
doesn’t guarantee that the bit pattern of NaNs are conserved over arithmetic operations, the
result of <code>copysign</code> with <code>sign</code> being a NaN might produce an unexpected or non-portable
result. See the <a href="primitive.f32.html#nan-bit-patterns" title="primitive f32">specification of NaN bit patterns</a> for more
info.</p>
<h5 id="examples-56"><a class="doc-anchor" href="#examples-56">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f = <span class="number">3.5_f32</span>;

<span class="macro">assert_eq!</span>(f.copysign(<span class="number">0.42</span>), <span class="number">3.5_f32</span>);
<span class="macro">assert_eq!</span>(f.copysign(-<span class="number">0.42</span>), -<span class="number">3.5_f32</span>);
<span class="macro">assert_eq!</span>((-f).copysign(<span class="number">0.42</span>), <span class="number">3.5_f32</span>);
<span class="macro">assert_eq!</span>((-f).copysign(-<span class="number">0.42</span>), -<span class="number">3.5_f32</span>);

<span class="macro">assert!</span>(f32::NAN.copysign(<span class="number">1.0</span>).is_nan());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f+=+3.5_f32;%0A++++%0A++++assert_eq!(f.copysign(0.42),+3.5_f32);%0A++++assert_eq!(f.copysign(-0.42),+-3.5_f32);%0A++++assert_eq!((-f).copysign(0.42),+3.5_f32);%0A++++assert_eq!((-f).copysign(-0.42),+-3.5_f32);%0A++++%0A++++assert!(f32::NAN.copysign(1.0).is_nan());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.algebraic_add" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#1568">Source</a><h4 class="code-header">pub const fn <a href="#method.algebraic_add" class="fn">algebraic_add</a>(self, rhs: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_algebraic</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136469">#136469</a>)</span></div></span></summary><div class="docblock"><p>Float addition that allows optimizations based on algebraic rules.</p>
<p>See <a href="primitive.f32.html#algebraic-operators" title="primitive f32">algebraic operators</a> for more info.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.algebraic_sub" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#1579">Source</a><h4 class="code-header">pub const fn <a href="#method.algebraic_sub" class="fn">algebraic_sub</a>(self, rhs: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_algebraic</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136469">#136469</a>)</span></div></span></summary><div class="docblock"><p>Float subtraction that allows optimizations based on algebraic rules.</p>
<p>See <a href="primitive.f32.html#algebraic-operators" title="primitive f32">algebraic operators</a> for more info.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.algebraic_mul" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#1590">Source</a><h4 class="code-header">pub const fn <a href="#method.algebraic_mul" class="fn">algebraic_mul</a>(self, rhs: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_algebraic</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136469">#136469</a>)</span></div></span></summary><div class="docblock"><p>Float multiplication that allows optimizations based on algebraic rules.</p>
<p>See <a href="primitive.f32.html#algebraic-operators" title="primitive f32">algebraic operators</a> for more info.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.algebraic_div" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#1601">Source</a><h4 class="code-header">pub const fn <a href="#method.algebraic_div" class="fn">algebraic_div</a>(self, rhs: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_algebraic</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136469">#136469</a>)</span></div></span></summary><div class="docblock"><p>Float division that allows optimizations based on algebraic rules.</p>
<p>See <a href="primitive.f32.html#algebraic-operators" title="primitive f32">algebraic operators</a> for more info.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.algebraic_rem" class="method"><a class="src rightside" href="../src/core/num/f32.rs.html#1612">Source</a><h4 class="code-header">pub const fn <a href="#method.algebraic_rem" class="fn">algebraic_rem</a>(self, rhs: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>float_algebraic</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/136469">#136469</a>)</span></div></span></summary><div class="docblock"><p>Float remainder that allows optimizations based on algebraic rules.</p>
<p>See <a href="primitive.f32.html#algebraic-operators" title="primitive f32">algebraic operators</a> for more info.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3C%26f32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#114">Source</a></span><a href="#impl-Add%3C%26f32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-13" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#associatedtype.Output-13" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#method.add-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#114">Source</a></span><a href="#impl-Add%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-12" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#associatedtype.Output-12" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3Cf32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#114">Source</a></span><a href="#impl-Add%3Cf32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-11" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#associatedtype.Output-11" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#114">Source</a></span><a href="#impl-Add-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#associatedtype.Output-10" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#114">Source</a><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Add.html#tymethod.add" class="fn">add</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0, const unstable">1.22.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#800">Source</a></span><a href="#impl-AddAssign%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.AddAssign.html" title="trait std::ops::AddAssign">AddAssign</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#800">Source</a><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0, const unstable">1.8.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#800">Source</a></span><a href="#impl-AddAssign-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.AddAssign.html" title="trait std::ops::AddAssign">AddAssign</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#800">Source</a><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/142757" title="Tracking issue for const_clone">unstable</a>)</span> · <a class="src" href="../src/core/clone.rs.html#627-632">Source</a></span><a href="#impl-Clone-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#627-632">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/fmt/float.rs.html#240">Source</a></span><a href="#impl-Debug-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/float.rs.html#240">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143894" title="Tracking issue for const_default">unstable</a>)</span> · <a class="src" href="../src/core/default.rs.html#184">Source</a></span><a href="#impl-Default-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="default/trait.Default.html" title="trait std::default::Default">Default</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../src/core/default.rs.html#184">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Returns the default value of <code>0.0</code></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/fmt/float.rs.html#240">Source</a></span><a href="#impl-Display-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.Display.html" title="trait std::fmt::Display">Display</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/float.rs.html#240">Source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div%3C%26f32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#526">Source</a></span><a href="#impl-Div%3C%26f32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type std::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#method.div-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type std::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#526">Source</a></span><a href="#impl-Div%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type std::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#method.div-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type std::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div%3Cf32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#526">Source</a></span><a href="#impl-Div%3Cf32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type std::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#method.div-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a>&gt;::<a class="associatedtype" href="ops/trait.Div.html#associatedtype.Output" title="type std::ops::Div::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Div-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#526">Source</a></span><a href="#impl-Div-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Div.html" title="trait std::ops::Div">Div</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Div.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>/</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.div" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#526">Source</a><a href="#method.div" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Div.html#tymethod.div" class="fn">div</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>Performs the <code>/</code> operation. <a href="ops/trait.Div.html#tymethod.div">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DivAssign%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0, const unstable">1.22.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#994">Source</a></span><a href="#impl-DivAssign%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.DivAssign.html" title="trait std::ops::DivAssign">DivAssign</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.div_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#994">Source</a><a href="#method.div_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.DivAssign.html#tymethod.div_assign" class="fn">div_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>/=</code> operation. <a href="ops/trait.DivAssign.html#tymethod.div_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DivAssign-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0, const unstable">1.8.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#994">Source</a></span><a href="#impl-DivAssign-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.DivAssign.html" title="trait std::ops::DivAssign">DivAssign</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.div_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#994">Source</a><a href="#method.div_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.DivAssign.html#tymethod.div_assign" class="fn">div_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>/=</code> operation. <a href="ops/trait.DivAssign.html#tymethod.div_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cbool%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.68.0, const unstable">1.68.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> · <a class="src" href="../src/core/convert/num.rs.html#239">Source</a></span><a href="#impl-From%3Cbool%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#239">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Converts a <a href="primitive.bool.html" title="primitive bool"><code>bool</code></a> to <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> losslessly.
The resulting value is positive <code>0.0</code> for <code>false</code> and <code>1.0</code> for <code>true</code> values.</p>
<h5 id="examples-57"><a class="doc-anchor" href="#examples-57">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x: f32 = <span class="bool-val">false</span>.into();
<span class="macro">assert_eq!</span>(x, <span class="number">0.0</span>);
<span class="macro">assert!</span>(x.is_sign_positive());

<span class="kw">let </span>y: f32 = <span class="bool-val">true</span>.into();
<span class="macro">assert_eq!</span>(y, <span class="number">1.0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x:+f32+=+false.into();%0A++++assert_eq!(x,+0.0);%0A++++assert!(x.is_sign_positive());%0A++++%0A++++let+y:+f32+=+true.into();%0A++++assert_eq!(y,+1.0);%0A%7D&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cf32%3E-for-f128" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0, const unstable">1.6.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> · <a class="src" href="../src/core/convert/num.rs.html#193">Source</a></span><a href="#impl-From%3Cf32%3E-for-f128" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f128.html">f128</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#193">Source</a><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f128.html">f128</a></h4></section></summary><div class="docblock"><p>Converts <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> to <a href="primitive.f128.html" title="primitive f128"><code>f128</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cf32%3E-for-f64" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0, const unstable">1.6.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> · <a class="src" href="../src/core/convert/num.rs.html#192">Source</a></span><a href="#impl-From%3Cf32%3E-for-f64" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f64.html">f64</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#192">Source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f64.html">f64</a></h4></section></summary><div class="docblock"><p>Converts <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> to <a href="primitive.f64.html" title="primitive f64"><code>f64</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Ci16%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0, const unstable">1.6.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> · <a class="src" href="../src/core/convert/num.rs.html#166">Source</a></span><a href="#impl-From%3Ci16%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.i16.html">i16</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#166">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.i16.html">i16</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Converts <a href="primitive.i16.html" title="primitive i16"><code>i16</code></a> to <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Ci8%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0, const unstable">1.6.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> · <a class="src" href="../src/core/convert/num.rs.html#163">Source</a></span><a href="#impl-From%3Ci8%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.i8.html">i8</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#163">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.i8.html">i8</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Converts <a href="primitive.i8.html" title="primitive i8"><code>i8</code></a> to <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cu16%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0, const unstable">1.6.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> · <a class="src" href="../src/core/convert/num.rs.html#179">Source</a></span><a href="#impl-From%3Cu16%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.u16.html">u16</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#179">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.u16.html">u16</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Converts <a href="primitive.u16.html" title="primitive u16"><code>u16</code></a> to <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3Cu8%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0, const unstable">1.6.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> · <a class="src" href="../src/core/convert/num.rs.html#176">Source</a></span><a href="#impl-From%3Cu8%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../src/core/convert/num.rs.html#176">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(small: <a class="primitive" href="primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class="docblock"><p>Converts <a href="primitive.u8.html" title="primitive u8"><code>u8</code></a> to <a href="primitive.f32.html" title="primitive f32"><code>f32</code></a> losslessly.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/num/dec2flt/mod.rs.html#179">Source</a></span><a href="#impl-FromStr-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="str/trait.FromStr.html" title="trait std::str::FromStr">FromStr</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../src/core/num/dec2flt/mod.rs.html#179">Source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="str/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(src: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>, <a class="struct" href="num/struct.ParseFloatError.html" title="struct std::num::ParseFloatError">ParseFloatError</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a string in base 10 to a float.
Accepts an optional decimal exponent.</p>
<p>This function accepts strings such as</p>
<ul>
<li>‘3.14’</li>
<li>‘-3.14’</li>
<li>‘2.5E10’, or equivalently, ‘2.5e10’</li>
<li>‘2.5E-10’</li>
<li>‘5.’</li>
<li>‘.5’, or, equivalently, ‘0.5’</li>
<li>‘7’</li>
<li>‘007’</li>
<li>‘inf’, ‘-inf’, ‘+infinity’, ‘NaN’</li>
</ul>
<p>Note that alphabetical characters are not case-sensitive.</p>
<p>Leading and trailing whitespace represent an error.</p>
<h5 id="grammar"><a class="doc-anchor" href="#grammar">§</a>Grammar</h5>
<p>All strings that adhere to the following <a href="https://www.w3.org/TR/REC-xml/#sec-notation">EBNF</a> grammar when
lowercased will result in an <a href="result/enum.Result.html#variant.Ok" title="variant std::result::Result::Ok"><code>Ok</code></a> being returned:</p>
<div class="example-wrap"><pre class="language-txt"><code>Float  ::= Sign? ( &#39;inf&#39; | &#39;infinity&#39; | &#39;nan&#39; | Number )
Number ::= ( Digit+ |
             Digit+ &#39;.&#39; Digit* |
             Digit* &#39;.&#39; Digit+ ) Exp?
Exp    ::= &#39;e&#39; Sign? Digit+
Sign   ::= [+-]
Digit  ::= [0-9]</code></pre></div><h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h5>
<ul>
<li>src - A string</li>
</ul>
<h5 id="return-value"><a class="doc-anchor" href="#return-value">§</a>Return value</h5>
<p><code>Err(ParseFloatError)</code> if the string did not represent a valid
number. Otherwise, <code>Ok(n)</code> where <code>n</code> is the closest
representable floating-point number to the number represented
by <code>src</code> (following the same rules for rounding as for the
results of primitive operations).</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/num/dec2flt/mod.rs.html#179">Source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="str/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="num/struct.ParseFloatError.html" title="struct std::num::ParseFloatError">ParseFloatError</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-LowerExp-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/fmt/float.rs.html#240">Source</a></span><a href="#impl-LowerExp-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.LowerExp.html" title="trait std::fmt::LowerExp">LowerExp</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/float.rs.html#240">Source</a><a href="#method.fmt-2" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.LowerExp.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.LowerExp.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3C%26f32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#361">Source</a></span><a href="#impl-Mul%3C%26f32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-21" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#associatedtype.Output-21" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type std::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#method.mul-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type std::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#361">Source</a></span><a href="#impl-Mul%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-20" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#associatedtype.Output-20" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type std::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#method.mul-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type std::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3Cf32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#361">Source</a></span><a href="#impl-Mul%3Cf32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-19" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#associatedtype.Output-19" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type std::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#method.mul-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a>&gt;::<a class="associatedtype" href="ops/trait.Mul.html#associatedtype.Output" title="type std::ops::Mul::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#361">Source</a></span><a href="#impl-Mul-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Mul.html" title="trait std::ops::Mul">Mul</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-18" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#associatedtype.Output-18" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#361">Source</a><a href="#method.mul" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="ops/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-MulAssign%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0, const unstable">1.22.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#933">Source</a></span><a href="#impl-MulAssign%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.MulAssign.html" title="trait std::ops::MulAssign">MulAssign</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.mul_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#933">Source</a><a href="#method.mul_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.MulAssign.html#tymethod.mul_assign" class="fn">mul_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>*=</code> operation. <a href="ops/trait.MulAssign.html#tymethod.mul_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-MulAssign-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0, const unstable">1.8.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#933">Source</a></span><a href="#impl-MulAssign-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.MulAssign.html" title="trait std::ops::MulAssign">MulAssign</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.mul_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#933">Source</a><a href="#method.mul_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.MulAssign.html#tymethod.mul_assign" class="fn">mul_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>*=</code> operation. <a href="ops/trait.MulAssign.html#tymethod.mul_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Neg-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#729">Source</a></span><a href="#impl-Neg-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Neg.html" title="trait std::ops::Neg">Neg</a> for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#729">Source</a><a href="#associatedtype.Output-9" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Neg.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Neg.html" title="trait std::ops::Neg">Neg</a>&gt;::<a class="associatedtype" href="ops/trait.Neg.html#associatedtype.Output" title="type std::ops::Neg::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.neg-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#729">Source</a><a href="#method.neg-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Neg.html#tymethod.neg" class="fn">neg</a>(self) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Neg.html" title="trait std::ops::Neg">Neg</a>&gt;::<a class="associatedtype" href="ops/trait.Neg.html#associatedtype.Output" title="type std::ops::Neg::Output">Output</a></h4></section></summary><div class='docblock'>Performs the unary <code>-</code> operation. <a href="ops/trait.Neg.html#tymethod.neg">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Neg-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#729">Source</a></span><a href="#impl-Neg-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Neg.html" title="trait std::ops::Neg">Neg</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#729">Source</a><a href="#associatedtype.Output-8" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Neg.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.neg" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#729">Source</a><a href="#method.neg" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Neg.html#tymethod.neg" class="fn">neg</a>(self) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>Performs the unary <code>-</code> operation. <a href="ops/trait.Neg.html#tymethod.neg">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#1890-1892">Source</a></span><a href="#impl-PartialEq-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1890-1892">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1890-1892">Source</a><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#1983">Source</a></span><a href="#impl-PartialOrd-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1983">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1983">Source</a><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1983">Source</a><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1983">Source</a><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#1983">Source</a><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Product%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> · <a class="src" href="../src/core/iter/traits/accum.rs.html#206">Source</a></span><a href="#impl-Product%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="iter/trait.Product.html" title="trait std::iter::Product">Product</a>&lt;&amp;'a <a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.product-1" class="method trait-impl"><a class="src rightside" href="../src/core/iter/traits/accum.rs.html#206">Source</a><a href="#method.product-1" class="anchor">§</a><h4 class="code-header">fn <a href="iter/trait.Product.html#tymethod.product" class="fn">product</a>&lt;I&gt;(iter: I) -&gt; <a class="primitive" href="primitive.f32.html">f32</a><div class="where">where
    I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.f32.html">f32</a>&gt;,</div></h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by multiplying
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Product-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> · <a class="src" href="../src/core/iter/traits/accum.rs.html#206">Source</a></span><a href="#impl-Product-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="iter/trait.Product.html" title="trait std::iter::Product">Product</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.product" class="method trait-impl"><a class="src rightside" href="../src/core/iter/traits/accum.rs.html#206">Source</a><a href="#method.product" class="anchor">§</a><h4 class="code-header">fn <a href="iter/trait.Product.html#tymethod.product" class="fn">product</a>&lt;I&gt;(iter: I) -&gt; <a class="primitive" href="primitive.f32.html">f32</a><div class="where">where
    I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="primitive.f32.html">f32</a>&gt;,</div></h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by multiplying
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem%3C%26f32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#650">Source</a></span><a href="#impl-Rem%3C%26f32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#associatedtype.Output-7" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type std::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#method.rem-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type std::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#650">Source</a></span><a href="#impl-Rem%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type std::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#method.rem-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type std::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem%3Cf32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#650">Source</a></span><a href="#impl-Rem%3Cf32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type std::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#method.rem-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a>&gt;::<a class="associatedtype" href="ops/trait.Rem.html#associatedtype.Output" title="type std::ops::Rem::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Rem-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#650">Source</a></span><a href="#impl-Rem-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Rem.html" title="trait std::ops::Rem">Rem</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3><div class="docblock"><p>The remainder from the division of two floats.</p>
</div></section></summary><div class="docblock"><p>The remainder has the same sign as the dividend and is computed as:
<code>x - (x / y).trunc() * y</code>.</p>
<h4 id="examples-58"><a class="doc-anchor" href="#examples-58">§</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x: f32 = <span class="number">50.50</span>;
<span class="kw">let </span>y: f32 = <span class="number">8.125</span>;
<span class="kw">let </span>remainder = x - (x / y).trunc() * y;

<span class="comment">// The answer to both operations is 1.75
</span><span class="macro">assert_eq!</span>(x % y, remainder);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x:+f32+=+50.50;%0A++++let+y:+f32+=+8.125;%0A++++let+remainder+=+x+-+(x+/+y).trunc()+*+y;%0A++++%0A++++//+The+answer+to+both+operations+is+1.75%0A++++assert_eq!(x+%25+y,+remainder);%0A%7D&amp;edition=2024"></a></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Rem.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>%</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.rem" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#650">Source</a><a href="#method.rem" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Rem.html#tymethod.rem" class="fn">rem</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>Performs the <code>%</code> operation. <a href="ops/trait.Rem.html#tymethod.rem">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RemAssign%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0, const unstable">1.22.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#1059">Source</a></span><a href="#impl-RemAssign%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.RemAssign.html" title="trait std::ops::RemAssign">RemAssign</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.rem_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#1059">Source</a><a href="#method.rem_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.RemAssign.html#tymethod.rem_assign" class="fn">rem_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>%=</code> operation. <a href="ops/trait.RemAssign.html#tymethod.rem_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RemAssign-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0, const unstable">1.8.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#1059">Source</a></span><a href="#impl-RemAssign-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.RemAssign.html" title="trait std::ops::RemAssign">RemAssign</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.rem_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#1059">Source</a><a href="#method.rem_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.RemAssign.html#tymethod.rem_assign" class="fn">rem_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>%=</code> operation. <a href="ops/trait.RemAssign.html#tymethod.rem_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SimdElement-for-f32" class="impl"><a class="src rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1198">Source</a><a href="#impl-SimdElement-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="simd/trait.SimdElement.html" title="trait std::simd::SimdElement">SimdElement</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Mask" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1199">Source</a><a href="#associatedtype.Mask" class="anchor">§</a><h4 class="code-header">type <a href="simd/trait.SimdElement.html#associatedtype.Mask" class="associatedtype">Mask</a> = <a class="primitive" href="primitive.i32.html">i32</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/86656">#86656</a>)</span></div></span><div class='docblock'>The mask element type corresponding to this element type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3C%26f32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#227">Source</a></span><a href="#impl-Sub%3C%26f32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-17" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#associatedtype.Output-17" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type std::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type std::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#227">Source</a></span><a href="#impl-Sub%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-16" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#associatedtype.Output-16" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type std::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type std::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3Cf32%3E-for-%26f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#227">Source</a></span><a href="#impl-Sub%3Cf32%3E-for-%26f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&lt;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for &amp;<a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-15" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#associatedtype.Output-15" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type std::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; &lt;<a class="primitive" href="primitive.f32.html">f32</a> as <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a>&gt;::<a class="associatedtype" href="ops/trait.Sub.html#associatedtype.Output" title="type std::ops::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#227">Source</a></span><a href="#impl-Sub-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.Sub.html" title="trait std::ops::Sub">Sub</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-14" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#associatedtype.Output-14" class="anchor">§</a><h4 class="code-header">type <a href="ops/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#227">Source</a><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, other: <a class="primitive" href="primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="primitive.f32.html">f32</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="ops/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0, const unstable">1.22.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#871">Source</a></span><a href="#impl-SubAssign%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.SubAssign.html" title="trait std::ops::SubAssign">SubAssign</a>&lt;&amp;<a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#871">Source</a><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="ops/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0, const unstable">1.8.0 (const: <a href="https://github.com/rust-lang/rust/issues/143802" title="Tracking issue for const_ops">unstable</a>)</span> · <a class="src" href="../src/core/ops/arith.rs.html#871">Source</a></span><a href="#impl-SubAssign-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="ops/trait.SubAssign.html" title="trait std::ops::SubAssign">SubAssign</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="../src/core/ops/arith.rs.html#871">Source</a><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="ops/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, other: <a class="primitive" href="primitive.f32.html">f32</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="ops/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sum%3C%26f32%3E-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> · <a class="src" href="../src/core/iter/traits/accum.rs.html#206">Source</a></span><a href="#impl-Sum%3C%26f32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="iter/trait.Sum.html" title="trait std::iter::Sum">Sum</a>&lt;&amp;'a <a class="primitive" href="primitive.f32.html">f32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sum-1" class="method trait-impl"><a class="src rightside" href="../src/core/iter/traits/accum.rs.html#206">Source</a><a href="#method.sum-1" class="anchor">§</a><h4 class="code-header">fn <a href="iter/trait.Sum.html#tymethod.sum" class="fn">sum</a>&lt;I&gt;(iter: I) -&gt; <a class="primitive" href="primitive.f32.html">f32</a><div class="where">where
    I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.f32.html">f32</a>&gt;,</div></h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by “summing up”
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sum-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> · <a class="src" href="../src/core/iter/traits/accum.rs.html#206">Source</a></span><a href="#impl-Sum-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="iter/trait.Sum.html" title="trait std::iter::Sum">Sum</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sum" class="method trait-impl"><a class="src rightside" href="../src/core/iter/traits/accum.rs.html#206">Source</a><a href="#method.sum" class="anchor">§</a><h4 class="code-header">fn <a href="iter/trait.Sum.html#tymethod.sum" class="fn">sum</a>&lt;I&gt;(iter: I) -&gt; <a class="primitive" href="primitive.f32.html">f32</a><div class="where">where
    I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="primitive.f32.html">f32</a>&gt;,</div></h4></section></summary><div class='docblock'>Takes an iterator and generates <code>Self</code> from the elements by “summing up”
the items.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-UpperExp-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/fmt/float.rs.html#240">Source</a></span><a href="#impl-UpperExp-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.UpperExp.html" title="trait std::fmt::UpperExp">UpperExp</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/float.rs.html#240">Source</a><a href="#method.fmt-3" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.UpperExp.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.UpperExp.html#tymethod.fmt">Read more</a></div></details></div></details><section id="impl-Copy-for-f32" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="../src/core/marker.rs.html#474-484">Source</a></span><a href="#impl-Copy-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Ci128%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Ci128%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i128.html">i128</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Ci16%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Ci16%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i16.html">i16</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Ci32%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Ci32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i32.html">i32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Ci64%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Ci64%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i64.html">i64</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Ci8%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Ci8%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.i8.html">i8</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Cisize%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Cisize%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.isize.html">isize</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Cu128%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Cu128%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u128.html">u128</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Cu16%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Cu16%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u16.html">u16</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Cu32%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Cu32%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u32.html">u32</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Cu64%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Cu64%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u64.html">u64</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Cu8%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Cu8%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-FloatToInt%3Cusize%3E-for-f32" class="impl"><a class="src rightside" href="../src/core/convert/num.rs.html#38">Source</a><a href="#impl-FloatToInt%3Cusize%3E-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.FloatToInt.html" title="trait std::convert::FloatToInt">FloatToInt</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-SimdCast-for-f32" class="impl"><a class="src rightside" href="../src/core/portable-simd/crates/core_simd/src/cast.rs.html#48">Source</a><a href="#impl-SimdCast-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="simd/trait.SimdCast.html" title="trait std::simd::SimdCast">SimdCast</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-UseCloned-for-f32" class="impl"><a class="src rightside" href="../src/core/clone.rs.html#339-344">Source</a><a href="#impl-UseCloned-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="clone/trait.UseCloned.html" title="trait std::clone::UseCloned">UseCloned</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-f32" class="impl"><a href="#impl-Freeze-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Freeze.html" title="trait std::marker::Freeze">Freeze</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-RefUnwindSafe-for-f32" class="impl"><a href="#impl-RefUnwindSafe-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-Send-for-f32" class="impl"><a href="#impl-Send-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-Sync-for-f32" class="impl"><a href="#impl-Sync-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-Unpin-for-f32" class="impl"><a href="#impl-Unpin-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section><section id="impl-UnwindSafe-for-f32" class="impl"><a href="#impl-UnwindSafe-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.f32.html">f32</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="../src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="../src/core/clone.rs.html#547">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="clone/trait.CloneToUninit.html" title="trait std::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#549">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-7" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="../src/alloc/borrow.rs.html#72-74">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="../src/alloc/borrow.rs.html#76">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="../src/alloc/borrow.rs.html#77">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="../src/alloc/borrow.rs.html#81">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="../src/alloc/string.rs.html#2893">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="string/trait.ToString.html" title="trait std::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="fmt/trait.Display.html" title="trait std::fmt::Display">Display</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="../src/alloc/string.rs.html#2895">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>