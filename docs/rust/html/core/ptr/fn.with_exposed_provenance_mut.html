<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Converts an address back to a mutable pointer, picking up some previously ‘exposed’ provenance."><title>with_exposed_provenance_mut in core::ptr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-bbd8d786.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.95.0" data-rustdoc-version="1.95.0-nightly (eda76d9d1 2026-01-21)" data-channel="nightly" data-search-js="search-86d08462.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items1.95.0.js"></script><script defer src="../../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">with_exposed_provenance_mut</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../../core/index.html">core</a><span class="version">1.95.0-nightly</span></h2></div><div class="version">(eda76d9d1	2026-01-21)</div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In core::<wbr>ptr</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">core</a>::<wbr><a href="index.html">ptr</a></div><h1>Function <span class="fn">with_<wbr>exposed_<wbr>provenance_<wbr>mut</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.84.0, const since 1.91.0">1.84.0 (const: 1.91.0)</span> · <a class="src" href="../../src/core/ptr/mod.rs.html#1028-1030">Source</a> </span></div><pre class="rust item-decl"><code>pub const fn with_exposed_provenance_mut&lt;T&gt;(addr: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="../primitive.pointer.html">*mut T</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Converts an address back to a mutable pointer, picking up some previously ‘exposed’
<a href="index.html#provenance" title="mod core::ptr">provenance</a>.</p>
<p>This is fully equivalent to <code>addr as *mut T</code>. The provenance of the returned pointer is that
of <em>some</em> pointer that was previously exposed by passing it to
<a href="../primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a>, or a <code>ptr as usize</code> cast. In addition, memory
which is outside the control of the Rust abstract machine (MMIO registers, for example) is
always considered to be accessible with an exposed provenance, so long as this memory is disjoint
from memory that will be used by the abstract machine such as the stack, heap, and statics.</p>
<p>The exact provenance that gets picked is not specified. The compiler will do its best to pick
the “right” provenance for you (whatever that may be), but currently we cannot provide any
guarantees about which provenance the resulting pointer will have – and therefore there
is no definite specification for which memory the resulting pointer may access.</p>
<p>If there is <em>no</em> previously ‘exposed’ provenance that justifies the way the returned pointer
will be used, the program has undefined behavior. In particular, the aliasing rules still apply:
pointers and references that have been invalidated due to aliasing accesses cannot be used
anymore, even if they have been exposed!</p>
<p>Due to its inherent ambiguity, this operation may not be supported by tools that help you to
stay conformant with the Rust memory model. It is recommended to use <a href="index.html#strict-provenance" title="mod core::ptr">Strict
Provenance</a> APIs such as <a href="../primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> wherever
possible.</p>
<p>On most platforms this will produce a value with the same bytes as the address. Platforms
which need to store additional information in a pointer may not support this operation,
since it is generally not possible to actually <em>compute</em> which provenance the returned
pointer has to pick up.</p>
<p>This is an <a href="index.html#exposed-provenance" title="mod core::ptr">Exposed Provenance</a> API.</p>
</div></details></section></div></main></body></html>