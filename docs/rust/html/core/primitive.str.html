<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="String slices."><title>str - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-bbd8d786.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.95.0" data-rustdoc-version="1.95.0-nightly (d222ddc4d 2026-01-23)" data-channel="nightly" data-search-js="search-86d08462.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items1.95.0.js"></script><script defer src="../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">str</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../core/index.html"><img class="rust-logo" src="../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../core/index.html">core</a><span class="version">1.95.0-nightly</span></h2></div><div class="version">(d222ddc4d	2026-01-23)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">str</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#basic-usage" title="Basic Usage">Basic Usage</a></li><li><a href="#representation" title="Representation">Representation</a></li><li><a href="#invariant" title="Invariant">Invariant</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.as_ascii" title="as_ascii">as_ascii</a></li><li><a href="#method.as_ascii_unchecked" title="as_ascii_unchecked">as_ascii_unchecked</a></li><li><a href="#method.as_bytes" title="as_bytes">as_bytes</a></li><li><a href="#method.as_bytes_mut" title="as_bytes_mut">as_bytes_mut</a></li><li><a href="#method.as_mut_ptr" title="as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr" title="as_ptr">as_ptr</a></li><li><a href="#method.as_str" title="as_str">as_str</a></li><li><a href="#method.bytes" title="bytes">bytes</a></li><li><a href="#method.ceil_char_boundary" title="ceil_char_boundary">ceil_char_boundary</a></li><li><a href="#method.char_indices" title="char_indices">char_indices</a></li><li><a href="#method.chars" title="chars">chars</a></li><li><a href="#method.contains" title="contains">contains</a></li><li><a href="#method.encode_utf16" title="encode_utf16">encode_utf16</a></li><li><a href="#method.ends_with" title="ends_with">ends_with</a></li><li><a href="#method.eq_ignore_ascii_case" title="eq_ignore_ascii_case">eq_ignore_ascii_case</a></li><li><a href="#method.escape_debug" title="escape_debug">escape_debug</a></li><li><a href="#method.escape_default" title="escape_default">escape_default</a></li><li><a href="#method.escape_unicode" title="escape_unicode">escape_unicode</a></li><li><a href="#method.find" title="find">find</a></li><li><a href="#method.floor_char_boundary" title="floor_char_boundary">floor_char_boundary</a></li><li><a href="#method.from_utf8" title="from_utf8">from_utf8</a></li><li><a href="#method.from_utf8_mut" title="from_utf8_mut">from_utf8_mut</a></li><li><a href="#method.from_utf8_unchecked" title="from_utf8_unchecked">from_utf8_unchecked</a></li><li><a href="#method.from_utf8_unchecked_mut" title="from_utf8_unchecked_mut">from_utf8_unchecked_mut</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.get_mut" title="get_mut">get_mut</a></li><li><a href="#method.get_unchecked" title="get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut" title="get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_ascii" title="is_ascii">is_ascii</a></li><li><a href="#method.is_char_boundary" title="is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.lines" title="lines">lines</a></li><li><a href="#method.lines_any" title="lines_any">lines_any</a></li><li><a href="#method.make_ascii_lowercase" title="make_ascii_lowercase">make_ascii_lowercase</a></li><li><a href="#method.make_ascii_uppercase" title="make_ascii_uppercase">make_ascii_uppercase</a></li><li><a href="#method.match_indices" title="match_indices">match_indices</a></li><li><a href="#method.matches" title="matches">matches</a></li><li><a href="#method.parse" title="parse">parse</a></li><li><a href="#method.rfind" title="rfind">rfind</a></li><li><a href="#method.rmatch_indices" title="rmatch_indices">rmatch_indices</a></li><li><a href="#method.rmatches" title="rmatches">rmatches</a></li><li><a href="#method.rsplit" title="rsplit">rsplit</a></li><li><a href="#method.rsplit_once" title="rsplit_once">rsplit_once</a></li><li><a href="#method.rsplit_terminator" title="rsplit_terminator">rsplit_terminator</a></li><li><a href="#method.rsplitn" title="rsplitn">rsplitn</a></li><li><a href="#method.slice_mut_unchecked" title="slice_mut_unchecked">slice_mut_unchecked</a></li><li><a href="#method.slice_unchecked" title="slice_unchecked">slice_unchecked</a></li><li><a href="#method.split" title="split">split</a></li><li><a href="#method.split_ascii_whitespace" title="split_ascii_whitespace">split_ascii_whitespace</a></li><li><a href="#method.split_at" title="split_at">split_at</a></li><li><a href="#method.split_at_checked" title="split_at_checked">split_at_checked</a></li><li><a href="#method.split_at_mut" title="split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_mut_checked" title="split_at_mut_checked">split_at_mut_checked</a></li><li><a href="#method.split_inclusive" title="split_inclusive">split_inclusive</a></li><li><a href="#method.split_once" title="split_once">split_once</a></li><li><a href="#method.split_terminator" title="split_terminator">split_terminator</a></li><li><a href="#method.split_whitespace" title="split_whitespace">split_whitespace</a></li><li><a href="#method.splitn" title="splitn">splitn</a></li><li><a href="#method.starts_with" title="starts_with">starts_with</a></li><li><a href="#method.strip_circumfix" title="strip_circumfix">strip_circumfix</a></li><li><a href="#method.strip_prefix" title="strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix" title="strip_suffix">strip_suffix</a></li><li><a href="#method.substr_range" title="substr_range">substr_range</a></li><li><a href="#method.trim" title="trim">trim</a></li><li><a href="#method.trim_ascii" title="trim_ascii">trim_ascii</a></li><li><a href="#method.trim_ascii_end" title="trim_ascii_end">trim_ascii_end</a></li><li><a href="#method.trim_ascii_start" title="trim_ascii_start">trim_ascii_start</a></li><li><a href="#method.trim_end" title="trim_end">trim_end</a></li><li><a href="#method.trim_end_matches" title="trim_end_matches">trim_end_matches</a></li><li><a href="#method.trim_left" title="trim_left">trim_left</a></li><li><a href="#method.trim_left_matches" title="trim_left_matches">trim_left_matches</a></li><li><a href="#method.trim_matches" title="trim_matches">trim_matches</a></li><li><a href="#method.trim_prefix" title="trim_prefix">trim_prefix</a></li><li><a href="#method.trim_right" title="trim_right">trim_right</a></li><li><a href="#method.trim_right_matches" title="trim_right_matches">trim_right_matches</a></li><li><a href="#method.trim_start" title="trim_start">trim_start</a></li><li><a href="#method.trim_start_matches" title="trim_start_matches">trim_start_matches</a></li><li><a href="#method.trim_suffix" title="trim_suffix">trim_suffix</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Error-for-%26str" title="!Error">!Error</a></li><li><a href="#impl-AsMut%3Cstr%3E-for-str" title="AsMut&#60;str&#62;">AsMut&#60;str&#62;</a></li><li><a href="#impl-AsRef%3CByteStr%3E-for-str" title="AsRef&#60;ByteStr&#62;">AsRef&#60;ByteStr&#62;</a></li><li><a href="#impl-AsRef%3C%5Bu8%5D%3E-for-str" title="AsRef&#60;[u8]&#62;">AsRef&#60;[u8]&#62;</a></li><li><a href="#impl-AsRef%3Cstr%3E-for-str" title="AsRef&#60;str&#62;">AsRef&#60;str&#62;</a></li><li><a href="#impl-CloneToUninit-for-str" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-ConstParamTy_-for-str" title="ConstParamTy_">ConstParamTy_</a></li><li><a href="#impl-Debug-for-str" title="Debug">Debug</a></li><li><a href="#impl-Default-for-%26mut+str" title="Default">Default</a></li><li><a href="#impl-Default-for-%26str" title="Default">Default</a></li><li><a href="#impl-Display-for-str" title="Display">Display</a></li><li><a href="#impl-Eq-for-str" title="Eq">Eq</a></li><li><a href="#impl-Hash-for-str" title="Hash">Hash</a></li><li><a href="#impl-Index%3CI%3E-for-str" title="Index&#60;I&#62;">Index&#60;I&#62;</a></li><li><a href="#impl-IndexMut%3CI%3E-for-str" title="IndexMut&#60;I&#62;">IndexMut&#60;I&#62;</a></li><li><a href="#impl-Ord-for-str" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-str" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialEq%3C%26str%3E-for-ByteStr" title="PartialEq&#60;&#38;str&#62;">PartialEq&#60;&#38;str&#62;</a></li><li><a href="#impl-PartialEq%3CByteStr%3E-for-%26str" title="PartialEq&#60;ByteStr&#62;">PartialEq&#60;ByteStr&#62;</a></li><li><a href="#impl-PartialEq%3CByteStr%3E-for-str" title="PartialEq&#60;ByteStr&#62;">PartialEq&#60;ByteStr&#62;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-ByteStr" title="PartialEq&#60;str&#62;">PartialEq&#60;str&#62;</a></li><li><a href="#impl-PartialOrd-for-str" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-Pattern-for-%26str" title="Pattern">Pattern</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E-1" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E-1" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFull" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E-1" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E" title="SliceIndex&#60;str&#62;">SliceIndex&#60;str&#62;</a></li><li><a href="#impl-StructuralPartialEq-for-str" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-TryFrom%3C%26ByteStr%3E-for-%26str" title="TryFrom&#60;&#38;&#39;a ByteStr&#62;">TryFrom&#60;&#38;&#39;a ByteStr&#62;</a></li><li><a href="#impl-TryFrom%3C%26mut+ByteStr%3E-for-%26mut+str" title="TryFrom&#60;&#38;&#39;a mut ByteStr&#62;">TryFrom&#60;&#38;&#39;a mut ByteStr&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Sized-for-str" title="!Sized">!Sized</a></li><li><a href="#impl-Freeze-for-str" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-str" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-str" title="Send">Send</a></li><li><a href="#impl-Sync-for-str" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-str" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-str" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate core</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Primitive Type <span class="primitive">str</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>String slices.</p>
<p><em><a href="str/index.html" title="mod core::str">See also the <code>std::str</code> module</a>.</em></p>
<p>The <code>str</code> type, also called a â€˜string sliceâ€™, is the most primitive string
type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type
of string literals, <code>&amp;'static str</code>.</p>
<h2 id="basic-usage"><a class="doc-anchor" href="#basic-usage">Â§</a>Basic Usage</h2>
<p>String literals are string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>hello_world = <span class="string">"Hello, World!"</span>;</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+hello_world+=+%22Hello,+World!%22;%0A%7D&amp;edition=2024"></a></div>
<p>Here we have declared a string slice initialized with a string literal.
String literals have a static lifetime, which means the string <code>hello_world</code>
is guaranteed to be valid for the duration of the entire program.
We can explicitly specify <code>hello_world</code>â€™s lifetime as well:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>hello_world: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str = <span class="string">"Hello, world!"</span>;</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+hello_world:+%26'static+str+=+%22Hello,+world!%22;%0A%7D&amp;edition=2024"></a></div><h2 id="representation"><a class="doc-anchor" href="#representation">Â§</a>Representation</h2>
<p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a
length. You can look at these with the <a href="primitive.str.html#method.as_ptr" title="method str::as_ptr"><code>as_ptr</code></a> and <a href="primitive.str.html#method.len" title="method str::len"><code>len</code></a> methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::slice;
<span class="kw">use </span>std::str;

<span class="kw">let </span>story = <span class="string">"Once upon a time..."</span>;

<span class="kw">let </span>ptr = story.as_ptr();
<span class="kw">let </span>len = story.len();

<span class="comment">// story has nineteen bytes
</span><span class="macro">assert_eq!</span>(<span class="number">19</span>, len);

<span class="comment">// We can re-build a str out of ptr and len. This is all unsafe because
// we are responsible for making sure the two components are valid:
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{
    <span class="comment">// First, we build a &amp;[u8]...
    </span><span class="kw">let </span>slice = slice::from_raw_parts(ptr, len);

    <span class="comment">// ... and then convert that slice into a string slice
    </span>str::from_utf8(slice)
};

<span class="macro">assert_eq!</span>(s, <span class="prelude-val">Ok</span>(story));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::slice;%0A++++use+std::str;%0A++++%0A++++let+story+=+%22Once+upon+a+time...%22;%0A++++%0A++++let+ptr+=+story.as_ptr();%0A++++let+len+=+story.len();%0A++++%0A++++//+story+has+nineteen+bytes%0A++++assert_eq!(19,+len);%0A++++%0A++++//+We+can+re-build+a+str+out+of+ptr+and+len.+This+is+all+unsafe+because%0A++++//+we+are+responsible+for+making+sure+the+two+components+are+valid:%0A++++let+s+=+unsafe+%7B%0A++++++++//+First,+we+build+a+%26%5Bu8%5D...%0A++++++++let+slice+=+slice::from_raw_parts(ptr,+len);%0A++++%0A++++++++//+...+and+then+convert+that+slice+into+a+string+slice%0A++++++++str::from_utf8(slice)%0A++++%7D;%0A++++%0A++++assert_eq!(s,+Ok(story));%0A%7D&amp;edition=2024"></a></div>
<p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be
used to get a string slice under normal circumstances. Use <code>as_str</code>
instead.</p>
<h2 id="invariant"><a class="doc-anchor" href="#invariant">Â§</a>Invariant</h2>
<p>Rust libraries may assume that string slices are always valid UTF-8.</p>
<p>Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function
called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string
slice can lead to undefined behavior down the road.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">Â§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-str" class="impl"><a class="src rightside" href="../src/core/str/mod.rs.html#118-3128">Source</a><a href="#impl-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#141-143">Source</a></span><h4 class="code-header">pub const fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>len = <span class="string">"foo"</span>.len();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, len);

<span class="macro">assert_eq!</span>(<span class="string">"Æ’oo"</span>.len(), <span class="number">4</span>); <span class="comment">// fancy f!
</span><span class="macro">assert_eq!</span>(<span class="string">"Æ’oo"</span>.chars().count(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+len+=+%22foo%22.len();%0A++++assert_eq!(3,+len);%0A++++%0A++++assert_eq!(%22%C6%92oo%22.len(),+4);+//+fancy+f!%0A++++assert_eq!(%22%C6%92oo%22.chars().count(),+3);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#161-163">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">""</span>;
<span class="macro">assert!</span>(s.is_empty());

<span class="kw">let </span>s = <span class="string">"not empty"</span>;
<span class="macro">assert!</span>(!s.is_empty());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%22;%0A++++assert!(s.is_empty());%0A++++%0A++++let+s+=+%22not+empty%22;%0A++++assert!(!s.is_empty());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_utf8" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#239-241">Source</a></span><h4 class="code-header">pub const fn <a href="#method.from_utf8" class="fn">from_utf8</a>(v: &amp;[<a class="primitive" href="primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>, <a class="struct" href="str/struct.Utf8Error.html" title="struct core::str::Utf8Error">Utf8Error</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a slice of bytes to a string slice.</p>
<p>A string slice (<a href="primitive.str.html" title="primitive str"><code>&amp;str</code></a>) is made of bytes (<a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>), and a byte slice
(<a href="primitive.slice.html" title="primitive slice"><code>&amp;[u8]</code></a>) is made of bytes, so this function converts between
the two. Not all byte slices are valid string slices, however: <a href="primitive.str.html" title="primitive str"><code>&amp;str</code></a> requires
that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that the bytes are valid
UTF-8, and then does the conversion.</p>
<p>If you are sure that the byte slice is valid UTF-8, and you donâ€™t want to
incur the overhead of the validity check, there is an unsafe version of
this function, <a href="str/fn.from_utf8_unchecked.html" title="fn core::str::from_utf8_unchecked"><code>from_utf8_unchecked</code></a>, which has the same
behavior but skips the check.</p>
<p>If you need a <code>String</code> instead of a <code>&amp;str</code>, consider
<a href="../std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a>.</p>
<p>Because you can stack-allocate a <code>[u8; N]</code>, and you can take a
<a href="primitive.slice.html" title="primitive slice"><code>&amp;[u8]</code></a> of it, this function is one way to have a
stack-allocated string. There is an example of this in the
examples section below.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">Â§</a>Errors</h5>
<p>Returns <code>Err</code> if the slice is not UTF-8 with a description as to why the
provided slice is not UTF-8.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// some bytes, in a vector
</span><span class="kw">let </span>sparkle_heart = <span class="macro">vec!</span>[<span class="number">240</span>, <span class="number">159</span>, <span class="number">146</span>, <span class="number">150</span>];

<span class="comment">// We can use the ? (try) operator to check if the bytes are valid
</span><span class="kw">let </span>sparkle_heart = str::from_utf8(<span class="kw-2">&amp;</span>sparkle_heart)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="string">"ğŸ’–"</span>, sparkle_heart);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+core::result::Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++//+some+bytes,+in+a+vector%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++//+We+can+use+the+?+(try)+operator+to+check+if+the+bytes+are+valid%0A++++let+sparkle_heart+=+str::from_utf8(%26sparkle_heart)?;%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A++++Ok::%3C_,+std::str::Utf8Error%3E(())%0A%7D+_inner().unwrap()+%7D&amp;edition=2024"></a></div>
<p>Incorrect bytes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// some invalid bytes, in a vector
</span><span class="kw">let </span>sparkle_heart = <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">159</span>, <span class="number">146</span>, <span class="number">150</span>];

<span class="macro">assert!</span>(str::from_utf8(<span class="kw-2">&amp;</span>sparkle_heart).is_err());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+some+invalid+bytes,+in+a+vector%0A++++let+sparkle_heart+=+vec!%5B0,+159,+146,+150%5D;%0A++++%0A++++assert!(str::from_utf8(%26sparkle_heart).is_err());%0A%7D&amp;edition=2024"></a></div>
<p>See the docs for <a href="str/struct.Utf8Error.html" title="struct core::str::Utf8Error"><code>Utf8Error</code></a> for more details on the kinds of
errors that can be returned.</p>
<p>A â€œstack allocated stringâ€:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// some bytes, in a stack-allocated array
</span><span class="kw">let </span>sparkle_heart = [<span class="number">240</span>, <span class="number">159</span>, <span class="number">146</span>, <span class="number">150</span>];

<span class="comment">// We know these bytes are valid, so just use `unwrap()`.
</span><span class="kw">let </span>sparkle_heart: <span class="kw-2">&amp;</span>str = str::from_utf8(<span class="kw-2">&amp;</span>sparkle_heart).unwrap();

<span class="macro">assert_eq!</span>(<span class="string">"ğŸ’–"</span>, sparkle_heart);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+some+bytes,+in+a+stack-allocated+array%0A++++let+sparkle_heart+=+%5B240,+159,+146,+150%5D;%0A++++%0A++++//+We+know+these+bytes+are+valid,+so+just+use+%60unwrap()%60.%0A++++let+sparkle_heart:+%26str+=+str::from_utf8(%26sparkle_heart).unwrap();%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_utf8_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#272-274">Source</a></span><h4 class="code-header">pub const fn <a href="#method.from_utf8_mut" class="fn">from_utf8_mut</a>(v: &amp;mut [<a class="primitive" href="primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;mut <a class="primitive" href="primitive.str.html">str</a>, <a class="struct" href="str/struct.Utf8Error.html" title="struct core::str::Utf8Error">Utf8Error</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a mutable slice of bytes to a mutable string slice.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// "Hello, Rust!" as a mutable vector
</span><span class="kw">let </span><span class="kw-2">mut </span>hellorust = <span class="macro">vec!</span>[<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">44</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">33</span>];

<span class="comment">// As we know these bytes are valid, we can use `unwrap()`
</span><span class="kw">let </span>outstr = str::from_utf8_mut(<span class="kw-2">&amp;mut </span>hellorust).unwrap();

<span class="macro">assert_eq!</span>(<span class="string">"Hello, Rust!"</span>, outstr);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+%22Hello,+Rust!%22+as+a+mutable+vector%0A++++let+mut+hellorust+=+vec!%5B72,+101,+108,+108,+111,+44,+32,+82,+117,+115,+116,+33%5D;%0A++++%0A++++//+As+we+know+these+bytes+are+valid,+we+can+use+%60unwrap()%60%0A++++let+outstr+=+str::from_utf8_mut(%26mut+hellorust).unwrap();%0A++++%0A++++assert_eq!(%22Hello,+Rust!%22,+outstr);%0A%7D&amp;edition=2024"></a></div>
<p>Incorrect bytes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Some invalid bytes in a mutable vector
</span><span class="kw">let </span><span class="kw-2">mut </span>invalid = <span class="macro">vec!</span>[<span class="number">128</span>, <span class="number">223</span>];

<span class="macro">assert!</span>(str::from_utf8_mut(<span class="kw-2">&amp;mut </span>invalid).is_err());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+Some+invalid+bytes+in+a+mutable+vector%0A++++let+mut+invalid+=+vec!%5B128,+223%5D;%0A++++%0A++++assert!(str::from_utf8_mut(%26mut+invalid).is_err());%0A%7D&amp;edition=2024"></a></div>
<p>See the docs for <a href="str/struct.Utf8Error.html" title="struct core::str::Utf8Error"><code>Utf8Error</code></a> for more details on the kinds of
errors that can be returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_utf8_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#304-307">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.from_utf8_unchecked" class="fn">from_utf8_unchecked</a>(v: &amp;[<a class="primitive" href="primitive.u8.html">u8</a>]) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Converts a slice of bytes to a string slice without checking
that the string contains valid UTF-8.</p>
<p>See the safe version, <a href="str/fn.from_utf8.html" title="fn core::str::from_utf8"><code>from_utf8</code></a>, for more information.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">Â§</a>Safety</h5>
<p>The bytes passed in must be valid UTF-8.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// some bytes, in a vector
</span><span class="kw">let </span>sparkle_heart = <span class="macro">vec!</span>[<span class="number">240</span>, <span class="number">159</span>, <span class="number">146</span>, <span class="number">150</span>];

<span class="kw">let </span>sparkle_heart = <span class="kw">unsafe </span>{
    str::from_utf8_unchecked(<span class="kw-2">&amp;</span>sparkle_heart)
};

<span class="macro">assert_eq!</span>(<span class="string">"ğŸ’–"</span>, sparkle_heart);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+some+bytes,+in+a+vector%0A++++let+sparkle_heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++%0A++++let+sparkle_heart+=+unsafe+%7B%0A++++++++str::from_utf8_unchecked(%26sparkle_heart)%0A++++%7D;%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+sparkle_heart);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_utf8_unchecked_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#329-332">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.from_utf8_unchecked_mut" class="fn">from_utf8_unchecked_mut</a>(v: &amp;mut [<a class="primitive" href="primitive.u8.html">u8</a>]) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Converts a slice of bytes to a string slice without checking
that the string contains valid UTF-8; mutable version.</p>
<p>See the immutable version, <a href="str/fn.from_utf8_unchecked.html" title="fn core::str::from_utf8_unchecked"><code>from_utf8_unchecked()</code></a> for documentation and safety requirements.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>heart = <span class="macro">vec!</span>[<span class="number">240</span>, <span class="number">159</span>, <span class="number">146</span>, <span class="number">150</span>];
<span class="kw">let </span>heart = <span class="kw">unsafe </span>{ str::from_utf8_unchecked_mut(<span class="kw-2">&amp;mut </span>heart) };

<span class="macro">assert_eq!</span>(<span class="string">"ğŸ’–"</span>, heart);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+heart+=+vec!%5B240,+159,+146,+150%5D;%0A++++let+heart+=+unsafe+%7B+str::from_utf8_unchecked_mut(%26mut+heart)+%7D;%0A++++%0A++++assert_eq!(%22%F0%9F%92%96%22,+heart);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const since 1.86.0">1.9.0 (const: 1.86.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#361-384">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_char_boundary" class="fn">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="macro">assert!</span>(s.is_char_boundary(<span class="number">0</span>));
<span class="comment">// start of `è€`
</span><span class="macro">assert!</span>(s.is_char_boundary(<span class="number">6</span>));
<span class="macro">assert!</span>(s.is_char_boundary(s.len()));

<span class="comment">// second byte of `Ã¶`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">2</span>));

<span class="comment">// third byte of `è€`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++assert!(s.is_char_boundary(0));%0A++++//+start+of+%60%E8%80%81%60%0A++++assert!(s.is_char_boundary(6));%0A++++assert!(s.is_char_boundary(s.len()));%0A++++%0A++++//+second+byte+of+%60%C3%B6%60%0A++++assert!(!s.is_char_boundary(2));%0A++++%0A++++//+third+byte+of+%60%E8%80%81%60%0A++++assert!(!s.is_char_boundary(8));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.floor_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0, const since 1.91.0">1.91.0 (const: 1.91.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#410-427">Source</a></span><h4 class="code-header">pub const fn <a href="#method.floor_char_boundary" class="fn">floor_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <a href="primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p>
<p>This method can help you truncate a string so that itâ€™s still valid UTF-8, but doesnâ€™t
exceed a given number of bytes. Note that this is done purely at the character level
and can still visually split graphemes, even though the underlying characters arenâ€™t
split. For example, the emoji ğŸ§‘â€ğŸ”¬ (scientist) could be split so that the string only
includes ğŸ§‘ (person) instead.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.floor_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"â¤ï¸ğŸ§¡"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.floor_char_boundary(13);%0A++++assert_eq!(closest,+10);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ceil_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0, const since 1.91.0">1.91.0 (const: 1.91.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#453-470">Source</a></span><h4 class="code-header">pub const fn <a href="#method.ceil_char_boundary" class="fn">ceil_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Finds the closest <code>x</code> not below <code>index</code> where <a href="primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p>
<p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p>
<p>This method is the natural complement to <a href="primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method
for more details.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.ceil_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"â¤ï¸ğŸ§¡ğŸ’›"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%F0%9F%92%9A%F0%9F%92%99%F0%9F%92%9C%22;%0A++++assert_eq!(s.len(),+26);%0A++++assert!(!s.is_char_boundary(13));%0A++++%0A++++let+closest+=+s.ceil_char_boundary(13);%0A++++assert_eq!(closest,+14);%0A++++assert_eq!(%26s%5B..closest%5D,+%22%E2%9D%A4%EF%B8%8F%F0%9F%A7%A1%F0%9F%92%9B%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#486-489">Source</a></span><h4 class="code-header">pub const fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="primitive.u8.html">u8</a>]</h4></section></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="str/fn.from_utf8.html" title="fn core::str::from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="string">"bors"</span>.as_bytes();
<span class="macro">assert_eq!</span>(<span class="string">b"bors"</span>, bytes);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bytes+=+%22bors%22.as_bytes();%0A++++assert_eq!(b%22bors%22,+bytes);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const since 1.83.0">1.20.0 (const: 1.83.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#531-537">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.as_bytes_mut" class="fn">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="primitive" href="primitive.u8.html">u8</a>]</h4></section></summary><div class="docblock"><p>Converts a mutable string slice to a mutable byte slice.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">Â§</a>Safety</h5>
<p>The caller must ensure that the content of the slice is valid UTF-8
before the borrow ends and the underlying <code>str</code> is used.</p>
<p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"Hello"</span>);
<span class="kw">let </span>bytes = <span class="kw">unsafe </span>{ s.as_bytes_mut() };

<span class="macro">assert_eq!</span>(<span class="string">b"Hello"</span>, bytes);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Hello%22);%0A++++let+bytes+=+unsafe+%7B+s.as_bytes_mut()+%7D;%0A++++%0A++++assert_eq!(b%22Hello%22,+bytes);%0A%7D&amp;edition=2024"></a></div>
<p>Mutability:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"ğŸ—»âˆˆğŸŒ"</span>);

<span class="kw">unsafe </span>{
    <span class="kw">let </span>bytes = s.as_bytes_mut();

    bytes[<span class="number">0</span>] = <span class="number">0xF0</span>;
    bytes[<span class="number">1</span>] = <span class="number">0x9F</span>;
    bytes[<span class="number">2</span>] = <span class="number">0x8D</span>;
    bytes[<span class="number">3</span>] = <span class="number">0x94</span>;
}

<span class="macro">assert_eq!</span>(<span class="string">"ğŸ”âˆˆğŸŒ"</span>, s);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++unsafe+%7B%0A++++++++let+bytes+=+s.as_bytes_mut();%0A++++%0A++++++++bytes%5B0%5D+=+0xF0;%0A++++++++bytes%5B1%5D+=+0x9F;%0A++++++++bytes%5B2%5D+=+0x8D;%0A++++++++bytes%5B3%5D+=+0x94;%0A++++%7D%0A++++%0A++++assert_eq!(%22%F0%9F%8D%94%E2%88%88%F0%9F%8C%8F%22,+s);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.32.0">1.0.0 (const: 1.32.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#562-564">Source</a></span><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Hello"</span>;
<span class="kw">let </span>ptr = s.as_ptr();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Hello%22;%0A++++let+ptr+=+s.as_ptr();%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.83.0">1.36.0 (const: 1.83.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#580-582">Source</a></span><h4 class="code-header">pub const fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a mutable string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>It is your responsibility to make sure that the string slice only gets
modified in a way that it remains valid UTF-8.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#606-608">Source</a></span><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(&amp;self, i: I) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = String::from(<span class="string">"ğŸ—»âˆˆğŸŒ"</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"ğŸ—»"</span>), v.get(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries
</span><span class="macro">assert!</span>(v.get(<span class="number">1</span>..).is_none());
<span class="macro">assert!</span>(v.get(..<span class="number">8</span>).is_none());

<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get(..<span class="number">42</span>).is_none());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++%0A++++assert_eq!(Some(%22%F0%9F%97%BB%22),+v.get(0..4));%0A++++%0A++++//+indices+not+on+UTF-8+sequence+boundaries%0A++++assert!(v.get(1..).is_none());%0A++++assert!(v.get(..8).is_none());%0A++++%0A++++//+out+of+bounds%0A++++assert!(v.get(..42).is_none());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#639-641">Source</a></span><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>&lt;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(&amp;mut self, i: I) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>v = String::from(<span class="string">"hello"</span>);
<span class="comment">// correct length
</span><span class="macro">assert!</span>(v.get_mut(<span class="number">0</span>..<span class="number">5</span>).is_some());
<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get_mut(..<span class="number">42</span>).is_none());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"he"</span>), v.get_mut(<span class="number">0</span>..<span class="number">2</span>).map(|v| <span class="kw-2">&amp;*</span>v));

<span class="macro">assert_eq!</span>(<span class="string">"hello"</span>, v);
{
    <span class="kw">let </span>s = v.get_mut(<span class="number">0</span>..<span class="number">2</span>);
    <span class="kw">let </span>s = s.map(|s| {
        s.make_ascii_uppercase();
        <span class="kw-2">&amp;*</span>s
    });
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"HE"</span>), s);
}
<span class="macro">assert_eq!</span>(<span class="string">"HEllo"</span>, v);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22hello%22);%0A++++//+correct+length%0A++++assert!(v.get_mut(0..5).is_some());%0A++++//+out+of+bounds%0A++++assert!(v.get_mut(..42).is_none());%0A++++assert_eq!(Some(%22he%22),+v.get_mut(0..2).map(%7Cv%7C+%26*v));%0A++++%0A++++assert_eq!(%22hello%22,+v);%0A++++%7B%0A++++++++let+s+=+v.get_mut(0..2);%0A++++++++let+s+=+s.map(%7Cs%7C+%7B%0A++++++++++++s.make_ascii_uppercase();%0A++++++++++++%26*s%0A++++++++%7D);%0A++++++++assert_eq!(Some(%22HE%22),+s);%0A++++%7D%0A++++assert_eq!(%22HEllo%22,+v);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#671-676">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(&amp;self, i: I) -&gt; &amp;I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">Â§</a>Safety</h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="string">"ğŸ—»âˆˆğŸŒ"</span>;
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸ—»"</span>, v.get_unchecked(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"âˆˆ"</span>, v.get_unchecked(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸŒ"</span>, v.get_unchecked(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v+=+%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22;%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked(7..11));%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#706-711">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fn">get_unchecked_mut</a>&lt;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;(
    &amp;mut self,
    i: I,
) -&gt; &amp;mut I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class="docblock"><p>Returns a mutable, unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">Â§</a>Safety</h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>v = String::from(<span class="string">"ğŸ—»âˆˆğŸŒ"</span>);
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸ—»"</span>, v.get_unchecked_mut(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"âˆˆ"</span>, v.get_unchecked_mut(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸŒ"</span>, v.get_unchecked_mut(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+v+=+String::from(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22);%0A++++unsafe+%7B%0A++++++++assert_eq!(%22%F0%9F%97%BB%22,+v.get_unchecked_mut(0..4));%0A++++++++assert_eq!(%22%E2%88%88%22,+v.get_unchecked_mut(4..7));%0A++++++++assert_eq!(%22%F0%9F%8C%8F%22,+v.get_unchecked_mut(7..11));%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.slice_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#757-762">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fn">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="primitive.usize.html">usize</a>, end: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.Index.html" title="trait core::ops::Index"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">Â§</a>Safety</h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"LÃ¶we è€è™ LÃ©opard"</span>, s.slice_unchecked(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let </span>s = <span class="string">"Hello, world!"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"world"</span>, s.slice_unchecked(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22,+s.slice_unchecked(0,+21));%0A++++%7D%0A++++%0A++++let+s+=+%22Hello,+world!%22;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(%22world%22,+s.slice_unchecked(7,+12));%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.slice_mut_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#791-796">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_mut_unchecked" class="fn">slice_mut_unchecked</a>(
    &amp;mut self,
    begin: <a class="primitive" href="primitive.usize.html">usize</a>,
    end: <a class="primitive" href="primitive.usize.html">usize</a>,
) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked_mut(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="primitive str"><code>str</code></a> and <a href="ops/trait.IndexMut.html" title="trait core::ops::IndexMut"><code>IndexMut</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get an immutable string slice instead, see the
<a href="primitive.str.html#method.slice_unchecked" title="method str::slice_unchecked"><code>slice_unchecked</code></a> method.</p>
<h5 id="safety-5"><a class="doc-anchor" href="#safety-5">Â§</a>Safety</h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0, const since 1.86.0">1.4.0 (const: 1.86.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#831-836">Source</a></span><h4 class="code-header">pub const fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Divides one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">Â§</a>Panics</h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past
the end of the last code point of the string slice.  For a non-panicking
alternative see <a href="primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a>.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-LÃ¶f"</span>;

<span class="kw">let </span>(first, last) = s.split_at(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at(3);%0A++++%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0, const since 1.86.0">1.4.0 (const: 1.86.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#872-880">Source</a></span><h4 class="code-header">pub const fn <a href="#method.split_at_mut" class="fn">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (&amp;mut <a class="primitive" href="primitive.str.html">str</a>, &amp;mut <a class="primitive" href="primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Divides one mutable string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at" title="method str::split_at"><code>split_at</code></a> method.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">Â§</a>Panics</h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past
the end of the last code point of the string slice.  For a non-panicking
alternative see <a href="primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a>.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">"Per Martin-LÃ¶f"</span>.to_string();
{
    <span class="kw">let </span>(first, last) = s.split_at_mut(<span class="number">3</span>);
    first.make_ascii_uppercase();
    <span class="macro">assert_eq!</span>(<span class="string">"PER"</span>, first);
    <span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);
}
<span class="macro">assert_eq!</span>(<span class="string">"PER Martin-LÃ¶f"</span>, s);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++%7B%0A++++++++let+(first,+last)+=+s.split_at_mut(3);%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.86.0">1.80.0 (const: 1.86.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#912-920">Source</a></span><h4 class="code-header">pub const fn <a href="#method.split_at_checked" class="fn">split_at_checked</a>(&amp;self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a>)&gt;</h4></section></summary><div class="docblock"><p>Divides one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point. The
method returns <code>None</code> if thatâ€™s not the case.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a>
method.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-LÃ¶f"</span>;

<span class="kw">let </span>(first, last) = s.split_at_checked(<span class="number">3</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">13</span>));  <span class="comment">// Inside â€œÃ¶â€
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">16</span>));  <span class="comment">// Beyond the string length</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22Per+Martin-L%C3%B6f%22;%0A++++%0A++++let+(first,+last)+=+s.split_at_checked(3).unwrap();%0A++++assert_eq!(%22Per%22,+first);%0A++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%0A++++assert_eq!(None,+s.split_at_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_checked(16));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.86.0">1.80.0 (const: 1.86.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#953-961">Source</a></span><h4 class="code-header">pub const fn <a href="#method.split_at_mut_checked" class="fn">split_at_mut_checked</a>(
    &amp;mut self,
    mid: <a class="primitive" href="primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;mut <a class="primitive" href="primitive.str.html">str</a>, &amp;mut <a class="primitive" href="primitive.str.html">str</a>)&gt;</h4></section></summary><div class="docblock"><p>Divides one mutable string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point. The
method returns <code>None</code> if thatâ€™s not the case.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a> method.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = <span class="string">"Per Martin-LÃ¶f"</span>.to_string();
<span class="kw">if let </span><span class="prelude-val">Some</span>((first, last)) = s.split_at_mut_checked(<span class="number">3</span>) {
    first.make_ascii_uppercase();
    <span class="macro">assert_eq!</span>(<span class="string">"PER"</span>, first);
    <span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);
}
<span class="macro">assert_eq!</span>(<span class="string">"PER Martin-LÃ¶f"</span>, s);

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_mut_checked(<span class="number">13</span>));  <span class="comment">// Inside â€œÃ¶â€
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_mut_checked(<span class="number">16</span>));  <span class="comment">// Beyond the string length</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%22Per+Martin-L%C3%B6f%22.to_string();%0A++++if+let+Some((first,+last))+=+s.split_at_mut_checked(3)+%7B%0A++++++++first.make_ascii_uppercase();%0A++++++++assert_eq!(%22PER%22,+first);%0A++++++++assert_eq!(%22+Martin-L%C3%B6f%22,+last);%0A++++%7D%0A++++assert_eq!(%22PER+Martin-L%C3%B6f%22,+s);%0A++++%0A++++assert_eq!(None,+s.split_at_mut_checked(13));++//+Inside+%E2%80%9C%C3%B6%E2%80%9D%0A++++assert_eq!(None,+s.split_at_mut_checked(16));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1050-1052">Source</a></span><h4 class="code-header">pub fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Chars.html" title="struct core::str::Chars">Chars</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Chars&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p>
<p>Itâ€™s important to remember that <a href="primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rustâ€™s standard library, check crates.io instead.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.chars().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>chars = word.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'g'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'d'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'b'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'e'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.chars().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+chars+=+word.chars();%0A++++%0A++++assert_eq!(Some('g'),+chars.next());%0A++++assert_eq!(Some('o'),+chars.next());%0A++++assert_eq!(Some('o'),+chars.next());%0A++++assert_eq!(Some('d'),+chars.next());%0A++++assert_eq!(Some('b'),+chars.next());%0A++++assert_eq!(Some('y'),+chars.next());%0A++++assert_eq!(Some('e'),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&amp;edition=2024"></a></div>
<p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>y = <span class="string">"yÌ†"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>chars = y.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next()); <span class="comment">// not 'yÌ†'
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'\u{0306}'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+y+=+%22y%CC%86%22;%0A++++%0A++++let+mut+chars+=+y.chars();%0A++++%0A++++assert_eq!(Some('y'),+chars.next());+//+not+'y%CC%86'%0A++++assert_eq!(Some('%5Cu%7B0306%7D'),+chars.next());%0A++++%0A++++assert_eq!(None,+chars.next());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1107-1109">Source</a></span><h4 class="code-header">pub fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="CharIndices&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both
these <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="primitive.char.html" title="primitive char"><code>char</code></a> is
second.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.char_indices().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = word.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'g'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'d'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'b'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">'y'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">'e'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+word+=+%22goodbye%22;%0A++++%0A++++let+count+=+word.char_indices().count();%0A++++assert_eq!(7,+count);%0A++++%0A++++let+mut+char_indices+=+word.char_indices();%0A++++%0A++++assert_eq!(Some((0,+'g')),+char_indices.next());%0A++++assert_eq!(Some((1,+'o')),+char_indices.next());%0A++++assert_eq!(Some((2,+'o')),+char_indices.next());%0A++++assert_eq!(Some((3,+'d')),+char_indices.next());%0A++++assert_eq!(Some((4,+'b')),+char_indices.next());%0A++++assert_eq!(Some((5,+'y')),+char_indices.next());%0A++++assert_eq!(Some((6,+'e')),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&amp;edition=2024"></a></div>
<p>Remember, <a href="primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>yes = <span class="string">"yÌ†es"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = yes.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'y'</span>)), char_indices.next()); <span class="comment">// not (0, 'yÌ†')
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'\u{0306}'</span>)), char_indices.next());

<span class="comment">// note the 3 here - the previous character took up two bytes
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'e'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'s'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+yes+=+%22y%CC%86es%22;%0A++++%0A++++let+mut+char_indices+=+yes.char_indices();%0A++++%0A++++assert_eq!(Some((0,+'y')),+char_indices.next());+//+not+(0,+'y%CC%86')%0A++++assert_eq!(Some((1,+'%5Cu%7B0306%7D')),+char_indices.next());%0A++++%0A++++//+note+the+3+here+-+the+previous+character+took+up+two+bytes%0A++++assert_eq!(Some((3,+'e')),+char_indices.next());%0A++++assert_eq!(Some((4,+'s')),+char_indices.next());%0A++++%0A++++assert_eq!(None,+char_indices.next());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1130-1132">Source</a></span><h4 class="code-header">pub fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Bytes&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="string">"bors"</span>.bytes();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'b'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'o'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'r'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b's'</span>), bytes.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, bytes.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+bytes+=+%22bors%22.bytes();%0A++++%0A++++assert_eq!(Some(b'b'),+bytes.next());%0A++++assert_eq!(Some(b'o'),+bytes.next());%0A++++assert_eq!(Some(b'r'),+bytes.next());%0A++++assert_eq!(Some(b's'),+bytes.next());%0A++++%0A++++assert_eq!(None,+bytes.next());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1182-1184">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fn">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitWhitespace.html" title="struct core::str::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SplitWhitespace&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2024"></a></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta\u{2009}little  \n\t lamb"</span>.split_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta%5Cu%7B2009%7Dlittle++%5Cn%5Ct+lamb%22.split_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2024"></a></div>
<p>If the string is empty or all whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_whitespace().next(), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_whitespace().next(),+None);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1233-1237">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fn">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct core::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SplitAsciiWhitespace&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>This uses the same definition as <a href="primitive.char.html#method.is_ascii_whitespace" title="method char::is_ascii_whitespace"><code>char::is_ascii_whitespace</code></a>.
To split by Unicode <code>Whitespace</code> instead, use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_ascii_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22A+few+words%22.split_ascii_whitespace();%0A++++%0A++++assert_eq!(Some(%22A%22),+iter.next());%0A++++assert_eq!(Some(%22few%22),+iter.next());%0A++++assert_eq!(Some(%22words%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2024"></a></div>
<p>Various kinds of ASCII whitespace are considered
(see <a href="primitive.char.html#method.is_ascii_whitespace" title="method char::is_ascii_whitespace"><code>char::is_ascii_whitespace</code></a>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta little  \n\t lamb"</span>.split_ascii_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+iter+=+%22+Mary+++had%5Cta+little++%5Cn%5Ct+lamb%22.split_ascii_whitespace();%0A++++assert_eq!(Some(%22Mary%22),+iter.next());%0A++++assert_eq!(Some(%22had%22),+iter.next());%0A++++assert_eq!(Some(%22a%22),+iter.next());%0A++++assert_eq!(Some(%22little%22),+iter.next());%0A++++assert_eq!(Some(%22lamb%22),+iter.next());%0A++++%0A++++assert_eq!(None,+iter.next());%0A%7D&amp;edition=2024"></a></div>
<p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%22.split_ascii_whitespace().next(),+None);%0A++++assert_eq!(%22+++%22.split_ascii_whitespace().next(),+None);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1297-1299">Source</a></span><h4 class="code-header">pub fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Lines.html" title="struct core::str::Lines">Lines</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Lines&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the lines of a string, as string slices.</p>
<p>Lines are split at line endings that are either newlines (<code>\n</code>) or
sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p>
<p>Line terminators are not included in the lines returned by the iterator.</p>
<p>Note that any carriage return (<code>\r</code>) not immediately followed by a
line feed (<code>\n</code>) does not split a line. These carriage returns are
thereby included in the produced lines.</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<p>An empty string returns an empty iterator.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\r\nbar\n\nbaz\r"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="comment">// Trailing carriage return is included in the last line
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz\r"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cr%5Cnbar%5Cn%5Cnbaz%5Cr%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++//+Trailing+carriage+return+is+included+in+the+last+line%0A++++assert_eq!(Some(%22baz%5Cr%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&amp;edition=2024"></a></div>
<p>The final line does not require any ending:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\nbar\n\r\nbaz"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22foo%5Cnbar%5Cn%5Cr%5Cnbaz%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(Some(%22foo%22),+lines.next());%0A++++assert_eq!(Some(%22bar%22),+lines.next());%0A++++assert_eq!(Some(%22%22),+lines.next());%0A++++assert_eq!(Some(%22baz%22),+lines.next());%0A++++%0A++++assert_eq!(None,+lines.next());%0A%7D&amp;edition=2024"></a></div>
<p>An empty string returns an empty iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">""</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(lines.next(), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22%22;%0A++++let+mut+lines+=+text.lines();%0A++++%0A++++assert_eq!(lines.next(),+None);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.lines_any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1306-1308">Source</a></span><h4 class="code-header">pub fn <a href="#method.lines_any" class="fn">lines_any</a>(&amp;self) -&gt; <a class="struct" href="str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="LinesAny&lt;&#39;_&gt;">â“˜</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.4.0: use lines() instead now</span></div></span></summary><div class="docblock"><p>Returns an iterator over the lines of a string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1326-1328">Source</a></span><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fn">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EncodeUtf16.html" title="struct core::str::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EncodeUtf16&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded
as native endian UTF-16 (without byte-order mark).</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„"</span>;

<span class="kw">let </span>utf8_len = text.len();
<span class="kw">let </span>utf16_len = text.encode_utf16().count();

<span class="macro">assert!</span>(utf16_len &lt;= utf8_len);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+text+=+%22Za%C5%BC%C3%B3%C5%82%C4%87+g%C4%99%C5%9Bl%C4%85+ja%C5%BA%C5%84%22;%0A++++%0A++++let+utf8_len+=+text.len();%0A++++let+utf16_len+=+text.encode_utf16().count();%0A++++%0A++++assert!(utf16_len+%3C=+utf8_len);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1351-1353">Source</a></span><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.contains(<span class="string">"nana"</span>));
<span class="macro">assert!</span>(!bananas.contains(<span class="string">"apples"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.contains(%22nana%22));%0A++++assert!(!bananas.contains(%22apples%22));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1389-1391">Source</a></span><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, in which case this function will return true if
the <code>&amp;str</code> is a prefix of this string slice.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can also be a <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.
These will only be checked against the first character of this string slice.
Look at the second example below regarding behavior for slices of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.starts_with(<span class="string">"bana"</span>));
<span class="macro">assert!</span>(!bananas.starts_with(<span class="string">"nana"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.starts_with(%22bana%22));%0A++++assert!(!bananas.starts_with(%22nana%22));%0A%7D&amp;edition=2024"></a></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="comment">// Note that both of these assert successfully.
</span><span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'a'</span>]));
<span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++//+Note+that+both+of+these+assert+successfully.%0A++++assert!(bananas.starts_with(%26%5B'b',+'a',+'n',+'a'%5D));%0A++++assert!(bananas.starts_with(%26%5B'a',+'b',+'c',+'d'%5D));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1414-1419">Source</a></span><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.ends_with(<span class="string">"anas"</span>));
<span class="macro">assert!</span>(!bananas.ends_with(<span class="string">"nana"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+bananas+=+%22bananas%22;%0A++++%0A++++assert!(bananas.ends_with(%22anas%22));%0A++++assert!(!bananas.ends_with(%22nana%22));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1465-1467">Source</a></span><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.find(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">'Ã©'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.find('L'),+Some(0));%0A++++assert_eq!(s.find('%C3%A9'),+Some(14));%0A++++assert_eq!(s.find(%22pard%22),+Some(17));%0A%7D&amp;edition=2024"></a></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="macro">assert_eq!</span>(s.find(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(s.find(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| (c &lt; <span class="string">'o'</span>) &amp;&amp; (c &gt; <span class="string">'a'</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.find(char::is_whitespace),+Some(5));%0A++++assert_eq!(s.find(char::is_lowercase),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+c.is_whitespace()+%7C%7C+c.is_lowercase()),+Some(1));%0A++++assert_eq!(s.find(%7Cc:+char%7C+(c+%3C+'o')+%26%26+(c+%3E+'a')),+Some(4));%0A%7D&amp;edition=2024"></a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.find(x), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++%0A++++assert_eq!(s.find(x),+None);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1511-1516">Source</a></span><h4 class="code-header">pub fn <a href="#method.rfind" class="fn">rfind</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;<div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the byte index for the first character of the last match of the pattern in
this string slice.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'Ã©'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard+Gepardi%22;%0A++++%0A++++assert_eq!(s.rfind('L'),+Some(13));%0A++++assert_eq!(s.rfind('%C3%A9'),+Some(14));%0A++++assert_eq!(s.rfind(%22pard%22),+Some(24));%0A%7D&amp;edition=2024"></a></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="macro">assert_eq!</span>(s.rfind(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(s.rfind(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++%0A++++assert_eq!(s.rfind(char::is_whitespace),+Some(12));%0A++++assert_eq!(s.rfind(char::is_lowercase),+Some(20));%0A%7D&amp;edition=2024"></a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.rfind(x), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++%0A++++assert_eq!(s.rfind(x),+None);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1639-1647">Source</a></span><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;_, P&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>If there are no matches the full string slice is returned as the only
item in the iterator.</p>
<h5 id="iterator-behavior"><a class="doc-anchor" href="#iterator-behavior">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.split(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a"</span>, <span class="string">"little"</span>, <span class="string">"lamb"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.split(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"AABBCC"</span>.split(<span class="string">"DD"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"AABBCC"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1def2ghi"</span>.split(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXtigerXleopard"</span>.split(char::is_uppercase).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.split('+').collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a%22,+%22little%22,+%22lamb%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.split('X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.split('X').collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.split(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22AABBCC%22.split(%22DD%22).collect();%0A++++assert_eq!(v,+%5B%22AABBCC%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1def2ghi%22.split(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXtigerXleopard%22.split(char::is_uppercase).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22tiger%22,+%22leopard%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"2020-11-03 23:59"</span>.split(<span class="kw-2">&amp;</span>[<span class="string">'-'</span>, <span class="string">' '</span>, <span class="string">':'</span>, <span class="string">'@'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"2020"</span>, <span class="string">"11"</span>, <span class="string">"03"</span>, <span class="string">"23"</span>, <span class="string">"59"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%222020-11-03+23:59%22.split(%26%5B'-',+'+',+':',+'%40'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%222020%22,+%2211%22,+%2203%22,+%2223%22,+%2259%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.split(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.split(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22def%22,+%22ghi%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"||||a||b|c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'|'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22%7C%7C%7C%7Ca%7C%7Cb%7Cc%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('%7C').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"(///)"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'/'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"("</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">")"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22(///)%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('/').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22(%22,+%22%22,+%22%22,+%22)%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"010"</span>.split(<span class="string">"0"</span>).collect();
<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">""</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+d:+Vec%3C_%3E+=+%22010%22.split(%220%22).collect();%0A++++assert_eq!(d,+%26%5B%22%22,+%221%22,+%22%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"rust"</span>.split(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(f, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"r"</span>, <span class="string">"u"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">""</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+f:+Vec%3C_%3E+=+%22rust%22.split(%22%22).collect();%0A++++assert_eq!(f,+%26%5B%22%22,+%22r%22,+%22u%22,+%22s%22,+%22t%22,+%22%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"    a  b c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">' '</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+%22++++a++b+c%22.to_string();%0A++++let+d:+Vec%3C_%3E+=+x.split('+').collect();%0A++++%0A++++assert_eq!(d,+%26%5B%22%22,+%22%22,+%22%22,+%22%22,+%22a%22,+%22%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>It does <em>not</em> give you:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(d,+%26%5B%22a%22,+%22b%22,+%22c%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>Use <a href="primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1680-1688">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.SplitInclusive.html" title="struct core::str::SplitInclusive">SplitInclusive</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitInclusive&lt;&#39;_, P&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>Differs from the iterator produced by <code>split</code> in that <code>split_inclusive</code>
leaves the matched part as the terminator of the substring.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb."
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb."</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%22%0A++++++++.split_inclusive('%5Cn').collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb.\n"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%5Cnlittle+lamb%5Cnlittle+lamb.%5Cn%22%0A++++++++.split_inclusive('%5Cn').collect();%0A++++assert_eq!(v,+%5B%22Mary+had+a+little+lamb%5Cn%22,+%22little+lamb%5Cn%22,+%22little+lamb.%5Cn%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1735-1740">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplit&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1"><a class="doc-anchor" href="#iterator-behavior-1">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplit(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"a"</span>, <span class="string">"had"</span>, <span class="string">"Mary"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">""</span>, <span class="string">"lion"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplit(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplit('+').collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22a%22,+%22had%22,+%22Mary%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.rsplit('X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplit('X').collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22%22,+%22lion%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplit(%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lion%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplit(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"def"</span>, <span class="string">"abc"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplit(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22def%22,+%22abc%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1784-1786">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fn">split_terminator</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitTerminator&lt;&#39;_, P&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2"><a class="doc-anchor" href="#iterator-behavior-2">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.split_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.split_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.split_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.split_terminator('.').collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.split_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22%22,+%22B%22,+%22%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.split_terminator(%26%5B'.',+':'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22A%22,+%22B%22,+%22C%22,+%22D%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1830-1835">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fn">rsplit_terminator</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplitTerminator&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3"><a class="doc-anchor" href="#iterator-behavior-3">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.rsplit_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"B"</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.rsplit_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.rsplit_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B.%22.rsplit_terminator('.').collect();%0A++++assert_eq!(v,+%5B%22B%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A..B..%22.rsplit_terminator(%22.%22).collect();%0A++++assert_eq!(v,+%5B%22%22,+%22B%22,+%22%22,+%22A%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22A.B:C.D%22.rsplit_terminator(%26%5B'.',+':'%5D%5B..%5D).collect();%0A++++assert_eq!(v,+%5B%22D%22,+%22C%22,+%22B%22,+%22A%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1885-1887">Source</a></span><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;_, P&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by a pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4"><a class="doc-anchor" href="#iterator-behavior-4">Â§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lambda"</span>.splitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a little lambda"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.splitn(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tigerXleopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXdef"</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abcXdef"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lambda%22.splitn(3,+'+').collect();%0A++++assert_eq!(v,+%5B%22Mary%22,+%22had%22,+%22a+little+lambda%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.splitn(3,+%22X%22).collect();%0A++++assert_eq!(v,+%5B%22lion%22,+%22%22,+%22tigerXleopard%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXdef%22.splitn(1,+'X').collect();%0A++++assert_eq!(v,+%5B%22abcXdef%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22%22.splitn(1,+'X').collect();%0A++++assert_eq!(v,+%5B%22%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.splitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"defXghi"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.splitn(2,+%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22defXghi%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1934-1939">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplitN&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning at
most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5"><a class="doc-anchor" href="#iterator-behavior-5">Â§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"Mary had a"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplitn(<span class="number">3</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lionX"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplitn(<span class="number">2</span>, <span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"lion::tiger"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22Mary+had+a+little+lamb%22.rsplitn(3,+'+').collect();%0A++++assert_eq!(v,+%5B%22lamb%22,+%22little%22,+%22Mary+had+a%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lionXXtigerXleopard%22.rsplitn(3,+'X').collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22tiger%22,+%22lionX%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%22lion::tiger::leopard%22.rsplitn(2,+%22::%22).collect();%0A++++assert_eq!(v,+%5B%22leopard%22,+%22lion::tiger%22%5D);%0A%7D&amp;edition=2024"></a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"abc1def"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abc1defXghi%22.rsplitn(2,+%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X').collect();%0A++++assert_eq!(v,+%5B%22ghi%22,+%22abc1def%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1954-1958">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_once" class="fn">split_once</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, delimiter: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a>)&gt;</h4></section></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg="</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">""</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo=bar"</span>)));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.split_once('='),+None);%0A++++assert_eq!(%22cfg=%22.split_once('='),+Some((%22cfg%22,+%22%22)));%0A++++assert_eq!(%22cfg=foo%22.split_once('='),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.split_once('='),+Some((%22cfg%22,+%22foo=bar%22)));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#1973-1980">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fn">rsplit_once</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, delimiter: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a>)&gt;<div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg="</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">""</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg=foo"</span>, <span class="string">"bar"</span>)));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22cfg%22.rsplit_once('='),+None);%0A++++assert_eq!(%22cfg=%22.rsplit_once('='),+Some((%22cfg%22,+%22%22)));%0A++++assert_eq!(%22cfg=foo%22.rsplit_once('='),+Some((%22cfg%22,+%22foo%22)));%0A++++assert_eq!(%22cfg=foo=bar%22.rsplit_once('='),+Some((%22cfg=foo%22,+%22bar%22)));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2013-2015">Source</a></span><h4 class="code-header">pub fn <a href="#method.matches" class="fn">matches</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="Matches&lt;&#39;_, P&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within the
given string slice.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6"><a class="doc-anchor" href="#iterator-behavior-6">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.matches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.matches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.matches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.matches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%221%22,+%222%22,+%223%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2047-2052">Source</a></span><h4 class="code-header">pub fn <a href="#method.rmatches" class="fn">rmatches</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RMatches&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within this
string slice, yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7"><a class="doc-anchor" href="#iterator-behavior-7">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.rmatches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"1"</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C%26str%3E+=+%22abcXXXabcYYYabc%22.rmatches(%22abc%22).collect();%0A++++assert_eq!(v,+%5B%22abc%22,+%22abc%22,+%22abc%22%5D);%0A++++%0A++++let+v:+Vec%3C%26str%3E+=+%221abc2abc3%22.rmatches(char::is_numeric).collect();%0A++++assert_eq!(v,+%5B%223%22,+%222%22,+%221%22%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2091-2093">Source</a></span><h4 class="code-header">pub fn <a href="#method.match_indices" class="fn">match_indices</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="MatchIndices&lt;&#39;_, P&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8"><a class="doc-anchor" href="#iterator-behavior-8">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">12</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">1</span>, <span class="string">"abc"</span>), (<span class="number">4</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.match_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the first `aba`</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22abc%22),+(6,+%22abc%22),+(12,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.match_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(1,+%22abc%22),+(4,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.match_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(0,+%22aba%22)%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2131-2136">Source</a></span><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fn">rmatch_indices</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RMatchIndices&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9"><a class="doc-anchor" href="#iterator-behavior-9">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">12</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">0</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">4</span>, <span class="string">"abc"</span>), (<span class="number">1</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.rmatch_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">2</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the last `aba`</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+v:+Vec%3C_%3E+=+%22abcXXXabcYYYabc%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(12,+%22abc%22),+(6,+%22abc%22),+(0,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%221abcabc2%22.rmatch_indices(%22abc%22).collect();%0A++++assert_eq!(v,+%5B(4,+%22abc%22),+(1,+%22abc%22)%5D);%0A++++%0A++++let+v:+Vec%3C_%3E+=+%22ababa%22.rmatch_indices(%22aba%22).collect();%0A++++assert_eq!(v,+%5B(2,+%22aba%22)%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2155-2157">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld"</span>, s.trim());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%22,+s.trim());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2194-2196">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality"><a class="doc-anchor" href="#text-directionality">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t\n"</span>, s.trim_start());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%5Cn%22,+s.trim_start());%0A%7D&amp;edition=2024"></a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_start().chars().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×¢'</span>) == s.trim_start().chars().next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some('E')+==+s.trim_start().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%A2')+==+s.trim_start().chars().next());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2233-2235">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality-1"><a class="doc-anchor" href="#text-directionality-1">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"\n Hello\tworld"</span>, s.trim_end());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22%5Cn+Hello%5Ctworld%5Ct%5Cn%22;%0A++++assert_eq!(%22%5Cn+Hello%5Ctworld%22,+s.trim_end());%0A%7D&amp;edition=2024"></a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_end().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×ª'</span>) == s.trim_end().chars().rev().next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English++%22;%0A++++assert!(Some('h')+==+s.trim_end().chars().rev().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%AA')+==+s.trim_end().chars().rev().next());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.trim_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2273-2275">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left" class="fn">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2"><a class="doc-anchor" href="#text-directionality-2">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t"</span>, s.trim_left());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22Hello%5Ctworld%5Ct%22,+s.trim_left());%0A%7D&amp;edition=2024"></a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_left().chars().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×¢'</span>) == s.trim_left().chars().next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22++English%22;%0A++++assert!(Some('E')+==+s.trim_left().chars().next());%0A++++%0A++++let+s+=+%22++%D7%A2%D7%91%D7%A8%D7%99%D7%AA%22;%0A++++assert!(Some('%D7%A2')+==+s.trim_left().chars().next());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.trim_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2313-2315">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right" class="fn">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3"><a class="doc-anchor" href="#text-directionality-3">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">" Hello\tworld"</span>, s.trim_right());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22+Hello%5Ctworld%5Ct%22;%0A++++%0A++++assert_eq!(%22+Hello%5Ctworld%22,+s.trim_right());%0A%7D&amp;edition=2024"></a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_right().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×ª'</span>) == s.trim_right().chars().rev().next());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22English++%22;%0A++++assert!(Some('h')+==+s.trim_right().chars().rev().next());%0A++++%0A++++let+s+=+%22%D7%A2%D7%91%D7%A8%D7%99%D7%AA++%22;%0A++++assert!(Some('%D7%AA')+==+s.trim_right().chars().rev().next());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2346-2363">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fn">trim_matches</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.DoubleEndedSearcher.html" title="trait core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_matches(<span class="string">'1'</span>), <span class="string">"foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_matches(char::is_numeric), <span class="string">"foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_matches(x), <span class="string">"foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_matches('1'),+%22foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_matches(char::is_numeric),+%22foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_matches(x),+%22foo1bar%22);%0A%7D&amp;edition=2024"></a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1foo1barXX"</span>.trim_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221foo1barXX%22.trim_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%22foo1bar%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2393-2401">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fn">trim_start_matches</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4"><a class="doc-anchor" href="#text-directionality-4">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_start_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_start_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_start_matches(x), <span class="string">"foo1bar12"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_start_matches('1'),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_start_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_start_matches(x),+%22foo1bar12%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2427-2429">Source</a></span><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, prefix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix,
wrapped in <code>Some</code>. Unlike <a href="primitive.str.html#method.trim_start_matches" title="method str::trim_start_matches"><code>trim_start_matches</code></a>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-53"><a class="doc-anchor" href="#examples-53">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"foo:"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_prefix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22foo:%22),+Some(%22bar%22));%0A++++assert_eq!(%22foo:bar%22.strip_prefix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_prefix(%22foo%22),+Some(%22foo%22));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2455-2460">Source</a></span><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, suffix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <a href="primitive.str.html#method.trim_end_matches" title="method str::trim_end_matches"><code>trim_end_matches</code></a>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-54"><a class="doc-anchor" href="#examples-54">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">":foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_suffix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22:foo%22),+Some(%22bar%22));%0A++++assert_eq!(%22bar:foo%22.strip_suffix(%22bar%22),+None);%0A++++assert_eq!(%22foofoo%22.strip_suffix(%22foo%22),+Some(%22foo%22));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.strip_circumfix" class="method"><a class="src rightside" href="../src/core/str/mod.rs.html#2491-2496">Source</a><h4 class="code-header">pub fn <a href="#method.strip_circumfix" class="fn">strip_circumfix</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>, S: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(
    &amp;self,
    prefix: P,
    suffix: S,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    for&lt;'a&gt; S::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>strip_circumfix</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/147946">#147946</a>)</span></div></span></summary><div class="docblock"><p>Returns a string slice with the prefix and suffix removed.</p>
<p>If the string starts with the pattern <code>prefix</code> and ends with the pattern <code>suffix</code>, returns
the substring after the prefix and before the suffix, wrapped in <code>Some</code>.
Unlike <a href="primitive.str.html#method.trim_start_matches" title="method str::trim_start_matches"><code>trim_start_matches</code></a> and <a href="primitive.str.html#method.trim_end_matches" title="method str::trim_end_matches"><code>trim_end_matches</code></a>, this method removes both the prefix
and suffix exactly once.</p>
<p>If the string does not start with <code>prefix</code> or does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>Each <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-55"><a class="doc-anchor" href="#examples-55">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(strip_circumfix)]

</span><span class="macro">assert_eq!</span>(<span class="string">"bar:hello:foo"</span>.strip_circumfix(<span class="string">"bar:"</span>, <span class="string">":foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"hello"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_circumfix(<span class="string">"foo"</span>, <span class="string">"foo"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foo:bar;"</span>.strip_circumfix(<span class="string">"foo:"</span>, <span class="string">';'</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(strip_circumfix)%5D%0A%0A%0Afn+main()+%7B%0A++++assert_eq!(%22bar:hello:foo%22.strip_circumfix(%22bar:%22,+%22:foo%22),+Some(%22hello%22));%0A++++assert_eq!(%22bar:foo%22.strip_circumfix(%22foo%22,+%22foo%22),+None);%0A++++assert_eq!(%22foo:bar;%22.strip_circumfix(%22foo:%22,+';'),+Some(%22bar%22));%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_prefix" class="method"><a class="src rightside" href="../src/core/str/mod.rs.html#2531-2533">Source</a><h4 class="code-header">pub fn <a href="#method.trim_prefix" class="fn">trim_prefix</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, prefix: P) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>trim_prefix_suffix</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/142312">#142312</a>)</span></div></span></summary><div class="docblock"><p>Returns a string slice with the optional prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix.
Unlike <a href="primitive.str.html#method.strip_prefix" title="method str::strip_prefix"><code>strip_prefix</code></a>, this method always returns <code>&amp;str</code> for easy method chaining,
instead of returning <a href="option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;&amp;str&gt;</code></a>.</p>
<p>If the string does not start with <code>prefix</code>, returns the original string unchanged.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-56"><a class="doc-anchor" href="#examples-56">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(trim_prefix_suffix)]

</span><span class="comment">// Prefix present - removes it
</span><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.trim_prefix(<span class="string">"foo:"</span>), <span class="string">"bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.trim_prefix(<span class="string">"foo"</span>), <span class="string">"foo"</span>);

<span class="comment">// Prefix absent - returns original string
</span><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.trim_prefix(<span class="string">"bar"</span>), <span class="string">"foo:bar"</span>);

<span class="comment">// Method chaining example
</span><span class="macro">assert_eq!</span>(<span class="string">"&lt;https://example.com/&gt;"</span>.trim_prefix(<span class="string">'&lt;'</span>).trim_suffix(<span class="string">'&gt;'</span>), <span class="string">"https://example.com/"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(trim_prefix_suffix)%5D%0A%0A%0A//+Prefix+present+-+removes+it%0Afn+main()+%7B%0A++++assert_eq!(%22foo:bar%22.trim_prefix(%22foo:%22),+%22bar%22);%0A++++assert_eq!(%22foofoo%22.trim_prefix(%22foo%22),+%22foo%22);%0A++++%0A++++//+Prefix+absent+-+returns+original+string%0A++++assert_eq!(%22foo:bar%22.trim_prefix(%22bar%22),+%22foo:bar%22);%0A++++%0A++++//+Method+chaining+example%0A++++assert_eq!(%22%3Chttps://example.com/%3E%22.trim_prefix('%3C').trim_suffix('%3E'),+%22https://example.com/%22);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_suffix" class="method"><a class="src rightside" href="../src/core/str/mod.rs.html#2568-2573">Source</a><h4 class="code-header">pub fn <a href="#method.trim_suffix" class="fn">trim_suffix</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, suffix: P) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>trim_prefix_suffix</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/142312">#142312</a>)</span></div></span></summary><div class="docblock"><p>Returns a string slice with the optional suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix.
Unlike <a href="primitive.str.html#method.strip_suffix" title="method str::strip_suffix"><code>strip_suffix</code></a>, this method always returns <code>&amp;str</code> for easy method chaining,
instead of returning <a href="option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;&amp;str&gt;</code></a>.</p>
<p>If the string does not end with <code>suffix</code>, returns the original string unchanged.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-57"><a class="doc-anchor" href="#examples-57">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(trim_prefix_suffix)]

</span><span class="comment">// Suffix present - removes it
</span><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.trim_suffix(<span class="string">":foo"</span>), <span class="string">"bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.trim_suffix(<span class="string">"foo"</span>), <span class="string">"foo"</span>);

<span class="comment">// Suffix absent - returns original string
</span><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.trim_suffix(<span class="string">"bar"</span>), <span class="string">"bar:foo"</span>);

<span class="comment">// Method chaining example
</span><span class="macro">assert_eq!</span>(<span class="string">"&lt;https://example.com/&gt;"</span>.trim_prefix(<span class="string">'&lt;'</span>).trim_suffix(<span class="string">'&gt;'</span>), <span class="string">"https://example.com/"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(trim_prefix_suffix)%5D%0A%0A%0A//+Suffix+present+-+removes+it%0Afn+main()+%7B%0A++++assert_eq!(%22bar:foo%22.trim_suffix(%22:foo%22),+%22bar%22);%0A++++assert_eq!(%22foofoo%22.trim_suffix(%22foo%22),+%22foo%22);%0A++++%0A++++//+Suffix+absent+-+returns+original+string%0A++++assert_eq!(%22bar:foo%22.trim_suffix(%22bar%22),+%22bar:foo%22);%0A++++%0A++++//+Method+chaining+example%0A++++assert_eq!(%22%3Chttps://example.com/%3E%22.trim_prefix('%3C').trim_suffix('%3E'),+%22https://example.com/%22);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2611-2622">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fn">trim_end_matches</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5"><a class="doc-anchor" href="#text-directionality-5">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-58"><a class="doc-anchor" href="#examples-58">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_end_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_end_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_end_matches(x), <span class="string">"12foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_end_matches('1'),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_end_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_end_matches(x),+%2212foo1bar%22);%0A%7D&amp;edition=2024"></a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_end_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_end_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%221foo%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.trim_left_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2655-2657">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fn">trim_left_matches</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6"><a class="doc-anchor" href="#text-directionality-6">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-59"><a class="doc-anchor" href="#examples-59">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_left_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_left_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_left_matches(x), <span class="string">"foo1bar12"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_left_matches('1'),+%22foo1bar11%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_left_matches(char::is_numeric),+%22foo1bar123%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_left_matches(x),+%22foo1bar12%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.trim_right_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2698-2703">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fn">trim_right_matches</a>&lt;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a><div class="where">where
    for&lt;'a&gt; P::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7"><a class="doc-anchor" href="#text-directionality-7">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-60"><a class="doc-anchor" href="#examples-60">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_right_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_right_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_right_matches(x), <span class="string">"12foo1bar"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%2211foo1bar11%22.trim_right_matches('1'),+%2211foo1bar%22);%0A++++assert_eq!(%22123foo1bar123%22.trim_right_matches(char::is_numeric),+%22123foo1bar%22);%0A++++%0A++++let+x:+%26%5B_%5D+=+%26%5B'1',+'2'%5D;%0A++++assert_eq!(%2212foo1bar12%22.trim_right_matches(x),+%2212foo1bar%22);%0A%7D&amp;edition=2024"></a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_right_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%221fooX%22.trim_right_matches(%7Cc%7C+c+==+'1'+%7C%7C+c+==+'X'),+%221foo%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2749-2751">Source</a></span><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>&lt;F: <a class="trait" href="str/trait.FromStr.html" title="trait core::str::FromStr">FromStr</a>&gt;(&amp;self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="associatedtype" href="str/trait.FromStr.html#associatedtype.Err" title="type core::str::FromStr::Err">Err</a>&gt;</h4></section></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times youâ€™ll see
the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
youâ€™re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="str/trait.FromStr.html" title="trait core::str::FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">Â§</a>Errors</h5>
<p>Will return <a href="str/trait.FromStr.html#associatedtype.Err" title="associated type core::str::FromStr::Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-61"><a class="doc-anchor" href="#examples-61">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four: u32 = <span class="string">"4"</span>.parse().unwrap();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, four);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four:+u32+=+%224%22.parse().unwrap();%0A++++%0A++++assert_eq!(4,+four);%0A%7D&amp;edition=2024"></a></div>
<p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four = <span class="string">"4"</span>.parse::&lt;u32&gt;();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), four);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+four+=+%224%22.parse::%3Cu32%3E();%0A++++%0A++++assert_eq!(Ok(4),+four);%0A%7D&amp;edition=2024"></a></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nope = <span class="string">"j"</span>.parse::&lt;u32&gt;();

<span class="macro">assert!</span>(nope.is_err());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+nope+=+%22j%22.parse::%3Cu32%3E();%0A++++%0A++++assert!(nope.is_err());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.74.0">1.23.0 (const: 1.74.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2770-2775">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<p>An empty string returns <code>true</code>.</p>
<h5 id="examples-62"><a class="doc-anchor" href="#examples-62">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ascii = <span class="string">"hello!\n"</span>;
<span class="kw">let </span>non_ascii = <span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>;

<span class="macro">assert!</span>(ascii.is_ascii());
<span class="macro">assert!</span>(!non_ascii.is_ascii());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ascii+=+%22hello!%5Cn%22;%0A++++let+non_ascii+=+%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22;%0A++++%0A++++assert!(ascii.is_ascii());%0A++++assert!(!non_ascii.is_ascii());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii" class="method"><a class="src rightside" href="../src/core/str/mod.rs.html#2782-2785">Source</a><h4 class="code-header">pub const fn <a href="#method.as_ascii" class="fn">as_ascii</a>(&amp;self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="enum" href="ascii/enum.Char.html" title="enum core::ascii::Char">Char</a>]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/110998">#110998</a>)</span></div></span></summary><div class="docblock"><p>If this string slice <a href="primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice
of <a href="ascii/enum.Char.html" title="enum core::ascii::Char">ASCII characters</a>, otherwise returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii_unchecked" class="method"><a class="src rightside" href="../src/core/str/mod.rs.html#2796-2806">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_ascii_unchecked" class="fn">as_ascii_unchecked</a>(&amp;self) -&gt; &amp;[<a class="enum" href="ascii/enum.Char.html" title="enum core::ascii::Char">Char</a>]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/110998">#110998</a>)</span></div></span></summary><div class="docblock"><p>Converts this string slice into a slice of <a href="ascii/enum.Char.html" title="enum core::ascii::Char">ASCII characters</a>,
without checking whether they are valid.</p>
<h5 id="safety-6"><a class="doc-anchor" href="#safety-6">Â§</a>Safety</h5>
<p>Every character in this string must be ASCII, or else this is UB.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.89.0">1.23.0 (const: 1.89.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2824-2826">Source</a></span><h4 class="code-header">pub const fn <a href="#method.eq_ignore_ascii_case" class="fn">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-63"><a class="doc-anchor" href="#examples-63">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">"Ferris"</span>.eq_ignore_ascii_case(<span class="string">"FERRIS"</span>));
<span class="macro">assert!</span>(<span class="string">"FerrÃ¶s"</span>.eq_ignore_ascii_case(<span class="string">"FERRÃ¶S"</span>));
<span class="macro">assert!</span>(!<span class="string">"FerrÃ¶s"</span>.eq_ignore_ascii_case(<span class="string">"FERRÃ–S"</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert!(%22Ferris%22.eq_ignore_ascii_case(%22FERRIS%22));%0A++++assert!(%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%B6S%22));%0A++++assert!(!%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%96S%22));%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.84.0">1.23.0 (const: 1.84.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2850-2854">Source</a></span><h4 class="code-header">pub const fn <a href="#method.make_ascii_uppercase" class="fn">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Converts this string to its ASCII upper case equivalent in-place.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new uppercased value without modifying the existing one, use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase()</code></a>.</p>
<h5 id="examples-64"><a class="doc-anchor" href="#examples-64">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>);

s.make_ascii_uppercase();

<span class="macro">assert_eq!</span>(<span class="string">"GRÃ¼ÃŸE, JÃ¼RGEN â¤"</span>, s);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22Gr%C3%BC%C3%9Fe,+J%C3%BCrgen+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_uppercase();%0A++++%0A++++assert_eq!(%22GR%C3%BC%C3%9FE,+J%C3%BCRGEN+%E2%9D%A4%22,+s);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const since 1.84.0">1.23.0 (const: 1.84.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2878-2882">Source</a></span><h4 class="code-header">pub const fn <a href="#method.make_ascii_lowercase" class="fn">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Converts this string to its ASCII lower case equivalent in-place.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new lowercased value without modifying the existing one, use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase()</code></a>.</p>
<h5 id="examples-65"><a class="doc-anchor" href="#examples-65">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::from(<span class="string">"GRÃœÃŸE, JÃœRGEN â¤"</span>);

s.make_ascii_lowercase();

<span class="macro">assert_eq!</span>(<span class="string">"grÃœÃŸe, jÃœrgen â¤"</span>, s);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+String::from(%22GR%C3%9C%C3%9FE,+J%C3%9CRGEN+%E2%9D%A4%22);%0A++++%0A++++s.make_ascii_lowercase();%0A++++%0A++++assert_eq!(%22gr%C3%9C%C3%9Fe,+j%C3%9Crgen+%E2%9D%A4%22,+s);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2903-2907">Source</a></span><h4 class="code-header">pub const fn <a href="#method.trim_ascii_start" class="fn">trim_ascii_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading ASCII whitespace removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-66"><a class="doc-anchor" href="#examples-66">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">" \t \u{3000}hello world\n"</span>.trim_ascii_start(), <span class="string">"\u{3000}hello world\n"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_start(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_start(), <span class="string">""</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22+%5Ct+%5Cu%7B3000%7Dhello+world%5Cn%22.trim_ascii_start(),+%22%5Cu%7B3000%7Dhello+world%5Cn%22);%0A++++assert_eq!(%22++%22.trim_ascii_start(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_start(),+%22%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2928-2932">Source</a></span><h4 class="code-header">pub const fn <a href="#method.trim_ascii_end" class="fn">trim_ascii_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing ASCII whitespace removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-67"><a class="doc-anchor" href="#examples-67">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\u{3000}\n "</span>.trim_ascii_end(), <span class="string">"\r hello world\u{3000}"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_end(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_end(), <span class="string">""</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cu%7B3000%7D%5Cn+%22.trim_ascii_end(),+%22%5Cr+hello+world%5Cu%7B3000%7D%22);%0A++++assert_eq!(%22++%22.trim_ascii_end(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii_end(),+%22%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0, const since 1.80.0">1.80.0 (const: 1.80.0)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2954-2958">Source</a></span><h4 class="code-header">pub const fn <a href="#method.trim_ascii" class="fn">trim_ascii</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing ASCII whitespace
removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-68"><a class="doc-anchor" href="#examples-68">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\n "</span>.trim_ascii(), <span class="string">"hello world"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii(), <span class="string">""</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%5Cr+hello+world%5Cn+%22.trim_ascii(),+%22hello+world%22);%0A++++assert_eq!(%22++%22.trim_ascii(),+%22%22);%0A++++assert_eq!(%22%22.trim_ascii(),+%22%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#2997-3007">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fn">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDebug.html" title="struct core::str::EscapeDebug">EscapeDebug</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeDebug&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-69"><a class="doc-anchor" href="#examples-69">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_debug() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_debug()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2024"></a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_debug());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_debug());%0A%7D&amp;edition=2024"></a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"â¤\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%E2%9D%A4%5C%5Cn!%22);%0A%7D&amp;edition=2024"></a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_debug().to_string(), <span class="string">"â¤\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_debug().to_string(),+%22%E2%9D%A4%5C%5Cn!%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#3043-3045">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_default" class="fn">escape_default</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDefault.html" title="struct core::str::EscapeDefault">EscapeDefault</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeDefault&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-70"><a class="doc-anchor" href="#examples-70">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_default() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_default()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2024"></a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_default());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_default());%0A%7D&amp;edition=2024"></a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cn!%22);%0A%7D&amp;edition=2024"></a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_default().to_string(), <span class="string">"\\u{2764}\\n!"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_default().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cn!%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#3081-3083">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fn">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeUnicode.html" title="struct core::str::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeUnicode&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-71"><a class="doc-anchor" href="#examples-71">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_unicode() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++for+c+in+%22%E2%9D%A4%5Cn!%22.escape_unicode()+%7B%0A++++++++print!(%22%7Bc%7D%22);%0A++++%7D%0A++++println!();%0A%7D&amp;edition=2024"></a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_unicode());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%7B%7D%22,+%22%E2%9D%A4%5Cn!%22.escape_unicode());%0A%7D&amp;edition=2024"></a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\u{{a}}\\u{{21}}"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cu%7B%7Ba%7D%7D%5C%5Cu%7B%7B21%7D%7D%22);%0A%7D&amp;edition=2024"></a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_unicode().to_string(), <span class="string">"\\u{2764}\\u{a}\\u{21}"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22%E2%9D%A4%5Cn!%22.escape_unicode().to_string(),+%22%5C%5Cu%7B2764%7D%5C%5Cu%7Ba%7D%5C%5Cu%7B21%7D%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.substr_range" class="method"><a class="src rightside" href="../src/core/str/mod.rs.html#3114-3116">Source</a><h4 class="code-header">pub fn <a href="#method.substr_range" class="fn">substr_range</a>(&amp;self, substr: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="ops/struct.Range.html" title="struct core::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>substr_range</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/126769">#126769</a>)</span></div></span></summary><div class="docblock"><p>Returns the range that a substring points to.</p>
<p>Returns <code>None</code> if <code>substr</code> does not point within <code>self</code>.</p>
<p>Unlike <a href="primitive.str.html#method.find" title="method str::find"><code>str::find</code></a>, <strong>this does not search through the string</strong>.
Instead, it uses pointer arithmetic to find where in the string
<code>substr</code> is derived from.</p>
<p>This is useful for extending <a href="primitive.str.html#method.split" title="method str::split"><code>str::split</code></a> and similar methods.</p>
<p>Note that this method may return false positives (typically either
<code>Some(0..0)</code> or <code>Some(self.len()..self.len())</code>) if <code>substr</code> is a
zero-length <code>str</code> that points at the beginning or end of another,
independent, <code>str</code>.</p>
<h5 id="examples-72"><a class="doc-anchor" href="#examples-72">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(substr_range)]

</span><span class="kw">let </span>data = <span class="string">"a, b, b, a"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>iter = data.split(<span class="string">", "</span>).map(|s| data.substr_range(s).unwrap());

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">0</span>..<span class="number">1</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">3</span>..<span class="number">4</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">6</span>..<span class="number">7</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">9</span>..<span class="number">10</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(substr_range)%5D%0A%0A%0Afn+main()+%7B%0A++++let+data+=+%22a,+b,+b,+a%22;%0A++++let+mut+iter+=+data.split(%22,+%22).map(%7Cs%7C+data.substr_range(s).unwrap());%0A++++%0A++++assert_eq!(iter.next(),+Some(0..1));%0A++++assert_eq!(iter.next(),+Some(3..4));%0A++++assert_eq!(iter.next(),+Some(6..7));%0A++++assert_eq!(iter.next(),+Some(9..10));%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_str" class="method"><a class="src rightside" href="../src/core/str/mod.rs.html#3125-3127">Source</a><h4 class="code-header">pub const fn <a href="#method.as_str" class="fn">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>str_as_str</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/130366">#130366</a>)</span></div></span></summary><div class="docblock"><p>Returns the same string as a string slice <code>&amp;str</code>.</p>
<p>This method is redundant when used directly on <code>&amp;str</code>, but
it helps dereferencing other string-like types to string slices,
for example references to <code>Box&lt;str&gt;</code> or <code>Arc&lt;str&gt;</code>.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsMut%3Cstr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0, const unstable">1.51.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> Â· <a class="src" href="../src/core/convert/mod.rs.html#872-877">Source</a></span><a href="#impl-AsMut%3Cstr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#874-876">Source</a><a href="#method.as_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsMut.html#tymethod.as_mut" class="fn">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3C%5Bu8%5D%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#3132-3137">Source</a></span><a href="#impl-AsRef%3C%5Bu8%5D%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="primitive.u8.html">u8</a>]&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-2" class="method trait-impl"><a class="src rightside" href="../src/core/str/mod.rs.html#3134-3136">Source</a><a href="#method.as_ref-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="primitive.u8.html">u8</a>]</h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3CByteStr%3E-for-str" class="impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#240-245">Source</a><a href="#impl-AsRef%3CByteStr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-1" class="method trait-impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#242-244">Source</a><a href="#method.as_ref-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3Cstr%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> Â· <a class="src" href="../src/core/convert/mod.rs.html#863-868">Source</a></span><a href="#impl-AsRef%3Cstr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#865-867">Source</a><a href="#method.as_ref" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-CloneToUninit-for-str" class="impl"><a class="src rightside" href="../src/core/clone.rs.html#567-574">Source</a><a href="#impl-CloneToUninit-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#570-573">Source</a><a href="#method.clone_to_uninit" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/fmt/mod.rs.html#2909-2955">Source</a></span><a href="#impl-Debug-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/mod.rs.html#2910-2954">Source</a><a href="#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-%26mut+str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0, const unstable">1.28.0 (const: <a href="https://github.com/rust-lang/rust/issues/143894" title="Tracking issue for const_default">unstable</a>)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#3151-3158">Source</a></span><a href="#impl-Default-for-%26mut+str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;mut <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default-1" class="method trait-impl"><a class="src rightside" href="../src/core/str/mod.rs.html#3154-3157">Source</a><a href="#method.default-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates an empty mutable str</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143894" title="Tracking issue for const_default">unstable</a>)</span> Â· <a class="src" href="../src/core/str/mod.rs.html#3141-3147">Source</a></span><a href="#impl-Default-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;<a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../src/core/str/mod.rs.html#3144-3146">Source</a><a href="#method.default" class="anchor">Â§</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates an empty str</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/fmt/mod.rs.html#2958-2962">Source</a></span><a href="#impl-Display-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/mod.rs.html#2959-2961">Source</a><a href="#method.fmt-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/hash/mod.rs.html#863-868">Source</a></span><a href="#impl-Hash-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/core/hash/mod.rs.html#865-867">Source</a><a href="#method.hash" class="anchor">Â§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H: <a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Index%3CI%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#55-65">Source</a></span><a href="#impl-Index%3CI%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl&lt;I&gt; <a class="trait" href="ops/trait.Index.html" title="trait core::ops::Index">Index</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#59">Source</a><a href="#associatedtype.Output" class="anchor">Â§</a><h4 class="code-header">type <a href="ops/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class="toggle method-toggle" open><summary><section id="method.index" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#62-64">Source</a><a href="#method.index" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.Index.html#tymethod.index" class="fn">index</a>(&amp;self, index: I) -&gt; &amp;I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href="ops/trait.Index.html#tymethod.index">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CI%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#69-77">Source</a></span><a href="#impl-IndexMut%3CI%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl&lt;I&gt; <a class="trait" href="ops/trait.IndexMut.html" title="trait core::ops::IndexMut">IndexMut</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#74-76">Source</a><a href="#method.index_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="ops/trait.IndexMut.html#tymethod.index_mut" class="fn">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="ops/trait.IndexMut.html#tymethod.index_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/traits.rs.html#18-23">Source</a></span><a href="#impl-Ord-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.str.html">str</a></h3><div class="docblock"><p>Implements ordering of strings.</p>
</div></section></summary><div class="docblock"><p>Strings are ordered  <a href="cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">lexicographically</a> by their byte values. This orders Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Sorting strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#20-22">Source</a><a href="#method.cmp" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26str%3E-for-ByteStr" class="impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#143">Source</a><a href="#impl-PartialEq%3C%26str%3E-for-ByteStr" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#143">Source</a><a href="#method.eq-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;&amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#264-266">Source</a></span><a href="#method.ne-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CByteStr%3E-for-%26str" class="impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#143">Source</a><a href="#impl-PartialEq%3CByteStr%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>&gt; for &amp;<a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#143">Source</a><a href="#method.eq-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#264-266">Source</a></span><a href="#method.ne-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CByteStr%3E-for-str" class="impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#141">Source</a><a href="#impl-PartialEq%3CByteStr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#141">Source</a><a href="#method.eq-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#264-266">Source</a></span><a href="#method.ne-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-ByteStr" class="impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#141">Source</a><a href="#impl-PartialEq%3Cstr%3E-for-ByteStr" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/core/bstr/traits.rs.html#141">Source</a><a href="#method.eq" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#264-266">Source</a></span><a href="#method.ne" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#27-32">Source</a></span><a href="#impl-PartialEq-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-4" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#29-31">Source</a><a href="#method.eq-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#264-266">Source</a></span><a href="#method.ne-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/str/traits.rs.html#46-51">Source</a></span><a href="#impl-PartialOrd-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="primitive" href="primitive.str.html">str</a></h3><div class="docblock"><p>Implements comparison operations on strings.</p>
</div></section></summary><div class="docblock"><p>Strings are compared <a href="cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">lexicographically</a> by their byte values. This compares Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Comparing strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#48-50">Source</a><a href="#method.partial_cmp" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#1402-1404">Source</a></span><a href="#method.lt" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#1420-1422">Source</a></span><a href="#method.le" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#1438-1440">Source</a></span><a href="#method.gt" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="../src/core/cmp.rs.html#1456-1458">Source</a></span><a href="#method.ge" class="anchor">Â§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pattern-for-%26str" class="impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#971-1053">Source</a><a href="#impl-Pattern-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'b&gt; <a class="trait" href="str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a> for &amp;'b <a class="primitive" href="primitive.str.html">str</a></h3><div class="docblock"><p>Non-allocating substring search.</p>
</div></section></summary><div class="docblock"><p>Will handle the pattern <code>""</code> as returning empty matches at each character
boundary.</p>
<h4 id="examples-74"><a class="doc-anchor" href="#examples-74">Â§</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"Hello world"</span>.find(<span class="string">"world"</span>), <span class="prelude-val">Some</span>(<span class="number">6</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++assert_eq!(%22Hello+world%22.find(%22world%22),+Some(6));%0A%7D&amp;edition=2024"></a></div></div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_prefix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#981-983">Source</a><a href="#method.is_prefix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_prefix_of" class="fn">is_prefix_of</a>(self, haystack: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Checks whether the pattern matches at the front of the haystack.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_contained_in" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#987-1012">Source</a><a href="#method.is_contained_in" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_contained_in" class="fn">is_contained_in</a>(self, haystack: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Checks whether the pattern matches anywhere in the haystack</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#1016-1023">Source</a><a href="#method.strip_prefix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_prefix_of" class="fn">strip_prefix_of</a>(self, haystack: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Removes the pattern from the front of haystack, if it matches.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_suffix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#1027-1032">Source</a><a href="#method.is_suffix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_suffix_of" class="fn">is_suffix_of</a>&lt;'a&gt;(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    Self::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Checks whether the pattern matches at the back of the haystack.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix_of" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#1036-1047">Source</a><a href="#method.strip_suffix_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.strip_suffix_of" class="fn">strip_suffix_of</a>&lt;'a&gt;(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;<div class="where">where
    Self::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span></summary><div class="docblock"><p>Removes the pattern from the back of haystack, if it matches.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Searcher" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#972">Source</a><a href="#associatedtype.Searcher" class="anchor">Â§</a><h4 class="code-header">type <a href="str/pattern/trait.Pattern.html#associatedtype.Searcher" class="associatedtype">Searcher</a>&lt;'a&gt; = <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct core::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Associated searcher for this pattern</div></details><details class="toggle method-toggle" open><summary><section id="method.into_searcher" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#975-977">Source</a><a href="#method.into_searcher" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#tymethod.into_searcher" class="fn">into_searcher</a>(self, haystack: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct core::str::pattern::StrSearcher">StrSearcher</a>&lt;'_, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Constructs the associated searcher from
<code>self</code> and the <code>haystack</code> to search in.</div></details><details class="toggle method-toggle" open><summary><section id="method.as_utf8_pattern" class="method trait-impl"><a class="src rightside" href="../src/core/str/pattern.rs.html#1050-1052">Source</a><a href="#method.as_utf8_pattern" class="anchor">Â§</a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.as_utf8_pattern" class="fn">as_utf8_pattern</a>(&amp;self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="str/pattern/enum.Utf8Pattern.html" title="enum core::str::pattern::Utf8Pattern">Utf8Pattern</a>&lt;'_&gt;&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</span></div></span><div class='docblock'>Returns the pattern as utf-8 bytes if possible.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.73.0">1.73.0</span> Â· <a class="src" href="../src/core/str/traits.rs.html#387-423">Source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-(Bound%3Cusize%3E,+Bound%3Cusize%3E)" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for (<a class="enum" href="ops/enum.Bound.html" title="enum core::ops::Bound">Bound</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;, <a class="enum" href="ops/enum.Bound.html" title="enum core::ops::Bound">Bound</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;)</h3><div class="docblock"><p>Implements substring slicing for arbitrary bounds.</p>
</div></section></summary><div class="docblock"><p>Returns a slice of the given string bounded by the byte indices
provided by each bound.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-3"><a class="doc-anchor" href="#panics-3">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> or <code>end</code> (if it exists and once adjusted for
inclusion/exclusion) does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if
<code>end &gt; len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#388">Source</a><a href="#associatedtype.Output-4" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-4" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#391-393">Source</a><a href="#method.get-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-4" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#396-398">Source</a><a href="#method.get_mut-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-4" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#401-405">Source</a><a href="#method.get_unchecked-4" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-4" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#408-412">Source</a><a href="#method.get_unchecked_mut-4" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-4" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#415-417">Source</a><a href="#method.index-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-4" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#420-422">Source</a><a href="#method.index_mut-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#165-266">Source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.Range.html" title="struct core::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin .. end]</code> or <code>&amp;mut self[begin .. end]</code>.</p>
</div></section></summary><div class="docblock"><p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>).</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-2"><a class="doc-anchor" href="#panics-2">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if
<code>end &gt; len</code>.</p>
<h4 id="examples-73"><a class="doc-anchor" href="#examples-73">Â§</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[<span class="number">0 </span>.. <span class="number">1</span>], <span class="string">"L"</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[<span class="number">1 </span>.. <span class="number">9</span>], <span class="string">"Ã¶we è€"</span>);

<span class="comment">// these will panic:
// byte 2 lies within `Ã¶`:
// &amp;s[2 ..3];

// byte 8 lies within `è€`
// &amp;s[1 .. 8];

// byte 100 is outside the string
// &amp;s[3 .. 100];</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s+=+%22L%C3%B6we+%E8%80%81%E8%99%8E+L%C3%A9opard%22;%0A++++assert_eq!(%26s%5B0+..+1%5D,+%22L%22);%0A++++%0A++++assert_eq!(%26s%5B1+..+9%5D,+%22%C3%B6we+%E8%80%81%22);%0A%7D&amp;edition=2024"></a></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#166">Source</a><a href="#associatedtype.Output-2" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-2" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#168-180">Source</a><a href="#method.get-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-2" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#182-193">Source</a><a href="#method.get_mut-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-2" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#196-221">Source</a><a href="#method.get_unchecked-2" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-2" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#224-242">Source</a><a href="#method.get_unchecked_mut-2" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-2" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#244-250">Source</a><a href="#method.index-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-2" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#252-265">Source</a><a href="#method.index_mut-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E-1" class="impl"><a class="src rightside" href="../src/core/str/traits.rs.html#270-371">Source</a><a href="#impl-SliceIndex%3Cstr%3E-for-Range%3Cusize%3E-1" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="range/struct.Range.html" title="struct core::range::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#271">Source</a><a href="#associatedtype.Output-3" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-3" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#273-285">Source</a><a href="#method.get-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-3" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#287-298">Source</a><a href="#method.get_mut-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-3" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#301-326">Source</a><a href="#method.get_unchecked-3" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-3" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#329-347">Source</a><a href="#method.get_unchecked_mut-3" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-3" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#349-355">Source</a><a href="#method.index-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-3" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#357-370">Source</a><a href="#method.index_mut-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#511-563">Source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFrom.html" title="struct core::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..]</code> or <code>&amp;mut self[begin ..]</code>.</p>
</div></section></summary><div class="docblock"><p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>len</code>).
Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-5"><a class="doc-anchor" href="#panics-5">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), or if <code>begin &gt; len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#512">Source</a><a href="#associatedtype.Output-6" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-6" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#514-522">Source</a><a href="#method.get-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-6" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#524-532">Source</a><a href="#method.get_mut-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-6" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#534-538">Source</a><a href="#method.get_unchecked-6" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-6" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#540-544">Source</a><a href="#method.get_unchecked_mut-6" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-6" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#546-552">Source</a><a href="#method.index-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-6" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#554-562">Source</a><a href="#method.index_mut-6" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E-1" class="impl"><a class="src rightside" href="../src/core/str/traits.rs.html#567-619">Source</a><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFrom%3Cusize%3E-1" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="range/struct.RangeFrom.html" title="struct core::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#568">Source</a><a href="#associatedtype.Output-7" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-7" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#570-578">Source</a><a href="#method.get-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-7" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#580-588">Source</a><a href="#method.get_mut-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-7" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#590-594">Source</a><a href="#method.get_unchecked-7" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-7" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#596-600">Source</a><a href="#method.get_unchecked_mut-7" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-7" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#602-608">Source</a><a href="#method.index-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-7" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#610-618">Source</a><a href="#method.index_mut-7" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeFull" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#100-126">Source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeFull" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFull.html" title="struct core::ops::RangeFull">RangeFull</a></h3><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..]</code> or <code>&amp;mut self[..]</code>.</p>
</div></section></summary><div class="docblock"><p>Returns a slice of the whole string, i.e., returns <code>&amp;self</code> or <code>&amp;mut self</code>. Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>. Unlike
other indexing operations, this can never panic.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<p>Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#101">Source</a><a href="#associatedtype.Output-1" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-1" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#103-105">Source</a><a href="#method.get-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-1" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#107-109">Source</a><a href="#method.get_mut-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-1" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#111-113">Source</a><a href="#method.get_unchecked-1" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-1" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#115-117">Source</a><a href="#method.get_unchecked_mut-1" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-1" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#119-121">Source</a><a href="#method.index-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-1" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#123-125">Source</a><a href="#method.index_mut-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#639-673">Source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct core::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..= end]</code> or <code>&amp;mut self[begin ..= end]</code>.</p>
</div></section></summary><div class="docblock"><p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>]. Equivalent to <code>&amp;self [begin .. end + 1]</code> or <code>&amp;mut self[begin .. end + 1]</code>, except if <code>end</code> has the maximum value for
<code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-6"><a class="doc-anchor" href="#panics-6">Â§</a>Panics</h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>end</code> does not point
to the ending byte offset of a character (<code>end + 1</code> is either a starting
byte offset or equal to <code>len</code>), if <code>begin &gt; end</code>, or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#640">Source</a><a href="#associatedtype.Output-8" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-8" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#642-644">Source</a><a href="#method.get-8" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-8" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#646-648">Source</a><a href="#method.get_mut-8" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-8" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#650-653">Source</a><a href="#method.get_unchecked-8" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-8" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#655-658">Source</a><a href="#method.get_unchecked_mut-8" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-8" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#660-665">Source</a><a href="#method.index-8" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-8" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#667-672">Source</a><a href="#method.index_mut-8" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E-1" class="impl"><a class="src rightside" href="../src/core/str/traits.rs.html#677-711">Source</a><a href="#impl-SliceIndex%3Cstr%3E-for-RangeInclusive%3Cusize%3E-1" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="range/struct.RangeInclusive.html" title="struct core::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#678">Source</a><a href="#associatedtype.Output-9" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-9" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#680-682">Source</a><a href="#method.get-9" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-9" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#684-686">Source</a><a href="#method.get_mut-9" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-9" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#688-691">Source</a><a href="#method.get_unchecked-9" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-9" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#693-696">Source</a><a href="#method.get_unchecked_mut-9" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-9" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#698-703">Source</a><a href="#method.index-9" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-9" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#705-710">Source</a><a href="#method.index_mut-9" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#442-492">Source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeTo%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeTo.html" title="struct core::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[.. end]</code> or <code>&amp;mut self[.. end]</code>.</p>
</div></section></summary><div class="docblock"><p>Returns a slice of the given string from the byte range [0, <code>end</code>).
Equivalent to <code>&amp;self[0 .. end]</code> or <code>&amp;mut self[0 .. end]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-4"><a class="doc-anchor" href="#panics-4">Â§</a>Panics</h4>
<p>Panics if <code>end</code> does not point to the starting byte offset of a
character (as defined by <code>is_char_boundary</code>), or if <code>end &gt; len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#443">Source</a><a href="#associatedtype.Output-5" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-5" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#445-453">Source</a><a href="#method.get-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-5" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#455-463">Source</a><a href="#method.get_mut-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-5" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#465-468">Source</a><a href="#method.get_unchecked-5" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-5" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#470-473">Source</a><a href="#method.get_unchecked_mut-5" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-5" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#475-481">Source</a><a href="#method.index-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-5" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#483-491">Source</a><a href="#method.index_mut-5" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/143775" title="Tracking issue for const_index">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#729-757">Source</a></span><a href="#impl-SliceIndex%3Cstr%3E-for-RangeToInclusive%3Cusize%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeToInclusive.html" title="struct core::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..= end]</code> or <code>&amp;mut self[..= end]</code>.</p>
</div></section></summary><div class="docblock"><p>Returns a slice of the given string from the byte range [0, <code>end</code>].
Equivalent to <code>&amp;self [0 .. end + 1]</code>, except if <code>end</code> has the maximum
value for <code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-7"><a class="doc-anchor" href="#panics-7">Â§</a>Panics</h4>
<p>Panics if <code>end</code> does not point to the ending byte offset of a character
(<code>end + 1</code> is either a starting byte offset as defined by
<code>is_char_boundary</code>, or equal to <code>len</code>), or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#730">Source</a><a href="#associatedtype.Output-10" class="anchor">Â§</a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></section></summary><div class='docblock'>The output type returned by methods.</div></details><details class="toggle method-toggle" open><summary><section id="method.get-10" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#732-734">Source</a><a href="#method.get-10" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fn">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut-10" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#736-738">Source</a><a href="#method.get_mut-10" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fn">get_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, if in
bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked-10" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#740-743">Source</a><a href="#method.get_unchecked-10" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fn">get_unchecked</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut-10" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#745-748">Source</a><a href="#method.get_unchecked_mut-10" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fn">get_unchecked_mut</a>(self, slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable pointer to the output at this location, without
performing any bounds checking. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.index-10" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#750-752">Source</a><a href="#method.index-10" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fn">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a shared reference to the output at this location, panicking
if out of bounds.</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut-10" class="method trait-impl"><a class="src rightside" href="../src/core/str/traits.rs.html#754-756">Source</a><a href="#method.index_mut-10" class="anchor">Â§</a><h4 class="code-header">fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fn">index_mut</a>(self, slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>slice_index_methods</code>)</span></div></span><div class='docblock'>Returns a mutable reference to the output at this location, panicking
if out of bounds.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26ByteStr%3E-for-%26str" class="impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#344-351">Source</a><a href="#impl-TryFrom%3C%26ByteStr%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a <a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>&gt; for &amp;'a <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#345">Source</a><a href="#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="str/struct.Utf8Error.html" title="struct core::str::Utf8Error">Utf8Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#348-350">Source</a><a href="#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(s: &amp;'a <a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3C%26mut+ByteStr%3E-for-%26mut+str" class="impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#355-362">Source</a><a href="#impl-TryFrom%3C%26mut+ByteStr%3E-for-%26mut+str" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a mut <a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>&gt; for &amp;'a mut <a class="primitive" href="primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#356">Source</a><a href="#associatedtype.Error-1" class="anchor">Â§</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="str/struct.Utf8Error.html" title="struct core::str::Utf8Error">Utf8Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="../src/core/bstr/mod.rs.html#359-361">Source</a><a href="#method.try_from-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(s: &amp;'a mut <a class="struct" href="bstr/struct.ByteStr.html" title="struct core::bstr::ByteStr">ByteStr</a>) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-ConstParamTy_-for-str" class="impl"><a class="src rightside" href="../src/core/marker.rs.html#1104-1111">Source</a><a href="#impl-ConstParamTy_-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.ConstParamTy_.html" title="trait core::marker::ConstParamTy_">ConstParamTy_</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Eq-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> Â· <a class="src" href="../src/core/str/traits.rs.html#36">Source</a></span><a href="#impl-Eq-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Error-for-%26str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.65.0">1.65.0</span> Â· <a class="src" href="../src/core/str/mod.rs.html#3216">Source</a></span><a href="#impl-Error-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl !<a class="trait" href="error/trait.Error.html" title="trait core::error::Error">Error</a> for &amp;<a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-StructuralPartialEq-for-str" class="impl"><a class="src rightside" href="../src/core/marker.rs.html#264-276">Source</a><a href="#impl-StructuralPartialEq-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-str" class="impl"><a href="#impl-Freeze-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-RefUnwindSafe-for-str" class="impl"><a href="#impl-RefUnwindSafe-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Send-for-str" class="impl"><a href="#impl-Send-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Sized-for-str" class="impl"><a href="#impl-Sized-for-str" class="anchor">Â§</a><h3 class="code-header">impl !<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Sync-for-str" class="impl"><a href="#impl-Sync-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-Unpin-for-str" class="impl"><a href="#impl-Unpin-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section><section id="impl-UnwindSafe-for-str" class="impl"><a href="#impl-UnwindSafe-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="../src/core/any.rs.html#138-142">Source</a><a href="#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../src/core/any.rs.html#139-141">Source</a><a href="#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#212-217">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#214-216">Source</a><a href="#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#221-225">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#222-224">Source</a><a href="#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details></div><script type="text/json" id="notable-traits-data">{"Bytes<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Bytes.html\" title=\"struct core::str::Bytes\">Bytes</a>&lt;'_&gt;</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Bytes.html\" title=\"struct core::str::Bytes\">Bytes</a>&lt;'_&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.u8.html\">u8</a>;</div>","CharIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.CharIndices.html\" title=\"struct core::str::CharIndices\">CharIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.CharIndices.html\" title=\"struct core::str::CharIndices\">CharIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"primitive.char.html\">char</a>);</div>","Chars<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Chars.html\" title=\"struct core::str::Chars\">Chars</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Chars.html\" title=\"struct core::str::Chars\">Chars</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","EncodeUtf16<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EncodeUtf16.html\" title=\"struct core::str::EncodeUtf16\">EncodeUtf16</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EncodeUtf16.html\" title=\"struct core::str::EncodeUtf16\">EncodeUtf16</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.u16.html\">u16</a>;</div>","EscapeDebug<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EscapeDebug.html\" title=\"struct core::str::EscapeDebug\">EscapeDebug</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EscapeDebug.html\" title=\"struct core::str::EscapeDebug\">EscapeDebug</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","EscapeDefault<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EscapeDefault.html\" title=\"struct core::str::EscapeDefault\">EscapeDefault</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EscapeDefault.html\" title=\"struct core::str::EscapeDefault\">EscapeDefault</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","EscapeUnicode<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.EscapeUnicode.html\" title=\"struct core::str::EscapeUnicode\">EscapeUnicode</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.EscapeUnicode.html\" title=\"struct core::str::EscapeUnicode\">EscapeUnicode</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"primitive.char.html\">char</a>;</div>","Lines<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Lines.html\" title=\"struct core::str::Lines\">Lines</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Lines.html\" title=\"struct core::str::Lines\">Lines</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","LinesAny<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.LinesAny.html\" title=\"struct core::str::LinesAny\">LinesAny</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.LinesAny.html\" title=\"struct core::str::LinesAny\">LinesAny</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","MatchIndices<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.MatchIndices.html\" title=\"struct core::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.MatchIndices.html\" title=\"struct core::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>);</div>","Matches<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Matches.html\" title=\"struct core::str::Matches\">Matches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Matches.html\" title=\"struct core::str::Matches\">Matches</a>&lt;'a, P&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RMatchIndices<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RMatchIndices.html\" title=\"struct core::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RMatchIndices.html\" title=\"struct core::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&lt;Searcher&lt;'a&gt;: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>);</div>","RMatches<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RMatches.html\" title=\"struct core::str::RMatches\">RMatches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RMatches.html\" title=\"struct core::str::RMatches\">RMatches</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&lt;Searcher&lt;'a&gt;: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RSplit<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RSplit.html\" title=\"struct core::str::RSplit\">RSplit</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RSplit.html\" title=\"struct core::str::RSplit\">RSplit</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&lt;Searcher&lt;'a&gt;: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RSplitN<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RSplitN.html\" title=\"struct core::str::RSplitN\">RSplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RSplitN.html\" title=\"struct core::str::RSplitN\">RSplitN</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&lt;Searcher&lt;'a&gt;: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","RSplitTerminator<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.RSplitTerminator.html\" title=\"struct core::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.RSplitTerminator.html\" title=\"struct core::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&lt;Searcher&lt;'a&gt;: <a class=\"trait\" href=\"str/pattern/trait.ReverseSearcher.html\" title=\"trait core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;&gt;,</div></div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","Split<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.Split.html\" title=\"struct core::str::Split\">Split</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.Split.html\" title=\"struct core::str::Split\">Split</a>&lt;'a, P&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitAsciiWhitespace<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitAsciiWhitespace.html\" title=\"struct core::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitAsciiWhitespace.html\" title=\"struct core::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitInclusive<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitInclusive.html\" title=\"struct core::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitInclusive.html\" title=\"struct core::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitN<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitN.html\" title=\"struct core::str::SplitN\">SplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitN.html\" title=\"struct core::str::SplitN\">SplitN</a>&lt;'a, P&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitTerminator<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitTerminator.html\" title=\"struct core::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P: <a class=\"trait\" href=\"str/pattern/trait.Pattern.html\" title=\"trait core::str::pattern::Pattern\">Pattern</a>&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitTerminator.html\" title=\"struct core::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>","SplitWhitespace<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"str/struct.SplitWhitespace.html\" title=\"struct core::str::SplitWhitespace\">SplitWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"iter/trait.Iterator.html\" title=\"trait core::iter::Iterator\">Iterator</a> for <a class=\"struct\" href=\"str/struct.SplitWhitespace.html\" title=\"struct core::str::SplitWhitespace\">SplitWhitespace</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"iter/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"primitive.str.html\">str</a>;</div>"}</script></section></div></main></body></html>