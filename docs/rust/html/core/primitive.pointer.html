<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Raw, unsafe pointers, `*const T`, and `*mut T`."><title>pointer - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-b10cf797.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.95.0" data-rustdoc-version="1.95.0-nightly (5c49c4f7c 2026-01-20)" data-channel="nightly" data-search-js="search-86d08462.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items1.95.0.js"></script><script defer src="../static.files/main-7bab91a1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">pointer</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../core/index.html"><img class="rust-logo" src="../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../core/index.html">core</a><span class="version">1.95.0-nightly</span></h2></div><div class="version">(5c49c4f7c	2026-01-20)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">pointer</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#common-ways-to-create-raw-pointers" title="Common ways to create raw pointers">Common ways to create raw pointers</a><ul><li><a href="#1-coerce-a-reference-t-or-mutable-reference-mut-t" title="1. Coerce a reference (`&#38;T`) or mutable reference (`&#38;mut T`).">1. Coerce a reference (<code>&amp;T</code>) or mutable reference (<code>&amp;mut T</code>).</a></li><li><a href="#2-consume-a-box-boxt" title="2. Consume a box (`Box&#60;T&#62;`).">2. Consume a box (<code>Box&lt;T&gt;</code>).</a></li><li><a href="#3-create-it-using-raw" title="3. Create it using `&#38;raw`">3. Create it using <code>&amp;raw</code></a></li><li><a href="#4-get-it-from-c" title="4. Get it from C.">4. Get it from C.</a></li></ul></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add" title="add">add</a></li><li><a href="#method.add-1" title="add">add</a></li><li><a href="#method.addr" title="addr">addr</a></li><li><a href="#method.addr-1" title="addr">addr</a></li><li><a href="#method.align_offset" title="align_offset">align_offset</a></li><li><a href="#method.align_offset-1" title="align_offset">align_offset</a></li><li><a href="#method.as_array" title="as_array">as_array</a></li><li><a href="#method.as_mut" title="as_mut">as_mut</a></li><li><a href="#method.as_mut_array" title="as_mut_array">as_mut_array</a></li><li><a href="#method.as_mut_ptr" title="as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_ptr-1" title="as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_slice" title="as_mut_slice">as_mut_slice</a></li><li><a href="#method.as_mut_unchecked" title="as_mut_unchecked">as_mut_unchecked</a></li><li><a href="#method.as_ptr" title="as_ptr">as_ptr</a></li><li><a href="#method.as_ptr-1" title="as_ptr">as_ptr</a></li><li><a href="#method.as_ref" title="as_ref">as_ref</a></li><li><a href="#method.as_ref-1" title="as_ref">as_ref</a></li><li><a href="#method.as_ref_unchecked" title="as_ref_unchecked">as_ref_unchecked</a></li><li><a href="#method.as_ref_unchecked-1" title="as_ref_unchecked">as_ref_unchecked</a></li><li><a href="#method.as_slice" title="as_slice">as_slice</a></li><li><a href="#method.as_uninit_mut" title="as_uninit_mut">as_uninit_mut</a></li><li><a href="#method.as_uninit_ref" title="as_uninit_ref">as_uninit_ref</a></li><li><a href="#method.as_uninit_ref-1" title="as_uninit_ref">as_uninit_ref</a></li><li><a href="#method.as_uninit_slice" title="as_uninit_slice">as_uninit_slice</a></li><li><a href="#method.as_uninit_slice-1" title="as_uninit_slice">as_uninit_slice</a></li><li><a href="#method.as_uninit_slice_mut" title="as_uninit_slice_mut">as_uninit_slice_mut</a></li><li><a href="#method.byte_add" title="byte_add">byte_add</a></li><li><a href="#method.byte_add-1" title="byte_add">byte_add</a></li><li><a href="#method.byte_offset" title="byte_offset">byte_offset</a></li><li><a href="#method.byte_offset-1" title="byte_offset">byte_offset</a></li><li><a href="#method.byte_offset_from" title="byte_offset_from">byte_offset_from</a></li><li><a href="#method.byte_offset_from-1" title="byte_offset_from">byte_offset_from</a></li><li><a href="#method.byte_offset_from_unsigned" title="byte_offset_from_unsigned">byte_offset_from_unsigned</a></li><li><a href="#method.byte_offset_from_unsigned-1" title="byte_offset_from_unsigned">byte_offset_from_unsigned</a></li><li><a href="#method.byte_sub" title="byte_sub">byte_sub</a></li><li><a href="#method.byte_sub-1" title="byte_sub">byte_sub</a></li><li><a href="#method.cast" title="cast">cast</a></li><li><a href="#method.cast-1" title="cast">cast</a></li><li><a href="#method.cast_array" title="cast_array">cast_array</a></li><li><a href="#method.cast_array-1" title="cast_array">cast_array</a></li><li><a href="#method.cast_const" title="cast_const">cast_const</a></li><li><a href="#method.cast_init" title="cast_init">cast_init</a></li><li><a href="#method.cast_init-1" title="cast_init">cast_init</a></li><li><a href="#method.cast_mut" title="cast_mut">cast_mut</a></li><li><a href="#method.cast_uninit" title="cast_uninit">cast_uninit</a></li><li><a href="#method.cast_uninit-1" title="cast_uninit">cast_uninit</a></li><li><a href="#method.copy_from" title="copy_from">copy_from</a></li><li><a href="#method.copy_from_nonoverlapping" title="copy_from_nonoverlapping">copy_from_nonoverlapping</a></li><li><a href="#method.copy_to" title="copy_to">copy_to</a></li><li><a href="#method.copy_to-1" title="copy_to">copy_to</a></li><li><a href="#method.copy_to_nonoverlapping" title="copy_to_nonoverlapping">copy_to_nonoverlapping</a></li><li><a href="#method.copy_to_nonoverlapping-1" title="copy_to_nonoverlapping">copy_to_nonoverlapping</a></li><li><a href="#method.drop_in_place" title="drop_in_place">drop_in_place</a></li><li><a href="#method.expose_provenance" title="expose_provenance">expose_provenance</a></li><li><a href="#method.expose_provenance-1" title="expose_provenance">expose_provenance</a></li><li><a href="#method.get_unchecked" title="get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut" title="get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.guaranteed_eq" title="guaranteed_eq">guaranteed_eq</a></li><li><a href="#method.guaranteed_eq-1" title="guaranteed_eq">guaranteed_eq</a></li><li><a href="#method.guaranteed_ne" title="guaranteed_ne">guaranteed_ne</a></li><li><a href="#method.guaranteed_ne-1" title="guaranteed_ne">guaranteed_ne</a></li><li><a href="#method.is_aligned" title="is_aligned">is_aligned</a></li><li><a href="#method.is_aligned-1" title="is_aligned">is_aligned</a></li><li><a href="#method.is_aligned_to" title="is_aligned_to">is_aligned_to</a></li><li><a href="#method.is_aligned_to-1" title="is_aligned_to">is_aligned_to</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.is_empty-1" title="is_empty">is_empty</a></li><li><a href="#method.is_null" title="is_null">is_null</a></li><li><a href="#method.is_null-1" title="is_null">is_null</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.len-1" title="len">len</a></li><li><a href="#method.map_addr" title="map_addr">map_addr</a></li><li><a href="#method.map_addr-1" title="map_addr">map_addr</a></li><li><a href="#method.mask" title="mask">mask</a></li><li><a href="#method.mask-1" title="mask">mask</a></li><li><a href="#method.offset" title="offset">offset</a></li><li><a href="#method.offset-1" title="offset">offset</a></li><li><a href="#method.offset_from" title="offset_from">offset_from</a></li><li><a href="#method.offset_from-1" title="offset_from">offset_from</a></li><li><a href="#method.offset_from_unsigned" title="offset_from_unsigned">offset_from_unsigned</a></li><li><a href="#method.offset_from_unsigned-1" title="offset_from_unsigned">offset_from_unsigned</a></li><li><a href="#method.read" title="read">read</a></li><li><a href="#method.read-1" title="read">read</a></li><li><a href="#method.read_unaligned" title="read_unaligned">read_unaligned</a></li><li><a href="#method.read_unaligned-1" title="read_unaligned">read_unaligned</a></li><li><a href="#method.read_volatile" title="read_volatile">read_volatile</a></li><li><a href="#method.read_volatile-1" title="read_volatile">read_volatile</a></li><li><a href="#method.replace" title="replace">replace</a></li><li><a href="#method.split_at_mut" title="split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_mut_unchecked" title="split_at_mut_unchecked">split_at_mut_unchecked</a></li><li><a href="#method.sub" title="sub">sub</a></li><li><a href="#method.sub-1" title="sub">sub</a></li><li><a href="#method.swap" title="swap">swap</a></li><li><a href="#method.to_raw_parts" title="to_raw_parts">to_raw_parts</a></li><li><a href="#method.to_raw_parts-1" title="to_raw_parts">to_raw_parts</a></li><li><a href="#method.try_cast_aligned" title="try_cast_aligned">try_cast_aligned</a></li><li><a href="#method.try_cast_aligned-1" title="try_cast_aligned">try_cast_aligned</a></li><li><a href="#method.with_addr" title="with_addr">with_addr</a></li><li><a href="#method.with_addr-1" title="with_addr">with_addr</a></li><li><a href="#method.with_metadata_of" title="with_metadata_of">with_metadata_of</a></li><li><a href="#method.with_metadata_of-1" title="with_metadata_of">with_metadata_of</a></li><li><a href="#method.wrapping_add" title="wrapping_add">wrapping_add</a></li><li><a href="#method.wrapping_add-1" title="wrapping_add">wrapping_add</a></li><li><a href="#method.wrapping_byte_add" title="wrapping_byte_add">wrapping_byte_add</a></li><li><a href="#method.wrapping_byte_add-1" title="wrapping_byte_add">wrapping_byte_add</a></li><li><a href="#method.wrapping_byte_offset" title="wrapping_byte_offset">wrapping_byte_offset</a></li><li><a href="#method.wrapping_byte_offset-1" title="wrapping_byte_offset">wrapping_byte_offset</a></li><li><a href="#method.wrapping_byte_sub" title="wrapping_byte_sub">wrapping_byte_sub</a></li><li><a href="#method.wrapping_byte_sub-1" title="wrapping_byte_sub">wrapping_byte_sub</a></li><li><a href="#method.wrapping_offset" title="wrapping_offset">wrapping_offset</a></li><li><a href="#method.wrapping_offset-1" title="wrapping_offset">wrapping_offset</a></li><li><a href="#method.wrapping_sub" title="wrapping_sub">wrapping_sub</a></li><li><a href="#method.wrapping_sub-1" title="wrapping_sub">wrapping_sub</a></li><li><a href="#method.write" title="write">write</a></li><li><a href="#method.write_bytes" title="write_bytes">write_bytes</a></li><li><a href="#method.write_unaligned" title="write_unaligned">write_unaligned</a></li><li><a href="#method.write_volatile" title="write_volatile">write_volatile</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Send-for-*const+T" title="!Send">!Send</a></li><li><a href="#impl-Send-for-*mut+T" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-*const+T" title="!Sync">!Sync</a></li><li><a href="#impl-Sync-for-*mut+T" title="!Sync">!Sync</a></li><li><a href="#impl-AtomicPrimitive-for-*mut+T" title="AtomicPrimitive">AtomicPrimitive</a></li><li><a href="#impl-Clone-for-*const+T" title="Clone">Clone</a></li><li><a href="#impl-Clone-for-*mut+T" title="Clone">Clone</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26T" title="CoerceUnsized&#60;*const U&#62;">CoerceUnsized&#60;*const U&#62;</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26mut+T" title="CoerceUnsized&#60;*const U&#62;">CoerceUnsized&#60;*const U&#62;</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*const+T" title="CoerceUnsized&#60;*const U&#62;">CoerceUnsized&#60;*const U&#62;</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*mut+T" title="CoerceUnsized&#60;*const U&#62;">CoerceUnsized&#60;*const U&#62;</a></li><li><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-%26mut+T" title="CoerceUnsized&#60;*mut U&#62;">CoerceUnsized&#60;*mut U&#62;</a></li><li><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-*mut+T" title="CoerceUnsized&#60;*mut U&#62;">CoerceUnsized&#60;*mut U&#62;</a></li><li><a href="#impl-Copy-for-*const+T" title="Copy">Copy</a></li><li><a href="#impl-Copy-for-*mut+T" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-*const+T" title="Debug">Debug</a></li><li><a href="#impl-Debug-for-*mut+T" title="Debug">Debug</a></li><li><a href="#impl-Default-for-*const+T" title="Default">Default</a></li><li><a href="#impl-Default-for-*mut+T" title="Default">Default</a></li><li><a href="#impl-DispatchFromDyn%3C*const+U%3E-for-*const+T" title="DispatchFromDyn&#60;*const U&#62;">DispatchFromDyn&#60;*const U&#62;</a></li><li><a href="#impl-DispatchFromDyn%3C*mut+U%3E-for-*mut+T" title="DispatchFromDyn&#60;*mut U&#62;">DispatchFromDyn&#60;*mut U&#62;</a></li><li><a href="#impl-Eq-for-*const+T" title="Eq">Eq</a></li><li><a href="#impl-Eq-for-*mut+T" title="Eq">Eq</a></li><li><a href="#impl-Freeze-for-*const+T" title="Freeze">Freeze</a></li><li><a href="#impl-Freeze-for-*mut+T" title="Freeze">Freeze</a></li><li><a href="#impl-From%3C*mut+T%3E-for-AtomicPtr%3CT%3E" title="From&#60;*mut T&#62;">From&#60;*mut T&#62;</a></li><li><a href="#impl-Hash-for-*const+T" title="Hash">Hash</a></li><li><a href="#impl-Hash-for-*mut+T" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-*const+T" title="Ord">Ord</a></li><li><a href="#impl-Ord-for-*mut+T" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-*const+T" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialEq-for-*mut+T" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-*const+T" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-PartialOrd-for-*mut+T" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-PinCoerceUnsized-for-*const+T" title="PinCoerceUnsized">PinCoerceUnsized</a></li><li><a href="#impl-PinCoerceUnsized-for-*mut+T" title="PinCoerceUnsized">PinCoerceUnsized</a></li><li><a href="#impl-Pointer-for-*const+T" title="Pointer">Pointer</a></li><li><a href="#impl-Pointer-for-*mut+T" title="Pointer">Pointer</a></li><li><a href="#impl-SimdElement-for-*const+T" title="SimdElement">SimdElement</a></li><li><a href="#impl-SimdElement-for-*mut+T" title="SimdElement">SimdElement</a></li><li><a href="#impl-Unpin-for-*const+T" title="Unpin">Unpin</a></li><li><a href="#impl-Unpin-for-*mut+T" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-*const+T" title="UnwindSafe">UnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-*mut+T" title="UnwindSafe">UnwindSafe</a></li><li><a href="#impl-VaArgSafe-for-*const+T" title="VaArgSafe">VaArgSafe</a></li><li><a href="#impl-VaArgSafe-for-*mut+T" title="VaArgSafe">VaArgSafe</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-*const+T" title="RefUnwindSafe">RefUnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate core</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Primitive Type <span class="primitive">pointer</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Raw, unsafe pointers, <code>*const T</code>, and <code>*mut T</code>.</p>
<p><em><a href="ptr/index.html" title="mod core::ptr">See also the <code>std::ptr</code> module</a>.</em></p>
<p>Working with raw pointers in Rust is uncommon, typically limited to a few patterns. Raw pointers
can be out-of-bounds, unaligned, or <a href="ptr/fn.null.html" title="fn core::ptr::null"><code>null</code></a>. However, when loading from or storing to a raw
pointer, it must be <a href="ptr/index.html#safety" title="mod core::ptr">valid</a> for the given access and aligned. When using a field expression,
tuple index expression, or array/slice index expression on a raw pointer, it follows the rules
of <a href="primitive.pointer.html#method.offset" title="method pointer::offset">in-bounds pointer arithmetic</a>.</p>
<p>Storing through a raw pointer using <code>*ptr = data</code> calls <code>drop</code> on the old value, so
<a href="ptr/fn.write.html" title="fn core::ptr::write"><code>write</code></a> must be used if the type has drop glue and memory is not already
initialized - otherwise <code>drop</code> would be called on the uninitialized memory.</p>
<p>Use the <a href="ptr/fn.null.html" title="fn core::ptr::null"><code>null</code></a> and <a href="ptr/fn.null_mut.html" title="fn core::ptr::null_mut"><code>null_mut</code></a> functions to create null pointers, and the
<a href="primitive.pointer.html#method.is_null" title="method pointer::is_null"><code>is_null</code></a> method of the <code>*const T</code> and <code>*mut T</code> types to check for null.
The <code>*const T</code> and <code>*mut T</code> types also define the <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>offset</code></a> method, for
pointer math.</p>
<h2 id="common-ways-to-create-raw-pointers"><a class="doc-anchor" href="#common-ways-to-create-raw-pointers">¬ß</a>Common ways to create raw pointers</h2><h3 id="1-coerce-a-reference-t-or-mutable-reference-mut-t"><a class="doc-anchor" href="#1-coerce-a-reference-t-or-mutable-reference-mut-t">¬ß</a>1. Coerce a reference (<code>&amp;T</code>) or mutable reference (<code>&amp;mut T</code>).</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_num: i32 = <span class="number">10</span>;
<span class="kw">let </span>my_num_ptr: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>my_num;
<span class="kw">let </span><span class="kw-2">mut </span>my_speed: i32 = <span class="number">88</span>;
<span class="kw">let </span>my_speed_ptr: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut </span>my_speed;</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+my_num:+i32+=+10;%0A++++let+my_num_ptr:+*const+i32+=+%26my_num;%0A++++let+mut+my_speed:+i32+=+88;%0A++++let+my_speed_ptr:+*mut+i32+=+%26mut+my_speed;%0A%7D&amp;edition=2024"></a></div>
<p>To get a pointer to a boxed value, dereference the box:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_num: Box&lt;i32&gt; = Box::new(<span class="number">10</span>);
<span class="kw">let </span>my_num_ptr: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;*</span>my_num;
<span class="kw">let </span><span class="kw-2">mut </span>my_speed: Box&lt;i32&gt; = Box::new(<span class="number">88</span>);
<span class="kw">let </span>my_speed_ptr: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut *</span>my_speed;</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+my_num:+Box%3Ci32%3E+=+Box::new(10);%0A++++let+my_num_ptr:+*const+i32+=+%26*my_num;%0A++++let+mut+my_speed:+Box%3Ci32%3E+=+Box::new(88);%0A++++let+my_speed_ptr:+*mut+i32+=+%26mut+*my_speed;%0A%7D&amp;edition=2024"></a></div>
<p>This does not take ownership of the original allocation
and requires no resource management later,
but you must not use the pointer after its lifetime.</p>
<h3 id="2-consume-a-box-boxt"><a class="doc-anchor" href="#2-consume-a-box-boxt">¬ß</a>2. Consume a box (<code>Box&lt;T&gt;</code>).</h3>
<p>The <a href="../std/boxed/struct.Box.html#method.into_raw"><code>into_raw</code></a> function consumes a box and returns
the raw pointer. It doesn‚Äôt destroy <code>T</code> or deallocate any memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_speed: Box&lt;i32&gt; = Box::new(<span class="number">88</span>);
<span class="kw">let </span>my_speed: <span class="kw-2">*mut </span>i32 = Box::into_raw(my_speed);

<span class="comment">// By taking ownership of the original `Box&lt;T&gt;` though
// we are obligated to put it together later to be destroyed.
</span><span class="kw">unsafe </span>{
    drop(Box::from_raw(my_speed));
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+my_speed:+Box%3Ci32%3E+=+Box::new(88);%0A++++let+my_speed:+*mut+i32+=+Box::into_raw(my_speed);%0A++++%0A++++//+By+taking+ownership+of+the+original+%60Box%3CT%3E%60+though%0A++++//+we+are+obligated+to+put+it+together+later+to+be+destroyed.%0A++++unsafe+%7B%0A++++++++drop(Box::from_raw(my_speed));%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
<p>Note that here the call to <a href="mem/fn.drop.html" title="fn core::mem::drop"><code>drop</code></a> is for clarity - it indicates
that we are done with the given value and it should be destroyed.</p>
<h3 id="3-create-it-using-raw"><a class="doc-anchor" href="#3-create-it-using-raw">¬ß</a>3. Create it using <code>&amp;raw</code></h3>
<p>Instead of coercing a reference to a raw pointer, you can use the raw borrow
operators <code>&amp;raw const</code> (for <code>*const T</code>) and <code>&amp;raw mut</code> (for <code>*mut T</code>).
These operators allow you to create raw pointers to fields to which you cannot
create a reference (without causing undefined behavior), such as an
unaligned field. This might be necessary if packed structs or uninitialized
memory is involved.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Default, Copy, Clone)]
#[repr(C, packed)]
</span><span class="kw">struct </span>S {
    aligned: u8,
    unaligned: u32,
}
<span class="kw">let </span>s = S::default();
<span class="kw">let </span>p = <span class="kw-2">&amp;</span><span class="kw">raw const </span>s.unaligned; <span class="comment">// not allowed with coercion</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++%23%5Bderive(Debug,+Default,+Copy,+Clone)%5D%0A++++%23%5Brepr(C,+packed)%5D%0A++++struct+S+%7B%0A++++++++aligned:+u8,%0A++++++++unaligned:+u32,%0A++++%7D%0A++++let+s+=+S::default();%0A++++let+p+=+%26raw+const+s.unaligned;%0A%7D&amp;edition=2024"></a></div><h3 id="4-get-it-from-c"><a class="doc-anchor" href="#4-get-it-from-c">¬ß</a>4. Get it from C.</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[allow(unused_extern_crates)]
</span><span class="kw">extern crate </span>libc;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>my_num: <span class="kw-2">*mut </span>i32 = libc::malloc(size_of::&lt;i32&gt;()) <span class="kw">as </span><span class="kw-2">*mut </span>i32;
    <span class="kw">if </span>my_num.is_null() {
        <span class="macro">panic!</span>(<span class="string">"failed to allocate memory"</span>);
    }
    libc::free(my_num <span class="kw">as </span><span class="kw-2">*mut </span>core::ffi::c_void);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%0A%23%5Bcfg(false)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+libc;%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Afn+main()+%7B%0A++++mod+libc+%7B%0A++++pub+unsafe+fn+malloc(_size:+usize)+-%3E+*mut+core::ffi::c_void+%7B+core::ptr::NonNull::dangling().as_ptr()+%7D%0A++++pub+unsafe+fn+free(_ptr:+*mut+core::ffi::c_void)+%7B%7D%0A++++%7D%0A++++%0A++++unsafe+%7B%0A++++++++let+my_num:+*mut+i32+=+libc::malloc(size_of::%3Ci32%3E())+as+*mut+i32;%0A++++++++if+my_num.is_null()+%7B%0A++++++++++++panic!(%22failed+to+allocate+memory%22);%0A++++++++%7D%0A++++++++libc::free(my_num+as+*mut+core::ffi::c_void);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
<p>Usually you wouldn‚Äôt literally use <code>malloc</code> and <code>free</code> from Rust,
but C APIs hand out a lot of pointers generally, so are a common source
of raw pointers in Rust.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">¬ß</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-*const+T" class="impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#7-1379">Source</a><a href="#impl-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_null" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.84.0">1.0.0 (const: 1.84.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#22-41">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_null" class="fn">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the pointer is null.</p>
<p>Note that unsized types have many possible null pointers, as only the
raw data pointer is considered, not their length, vtable, etc.
Therefore, two pointers that are null may still not compare equal to
each other.</p>
<h5 id="panics-during-const-evaluation"><a class="doc-anchor" href="#panics-during-const-evaluation">¬ß</a>Panics during const evaluation</h5>
<p>If this method is used during const evaluation, and <code>self</code> is a pointer
that is offset beyond the bounds of the memory it initially pointed to,
then there might not be enough information to determine whether the
pointer is null. This is because the absolute address in memory is not
known at compile time. If the nullness of the pointer cannot be
determined, this method will panic.</p>
<p>In-bounds pointers are never null, so the method will never panic for
such pointers.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">"Follow the rabbit"</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = s.as_ptr();
<span class="macro">assert!</span>(!ptr.is_null());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s:+%26str+=+%22Follow+the+rabbit%22;%0A++++let+ptr:+*const+u8+=+s.as_ptr();%0A++++assert!(!ptr.is_null());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cast" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#48-50">Source</a></span><h4 class="code-header">pub const fn <a href="#method.cast" class="fn">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const U</a></h4></section></summary><div class="docblock"><p>Casts to a pointer of another type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_cast_aligned" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#74-76">Source</a><h4 class="code-header">pub fn <a href="#method.try_cast_aligned" class="fn">try_cast_aligned</a>&lt;U&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>pointer_try_cast_aligned</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/141221">#141221</a>)</span></div></span></summary><div class="docblock"><p>Try to cast to a pointer of another type by checking alignment.</p>
<p>If the pointer is properly aligned to the target type, it will be
cast to the target type. Otherwise, <code>None</code> is returned.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_try_cast_aligned)]

</span><span class="kw">let </span>x = <span class="number">0u64</span>;

<span class="kw">let </span>aligned: <span class="kw-2">*const </span>u64 = <span class="kw-2">&amp;</span>x;
<span class="kw">let </span>unaligned = <span class="kw">unsafe </span>{ aligned.byte_add(<span class="number">1</span>) };

<span class="macro">assert!</span>(aligned.try_cast_aligned::&lt;u32&gt;().is_some());
<span class="macro">assert!</span>(unaligned.try_cast_aligned::&lt;u32&gt;().is_none());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_try_cast_aligned)%5D%0A%0A%0Afn+main()+%7B%0A++++let+x+=+0u64;%0A++++%0A++++let+aligned:+*const+u64+=+%26x;%0A++++let+unaligned+=+unsafe+%7B+aligned.byte_add(1)+%7D;%0A++++%0A++++assert!(aligned.try_cast_aligned::%3Cu32%3E().is_some());%0A++++assert!(unaligned.try_cast_aligned::%3Cu32%3E().is_none());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_metadata_of" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#130-135">Source</a><h4 class="code-header">pub const fn <a href="#method.with_metadata_of" class="fn">with_metadata_of</a>&lt;U&gt;(self, meta: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const U</a><div class="where">where
    U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</span></div></span></summary><div class="docblock"><p>Uses the address value in a new pointer of another type.</p>
<p>This operation will ignore the address part of its <code>meta</code> operand and discard existing
metadata of <code>self</code>. For pointers to a sized types (thin pointers), this has the same effect
as a simple cast. For pointers to an unsized type (fat pointers) this recombines the address
with new metadata such as slice lengths or <code>dyn</code>-vtable.</p>
<p>The resulting pointer will have provenance of <code>self</code>. This operation is semantically the
same as creating a new pointer with the data pointer value of <code>self</code> but the metadata of
<code>meta</code>, being fat or thin depending on the <code>meta</code> operand.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">¬ß</a>Examples</h5>
<p>This function is primarily useful for enabling pointer arithmetic on potentially fat
pointers. The pointer is cast to a sized pointee to utilize offset operations and then
recombined with its own original metadata.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(set_ptr_value)]
</span><span class="kw">let </span>arr: [i32; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr = arr.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span><span class="kw">dyn </span>Debug;
<span class="kw">let </span>thin = ptr <span class="kw">as </span><span class="kw-2">*const </span>u8;
<span class="kw">unsafe </span>{
    ptr = thin.add(<span class="number">8</span>).with_metadata_of(ptr);
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, <span class="kw-2">&amp;*</span>ptr); <span class="comment">// will print "3"
</span>}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Afn+main()+%7B%0A++++use+core::fmt::Debug;%0A++++let+arr:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0A++++let+mut+ptr+=+arr.as_ptr()+as+*const+dyn+Debug;%0A++++let+thin+=+ptr+as+*const+u8;%0A++++unsafe+%7B%0A++++++++ptr+=+thin.add(8).with_metadata_of(ptr);%0A++++assert_eq!(*(ptr+as+*const+i32),+3);%0A++++++++println!(%22%7B:?%7D%22,+%26*ptr);+//+will+print+%223%22%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div><h5 id="incorrect-usage"><a class="doc-anchor" href="#incorrect-usage">¬ß</a><em>Incorrect</em> usage</h5>
<p>The provenance from pointers is <em>not</em> combined. The result must only be used to refer to the
address allowed by <code>self</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(set_ptr_value)]
</span><span class="kw">let </span>x = <span class="number">0u32</span>;
<span class="kw">let </span>y = <span class="number">1u32</span>;

<span class="kw">let </span>x = (<span class="kw-2">&amp;</span>x) <span class="kw">as </span><span class="kw-2">*const </span>u32;
<span class="kw">let </span>y = (<span class="kw-2">&amp;</span>y) <span class="kw">as </span><span class="kw-2">*const </span>u32;

<span class="kw">let </span>offset = (x <span class="kw">as </span>usize - y <span class="kw">as </span>usize) / <span class="number">4</span>;
<span class="kw">let </span>bad = x.wrapping_add(offset).with_metadata_of(y);

<span class="comment">// This dereference is UB. The pointer only has provenance for `x` but points to `y`.
</span><span class="macro">println!</span>(<span class="string">"{:?}"</span>, <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>bad });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0A%0Afn+main()+%7B%0A++++let+x+=+0u32;%0A++++let+y+=+1u32;%0A++++%0A++++let+x+=+(%26x)+as+*const+u32;%0A++++let+y+=+(%26y)+as+*const+u32;%0A++++%0A++++let+offset+=+(x+as+usize+-+y+as+usize)+/+4;%0A++++let+bad+=+x.wrapping_add(offset).with_metadata_of(y);%0A++++%0A++++//+This+dereference+is+UB.+The+pointer+only+has+provenance+for+%60x%60+but+points+to+%60y%60.%0A++++println!(%22%7B:?%7D%22,+unsafe+%7B+%26*bad+%7D);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cast_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.65.0, const since 1.65.0">1.65.0 (const: 1.65.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#145-147">Source</a></span><h4 class="code-header">pub const fn <a href="#method.cast_mut" class="fn">cast_mut</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Changes constness without changing the type.</p>
<p>This is a bit safer than <code>as</code> because it wouldn‚Äôt silently change the type if the code is
refactored.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.addr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#153-160">Source</a></span><h4 class="code-header">pub fn <a href="#method.addr" class="fn">addr</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the ‚Äúaddress‚Äù portion of the pointer.</p>
<p>This is similar to <code>self as usize</code>, except that the <a href="ptr/index.html#provenance" title="mod core::ptr">provenance</a> of
the pointer is discarded and not <a href="ptr/index.html#exposed-provenance" title="mod core::ptr">exposed</a>. This means that
casting the returned address back to a pointer yields a <a href="ptr/fn.without_provenance.html" title="fn core::ptr::without_provenance">pointer without
provenance</a>, which is undefined behavior to dereference. To properly
restore the lost information and obtain a dereferenceable pointer, use
<a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> or <a href="primitive.pointer.html#method.map_addr" title="method pointer::map_addr"><code>map_addr</code></a>.</p>
<p>If using those APIs is not possible because there is no way to preserve a pointer with the
required provenance, then Strict Provenance might not be for you. Use pointer-integer casts
or <a href="primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a> and <a href="ptr/fn.with_exposed_provenance.html" title="fn core::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a>
instead. However, note that this makes your code less portable and less amenable to tools
that check for compliance with the Rust memory model.</p>
<p>On most platforms this will produce a value with the same bytes as the original
pointer, because all the bytes are dedicated to describing the address.
Platforms which need to store additional information in the pointer may
perform a change of representation to produce a value containing only the address
portion of the pointer. What that means is up to the platform to define.</p>
<p>This is a <a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expose_provenance" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#186-188">Source</a></span><h4 class="code-header">pub fn <a href="#method.expose_provenance" class="fn">expose_provenance</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Exposes the <a href="ptr/index.html#provenance" title="mod core::ptr">‚Äúprovenance‚Äù</a> part of the pointer for future use in
<a href="ptr/fn.with_exposed_provenance.html" title="fn core::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a> and returns the ‚Äúaddress‚Äù portion.</p>
<p>This is equivalent to <code>self as usize</code>, which semantically discards provenance information.
Furthermore, this (like the <code>as</code> cast) has the implicit side-effect of marking the
provenance as ‚Äòexposed‚Äô, so on platforms that support it you can later call
<a href="ptr/fn.with_exposed_provenance.html" title="fn core::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a> to reconstitute the original pointer including its provenance.</p>
<p>Due to its inherent ambiguity, <a href="ptr/fn.with_exposed_provenance.html" title="fn core::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a> may not be supported by tools
that help you to stay conformant with the Rust memory model. It is recommended to use
<a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> APIs such as <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a>
wherever possible, in which case <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>addr</code></a> should be used instead of <code>expose_provenance</code>.</p>
<p>On most platforms this will produce a value with the same bytes as the original pointer,
because all the bytes are dedicated to describing the address. Platforms which need to store
additional information in the pointer may not support this operation, since the ‚Äòexpose‚Äô
side-effect which is required for <a href="ptr/fn.with_exposed_provenance.html" title="fn core::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a> to work is typically not
available.</p>
<p>This is an <a href="ptr/index.html#exposed-provenance" title="mod core::ptr">Exposed Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_addr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#204-212">Source</a></span><h4 class="code-header">pub fn <a href="#method.with_addr" class="fn">with_addr</a>(self, addr: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new pointer with the given address and the <a href="ptr/index.html#provenance" title="mod core::ptr">provenance</a> of
<code>self</code>.</p>
<p>This is similar to a <code>addr as *const T</code> cast, but copies
the <em>provenance</em> of <code>self</code> to the new pointer.
This avoids the inherent ambiguity of the unary cast.</p>
<p>This is equivalent to using <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset"><code>wrapping_offset</code></a> to offset
<code>self</code> to the given address, and therefore has all the same capabilities and restrictions.</p>
<p>This is a <a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map_addr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#223-225">Source</a></span><h4 class="code-header">pub fn <a href="#method.map_addr" class="fn">map_addr</a>(self, f: impl <a class="trait" href="ops/trait.FnOnce.html" title="trait core::ops::FnOnce">FnOnce</a>(<a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new pointer by mapping <code>self</code>‚Äôs address to a new one, preserving the
<a href="ptr/index.html#provenance" title="mod core::ptr">provenance</a> of <code>self</code>.</p>
<p>This is a convenience for <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a>, see that method for details.</p>
<p>This is a <a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_raw_parts" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#232-234">Source</a><h4 class="code-header">pub const fn <a href="#method.to_raw_parts" class="fn">to_raw_parts</a>(self) -&gt; (<a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait core::ptr::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type core::ptr::Pointee::Metadata">Metadata</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</span></div></span></summary><div class="docblock"><p>Decompose a (possibly wide) pointer into its data pointer and metadata components.</p>
<p>The pointer can be later reconstructed with <a href="ptr/fn.from_raw_parts.html" title="fn core::ptr::from_raw_parts"><code>from_raw_parts</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const since 1.84.0">1.9.0 (const: 1.84.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#265-269">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.as_ref" class="fn">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. If the value may be uninitialized, <a href="#method.as_uninit_ref"><code>as_uninit_ref</code></a>
must be used instead.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.</p>
<h5 id="panics-during-const-evaluation-1"><a class="doc-anchor" href="#panics-during-const-evaluation-1">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null"><code>is_null</code></a> for more information.</p>
<h5 id="null-unchecked-version"><a class="doc-anchor" href="#null-unchecked-version">¬ß</a>Null-unchecked version</h5>
<p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_ref_unchecked</code> that returns the <code>&amp;T</code> instead of <code>Option&lt;&amp;T&gt;</code>, know that you can
dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = <span class="kw-2">&amp;</span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>val_back = <span class="kw-2">&amp;*</span>ptr;
    <span class="macro">assert_eq!</span>(val_back, <span class="kw-2">&amp;</span><span class="number">10</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr:+*const+u8+=+%2610u8+as+*const+u8;%0A++++%0A++++unsafe+%7B%0A++++++++let+val_back+=+%26*ptr;%0A++++++++assert_eq!(val_back,+%2610);%0A++++%7D%0A%7D&amp;edition=2024"></a></div><h5 id="examples-3"><a class="doc-anchor" href="#examples-3">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = <span class="kw-2">&amp;</span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_ref() {
        <span class="macro">assert_eq!</span>(val_back, <span class="kw-2">&amp;</span><span class="number">10</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr:+*const+u8+=+%2610u8+as+*const+u8;%0A++++%0A++++unsafe+%7B%0A++++++++if+let+Some(val_back)+=+ptr.as_ref()+%7B%0A++++++++++++assert_eq!(val_back,+%2610);%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_ref_unchecked" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#297-300">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_ref_unchecked" class="fn">as_ref_unchecked</a>&lt;'a&gt;(self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;'a T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_ref_unchecked</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/122034">#122034</a>)</span></div></span></summary><div class="docblock"><p>Returns a shared reference to the value behind the pointer.
If the pointer may be null or the value may be uninitialized, <a href="#method.as_uninit_ref"><code>as_uninit_ref</code></a> must be used instead.
If the pointer may be null, but the value is known to have been initialized, <a href="#method.as_ref"><code>as_ref</code></a> must be used instead.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_as_ref_unchecked)]
</span><span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = <span class="kw-2">&amp;</span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(ptr.as_ref_unchecked(), <span class="kw-2">&amp;</span><span class="number">10</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_ref_unchecked)%5D%0A%0Afn+main()+%7B%0A++++let+ptr:+*const+u8+=+%2610u8+as+*const+u8;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(ptr.as_ref_unchecked(),+%2610);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_ref" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#322-329">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_uninit_ref" class="fn">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_ref"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.
Note that because the created reference is to <code>MaybeUninit&lt;T&gt;</code>, the
source pointer can point to uninitialized memory.</p>
<h5 id="panics-during-const-evaluation-2"><a class="doc-anchor" href="#panics-during-const-evaluation-2">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null"><code>is_null</code></a> for more information.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_as_uninit)]

</span><span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = <span class="kw-2">&amp;</span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_uninit_ref() {
        <span class="macro">assert_eq!</span>(val_back.assume_init(), <span class="number">10</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0A%0Afn+main()+%7B%0A++++let+ptr:+*const+u8+=+%2610u8+as+*const+u8;%0A++++%0A++++unsafe+%7B%0A++++++++if+let+Some(val_back)+=+ptr.as_uninit_ref()+%7B%0A++++++++++++assert_eq!(val_back.assume_init(),+10);%0A++++++++%7D%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.61.0">1.0.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#349-385">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset" class="fn">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds a signed offset to a pointer.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p>The offset in bytes, <code>count * size_of::&lt;T&gt;()</code>, computed on mathematical integers (without
‚Äúwrapping around‚Äù), must fit in an <code>isize</code>.</p>
</li>
<li>
<p>If the computed offset is non-zero, then <code>self</code> must be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to some
<a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the entire memory range between <code>self</code> and the result must be in
bounds of that allocation. In particular, this range must not ‚Äúwrap around‚Äù the edge
of the address space. Note that ‚Äúrange‚Äù here refers to a half-open range as usual in Rust,
i.e., <code>self..result</code> for non-negative offsets and <code>result..self</code> for negative offsets.</p>
</li>
</ul>
<p>Allocations can never be larger than <code>isize::MAX</code> bytes, so if the computed offset
stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.
This implies, for instance, that <code>vec.as_ptr().add(vec.len())</code> (for <code>vec: Vec&lt;T&gt;</code>) is always
safe.</p>
<p>Consider using <a href="#method.wrapping_offset"><code>wrapping_offset</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">"123"</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = s.as_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>ptr.offset(<span class="number">1</span>) <span class="kw">as </span>char, <span class="string">'2'</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>ptr.offset(<span class="number">2</span>) <span class="kw">as </span>char, <span class="string">'3'</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s:+%26str+=+%22123%22;%0A++++let+ptr:+*const+u8+=+s.as_ptr();%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(*ptr.offset(1)+as+char,+'2');%0A++++++++assert_eq!(*ptr.offset(2)+as+char,+'3');%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#402-405">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_offset" class="fn">byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds a signed offset in bytes to a pointer.</p>
<p><code>count</code> is in units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.offset" title="method pointer::offset">offset</a> on it. See that method for documentation
and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_offset" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0, const since 1.61.0">1.16.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#463-469">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_offset" class="fn">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds a signed offset to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">¬ß</a>Safety</h5>
<p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p>The resulting pointer ‚Äúremembers‚Äù the <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a> that <code>self</code> points to
(this is called ‚Äú<a href="ptr/index.html#provenance">Provenance</a>‚Äù).
The pointer must not be used to read or write other allocations.</p>
<p>In other words, <code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocation.</p>
<p>Compared to <a href="#method.offset"><code>offset</code></a>, this method basically delays the requirement of staying within the
same allocation: <a href="#method.offset"><code>offset</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_offset</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.offset"><code>offset</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> is always the same as <code>x</code>. In other
words, leaving the allocation and then re-entering it later is permitted.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_offset(<span class="number">6</span>);

<span class="kw">let </span><span class="kw-2">mut </span>out = String::new();
<span class="kw">while </span><span class="macro">ptr !</span>= end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="macro">write!</span>(<span class="kw-2">&amp;mut </span>out, <span class="string">"{}, "</span>, <span class="kw-2">*</span>ptr)<span class="question-mark">?</span>;
    }
    ptr = ptr.wrapping_offset(step);
}
<span class="macro">assert_eq!</span>(out.as_str(), <span class="string">"1, 3, 5, "</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+core::result::Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::fmt::Write;%0A++++//+Iterate+using+a+raw+pointer+in+increments+of+two+elements%0A++++let+data+=+%5B1u8,+2,+3,+4,+5%5D;%0A++++let+mut+ptr:+*const+u8+=+data.as_ptr();%0A++++let+step+=+2;%0A++++let+end_rounded_up+=+ptr.wrapping_offset(6);%0A++++%0A++++let+mut+out+=+String::new();%0A++++while+ptr+!=+end_rounded_up+%7B%0A++++++++unsafe+%7B%0A++++++++++++write!(%26mut+out,+%22%7B%7D,+%22,+*ptr)?;%0A++++++++%7D%0A++++++++ptr+=+ptr.wrapping_offset(step);%0A++++%7D%0A++++assert_eq!(out.as_str(),+%221,+3,+5,+%22);%0A++++std::fmt::Result::Ok(())%0A%7D+_inner().unwrap()+%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_offset" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#485-487">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_byte_offset" class="fn">wrapping_byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds a signed offset in bytes to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset">wrapping_offset</a> on it. See that method
for documentation.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mask" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#523-525">Source</a><h4 class="code-header">pub fn <a href="#method.mask" class="fn">mask</a>(self, mask: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_mask</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/98290">#98290</a>)</span></div></span></summary><div class="docblock"><p>Masks out bits of the pointer according to a mask.</p>
<p>This is convenience for <code>ptr.map_addr(|a| a &amp; mask)</code>.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
<h6 id="examples-8"><a class="doc-anchor" href="#examples-8">¬ß</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_mask)]
</span><span class="kw">let </span>v = <span class="number">17_u32</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u32 = <span class="kw-2">&amp;</span>v;

<span class="comment">// `u32` is 4 bytes aligned,
// which means that lower 2 bits are always 0.
</span><span class="kw">let </span>tag_mask = <span class="number">0b11</span>;
<span class="kw">let </span>ptr_mask = !tag_mask;

<span class="comment">// We can store something in these lower bits
</span><span class="kw">let </span>tagged_ptr = ptr.map_addr(|a| a | <span class="number">0b10</span>);

<span class="comment">// Get the "tag" back
</span><span class="kw">let </span>tag = tagged_ptr.addr() &amp; tag_mask;
<span class="macro">assert_eq!</span>(tag, <span class="number">0b10</span>);

<span class="comment">// Note that `tagged_ptr` is unaligned, it's UB to read from it.
// To get original pointer `mask` can be used:
</span><span class="kw">let </span>masked_ptr = tagged_ptr.mask(ptr_mask);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ <span class="kw-2">*</span>masked_ptr }, <span class="number">17</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_mask)%5D%0A%0Afn+main()+%7B%0A++++let+v+=+17_u32;%0A++++let+ptr:+*const+u32+=+%26v;%0A++++%0A++++//+%60u32%60+is+4+bytes+aligned,%0A++++//+which+means+that+lower+2+bits+are+always+0.%0A++++let+tag_mask+=+0b11;%0A++++let+ptr_mask+=+!tag_mask;%0A++++%0A++++//+We+can+store+something+in+these+lower+bits%0A++++let+tagged_ptr+=+ptr.map_addr(%7Ca%7C+a+%7C+0b10);%0A++++%0A++++//+Get+the+%22tag%22+back%0A++++let+tag+=+tagged_ptr.addr()+%26+tag_mask;%0A++++assert_eq!(tag,+0b10);%0A++++%0A++++//+Note+that+%60tagged_ptr%60+is+unaligned,+it's+UB+to+read+from+it.%0A++++//+To+get+original+pointer+%60mask%60+can+be+used:%0A++++let+masked_ptr+=+tagged_ptr.mask(ptr_mask);%0A++++assert_eq!(unsafe+%7B+*masked_ptr+%7D,+17);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.47.0, const since 1.65.0">1.47.0 (const: 1.65.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#612-620">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from" class="fn">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation. The returned value is in
units of T: the distance in bytes divided by <code>size_of::&lt;T&gt;()</code>.</p>
<p>This is equivalent to <code>(self as isize - origin as isize) / (size_of::&lt;T&gt;() as isize)</code>,
except that it has a lot more opportunities for UB, in exchange for the compiler
better understanding what you are doing.</p>
<p>The primary motivation of this method is for computing the <code>len</code> of an array/slice
of <code>T</code> that you are currently representing as a ‚Äústart‚Äù and ‚Äúend‚Äù pointer
(and ‚Äúend‚Äù is ‚Äúone past the end‚Äù of the array).
In that case, <code>end.offset_from(start)</code> gets you the length of the array.</p>
<p>All of the following safety requirements are trivially satisfied for this usecase.</p>
<h5 id="safety-5"><a class="doc-anchor" href="#safety-5">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p><code>self</code> and <code>origin</code> must either</p>
<ul>
<li>point to the same address, or</li>
<li>both be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to the same <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the memory range between
the two pointers must be in bounds of that object. (See below for an example.)</li>
</ul>
</li>
<li>
<p>The distance between the pointers, in bytes, must be an exact multiple
of the size of <code>T</code>.</p>
</li>
</ul>
<p>As a consequence, the absolute distance between the pointers, in bytes, computed on
mathematical integers (without ‚Äúwrapping around‚Äù), cannot overflow an <code>isize</code>. This is
implied by the in-bounds requirement, and the fact that no allocation can be larger
than <code>isize::MAX</code> bytes.</p>
<p>The requirement for pointers to be derived from the same allocation is primarily
needed for <code>const</code>-compatibility: the distance between pointers into <em>different</em> allocated
objects is not known at compile-time. However, the requirement also exists at
runtime and may be exploited by optimizations. If you wish to compute the difference between
pointers that are not guaranteed to be from the same allocation, use <code>(self as isize - origin as isize) / size_of::&lt;T&gt;()</code>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">¬ß</a>Panics</h5>
<p>This function panics if <code>T</code> is a Zero-Sized Type (‚ÄúZST‚Äù).</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">¬ß</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>ptr1: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">1</span>];
<span class="kw">let </span>ptr2: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">3</span>];
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(ptr2.offset_from(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset_from(ptr2), -<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.offset(-<span class="number">2</span>), ptr1);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0;+5%5D;%0A++++let+ptr1:+*const+i32+=+%26a%5B1%5D;%0A++++let+ptr2:+*const+i32+=+%26a%5B3%5D;%0A++++unsafe+%7B%0A++++++++assert_eq!(ptr2.offset_from(ptr1),+2);%0A++++++++assert_eq!(ptr1.offset_from(ptr2),+-2);%0A++++++++assert_eq!(ptr1.offset(2),+ptr2);%0A++++++++assert_eq!(ptr2.offset(-2),+ptr1);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
<p><em>Incorrect</em> usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr1 = Box::into_raw(Box::new(<span class="number">0u8</span>)) <span class="kw">as </span><span class="kw-2">*const </span>u8;
<span class="kw">let </span>ptr2 = Box::into_raw(Box::new(<span class="number">1u8</span>)) <span class="kw">as </span><span class="kw-2">*const </span>u8;
<span class="kw">let </span>diff = (ptr2 <span class="kw">as </span>isize).wrapping_sub(ptr1 <span class="kw">as </span>isize);
<span class="comment">// Make ptr2_other an "alias" of ptr2.add(1), but derived from ptr1.
</span><span class="kw">let </span>ptr2_other = (ptr1 <span class="kw">as </span><span class="kw-2">*const </span>u8).wrapping_offset(diff).wrapping_offset(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(ptr2 <span class="kw">as </span>usize, ptr2_other <span class="kw">as </span>usize);
<span class="comment">// Since ptr2_other and ptr2 are derived from pointers to different objects,
// computing their offset is undefined behavior, even though
// they point to addresses that are in-bounds of the same object!
</span><span class="kw">unsafe </span>{
    <span class="kw">let </span>one = ptr2_other.offset_from(ptr2); <span class="comment">// Undefined Behavior! ‚ö†Ô∏è
</span>}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr1+=+Box::into_raw(Box::new(0u8))+as+*const+u8;%0A++++let+ptr2+=+Box::into_raw(Box::new(1u8))+as+*const+u8;%0A++++let+diff+=+(ptr2+as+isize).wrapping_sub(ptr1+as+isize);%0A++++//+Make+ptr2_other+an+%22alias%22+of+ptr2.add(1),+but+derived+from+ptr1.%0A++++let+ptr2_other+=+(ptr1+as+*const+u8).wrapping_offset(diff).wrapping_offset(1);%0A++++assert_eq!(ptr2+as+usize,+ptr2_other+as+usize);%0A++++//+Since+ptr2_other+and+ptr2+are+derived+from+pointers+to+different+objects,%0A++++//+computing+their+offset+is+undefined+behavior,+even+though%0A++++//+they+point+to+addresses+that+are+in-bounds+of+the+same+object!%0A++++unsafe+%7B%0A++++++++let+one+=+ptr2_other.offset_from(ptr2);+//+Undefined+Behavior!+%E2%9A%A0%EF%B8%8F%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset_from" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#635-638">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_offset_from" class="fn">byte_offset_from</a>&lt;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(self, origin: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation. The returned value is in
units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.offset_from" title="method pointer::offset_from"><code>offset_from</code></a> on it. See that method for
documentation and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation considers only the data pointers,
ignoring the metadata.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from_unsigned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#701-730">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from_unsigned" class="fn">offset_from_unsigned</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation, <em>where it‚Äôs known that
<code>self</code> is equal to or greater than <code>origin</code></em>. The returned value is in
units of T: the distance in bytes is divided by <code>size_of::&lt;T&gt;()</code>.</p>
<p>This computes the same value that <a href="#method.offset_from"><code>offset_from</code></a>
would compute, but with the added precondition that the offset is
guaranteed to be non-negative.  This method is equivalent to
<code>usize::try_from(self.offset_from(origin)).unwrap_unchecked()</code>,
but it provides slightly more information to the optimizer, which can
sometimes allow it to optimize slightly better with some backends.</p>
<p>This method can be thought of as recovering the <code>count</code> that was passed
to <a href="#method.add"><code>add</code></a> (or, with the parameters in the other order,
to <a href="#method.sub"><code>sub</code></a>).  The following are all equivalent, assuming
that their safety preconditions are met:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ptr.offset_from_unsigned(origin) == count
origin.add(count) == ptr
ptr.sub(count) == origin</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++unsafe+fn+blah(ptr:+*const+i32,+origin:+*const+i32,+count:+usize)+-%3E+bool+%7B+unsafe+%7B%0A++++ptr.offset_from_unsigned(origin)+==+count%0A++++%26%26%0A++++origin.add(count)+==+ptr%0A++++%26%26%0A++++ptr.sub(count)+==+origin%0A++++%7D+%7D%0A%7D&amp;edition=2024"></a></div><h5 id="safety-6"><a class="doc-anchor" href="#safety-6">¬ß</a>Safety</h5>
<ul>
<li>
<p>The distance between the pointers must be non-negative (<code>self &gt;= origin</code>)</p>
</li>
<li>
<p><em>All</em> the safety conditions of <a href="#method.offset_from"><code>offset_from</code></a>
apply to this method as well; see it for the full details.</p>
</li>
</ul>
<p>Importantly, despite the return type of this method being able to represent
a larger offset, it‚Äôs still <em>not permitted</em> to pass pointers which differ
by more than <code>isize::MAX</code> <em>bytes</em>.  As such, the result of this method will
always be less than or equal to <code>isize::MAX as usize</code>.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">¬ß</a>Panics</h5>
<p>This function panics if <code>T</code> is a Zero-Sized Type (‚ÄúZST‚Äù).</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>ptr1: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">1</span>];
<span class="kw">let </span>ptr2: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">3</span>];
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(ptr2.offset_from_unsigned(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.add(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.sub(<span class="number">2</span>), ptr1);
    <span class="macro">assert_eq!</span>(ptr2.offset_from_unsigned(ptr2), <span class="number">0</span>);
}

<span class="comment">// This would be incorrect, as the pointers are not correctly ordered:
// ptr1.offset_from_unsigned(ptr2)</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+a+=+%5B0;+5%5D;%0A++++let+ptr1:+*const+i32+=+%26a%5B1%5D;%0A++++let+ptr2:+*const+i32+=+%26a%5B3%5D;%0A++++unsafe+%7B%0A++++++++assert_eq!(ptr2.offset_from_unsigned(ptr1),+2);%0A++++++++assert_eq!(ptr1.add(2),+ptr2);%0A++++++++assert_eq!(ptr2.sub(2),+ptr1);%0A++++++++assert_eq!(ptr2.offset_from_unsigned(ptr2),+0);%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset_from_unsigned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#746-749">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_offset_from_unsigned" class="fn">byte_offset_from_unsigned</a>&lt;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(
    self,
    origin: <a class="primitive" href="primitive.pointer.html">*const U</a>,
) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation, <em>where it‚Äôs known that
<code>self</code> is equal to or greater than <code>origin</code></em>. The returned value is in
units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.offset_from_unsigned" title="method pointer::offset_from_unsigned"><code>offset_from_unsigned</code></a> on it.
See that method for documentation and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation considers only the data pointers,
ignoring the metadata.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_eq" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#771-779">Source</a><h4 class="code-header">pub const fn <a href="#method.guaranteed_eq" class="fn">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>Returns whether two pointers are guaranteed to be equal.</p>
<p>At runtime this function behaves like <code>Some(self == other)</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine equality of two pointers, so this function may
spuriously return <code>None</code> for pointers that later actually turn out to have its equality known.
But when it returns <code>Some</code>, the pointers‚Äô equality is guaranteed to be known.</p>
<p>The return value may change from <code>Some</code> to <code>None</code> and vice versa depending on the compiler
version and unsafe code must not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>None</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_ne" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#801-809">Source</a><h4 class="code-header">pub const fn <a href="#method.guaranteed_ne" class="fn">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>Returns whether two pointers are guaranteed to be inequal.</p>
<p>At runtime this function behaves like <code>Some(self != other)</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine inequality of two pointers, so this function may
spuriously return <code>None</code> for pointers that later actually turn out to have its inequality known.
But when it returns <code>Some</code>, the pointers‚Äô inequality is guaranteed to be known.</p>
<p>The return value may change from <code>Some</code> to <code>None</code> and vice versa depending on the compiler
version and unsafe code must not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>None</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#829-864">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.add" class="fn">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds an unsigned offset to a pointer.</p>
<p>This can only move the pointer forward (or not move it). If you need to move forward or
backward depending on the value, then you might want <a href="#method.offset"><code>offset</code></a> instead
which takes a signed offset.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-7"><a class="doc-anchor" href="#safety-7">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p>The offset in bytes, <code>count * size_of::&lt;T&gt;()</code>, computed on mathematical integers (without
‚Äúwrapping around‚Äù), must fit in an <code>isize</code>.</p>
</li>
<li>
<p>If the computed offset is non-zero, then <code>self</code> must be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to some
<a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the entire memory range between <code>self</code> and the result must be in
bounds of that allocation. In particular, this range must not ‚Äúwrap around‚Äù the edge
of the address space.</p>
</li>
</ul>
<p>Allocations can never be larger than <code>isize::MAX</code> bytes, so if the computed offset
stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.
This implies, for instance, that <code>vec.as_ptr().add(vec.len())</code> (for <code>vec: Vec&lt;T&gt;</code>) is always
safe.</p>
<p>Consider using <a href="#method.wrapping_add"><code>wrapping_add</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">"123"</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = s.as_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>ptr.add(<span class="number">1</span>), <span class="string">b'2'</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>ptr.add(<span class="number">2</span>), <span class="string">b'3'</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s:+%26str+=+%22123%22;%0A++++let+ptr:+*const+u8+=+s.as_ptr();%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(*ptr.add(1),+b'2');%0A++++++++assert_eq!(*ptr.add(2),+b'3');%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#881-884">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_add" class="fn">byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds an unsigned offset in bytes to a pointer.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.add" title="method pointer::add">add</a> on it. See that method for documentation
and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#935-976">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.sub" class="fn">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset from a pointer.</p>
<p>This can only move the pointer backward (or not move it). If you need to move forward or
backward depending on the value, then you might want <a href="#method.offset"><code>offset</code></a> instead
which takes a signed offset.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-8"><a class="doc-anchor" href="#safety-8">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p>The offset in bytes, <code>count * size_of::&lt;T&gt;()</code>, computed on mathematical integers (without
‚Äúwrapping around‚Äù), must fit in an <code>isize</code>.</p>
</li>
<li>
<p>If the computed offset is non-zero, then <code>self</code> must be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to some
<a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the entire memory range between <code>self</code> and the result must be in
bounds of that allocation. In particular, this range must not ‚Äúwrap around‚Äù the edge
of the address space.</p>
</li>
</ul>
<p>Allocations can never be larger than <code>isize::MAX</code> bytes, so if the computed offset
stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.
This implies, for instance, that <code>vec.as_ptr().add(vec.len())</code> (for <code>vec: Vec&lt;T&gt;</code>) is always
safe.</p>
<p>Consider using <a href="#method.wrapping_sub"><code>wrapping_sub</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">"123"</span>;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>end: <span class="kw-2">*const </span>u8 = s.as_ptr().add(<span class="number">3</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>end.sub(<span class="number">1</span>), <span class="string">b'3'</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>end.sub(<span class="number">2</span>), <span class="string">b'2'</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s:+%26str+=+%22123%22;%0A++++%0A++++unsafe+%7B%0A++++++++let+end:+*const+u8+=+s.as_ptr().add(3);%0A++++++++assert_eq!(*end.sub(1),+b'3');%0A++++++++assert_eq!(*end.sub(2),+b'2');%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#993-996">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_sub" class="fn">byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset in bytes from a pointer.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.sub" title="method pointer::sub">sub</a> on it. See that method for documentation
and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1053-1058">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_add" class="fn">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds an unsigned offset to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-9"><a class="doc-anchor" href="#safety-9">¬ß</a>Safety</h5>
<p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p>The resulting pointer ‚Äúremembers‚Äù the <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a> that <code>self</code> points to; it must not
be used to read or write other allocations.</p>
<p>In other words, <code>let z = x.wrapping_add((y as usize) - (x as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocation.</p>
<p>Compared to <a href="#method.add"><code>add</code></a>, this method basically delays the requirement of staying within the
same allocation: <a href="#method.add"><code>add</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_add</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.add"><code>add</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocation and then re-entering it later is permitted.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_add(<span class="number">6</span>);

<span class="kw">let </span><span class="kw-2">mut </span>out = String::new();
<span class="kw">while </span><span class="macro">ptr !</span>= end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="macro">write!</span>(<span class="kw-2">&amp;mut </span>out, <span class="string">"{}, "</span>, <span class="kw-2">*</span>ptr)<span class="question-mark">?</span>;
    }
    ptr = ptr.wrapping_add(step);
}
<span class="macro">assert_eq!</span>(out, <span class="string">"1, 3, 5, "</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+core::result::Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::fmt::Write;%0A++++//+Iterate+using+a+raw+pointer+in+increments+of+two+elements%0A++++let+data+=+%5B1u8,+2,+3,+4,+5%5D;%0A++++let+mut+ptr:+*const+u8+=+data.as_ptr();%0A++++let+step+=+2;%0A++++let+end_rounded_up+=+ptr.wrapping_add(6);%0A++++%0A++++let+mut+out+=+String::new();%0A++++while+ptr+!=+end_rounded_up+%7B%0A++++++++unsafe+%7B%0A++++++++++++write!(%26mut+out,+%22%7B%7D,+%22,+*ptr)?;%0A++++++++%7D%0A++++++++ptr+=+ptr.wrapping_add(step);%0A++++%7D%0A++++assert_eq!(out,+%221,+3,+5,+%22);%0A++++std::fmt::Result::Ok(())%0A%7D+_inner().unwrap()+%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1073-1075">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_byte_add" class="fn">wrapping_byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds an unsigned offset in bytes to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.wrapping_add" title="method pointer::wrapping_add">wrapping_add</a> on it. See that method for documentation.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1132-1137">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_sub" class="fn">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-10"><a class="doc-anchor" href="#safety-10">¬ß</a>Safety</h5>
<p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p>The resulting pointer ‚Äúremembers‚Äù the <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a> that <code>self</code> points to; it must not
be used to read or write other allocations.</p>
<p>In other words, <code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocation.</p>
<p>Compared to <a href="#method.sub"><code>sub</code></a>, this method basically delays the requirement of staying within the
same allocation: <a href="#method.sub"><code>sub</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_sub</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.sub"><code>sub</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocation and then re-entering it later is permitted.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements (backwards)
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>start_rounded_down = ptr.wrapping_sub(<span class="number">2</span>);
ptr = ptr.wrapping_add(<span class="number">4</span>);
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span><span class="kw-2">mut </span>out = String::new();
<span class="kw">while </span><span class="macro">ptr !</span>= start_rounded_down {
    <span class="kw">unsafe </span>{
        <span class="macro">write!</span>(<span class="kw-2">&amp;mut </span>out, <span class="string">"{}, "</span>, <span class="kw-2">*</span>ptr)<span class="question-mark">?</span>;
    }
    ptr = ptr.wrapping_sub(step);
}
<span class="macro">assert_eq!</span>(out, <span class="string">"5, 3, 1, "</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B+fn+_inner()+-%3E+core::result::Result%3C(),+impl+core::fmt::Debug%3E+%7B%0A++++use+std::fmt::Write;%0A++++//+Iterate+using+a+raw+pointer+in+increments+of+two+elements+(backwards)%0A++++let+data+=+%5B1u8,+2,+3,+4,+5%5D;%0A++++let+mut+ptr:+*const+u8+=+data.as_ptr();%0A++++let+start_rounded_down+=+ptr.wrapping_sub(2);%0A++++ptr+=+ptr.wrapping_add(4);%0A++++let+step+=+2;%0A++++let+mut+out+=+String::new();%0A++++while+ptr+!=+start_rounded_down+%7B%0A++++++++unsafe+%7B%0A++++++++++++write!(%26mut+out,+%22%7B%7D,+%22,+*ptr)?;%0A++++++++%7D%0A++++++++ptr+=+ptr.wrapping_sub(step);%0A++++%7D%0A++++assert_eq!(out,+%225,+3,+1,+%22);%0A++++std::fmt::Result::Ok(())%0A%7D+_inner().unwrap()+%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1152-1154">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_byte_sub" class="fn">wrapping_byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset in bytes from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.wrapping_sub" title="method pointer::wrapping_sub">wrapping_sub</a> on it. See that method for documentation.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1166-1172">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read" class="fn">read</a>(self) -&gt; T<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>See <a href="ptr/fn.read.html" title="fn core::ptr::read"><code>ptr::read</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_volatile" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1187-1193">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile" class="fn">read_volatile</a>(self) -&gt; T<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Performs a volatile read of the value from <code>self</code> without moving it. This
leaves the memory in <code>self</code> unchanged.</p>
<p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p>See <a href="ptr/fn.read_volatile.html" title="fn core::ptr::read_volatile"><code>ptr::read_volatile</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_unaligned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1207-1213">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read_unaligned" class="fn">read_unaligned</a>(self) -&gt; T<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>Unlike <code>read</code>, the pointer may be unaligned.</p>
<p>See <a href="ptr/fn.read_unaligned.html" title="fn core::ptr::read_unaligned"><code>ptr::read_unaligned</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1227-1233">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to" class="fn">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy.html" title="fn core::ptr::copy"><code>ptr::copy</code></a>.</p>
<p>See <a href="ptr/fn.copy.html" title="fn core::ptr::copy"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to_nonoverlapping" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1247-1253">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to_nonoverlapping" class="fn">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may <em>not</em> overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy_nonoverlapping.html" title="fn core::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p>See <a href="ptr/fn.copy_nonoverlapping.html" title="fn core::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.align_offset" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1294-1312">Source</a></span><h4 class="code-header">pub fn <a href="#method.align_offset" class="fn">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Computes the offset that needs to be applied to the pointer in order to make it aligned to
<code>align</code>.</p>
<p>If it is not possible to align the pointer, the implementation returns
<code>usize::MAX</code>.</p>
<p>The offset is expressed in number of <code>T</code> elements, and not bytes. The value returned can be
used with the <code>wrapping_add</code> method.</p>
<p>There are no guarantees whatsoever that offsetting the pointer will not overflow or go
beyond the allocation that the pointer points into. It is up to the caller to ensure that
the returned offset is correct in all terms other than alignment.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">¬ß</a>Panics</h5>
<p>The function panics if <code>align</code> is not a power-of-two.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">¬ß</a>Examples</h5>
<p>Accessing adjacent <code>u8</code> as <code>u16</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = [<span class="number">5_u8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];
<span class="kw">let </span>ptr = x.as_ptr();
<span class="kw">let </span>offset = ptr.align_offset(align_of::&lt;u16&gt;());

<span class="kw">if </span>offset &lt; x.len() - <span class="number">1 </span>{
    <span class="kw">let </span>u16_ptr = ptr.add(offset).cast::&lt;u16&gt;();
    <span class="macro">assert!</span>(<span class="kw-2">*</span>u16_ptr == u16::from_ne_bytes([<span class="number">5</span>, <span class="number">6</span>]) || <span class="kw-2">*</span>u16_ptr == u16::from_ne_bytes([<span class="number">6</span>, <span class="number">7</span>]));
} <span class="kw">else </span>{
    <span class="comment">// while the pointer can be aligned via `offset`, it would point
    // outside the allocation
</span>}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++unsafe+%7B%0A++++let+x+=+%5B5_u8,+6,+7,+8,+9%5D;%0A++++let+ptr+=+x.as_ptr();%0A++++let+offset+=+ptr.align_offset(align_of::%3Cu16%3E());%0A++++%0A++++if+offset+%3C+x.len()+-+1+%7B%0A++++++++let+u16_ptr+=+ptr.add(offset).cast::%3Cu16%3E();%0A++++++++assert!(*u16_ptr+==+u16::from_ne_bytes(%5B5,+6%5D)+%7C%7C+*u16_ptr+==+u16::from_ne_bytes(%5B6,+7%5D));%0A++++%7D+else+%7B%0A++++++++//+while+the+pointer+can+be+aligned+via+%60offset%60,+it+would+point%0A++++++++//+outside+the+allocation%0A++++%7D%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.79.0">1.79.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1332-1337">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_aligned" class="fn">is_aligned</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Returns whether the pointer is properly aligned for <code>T</code>.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// On some platforms, the alignment of i32 is less than 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>data <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned());
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">1</span>).is_aligned());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+On+some+platforms,+the+alignment+of+i32+is+less+than+4.%0A++++%23%5Brepr(align(4))%5D%0A++++struct+AlignedI32(i32);%0A++++%0A++++let+data+=+AlignedI32(42);%0A++++let+ptr+=+%26data+as+*const+AlignedI32;%0A++++%0A++++assert!(ptr.is_aligned());%0A++++assert!(!ptr.wrapping_byte_add(1).is_aligned());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned_to" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1372-1378">Source</a><h4 class="code-header">pub fn <a href="#method.is_aligned_to" class="fn">is_aligned_to</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>pointer_is_aligned_to</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96284">#96284</a>)</span></div></span></summary><div class="docblock"><p>Returns whether the pointer is aligned to <code>align</code>.</p>
<p>For non-<code>Sized</code> pointees this operation considers only the data pointer,
ignoring the metadata.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">¬ß</a>Panics</h5>
<p>The function panics if <code>align</code> is not a power-of-two (this includes 0).</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned_to)]

</span><span class="comment">// On some platforms, the alignment of i32 is less than 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>data <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));

<span class="macro">assert!</span>(ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">4</span>));

<span class="macro">assert_ne!</span>(ptr.is_aligned_to(<span class="number">8</span>), ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned_to)%5D%0A%0A%0A//+On+some+platforms,+the+alignment+of+i32+is+less+than+4.%0Afn+main()+%7B%0A++++%23%5Brepr(align(4))%5D%0A++++struct+AlignedI32(i32);%0A++++%0A++++let+data+=+AlignedI32(42);%0A++++let+ptr+=+%26data+as+*const+AlignedI32;%0A++++%0A++++assert!(ptr.is_aligned_to(1));%0A++++assert!(ptr.is_aligned_to(2));%0A++++assert!(ptr.is_aligned_to(4));%0A++++%0A++++assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));%0A++++assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));%0A++++%0A++++assert_ne!(ptr.is_aligned_to(8),+ptr.wrapping_add(1).is_aligned_to(8));%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*const+T-1" class="impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1381-1389">Source</a><a href="#impl-*const+T-1" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cast_uninit" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1386-1388">Source</a><h4 class="code-header">pub const fn <a href="#method.cast_uninit" class="fn">cast_uninit</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>cast_maybe_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145036">#145036</a>)</span></div></span></summary><div class="docblock"><p>Casts from a type to its maybe-uninitialized version.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*const+MaybeUninit%3CT%3E" class="impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1390-1401">Source</a><a href="#impl-*const+MaybeUninit%3CT%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cast_init" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1398-1400">Source</a><h4 class="code-header">pub const fn <a href="#method.cast_init" class="fn">cast_init</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>cast_maybe_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145036">#145036</a>)</span></div></span></summary><div class="docblock"><p>Casts from a maybe-uninitialized type to its initialized version.</p>
<p>This is always safe, since UB can only occur if the pointer is read
before being initialized.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*const+%5BT%5D" class="impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1403-1519">Source</a><a href="#impl-*const+%5BT%5D" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.slice.html">[T]</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.79.0, const since 1.79.0">1.79.0 (const: 1.79.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1422-1424">Source</a></span><h4 class="code-header">pub const fn <a href="#method.len" class="fn">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of a raw slice.</p>
<p>The returned value is the number of <strong>elements</strong>, not the number of bytes.</p>
<p>This function is safe, even when the raw slice cannot be cast to a slice
reference because the pointer is null or unaligned.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*const </span>[i8] = ptr::slice_from_raw_parts(ptr::null(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.len(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+slice:+*const+%5Bi8%5D+=+ptr::slice_from_raw_parts(ptr::null(),+3);%0A++++assert_eq!(slice.len(),+3);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.79.0, const since 1.79.0">1.79.0 (const: 1.79.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1439-1441">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_empty" class="fn">is_empty</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the raw slice has a length of 0.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*const </span>[i8] = ptr::slice_from_raw_parts(ptr::null(), <span class="number">3</span>);
<span class="macro">assert!</span>(!slice.is_empty());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+slice:+*const+%5Bi8%5D+=+ptr::slice_from_raw_parts(ptr::null(),+3);%0A++++assert!(!slice.is_empty());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1458-1460">Source</a><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fn">as_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to the slice‚Äôs buffer.</p>
<p>This is equivalent to casting <code>self</code> to <code>*const T</code>, but more type-safe.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]
</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*const </span>[i8] = ptr::slice_from_raw_parts(ptr::null(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.as_ptr(), ptr::null());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+slice:+*const+%5Bi8%5D+=+ptr::slice_from_raw_parts(ptr::null(),+3);%0A++++assert_eq!(slice.as_ptr(),+ptr::null());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_array" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.93.0, const since 1.93.0">1.93.0 (const: 1.93.0)</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1469-1476">Source</a></span><h4 class="code-header">pub const fn <a href="#method.as_array" class="fn">as_array</a>&lt;const N: <a class="primitive" href="primitive.usize.html">usize</a>&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.array.html">[T; N]</a>&gt;</h4></section></summary><div class="docblock"><p>Gets a raw pointer to the underlying array.</p>
<p>If <code>N</code> is not exactly equal to the length of <code>self</code>, then this method returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1500-1506">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I&gt;(self, index: I) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[T]</a>&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to an element or subslice, without doing bounds
checking.</p>
<p>Calling this method with an out-of-bounds index or when <code>self</code> is not dereferenceable
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]

</span><span class="kw">let </span>x = <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as </span><span class="kw-2">*const </span>[i32];

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(x.get_unchecked(<span class="number">1</span>), x.as_ptr().add(<span class="number">1</span>));
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0A%0Afn+main()+%7B%0A++++let+x+=+%26%5B1,+2,+4%5D+as+*const+%5Bi32%5D;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(x.get_unchecked(1),+x.as_ptr().add(1));%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_slice" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1511-1518">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_uninit_slice" class="fn">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a [<a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a shared slice to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_ref"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<h5 id="safety-11"><a class="doc-anchor" href="#safety-11">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li>
<p>The pointer must be <a href="ptr/index.html#safety" title="mod core::ptr">valid</a> for reads for <code>ptr.len() * size_of::&lt;T&gt;()</code> many bytes,
and it must be properly aligned. This means in particular:</p>
</li>
<li>
<p>The entire memory range of this slice must be contained within a single <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>!
Slices can never span across multiple allocations.</p>
</li>
<li>
<p>The pointer must be aligned even for zero-length slices. One
reason for this is that enum layout optimizations may rely on references
(including slices of any length) being aligned and non-null to distinguish
them from other data. You can obtain a pointer that is usable as <code>data</code>
for zero-length slices using <a href="ptr/struct.NonNull.html#method.dangling" title="associated function core::ptr::NonNull::dangling"><code>NonNull::dangling()</code></a>.</p>
</li>
<li>
<p>The total size <code>ptr.len() * size_of::&lt;T&gt;()</code> of the slice must be no larger than <code>isize::MAX</code>.
See the safety documentation of <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a>.</p>
</li>
<li>
<p>You must enforce Rust‚Äôs aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, while this reference exists, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p>This applies even if the result of this method is unused!</p>
<p>See also <a href="slice/fn.from_raw_parts.html" title="fn core::slice::from_raw_parts"><code>slice::from_raw_parts</code></a>.</p>
<h5 id="panics-during-const-evaluation-3"><a class="doc-anchor" href="#panics-during-const-evaluation-3">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null"><code>is_null</code></a> for more information.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*const+T-2" class="impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1521-1528">Source</a><a href="#impl-*const+T-2" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cast_array" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1525-1527">Source</a><h4 class="code-header">pub const fn <a href="#method.cast_array" class="fn">cast_array</a>&lt;const N: <a class="primitive" href="primitive.usize.html">usize</a>&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.array.html">[T; N]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_cast_array</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/144514">#144514</a>)</span></div></span></summary><div class="docblock"><p>Casts from a pointer-to-<code>T</code> to a pointer-to-<code>[T; N]</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*const+%5BT;+N%5D" class="impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1530-1566">Source</a><a href="#impl-*const+%5BT;+N%5D" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, const N: <a class="primitive" href="primitive.usize.html">usize</a>&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.array.html">[T; N]</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ptr-1" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1546-1548">Source</a><h4 class="code-header">pub const fn <a href="#method.as_ptr-1" class="fn">as_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>array_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/119834">#119834</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to the array‚Äôs buffer.</p>
<p>This is equivalent to casting <code>self</code> to <code>*const T</code>, but more type-safe.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(array_ptr_get)]
</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>arr: <span class="kw-2">*const </span>[i8; <span class="number">3</span>] = ptr::null();
<span class="macro">assert_eq!</span>(arr.as_ptr(), ptr::null());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(array_ptr_get)%5D%0A%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+arr:+*const+%5Bi8;+3%5D+=+ptr::null();%0A++++assert_eq!(arr.as_ptr(),+ptr::null());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_slice" class="method"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1563-1565">Source</a><h4 class="code-header">pub const fn <a href="#method.as_slice" class="fn">as_slice</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.slice.html">[T]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>array_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/119834">#119834</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to a slice containing the entire array.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(array_ptr_get)]

</span><span class="kw">let </span>arr: <span class="kw-2">*const </span>[i32; <span class="number">3</span>] = <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as </span><span class="kw-2">*const </span>[i32; <span class="number">3</span>];
<span class="kw">let </span>slice: <span class="kw-2">*const </span>[i32] = arr.as_slice();
<span class="macro">assert_eq!</span>(slice.len(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(array_ptr_get)%5D%0A%0A%0Afn+main()+%7B%0A++++let+arr:+*const+%5Bi32;+3%5D+=+%26%5B1,+2,+4%5D+as+*const+%5Bi32;+3%5D;%0A++++let+slice:+*const+%5Bi32%5D+=+arr.as_slice();%0A++++assert_eq!(slice.len(),+3);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+T" class="impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#8-1645">Source</a><a href="#impl-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_null-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.84.0">1.0.0 (const: 1.84.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#22-24">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_null-1" class="fn">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the pointer is null.</p>
<p>Note that unsized types have many possible null pointers, as only the
raw data pointer is considered, not their length, vtable, etc.
Therefore, two pointers that are null may still not compare equal to
each other.</p>
<h5 id="panics-during-const-evaluation-4"><a class="doc-anchor" href="#panics-during-const-evaluation-4">¬ß</a>Panics during const evaluation</h5>
<p>If this method is used during const evaluation, and <code>self</code> is a pointer
that is offset beyond the bounds of the memory it initially pointed to,
then there might not be enough information to determine whether the
pointer is null. This is because the absolute address in memory is not
known at compile time. If the nullness of the pointer cannot be
determined, this method will panic.</p>
<p>In-bounds pointers are never null, so the method will never panic for
such pointers.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();
<span class="macro">assert!</span>(!ptr.is_null());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%5B1,+2,+3%5D;%0A++++let+ptr:+*mut+u32+=+s.as_mut_ptr();%0A++++assert!(!ptr.is_null());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cast-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#31-33">Source</a></span><h4 class="code-header">pub const fn <a href="#method.cast-1" class="fn">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut U</a></h4></section></summary><div class="docblock"><p>Casts to a pointer of another type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_cast_aligned-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#57-59">Source</a><h4 class="code-header">pub fn <a href="#method.try_cast_aligned-1" class="fn">try_cast_aligned</a>&lt;U&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>pointer_try_cast_aligned</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/141221">#141221</a>)</span></div></span></summary><div class="docblock"><p>Try to cast to a pointer of another type by checking alignment.</p>
<p>If the pointer is properly aligned to the target type, it will be
cast to the target type. Otherwise, <code>None</code> is returned.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_try_cast_aligned)]

</span><span class="kw">let </span><span class="kw-2">mut </span>x = <span class="number">0u64</span>;

<span class="kw">let </span>aligned: <span class="kw-2">*mut </span>u64 = <span class="kw-2">&amp;mut </span>x;
<span class="kw">let </span>unaligned = <span class="kw">unsafe </span>{ aligned.byte_add(<span class="number">1</span>) };

<span class="macro">assert!</span>(aligned.try_cast_aligned::&lt;u32&gt;().is_some());
<span class="macro">assert!</span>(unaligned.try_cast_aligned::&lt;u32&gt;().is_none());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_try_cast_aligned)%5D%0A%0A%0Afn+main()+%7B%0A++++let+mut+x+=+0u64;%0A++++%0A++++let+aligned:+*mut+u64+=+%26mut+x;%0A++++let+unaligned+=+unsafe+%7B+aligned.byte_add(1)+%7D;%0A++++%0A++++assert!(aligned.try_cast_aligned::%3Cu32%3E().is_some());%0A++++assert!(unaligned.try_cast_aligned::%3Cu32%3E().is_none());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_metadata_of-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#113-118">Source</a><h4 class="code-header">pub const fn <a href="#method.with_metadata_of-1" class="fn">with_metadata_of</a>&lt;U&gt;(self, meta: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut U</a><div class="where">where
    U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</span></div></span></summary><div class="docblock"><p>Uses the address value in a new pointer of another type.</p>
<p>This operation will ignore the address part of its <code>meta</code> operand and discard existing
metadata of <code>self</code>. For pointers to a sized types (thin pointers), this has the same effect
as a simple cast. For pointers to an unsized type (fat pointers) this recombines the address
with new metadata such as slice lengths or <code>dyn</code>-vtable.</p>
<p>The resulting pointer will have provenance of <code>self</code>. This operation is semantically the
same as creating a new pointer with the data pointer value of <code>self</code> but the metadata of
<code>meta</code>, being fat or thin depending on the <code>meta</code> operand.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">¬ß</a>Examples</h5>
<p>This function is primarily useful for enabling pointer arithmetic on potentially fat
pointers. The pointer is cast to a sized pointee to utilize offset operations and then
recombined with its own original metadata.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(set_ptr_value)]
</span><span class="kw">let </span><span class="kw-2">mut </span>arr: [i32; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr = arr.as_mut_ptr() <span class="kw">as </span><span class="kw-2">*mut </span><span class="kw">dyn </span>Debug;
<span class="kw">let </span>thin = ptr <span class="kw">as </span><span class="kw-2">*mut </span>u8;
<span class="kw">unsafe </span>{
    ptr = thin.add(<span class="number">8</span>).with_metadata_of(ptr);
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, <span class="kw-2">&amp;*</span>ptr); <span class="comment">// will print "3"
</span>}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0A%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Afn+main()+%7B%0A++++use+core::fmt::Debug;%0A++++let+mut+arr:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0A++++let+mut+ptr+=+arr.as_mut_ptr()+as+*mut+dyn+Debug;%0A++++let+thin+=+ptr+as+*mut+u8;%0A++++unsafe+%7B%0A++++++++ptr+=+thin.add(8).with_metadata_of(ptr);%0A++++assert_eq!(*(ptr+as+*mut+i32),+3);%0A++++++++println!(%22%7B:?%7D%22,+%26*ptr);+//+will+print+%223%22%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div><h5 id="incorrect-usage-1"><a class="doc-anchor" href="#incorrect-usage-1">¬ß</a><em>Incorrect</em> usage</h5>
<p>The provenance from pointers is <em>not</em> combined. The result must only be used to refer to the
address allowed by <code>self</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(set_ptr_value)]
</span><span class="kw">let </span><span class="kw-2">mut </span>x = <span class="number">0u32</span>;
<span class="kw">let </span><span class="kw-2">mut </span>y = <span class="number">1u32</span>;

<span class="kw">let </span>x = (<span class="kw-2">&amp;mut </span>x) <span class="kw">as </span><span class="kw-2">*mut </span>u32;
<span class="kw">let </span>y = (<span class="kw-2">&amp;mut </span>y) <span class="kw">as </span><span class="kw-2">*mut </span>u32;

<span class="kw">let </span>offset = (x <span class="kw">as </span>usize - y <span class="kw">as </span>usize) / <span class="number">4</span>;
<span class="kw">let </span>bad = x.wrapping_add(offset).with_metadata_of(y);

<span class="comment">// This dereference is UB. The pointer only has provenance for `x` but points to `y`.
</span><span class="macro">println!</span>(<span class="string">"{:?}"</span>, <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>bad });</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0A%0Afn+main()+%7B%0A++++let+mut+x+=+0u32;%0A++++let+mut+y+=+1u32;%0A++++%0A++++let+x+=+(%26mut+x)+as+*mut+u32;%0A++++let+y+=+(%26mut+y)+as+*mut+u32;%0A++++%0A++++let+offset+=+(x+as+usize+-+y+as+usize)+/+4;%0A++++let+bad+=+x.wrapping_add(offset).with_metadata_of(y);%0A++++%0A++++//+This+dereference+is+UB.+The+pointer+only+has+provenance+for+%60x%60+but+points+to+%60y%60.%0A++++println!(%22%7B:?%7D%22,+unsafe+%7B+%26*bad+%7D);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cast_const" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.65.0, const since 1.65.0">1.65.0 (const: 1.65.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#134-136">Source</a></span><h4 class="code-header">pub const fn <a href="#method.cast_const" class="fn">cast_const</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Changes constness without changing the type.</p>
<p>This is a bit safer than <code>as</code> because it wouldn‚Äôt silently change the type if the code is
refactored.</p>
<p>While not strictly required (<code>*mut T</code> coerces to <code>*const T</code>), this is provided for symmetry
with <a href="primitive.pointer.html#method.cast_mut" title="method pointer::cast_mut"><code>cast_mut</code></a> on <code>*const T</code> and may have documentation value if used instead of implicit
coercion.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.addr-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#144-151">Source</a></span><h4 class="code-header">pub fn <a href="#method.addr-1" class="fn">addr</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the ‚Äúaddress‚Äù portion of the pointer.</p>
<p>This is similar to <code>self as usize</code>, except that the <a href="ptr/index.html#provenance" title="mod core::ptr">provenance</a> of
the pointer is discarded and not <a href="ptr/index.html#exposed-provenance" title="mod core::ptr">exposed</a>. This means that
casting the returned address back to a pointer yields a <a href="ptr/fn.without_provenance_mut.html" title="fn core::ptr::without_provenance_mut">pointer without
provenance</a>, which is undefined behavior to dereference. To properly
restore the lost information and obtain a dereferenceable pointer, use
<a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> or <a href="primitive.pointer.html#method.map_addr" title="method pointer::map_addr"><code>map_addr</code></a>.</p>
<p>If using those APIs is not possible because there is no way to preserve a pointer with the
required provenance, then Strict Provenance might not be for you. Use pointer-integer casts
or <a href="primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a> and <a href="ptr/fn.with_exposed_provenance.html" title="fn core::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a>
instead. However, note that this makes your code less portable and less amenable to tools
that check for compliance with the Rust memory model.</p>
<p>On most platforms this will produce a value with the same bytes as the original
pointer, because all the bytes are dedicated to describing the address.
Platforms which need to store additional information in the pointer may
perform a change of representation to produce a value containing only the address
portion of the pointer. What that means is up to the platform to define.</p>
<p>This is a <a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expose_provenance-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#177-179">Source</a></span><h4 class="code-header">pub fn <a href="#method.expose_provenance-1" class="fn">expose_provenance</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Exposes the <a href="ptr/index.html#provenance" title="mod core::ptr">‚Äúprovenance‚Äù</a> part of the pointer for future use in
<a href="ptr/fn.with_exposed_provenance_mut.html" title="fn core::ptr::with_exposed_provenance_mut"><code>with_exposed_provenance_mut</code></a> and returns the ‚Äúaddress‚Äù portion.</p>
<p>This is equivalent to <code>self as usize</code>, which semantically discards provenance information.
Furthermore, this (like the <code>as</code> cast) has the implicit side-effect of marking the
provenance as ‚Äòexposed‚Äô, so on platforms that support it you can later call
<a href="ptr/fn.with_exposed_provenance_mut.html" title="fn core::ptr::with_exposed_provenance_mut"><code>with_exposed_provenance_mut</code></a> to reconstitute the original pointer including its provenance.</p>
<p>Due to its inherent ambiguity, <a href="ptr/fn.with_exposed_provenance_mut.html" title="fn core::ptr::with_exposed_provenance_mut"><code>with_exposed_provenance_mut</code></a> may not be supported by tools
that help you to stay conformant with the Rust memory model. It is recommended to use
<a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> APIs such as <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a>
wherever possible, in which case <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>addr</code></a> should be used instead of <code>expose_provenance</code>.</p>
<p>On most platforms this will produce a value with the same bytes as the original pointer,
because all the bytes are dedicated to describing the address. Platforms which need to store
additional information in the pointer may not support this operation, since the ‚Äòexpose‚Äô
side-effect which is required for <a href="ptr/fn.with_exposed_provenance_mut.html" title="fn core::ptr::with_exposed_provenance_mut"><code>with_exposed_provenance_mut</code></a> to work is typically not
available.</p>
<p>This is an <a href="ptr/index.html#exposed-provenance" title="mod core::ptr">Exposed Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_addr-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#195-203">Source</a></span><h4 class="code-header">pub fn <a href="#method.with_addr-1" class="fn">with_addr</a>(self, addr: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new pointer with the given address and the <a href="ptr/index.html#provenance" title="mod core::ptr">provenance</a> of
<code>self</code>.</p>
<p>This is similar to a <code>addr as *mut T</code> cast, but copies
the <em>provenance</em> of <code>self</code> to the new pointer.
This avoids the inherent ambiguity of the unary cast.</p>
<p>This is equivalent to using <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset"><code>wrapping_offset</code></a> to offset
<code>self</code> to the given address, and therefore has all the same capabilities and restrictions.</p>
<p>This is a <a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map_addr-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.84.0">1.84.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#214-216">Source</a></span><h4 class="code-header">pub fn <a href="#method.map_addr-1" class="fn">map_addr</a>(self, f: impl <a class="trait" href="ops/trait.FnOnce.html" title="trait core::ops::FnOnce">FnOnce</a>(<a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new pointer by mapping <code>self</code>‚Äôs address to a new one, preserving the original
pointer‚Äôs <a href="ptr/index.html#provenance" title="mod core::ptr">provenance</a>.</p>
<p>This is a convenience for <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a>, see that method for details.</p>
<p>This is a <a href="ptr/index.html#strict-provenance" title="mod core::ptr">Strict Provenance</a> API.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_raw_parts-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#223-225">Source</a><h4 class="code-header">pub const fn <a href="#method.to_raw_parts-1" class="fn">to_raw_parts</a>(self) -&gt; (<a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait core::ptr::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type core::ptr::Pointee::Metadata">Metadata</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</span></div></span></summary><div class="docblock"><p>Decompose a (possibly wide) pointer into its data pointer and metadata components.</p>
<p>The pointer can be later reconstructed with <a href="ptr/fn.from_raw_parts_mut.html" title="fn core::ptr::from_raw_parts_mut"><code>from_raw_parts_mut</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ref-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const since 1.84.0">1.9.0 (const: 1.84.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#261-265">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.as_ref-1" class="fn">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. If the value may be uninitialized, <a href="primitive.pointer.html#method.as_uninit_ref-1" title="primitive pointer"><code>as_uninit_ref</code></a>
must be used instead.</p>
<h5 id="safety-12"><a class="doc-anchor" href="#safety-12">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.</p>
<h5 id="panics-during-const-evaluation-5"><a class="doc-anchor" href="#panics-during-const-evaluation-5">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null-1"><code>is_null</code></a> for more information.</p>
<h5 id="null-unchecked-version-1"><a class="doc-anchor" href="#null-unchecked-version-1">¬ß</a>Null-unchecked version</h5>
<p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_ref_unchecked</code> that returns the <code>&amp;T</code> instead of <code>Option&lt;&amp;T&gt;</code>, know that you can
dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = <span class="kw-2">&amp;mut </span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>val_back = <span class="kw-2">&amp;*</span>ptr;
    <span class="macro">println!</span>(<span class="string">"We got back the value: {val_back}!"</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr:+*mut+u8+=+%26mut+10u8+as+*mut+u8;%0A++++%0A++++unsafe+%7B%0A++++++++let+val_back+=+%26*ptr;%0A++++++++println!(%22We+got+back+the+value:+%7Bval_back%7D!%22);%0A++++%7D%0A%7D&amp;edition=2024"></a></div><h5 id="examples-27"><a class="doc-anchor" href="#examples-27">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = <span class="kw-2">&amp;mut </span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_ref() {
        <span class="macro">println!</span>(<span class="string">"We got back the value: {val_back}!"</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr:+*mut+u8+=+%26mut+10u8+as+*mut+u8;%0A++++%0A++++unsafe+%7B%0A++++++++if+let+Some(val_back)+=+ptr.as_ref()+%7B%0A++++++++++++println!(%22We+got+back+the+value:+%7Bval_back%7D!%22);%0A++++++++%7D%0A++++%7D%0A%7D&amp;edition=2024"></a></div><h5 id="see-also"><a class="doc-anchor" href="#see-also">¬ß</a>See Also</h5>
<p>For the mutable counterpart see <a href="#method.as_mut"><code>as_mut</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ref_unchecked-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#295-298">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_ref_unchecked-1" class="fn">as_ref_unchecked</a>&lt;'a&gt;(self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;'a T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_ref_unchecked</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/122034">#122034</a>)</span></div></span></summary><div class="docblock"><p>Returns a shared reference to the value behind the pointer.
If the pointer may be null or the value may be uninitialized, <a href="#method.as_uninit_ref"><code>as_uninit_ref</code></a> must be used instead.
If the pointer may be null, but the value is known to have been initialized, <a href="#method.as_ref"><code>as_ref</code></a> must be used instead.</p>
<p>For the mutable counterpart see <a href="#method.as_mut_unchecked"><code>as_mut_unchecked</code></a>.</p>
<h5 id="safety-13"><a class="doc-anchor" href="#safety-13">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_as_ref_unchecked)]
</span><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = <span class="kw-2">&amp;mut </span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;

<span class="kw">unsafe </span>{
    <span class="macro">println!</span>(<span class="string">"We got back the value: {}!"</span>, ptr.as_ref_unchecked());
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_ref_unchecked)%5D%0A%0Afn+main()+%7B%0A++++let+ptr:+*mut+u8+=+%26mut+10u8+as+*mut+u8;%0A++++%0A++++unsafe+%7B%0A++++++++println!(%22We+got+back+the+value:+%7B%7D!%22,+ptr.as_ref_unchecked());%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_ref-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#325-332">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_uninit_ref-1" class="fn">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a shared reference to
the value wrapped in <code>Some</code>. In contrast to <a href="primitive.pointer.html#method.as_ref-1" title="primitive pointer"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<h5 id="safety-14"><a class="doc-anchor" href="#safety-14">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.
Note that because the created reference is to <code>MaybeUninit&lt;T&gt;</code>, the
source pointer can point to uninitialized memory.</p>
<h5 id="panics-during-const-evaluation-6"><a class="doc-anchor" href="#panics-during-const-evaluation-6">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null-1"><code>is_null</code></a> for more information.</p>
<h5 id="see-also-1"><a class="doc-anchor" href="#see-also-1">¬ß</a>See Also</h5>
<p>For the mutable counterpart see <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_as_uninit)]

</span><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = <span class="kw-2">&amp;mut </span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_uninit_ref() {
        <span class="macro">println!</span>(<span class="string">"We got back the value: {}!"</span>, val_back.assume_init());
    }
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0A%0Afn+main()+%7B%0A++++let+ptr:+*mut+u8+=+%26mut+10u8+as+*mut+u8;%0A++++%0A++++unsafe+%7B%0A++++++++if+let+Some(val_back)+=+ptr.as_uninit_ref()+%7B%0A++++++++++++println!(%22We+got+back+the+value:+%7B%7D!%22,+val_back.assume_init());%0A++++++++%7D%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.offset-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.61.0">1.0.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#352-390">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset-1" class="fn">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds a signed offset to a pointer.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-15"><a class="doc-anchor" href="#safety-15">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p>The offset in bytes, <code>count * size_of::&lt;T&gt;()</code>, computed on mathematical integers (without
‚Äúwrapping around‚Äù), must fit in an <code>isize</code>.</p>
</li>
<li>
<p>If the computed offset is non-zero, then <code>self</code> must be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to some
<a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the entire memory range between <code>self</code> and the result must be in
bounds of that allocation. In particular, this range must not ‚Äúwrap around‚Äù the edge
of the address space. Note that ‚Äúrange‚Äù here refers to a half-open range as usual in Rust,
i.e., <code>self..result</code> for non-negative offsets and <code>result..self</code> for negative offsets.</p>
</li>
</ul>
<p>Allocations can never be larger than <code>isize::MAX</code> bytes, so if the computed offset
stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.
This implies, for instance, that <code>vec.as_ptr().add(vec.len())</code> (for <code>vec: Vec&lt;T&gt;</code>) is always
safe.</p>
<p>Consider using <a href="#method.wrapping_offset"><code>wrapping_offset</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="number">2</span>, <span class="kw-2">*</span>ptr.offset(<span class="number">1</span>));
    <span class="macro">assert_eq!</span>(<span class="number">3</span>, <span class="kw-2">*</span>ptr.offset(<span class="number">2</span>));
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%5B1,+2,+3%5D;%0A++++let+ptr:+*mut+u32+=+s.as_mut_ptr();%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(2,+*ptr.offset(1));%0A++++++++assert_eq!(3,+*ptr.offset(2));%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#407-410">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_offset-1" class="fn">byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds a signed offset in bytes to a pointer.</p>
<p><code>count</code> is in units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.offset" title="method pointer::offset">offset</a> on it. See that method for documentation
and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_offset-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0, const since 1.61.0">1.16.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#465-471">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_offset-1" class="fn">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds a signed offset to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-16"><a class="doc-anchor" href="#safety-16">¬ß</a>Safety</h5>
<p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p>The resulting pointer ‚Äúremembers‚Äù the <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a> that <code>self</code> points to
(this is called ‚Äú<a href="ptr/index.html#provenance">Provenance</a>‚Äù).
The pointer must not be used to read or write other allocations.</p>
<p>In other words, <code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocation.</p>
<p>Compared to <a href="#method.offset"><code>offset</code></a>, this method basically delays the requirement of staying within the
same allocation: <a href="#method.offset"><code>offset</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_offset</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.offset"><code>offset</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> is always the same as <code>x</code>. In other
words, leaving the allocation and then re-entering it later is permitted.</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements
</span><span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*mut </span>u8 = data.as_mut_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_offset(<span class="number">6</span>);

<span class="kw">while </span><span class="macro">ptr !</span>= end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="kw-2">*</span>ptr = <span class="number">0</span>;
    }
    ptr = ptr.wrapping_offset(step);
}
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>data, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+Iterate+using+a+raw+pointer+in+increments+of+two+elements%0A++++let+mut+data+=+%5B1u8,+2,+3,+4,+5%5D;%0A++++let+mut+ptr:+*mut+u8+=+data.as_mut_ptr();%0A++++let+step+=+2;%0A++++let+end_rounded_up+=+ptr.wrapping_offset(6);%0A++++%0A++++while+ptr+!=+end_rounded_up+%7B%0A++++++++unsafe+%7B%0A++++++++++++*ptr+=+0;%0A++++++++%7D%0A++++++++ptr+=+ptr.wrapping_offset(step);%0A++++%7D%0A++++assert_eq!(%26data,+%26%5B0,+2,+0,+4,+0%5D);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_offset-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#487-489">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_byte_offset-1" class="fn">wrapping_byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds a signed offset in bytes to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset">wrapping_offset</a> on it. See that method
for documentation.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mask-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#528-530">Source</a><h4 class="code-header">pub fn <a href="#method.mask-1" class="fn">mask</a>(self, mask: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_mask</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/98290">#98290</a>)</span></div></span></summary><div class="docblock"><p>Masks out bits of the pointer according to a mask.</p>
<p>This is convenience for <code>ptr.map_addr(|a| a &amp; mask)</code>.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
<h6 id="examples-32"><a class="doc-anchor" href="#examples-32">¬ß</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_mask)]
</span><span class="kw">let </span><span class="kw-2">mut </span>v = <span class="number">17_u32</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = <span class="kw-2">&amp;mut </span>v;

<span class="comment">// `u32` is 4 bytes aligned,
// which means that lower 2 bits are always 0.
</span><span class="kw">let </span>tag_mask = <span class="number">0b11</span>;
<span class="kw">let </span>ptr_mask = !tag_mask;

<span class="comment">// We can store something in these lower bits
</span><span class="kw">let </span>tagged_ptr = ptr.map_addr(|a| a | <span class="number">0b10</span>);

<span class="comment">// Get the "tag" back
</span><span class="kw">let </span>tag = tagged_ptr.addr() &amp; tag_mask;
<span class="macro">assert_eq!</span>(tag, <span class="number">0b10</span>);

<span class="comment">// Note that `tagged_ptr` is unaligned, it's UB to read from/write to it.
// To get original pointer `mask` can be used:
</span><span class="kw">let </span>masked_ptr = tagged_ptr.mask(ptr_mask);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ <span class="kw-2">*</span>masked_ptr }, <span class="number">17</span>);

<span class="kw">unsafe </span>{ <span class="kw-2">*</span>masked_ptr = <span class="number">0 </span>};
<span class="macro">assert_eq!</span>(v, <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_mask)%5D%0A%0Afn+main()+%7B%0A++++let+mut+v+=+17_u32;%0A++++let+ptr:+*mut+u32+=+%26mut+v;%0A++++%0A++++//+%60u32%60+is+4+bytes+aligned,%0A++++//+which+means+that+lower+2+bits+are+always+0.%0A++++let+tag_mask+=+0b11;%0A++++let+ptr_mask+=+!tag_mask;%0A++++%0A++++//+We+can+store+something+in+these+lower+bits%0A++++let+tagged_ptr+=+ptr.map_addr(%7Ca%7C+a+%7C+0b10);%0A++++%0A++++//+Get+the+%22tag%22+back%0A++++let+tag+=+tagged_ptr.addr()+%26+tag_mask;%0A++++assert_eq!(tag,+0b10);%0A++++%0A++++//+Note+that+%60tagged_ptr%60+is+unaligned,+it's+UB+to+read+from/write+to+it.%0A++++//+To+get+original+pointer+%60mask%60+can+be+used:%0A++++let+masked_ptr+=+tagged_ptr.mask(ptr_mask);%0A++++assert_eq!(unsafe+%7B+*masked_ptr+%7D,+17);%0A++++%0A++++unsafe+%7B+*masked_ptr+=+0+%7D;%0A++++assert_eq!(v,+0);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const since 1.84.0">1.9.0 (const: 1.84.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#582-586">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.as_mut" class="fn">as_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a mut T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a unique reference to
the value wrapped in <code>Some</code>. If the value may be uninitialized, <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>
must be used instead.</p>
<p>For the shared counterpart see <a href="primitive.pointer.html#method.as_ref-1" title="primitive pointer"><code>as_ref</code></a>.</p>
<h5 id="safety-17"><a class="doc-anchor" href="#safety-17">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em>
the pointer is null <em>or</em>
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.</p>
<h5 id="panics-during-const-evaluation-7"><a class="doc-anchor" href="#panics-during-const-evaluation-7">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null-1"><code>is_null</code></a> for more information.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();
<span class="kw">let </span>first_value = <span class="kw">unsafe </span>{ ptr.as_mut().unwrap() };
<span class="kw-2">*</span>first_value = <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">"{s:?}"</span>); <span class="comment">// It'll print: "[4, 2, 3]".</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%5B1,+2,+3%5D;%0A++++let+ptr:+*mut+u32+=+s.as_mut_ptr();%0A++++let+first_value+=+unsafe+%7B+ptr.as_mut().unwrap()+%7D;%0A++++*first_value+=+4;%0A++++assert_eq!(s,+%5B4,+2,+3%5D);%0A++++println!(%22%7Bs:?%7D%22);%0A%7D&amp;edition=2024"></a></div><h5 id="null-unchecked-version-2"><a class="doc-anchor" href="#null-unchecked-version-2">¬ß</a>Null-unchecked version</h5>
<p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_mut_unchecked</code> that returns the <code>&amp;mut T</code> instead of <code>Option&lt;&amp;mut T&gt;</code>, know that
you can dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();
<span class="kw">let </span>first_value = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>ptr };
<span class="kw-2">*</span>first_value = <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">"{s:?}"</span>); <span class="comment">// It'll print: "[4, 2, 3]".</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s+=+%5B1,+2,+3%5D;%0A++++let+ptr:+*mut+u32+=+s.as_mut_ptr();%0A++++let+first_value+=+unsafe+%7B+%26mut+*ptr+%7D;%0A++++*first_value+=+4;%0A++++assert_eq!(s,+%5B4,+2,+3%5D);%0A++++println!(%22%7Bs:?%7D%22);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_unchecked" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#618-621">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_mut_unchecked" class="fn">as_mut_unchecked</a>&lt;'a&gt;(self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;'a mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_ref_unchecked</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/122034">#122034</a>)</span></div></span></summary><div class="docblock"><p>Returns a unique reference to the value behind the pointer.
If the pointer may be null or the value may be uninitialized, <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a> must be used instead.
If the pointer may be null, but the value is known to have been initialized, <a href="#method.as_mut"><code>as_mut</code></a> must be used instead.</p>
<p>For the shared counterpart see <a href="#method.as_mut_unchecked"><code>as_ref_unchecked</code></a>.</p>
<h5 id="safety-18"><a class="doc-anchor" href="#safety-18">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_as_ref_unchecked)]
</span><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();
<span class="kw">let </span>first_value = <span class="kw">unsafe </span>{ ptr.as_mut_unchecked() };
<span class="kw-2">*</span>first_value = <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">"{s:?}"</span>); <span class="comment">// It'll print: "[4, 2, 3]".</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_ref_unchecked)%5D%0A%0Afn+main()+%7B%0A++++let+mut+s+=+%5B1,+2,+3%5D;%0A++++let+ptr:+*mut+u32+=+s.as_mut_ptr();%0A++++let+first_value+=+unsafe+%7B+ptr.as_mut_unchecked()+%7D;%0A++++*first_value+=+4;%0A++++assert_eq!(s,+%5B4,+2,+3%5D);%0A++++println!(%22%7Bs:?%7D%22);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_mut" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#645-652">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_uninit_mut" class="fn">as_uninit_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a mut <a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a unique reference to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_mut"><code>as_mut</code></a>, this does not require
that the value has to be initialized.</p>
<p>For the shared counterpart see <a href="primitive.pointer.html#method.as_uninit_ref-1" title="primitive pointer"><code>as_uninit_ref</code></a>.</p>
<h5 id="safety-19"><a class="doc-anchor" href="#safety-19">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
the pointer is <a href="ptr/index.html#pointer-to-reference-conversion" title="mod core::ptr">convertible to a reference</a>.</p>
<h5 id="panics-during-const-evaluation-8"><a class="doc-anchor" href="#panics-during-const-evaluation-8">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null-1"><code>is_null</code></a> for more information.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_eq-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#674-679">Source</a><h4 class="code-header">pub const fn <a href="#method.guaranteed_eq-1" class="fn">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>Returns whether two pointers are guaranteed to be equal.</p>
<p>At runtime this function behaves like <code>Some(self == other)</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine equality of two pointers, so this function may
spuriously return <code>None</code> for pointers that later actually turn out to have its equality known.
But when it returns <code>Some</code>, the pointers‚Äô equality is guaranteed to be known.</p>
<p>The return value may change from <code>Some</code> to <code>None</code> and vice versa depending on the compiler
version and unsafe code must not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>None</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_ne-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#701-706">Source</a><h4 class="code-header">pub const fn <a href="#method.guaranteed_ne-1" class="fn">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>Returns whether two pointers are guaranteed to be inequal.</p>
<p>At runtime this function behaves like <code>Some(self != other)</code>.
However, in some contexts (e.g., compile-time evaluation),
it is not always possible to determine inequality of two pointers, so this function may
spuriously return <code>None</code> for pointers that later actually turn out to have its inequality known.
But when it returns <code>Some</code>, the pointers‚Äô inequality is guaranteed to be known.</p>
<p>The return value may change from <code>Some</code> to <code>None</code> and vice versa depending on the compiler
version and unsafe code must not
rely on the result of this function for soundness. It is suggested to only use this function
for performance optimizations where spurious <code>None</code> return values by this function do not
affect the outcome, but just the performance.
The consequences of using this method to make runtime and compile-time code behave
differently have not been explored. This method should not be used to introduce such
differences, and it should also not be stabilized before we have a better understanding
of this issue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.47.0, const since 1.65.0">1.47.0 (const: 1.65.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#793-799">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from-1" class="fn">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation. The returned value is in
units of T: the distance in bytes divided by <code>size_of::&lt;T&gt;()</code>.</p>
<p>This is equivalent to <code>(self as isize - origin as isize) / (size_of::&lt;T&gt;() as isize)</code>,
except that it has a lot more opportunities for UB, in exchange for the compiler
better understanding what you are doing.</p>
<p>The primary motivation of this method is for computing the <code>len</code> of an array/slice
of <code>T</code> that you are currently representing as a ‚Äústart‚Äù and ‚Äúend‚Äù pointer
(and ‚Äúend‚Äù is ‚Äúone past the end‚Äù of the array).
In that case, <code>end.offset_from(start)</code> gets you the length of the array.</p>
<p>All of the following safety requirements are trivially satisfied for this usecase.</p>
<h5 id="safety-20"><a class="doc-anchor" href="#safety-20">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p><code>self</code> and <code>origin</code> must either</p>
<ul>
<li>point to the same address, or</li>
<li>both be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to the same <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the memory range between
the two pointers must be in bounds of that object. (See below for an example.)</li>
</ul>
</li>
<li>
<p>The distance between the pointers, in bytes, must be an exact multiple
of the size of <code>T</code>.</p>
</li>
</ul>
<p>As a consequence, the absolute distance between the pointers, in bytes, computed on
mathematical integers (without ‚Äúwrapping around‚Äù), cannot overflow an <code>isize</code>. This is
implied by the in-bounds requirement, and the fact that no allocation can be larger
than <code>isize::MAX</code> bytes.</p>
<p>The requirement for pointers to be derived from the same allocation is primarily
needed for <code>const</code>-compatibility: the distance between pointers into <em>different</em> allocated
objects is not known at compile-time. However, the requirement also exists at
runtime and may be exploited by optimizations. If you wish to compute the difference between
pointers that are not guaranteed to be from the same allocation, use <code>(self as isize - origin as isize) / size_of::&lt;T&gt;()</code>.</p>
<h5 id="panics-4"><a class="doc-anchor" href="#panics-4">¬ß</a>Panics</h5>
<p>This function panics if <code>T</code> is a Zero-Sized Type (‚ÄúZST‚Äù).</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">¬ß</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>ptr1: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut </span>a[<span class="number">1</span>];
<span class="kw">let </span>ptr2: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut </span>a[<span class="number">3</span>];
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(ptr2.offset_from(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset_from(ptr2), -<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.offset(-<span class="number">2</span>), ptr1);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+a+=+%5B0;+5%5D;%0A++++let+ptr1:+*mut+i32+=+%26mut+a%5B1%5D;%0A++++let+ptr2:+*mut+i32+=+%26mut+a%5B3%5D;%0A++++unsafe+%7B%0A++++++++assert_eq!(ptr2.offset_from(ptr1),+2);%0A++++++++assert_eq!(ptr1.offset_from(ptr2),+-2);%0A++++++++assert_eq!(ptr1.offset(2),+ptr2);%0A++++++++assert_eq!(ptr2.offset(-2),+ptr1);%0A++++%7D%0A%7D&amp;edition=2024"></a></div>
<p><em>Incorrect</em> usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr1 = Box::into_raw(Box::new(<span class="number">0u8</span>));
<span class="kw">let </span>ptr2 = Box::into_raw(Box::new(<span class="number">1u8</span>));
<span class="kw">let </span>diff = (ptr2 <span class="kw">as </span>isize).wrapping_sub(ptr1 <span class="kw">as </span>isize);
<span class="comment">// Make ptr2_other an "alias" of ptr2.add(1), but derived from ptr1.
</span><span class="kw">let </span>ptr2_other = (ptr1 <span class="kw">as </span><span class="kw-2">*mut </span>u8).wrapping_offset(diff).wrapping_offset(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(ptr2 <span class="kw">as </span>usize, ptr2_other <span class="kw">as </span>usize);
<span class="comment">// Since ptr2_other and ptr2 are derived from pointers to different objects,
// computing their offset is undefined behavior, even though
// they point to addresses that are in-bounds of the same object!
</span><span class="kw">unsafe </span>{
    <span class="kw">let </span>one = ptr2_other.offset_from(ptr2); <span class="comment">// Undefined Behavior! ‚ö†Ô∏è
</span>}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+ptr1+=+Box::into_raw(Box::new(0u8));%0A++++let+ptr2+=+Box::into_raw(Box::new(1u8));%0A++++let+diff+=+(ptr2+as+isize).wrapping_sub(ptr1+as+isize);%0A++++//+Make+ptr2_other+an+%22alias%22+of+ptr2.add(1),+but+derived+from+ptr1.%0A++++let+ptr2_other+=+(ptr1+as+*mut+u8).wrapping_offset(diff).wrapping_offset(1);%0A++++assert_eq!(ptr2+as+usize,+ptr2_other+as+usize);%0A++++//+Since+ptr2_other+and+ptr2+are+derived+from+pointers+to+different+objects,%0A++++//+computing+their+offset+is+undefined+behavior,+even+though%0A++++//+they+point+to+addresses+that+are+in-bounds+of+the+same+object!%0A++++unsafe+%7B%0A++++++++let+one+=+ptr2_other.offset_from(ptr2);+//+Undefined+Behavior!+%E2%9A%A0%EF%B8%8F%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset_from-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#814-817">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_offset_from-1" class="fn">byte_offset_from</a>&lt;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(self, origin: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation. The returned value is in
units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.offset_from" title="method pointer::offset_from"><code>offset_from</code></a> on it. See that method for
documentation and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation considers only the data pointers,
ignoring the metadata.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from_unsigned-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#882-888">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from_unsigned-1" class="fn">offset_from_unsigned</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation, <em>where it‚Äôs known that
<code>self</code> is equal to or greater than <code>origin</code></em>. The returned value is in
units of T: the distance in bytes is divided by <code>size_of::&lt;T&gt;()</code>.</p>
<p>This computes the same value that <a href="#method.offset_from"><code>offset_from</code></a>
would compute, but with the added precondition that the offset is
guaranteed to be non-negative.  This method is equivalent to
<code>usize::try_from(self.offset_from(origin)).unwrap_unchecked()</code>,
but it provides slightly more information to the optimizer, which can
sometimes allow it to optimize slightly better with some backends.</p>
<p>This method can be thought of as recovering the <code>count</code> that was passed
to <a href="#method.add"><code>add</code></a> (or, with the parameters in the other order,
to <a href="#method.sub"><code>sub</code></a>).  The following are all equivalent, assuming
that their safety preconditions are met:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ptr.offset_from_unsigned(origin) == count
origin.add(count) == ptr
ptr.sub(count) == origin</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++unsafe+fn+blah(ptr:+*mut+i32,+origin:+*mut+i32,+count:+usize)+-%3E+bool+%7B+unsafe+%7B%0A++++ptr.offset_from_unsigned(origin)+==+count%0A++++%26%26%0A++++origin.add(count)+==+ptr%0A++++%26%26%0A++++ptr.sub(count)+==+origin%0A++++%7D+%7D%0A%7D&amp;edition=2024"></a></div><h5 id="safety-21"><a class="doc-anchor" href="#safety-21">¬ß</a>Safety</h5>
<ul>
<li>
<p>The distance between the pointers must be non-negative (<code>self &gt;= origin</code>)</p>
</li>
<li>
<p><em>All</em> the safety conditions of <a href="#method.offset_from"><code>offset_from</code></a>
apply to this method as well; see it for the full details.</p>
</li>
</ul>
<p>Importantly, despite the return type of this method being able to represent
a larger offset, it‚Äôs still <em>not permitted</em> to pass pointers which differ
by more than <code>isize::MAX</code> <em>bytes</em>.  As such, the result of this method will
always be less than or equal to <code>isize::MAX as usize</code>.</p>
<h5 id="panics-5"><a class="doc-anchor" href="#panics-5">¬ß</a>Panics</h5>
<p>This function panics if <code>T</code> is a Zero-Sized Type (‚ÄúZST‚Äù).</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>p: <span class="kw-2">*mut </span>i32 = a.as_mut_ptr();
<span class="kw">unsafe </span>{
    <span class="kw">let </span>ptr1: <span class="kw-2">*mut </span>i32 = p.add(<span class="number">1</span>);
    <span class="kw">let </span>ptr2: <span class="kw-2">*mut </span>i32 = p.add(<span class="number">3</span>);

    <span class="macro">assert_eq!</span>(ptr2.offset_from_unsigned(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.add(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.sub(<span class="number">2</span>), ptr1);
    <span class="macro">assert_eq!</span>(ptr2.offset_from_unsigned(ptr2), <span class="number">0</span>);
}

<span class="comment">// This would be incorrect, as the pointers are not correctly ordered:
// ptr1.offset_from(ptr2)</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+a+=+%5B0;+5%5D;%0A++++let+p:+*mut+i32+=+a.as_mut_ptr();%0A++++unsafe+%7B%0A++++++++let+ptr1:+*mut+i32+=+p.add(1);%0A++++++++let+ptr2:+*mut+i32+=+p.add(3);%0A++++%0A++++++++assert_eq!(ptr2.offset_from_unsigned(ptr1),+2);%0A++++++++assert_eq!(ptr1.add(2),+ptr2);%0A++++++++assert_eq!(ptr2.sub(2),+ptr1);%0A++++++++assert_eq!(ptr2.offset_from_unsigned(ptr2),+0);%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset_from_unsigned-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0, const since 1.87.0">1.87.0 (const: 1.87.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#904-907">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_offset_from_unsigned-1" class="fn">byte_offset_from_unsigned</a>&lt;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(
    self,
    origin: <a class="primitive" href="primitive.pointer.html">*mut U</a>,
) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Calculates the distance between two pointers within the same allocation, <em>where it‚Äôs known that
<code>self</code> is equal to or greater than <code>origin</code></em>. The returned value is in
units of <strong>bytes</strong>.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.offset_from_unsigned" title="method pointer::offset_from_unsigned"><code>offset_from_unsigned</code></a> on it.
See that method for documentation and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation considers only the data pointers,
ignoring the metadata.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#927-962">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.add-1" class="fn">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds an unsigned offset to a pointer.</p>
<p>This can only move the pointer forward (or not move it). If you need to move forward or
backward depending on the value, then you might want <a href="#method.offset"><code>offset</code></a> instead
which takes a signed offset.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-22"><a class="doc-anchor" href="#safety-22">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p>The offset in bytes, <code>count * size_of::&lt;T&gt;()</code>, computed on mathematical integers (without
‚Äúwrapping around‚Äù), must fit in an <code>isize</code>.</p>
</li>
<li>
<p>If the computed offset is non-zero, then <code>self</code> must be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to some
<a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the entire memory range between <code>self</code> and the result must be in
bounds of that allocation. In particular, this range must not ‚Äúwrap around‚Äù the edge
of the address space.</p>
</li>
</ul>
<p>Allocations can never be larger than <code>isize::MAX</code> bytes, so if the computed offset
stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.
This implies, for instance, that <code>vec.as_ptr().add(vec.len())</code> (for <code>vec: Vec&lt;T&gt;</code>) is always
safe.</p>
<p>Consider using <a href="#method.wrapping_add"><code>wrapping_add</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s: String = <span class="string">"123"</span>.to_string();
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = s.as_mut_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">'2'</span>, <span class="kw-2">*</span>ptr.add(<span class="number">1</span>) <span class="kw">as </span>char);
    <span class="macro">assert_eq!</span>(<span class="string">'3'</span>, <span class="kw-2">*</span>ptr.add(<span class="number">2</span>) <span class="kw">as </span>char);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+mut+s:+String+=+%22123%22.to_string();%0A++++let+ptr:+*mut+u8+=+s.as_mut_ptr();%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!('2',+*ptr.add(1)+as+char);%0A++++++++assert_eq!('3',+*ptr.add(2)+as+char);%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#979-982">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_add-1" class="fn">byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds an unsigned offset in bytes to a pointer.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.add" title="method pointer::add">add</a> on it. See that method for documentation
and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1033-1074">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.sub-1" class="fn">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset from a pointer.</p>
<p>This can only move the pointer backward (or not move it). If you need to move forward or
backward depending on the value, then you might want <a href="#method.offset"><code>offset</code></a> instead
which takes a signed offset.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-23"><a class="doc-anchor" href="#safety-23">¬ß</a>Safety</h5>
<p>If any of the following conditions are violated, the result is Undefined Behavior:</p>
<ul>
<li>
<p>The offset in bytes, <code>count * size_of::&lt;T&gt;()</code>, computed on mathematical integers (without
‚Äúwrapping around‚Äù), must fit in an <code>isize</code>.</p>
</li>
<li>
<p>If the computed offset is non-zero, then <code>self</code> must be <a href="ptr/index.html#provenance" title="mod core::ptr">derived from</a> a pointer to some
<a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>, and the entire memory range between <code>self</code> and the result must be in
bounds of that allocation. In particular, this range must not ‚Äúwrap around‚Äù the edge
of the address space.</p>
</li>
</ul>
<p>Allocations can never be larger than <code>isize::MAX</code> bytes, so if the computed offset
stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.
This implies, for instance, that <code>vec.as_ptr().add(vec.len())</code> (for <code>vec: Vec&lt;T&gt;</code>) is always
safe.</p>
<p>Consider using <a href="#method.wrapping_sub"><code>wrapping_sub</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">"123"</span>;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>end: <span class="kw-2">*const </span>u8 = s.as_ptr().add(<span class="number">3</span>);
    <span class="macro">assert_eq!</span>(<span class="string">'3'</span>, <span class="kw-2">*</span>end.sub(<span class="number">1</span>) <span class="kw">as </span>char);
    <span class="macro">assert_eq!</span>(<span class="string">'2'</span>, <span class="kw-2">*</span>end.sub(<span class="number">2</span>) <span class="kw">as </span>char);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+s:+%26str+=+%22123%22;%0A++++%0A++++unsafe+%7B%0A++++++++let+end:+*const+u8+=+s.as_ptr().add(3);%0A++++++++assert_eq!('3',+*end.sub(1)+as+char);%0A++++++++assert_eq!('2',+*end.sub(2)+as+char);%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_sub-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1091-1094">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.byte_sub-1" class="fn">byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset in bytes from a pointer.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.sub" title="method pointer::sub">sub</a> on it. See that method for documentation
and safety requirements.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1148-1153">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_add-1" class="fn">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Adds an unsigned offset to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-24"><a class="doc-anchor" href="#safety-24">¬ß</a>Safety</h5>
<p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p>The resulting pointer ‚Äúremembers‚Äù the <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a> that <code>self</code> points to; it must not
be used to read or write other allocations.</p>
<p>In other words, <code>let z = x.wrapping_add((y as usize) - (x as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocation.</p>
<p>Compared to <a href="#method.add"><code>add</code></a>, this method basically delays the requirement of staying within the
same allocation: <a href="#method.add"><code>add</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_add</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.add"><code>add</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocation and then re-entering it later is permitted.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_add(<span class="number">6</span>);

<span class="comment">// This loop prints "1, 3, 5, "
</span><span class="kw">while </span><span class="macro">ptr !</span>= end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="macro">print!</span>(<span class="string">"{}, "</span>, <span class="kw-2">*</span>ptr);
    }
    ptr = ptr.wrapping_add(step);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+Iterate+using+a+raw+pointer+in+increments+of+two+elements%0A++++let+data+=+%5B1u8,+2,+3,+4,+5%5D;%0A++++let+mut+ptr:+*const+u8+=+data.as_ptr();%0A++++let+step+=+2;%0A++++let+end_rounded_up+=+ptr.wrapping_add(6);%0A++++%0A++++//+This+loop+prints+%221,+3,+5,+%22%0A++++while+ptr+!=+end_rounded_up+%7B%0A++++++++unsafe+%7B%0A++++++++++++print!(%22%7B%7D,+%22,+*ptr);%0A++++++++%7D%0A++++++++ptr+=+ptr.wrapping_add(step);%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1168-1170">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_byte_add-1" class="fn">wrapping_byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Adds an unsigned offset in bytes to a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.wrapping_add" title="method pointer::wrapping_add">wrapping_add</a> on it. See that method for documentation.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1224-1229">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_sub-1" class="fn">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h5 id="safety-25"><a class="doc-anchor" href="#safety-25">¬ß</a>Safety</h5>
<p>This operation itself is always safe, but using the resulting pointer is not.</p>
<p>The resulting pointer ‚Äúremembers‚Äù the <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a> that <code>self</code> points to; it must not
be used to read or write other allocations.</p>
<p>In other words, <code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> does <em>not</em> make <code>z</code>
the same as <code>y</code> even if we assume <code>T</code> has size <code>1</code> and there is no overflow: <code>z</code> is still
attached to the object <code>x</code> is attached to, and dereferencing it is Undefined Behavior unless
<code>x</code> and <code>y</code> point into the same allocation.</p>
<p>Compared to <a href="#method.sub"><code>sub</code></a>, this method basically delays the requirement of staying within the
same allocation: <a href="#method.sub"><code>sub</code></a> is immediate Undefined Behavior when crossing object
boundaries; <code>wrapping_sub</code> produces a pointer but still leads to Undefined Behavior if a
pointer is dereferenced when it is out-of-bounds of the object it is attached to. <a href="#method.sub"><code>sub</code></a>
can be optimized better and is thus preferable in performance-sensitive code.</p>
<p>The delayed check only considers the value of the pointer that was dereferenced, not the
intermediate values used during the computation of the final result. For example,
<code>x.wrapping_add(o).wrapping_sub(o)</code> is always the same as <code>x</code>. In other words, leaving the
allocation and then re-entering it later is permitted.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate using a raw pointer in increments of two elements (backwards)
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>start_rounded_down = ptr.wrapping_sub(<span class="number">2</span>);
ptr = ptr.wrapping_add(<span class="number">4</span>);
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="comment">// This loop prints "5, 3, 1, "
</span><span class="kw">while </span><span class="macro">ptr !</span>= start_rounded_down {
    <span class="kw">unsafe </span>{
        <span class="macro">print!</span>(<span class="string">"{}, "</span>, <span class="kw-2">*</span>ptr);
    }
    ptr = ptr.wrapping_sub(step);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+Iterate+using+a+raw+pointer+in+increments+of+two+elements+(backwards)%0A++++let+data+=+%5B1u8,+2,+3,+4,+5%5D;%0A++++let+mut+ptr:+*const+u8+=+data.as_ptr();%0A++++let+start_rounded_down+=+ptr.wrapping_sub(2);%0A++++ptr+=+ptr.wrapping_add(4);%0A++++let+step+=+2;%0A++++//+This+loop+prints+%225,+3,+1,+%22%0A++++while+ptr+!=+start_rounded_down+%7B%0A++++++++unsafe+%7B%0A++++++++++++print!(%22%7B%7D,+%22,+*ptr);%0A++++++++%7D%0A++++++++ptr+=+ptr.wrapping_sub(step);%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_sub-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.75.0, const since 1.75.0">1.75.0 (const: 1.75.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1244-1246">Source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_byte_sub-1" class="fn">wrapping_byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Subtracts an unsigned offset in bytes from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of bytes.</p>
<p>This is purely a convenience for casting to a <code>u8</code> pointer and
using <a href="primitive.pointer.html#method.wrapping_sub" title="method pointer::wrapping_sub">wrapping_sub</a> on it. See that method for documentation.</p>
<p>For non-<code>Sized</code> pointees this operation changes only the data pointer,
leaving the metadata untouched.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1258-1264">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read-1" class="fn">read</a>(self) -&gt; T<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>See <a href="ptr/fn.read.html" title="fn core::ptr::read"><code>ptr::read</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_volatile-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1279-1285">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile-1" class="fn">read_volatile</a>(self) -&gt; T<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Performs a volatile read of the value from <code>self</code> without moving it. This
leaves the memory in <code>self</code> unchanged.</p>
<p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p>See <a href="ptr/fn.read_volatile.html" title="fn core::ptr::read_volatile"><code>ptr::read_volatile</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_unaligned-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1299-1305">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read_unaligned-1" class="fn">read_unaligned</a>(self) -&gt; T<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>Unlike <code>read</code>, the pointer may be unaligned.</p>
<p>See <a href="ptr/fn.read_unaligned.html" title="fn core::ptr::read_unaligned"><code>ptr::read_unaligned</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1319-1325">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to-1" class="fn">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy.html" title="fn core::ptr::copy"><code>ptr::copy</code></a>.</p>
<p>See <a href="ptr/fn.copy.html" title="fn core::ptr::copy"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to_nonoverlapping-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1339-1345">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to_nonoverlapping-1" class="fn">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may <em>not</em> overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="ptr/fn.copy_nonoverlapping.html" title="fn core::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p>See <a href="ptr/fn.copy_nonoverlapping.html" title="fn core::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_from" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1359-1365">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_from" class="fn">copy_from</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>self</code>. The source
and destination may overlap.</p>
<p>NOTE: this has the <em>opposite</em> argument order of <a href="ptr/fn.copy.html" title="fn core::ptr::copy"><code>ptr::copy</code></a>.</p>
<p>See <a href="ptr/fn.copy.html" title="fn core::ptr::copy"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_from_nonoverlapping" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1379-1385">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_from_nonoverlapping" class="fn">copy_from_nonoverlapping</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>self</code>. The source
and destination may <em>not</em> overlap.</p>
<p>NOTE: this has the <em>opposite</em> argument order of <a href="ptr/fn.copy_nonoverlapping.html" title="fn core::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p>See <a href="ptr/fn.copy_nonoverlapping.html" title="fn core::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.drop_in_place" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/109342" title="Tracking issue for const_drop_in_place">unstable</a>)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1395-1401">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.drop_in_place" class="fn">drop_in_place</a>(self)<div class="where">where
    T:,</div></h4></section></summary><div class="docblock"><p>Executes the destructor (if any) of the pointed-to value.</p>
<p>See <a href="ptr/fn.drop_in_place.html" title="fn core::ptr::drop_in_place"><code>ptr::drop_in_place</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1413-1419">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.write" class="fn">write</a>(self, val: T)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
<p>See <a href="ptr/fn.write.html" title="fn core::ptr::write"><code>ptr::write</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1432-1438">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.write_bytes" class="fn">write_bytes</a>(self, val: <a class="primitive" href="primitive.u8.html">u8</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Invokes memset on the specified pointer, setting <code>count * size_of::&lt;T&gt;()</code>
bytes of memory starting at <code>self</code> to <code>val</code>.</p>
<p>See <a href="ptr/fn.write_bytes.html" title="fn core::ptr::write_bytes"><code>ptr::write_bytes</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_volatile" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1453-1459">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.write_volatile" class="fn">write_volatile</a>(self, val: T)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Performs a volatile write of a memory location with the given value without
reading or dropping the old value.</p>
<p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p>See <a href="ptr/fn.write_volatile.html" title="fn core::ptr::write_volatile"><code>ptr::write_volatile</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_unaligned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.83.0">1.26.0 (const: 1.83.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1473-1479">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.write_unaligned" class="fn">write_unaligned</a>(self, val: T)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
<p>Unlike <code>write</code>, the pointer may be unaligned.</p>
<p>See <a href="ptr/fn.write_unaligned.html" title="fn core::ptr::write_unaligned"><code>ptr::write_unaligned</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.88.0">1.26.0 (const: 1.88.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1490-1496">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.replace" class="fn">replace</a>(self, src: T) -&gt; T<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Replaces the value at <code>self</code> with <code>src</code>, returning the old
value, without dropping either.</p>
<p>See <a href="ptr/fn.replace.html" title="fn core::ptr::replace"><code>ptr::replace</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.85.0">1.26.0 (const: 1.85.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1508-1514">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.swap" class="fn">swap</a>(self, with: <a class="primitive" href="primitive.pointer.html">*mut T</a>)<div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Swaps the values at two mutable locations of the same type, without
deinitializing either. They may overlap, unlike <code>mem::swap</code> which is
otherwise equivalent.</p>
<p>See <a href="ptr/fn.swap.html" title="fn core::ptr::swap"><code>ptr::swap</code></a> for safety concerns and examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.align_offset-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1557-1578">Source</a></span><h4 class="code-header">pub fn <a href="#method.align_offset-1" class="fn">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Computes the offset that needs to be applied to the pointer in order to make it aligned to
<code>align</code>.</p>
<p>If it is not possible to align the pointer, the implementation returns
<code>usize::MAX</code>.</p>
<p>The offset is expressed in number of <code>T</code> elements, and not bytes. The value returned can be
used with the <code>wrapping_add</code> method.</p>
<p>There are no guarantees whatsoever that offsetting the pointer will not overflow or go
beyond the allocation that the pointer points into. It is up to the caller to ensure that
the returned offset is correct in all terms other than alignment.</p>
<h5 id="panics-6"><a class="doc-anchor" href="#panics-6">¬ß</a>Panics</h5>
<p>The function panics if <code>align</code> is not a power-of-two.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">¬ß</a>Examples</h5>
<p>Accessing adjacent <code>u8</code> as <code>u16</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>x = [<span class="number">5_u8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];
<span class="kw">let </span>ptr = x.as_mut_ptr();
<span class="kw">let </span>offset = ptr.align_offset(align_of::&lt;u16&gt;());

<span class="kw">if </span>offset &lt; x.len() - <span class="number">1 </span>{
    <span class="kw">let </span>u16_ptr = ptr.add(offset).cast::&lt;u16&gt;();
    <span class="kw-2">*</span>u16_ptr = <span class="number">0</span>;

    <span class="macro">assert!</span>(x == [<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] || x == [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">9</span>]);
} <span class="kw">else </span>{
    <span class="comment">// while the pointer can be aligned via `offset`, it would point
    // outside the allocation
</span>}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++unsafe+%7B%0A++++let+mut+x+=+%5B5_u8,+6,+7,+8,+9%5D;%0A++++let+ptr+=+x.as_mut_ptr();%0A++++let+offset+=+ptr.align_offset(align_of::%3Cu16%3E());%0A++++%0A++++if+offset+%3C+x.len()+-+1+%7B%0A++++++++let+u16_ptr+=+ptr.add(offset).cast::%3Cu16%3E();%0A++++++++*u16_ptr+=+0;%0A++++%0A++++++++assert!(x+==+%5B0,+0,+7,+8,+9%5D+%7C%7C+x+==+%5B5,+0,+0,+8,+9%5D);%0A++++%7D+else+%7B%0A++++++++//+while+the+pointer+can+be+aligned+via+%60offset%60,+it+would+point%0A++++++++//+outside+the+allocation%0A++++%7D%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.79.0">1.79.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1598-1603">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_aligned-1" class="fn">is_aligned</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a><div class="where">where
    T: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Returns whether the pointer is properly aligned for <code>T</code>.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// On some platforms, the alignment of i32 is less than 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span><span class="kw-2">mut </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>data <span class="kw">as </span><span class="kw-2">*mut </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned());
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">1</span>).is_aligned());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++//+On+some+platforms,+the+alignment+of+i32+is+less+than+4.%0A++++%23%5Brepr(align(4))%5D%0A++++struct+AlignedI32(i32);%0A++++%0A++++let+mut+data+=+AlignedI32(42);%0A++++let+ptr+=+%26mut+data+as+*mut+AlignedI32;%0A++++%0A++++assert!(ptr.is_aligned());%0A++++assert!(!ptr.wrapping_byte_add(1).is_aligned());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned_to-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1638-1644">Source</a><h4 class="code-header">pub fn <a href="#method.is_aligned_to-1" class="fn">is_aligned_to</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>pointer_is_aligned_to</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96284">#96284</a>)</span></div></span></summary><div class="docblock"><p>Returns whether the pointer is aligned to <code>align</code>.</p>
<p>For non-<code>Sized</code> pointees this operation considers only the data pointer,
ignoring the metadata.</p>
<h5 id="panics-7"><a class="doc-anchor" href="#panics-7">¬ß</a>Panics</h5>
<p>The function panics if <code>align</code> is not a power-of-two (this includes 0).</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned_to)]

</span><span class="comment">// On some platforms, the alignment of i32 is less than 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span><span class="kw-2">mut </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>data <span class="kw">as </span><span class="kw-2">*mut </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));

<span class="macro">assert!</span>(ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">4</span>));

<span class="macro">assert_ne!</span>(ptr.is_aligned_to(<span class="number">8</span>), ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned_to)%5D%0A%0A%0A//+On+some+platforms,+the+alignment+of+i32+is+less+than+4.%0Afn+main()+%7B%0A++++%23%5Brepr(align(4))%5D%0A++++struct+AlignedI32(i32);%0A++++%0A++++let+mut+data+=+AlignedI32(42);%0A++++let+ptr+=+%26mut+data+as+*mut+AlignedI32;%0A++++%0A++++assert!(ptr.is_aligned_to(1));%0A++++assert!(ptr.is_aligned_to(2));%0A++++assert!(ptr.is_aligned_to(4));%0A++++%0A++++assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));%0A++++assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));%0A++++%0A++++assert_ne!(ptr.is_aligned_to(8),+ptr.wrapping_add(1).is_aligned_to(8));%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+T-1" class="impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1647-1658">Source</a><a href="#impl-*mut+T-1" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cast_uninit-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1655-1657">Source</a><h4 class="code-header">pub const fn <a href="#method.cast_uninit-1" class="fn">cast_uninit</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>cast_maybe_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145036">#145036</a>)</span></div></span></summary><div class="docblock"><p>Casts from a type to its maybe-uninitialized version.</p>
<p>This is always safe, since UB can only occur if the pointer is read
before being initialized.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+MaybeUninit%3CT%3E" class="impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1659-1670">Source</a><a href="#impl-*mut+MaybeUninit%3CT%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cast_init-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1667-1669">Source</a><h4 class="code-header">pub const fn <a href="#method.cast_init-1" class="fn">cast_init</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>cast_maybe_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/145036">#145036</a>)</span></div></span></summary><div class="docblock"><p>Casts from a maybe-uninitialized type to its initialized version.</p>
<p>This is always safe, since UB can only occur if the pointer is read
before being initialized.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+%5BT%5D" class="impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1672-1949">Source</a><a href="#impl-*mut+%5BT%5D" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.79.0, const since 1.79.0">1.79.0 (const: 1.79.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1691-1693">Source</a></span><h4 class="code-header">pub const fn <a href="#method.len-1" class="fn">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of a raw slice.</p>
<p>The returned value is the number of <strong>elements</strong>, not the number of bytes.</p>
<p>This function is safe, even when the raw slice cannot be cast to a slice
reference because the pointer is null or unaligned.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*mut </span>[i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.len(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+slice:+*mut+%5Bi8%5D+=+ptr::slice_from_raw_parts_mut(ptr::null_mut(),+3);%0A++++assert_eq!(slice.len(),+3);%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.79.0, const since 1.79.0">1.79.0 (const: 1.79.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1708-1710">Source</a></span><h4 class="code-header">pub const fn <a href="#method.is_empty-1" class="fn">is_empty</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the raw slice has a length of 0.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*mut </span>[i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), <span class="number">3</span>);
<span class="macro">assert!</span>(!slice.is_empty());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+slice:+*mut+%5Bi8%5D+=+ptr::slice_from_raw_parts_mut(ptr::null_mut(),+3);%0A++++assert!(!slice.is_empty());%0A%7D&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_array" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.93.0, const since 1.93.0">1.93.0 (const: 1.93.0)</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#1719-1726">Source</a></span><h4 class="code-header">pub const fn <a href="#method.as_mut_array" class="fn">as_mut_array</a>&lt;const N: <a class="primitive" href="primitive.usize.html">usize</a>&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.array.html">[T; N]</a>&gt;</h4></section></summary><div class="docblock"><p>Gets a raw, mutable pointer to the underlying array.</p>
<p>If <code>N</code> is not exactly equal to the length of <code>self</code>, then this method returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1771-1776">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_mut" class="fn">split_at_mut</a>(self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>, <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>raw_slice_split</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95595">#95595</a>)</span></div></span></summary><div class="docblock"><p>Divides one mutable raw slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>
<h5 id="panics-8"><a class="doc-anchor" href="#panics-8">¬ß</a>Panics</h5>
<p>Panics if <code>mid &gt; len</code>.</p>
<h5 id="safety-26"><a class="doc-anchor" href="#safety-26">¬ß</a>Safety</h5>
<p><code>mid</code> must be <a href="#method.add">in-bounds</a> of the underlying <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>.
Which means <code>self</code> must be dereferenceable and span a single allocation
that is at least <code>mid * size_of::&lt;T&gt;()</code> bytes long. Not upholding these
requirements is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointers are not used.</p>
<p>Since <code>len</code> being in-bounds is not a safety invariant of <code>*mut [T]</code> the
safety requirements of this method are the same as for <a href="#method.split_at_mut_unchecked"><code>split_at_mut_unchecked</code></a>.
The explicit bounds check is only as useful as <code>len</code> is correct.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(raw_slice_split)]
#![feature(slice_ptr_get)]

</span><span class="kw">let </span><span class="kw-2">mut </span>v = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>];
<span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>v <span class="kw">as </span><span class="kw-2">*mut </span>[<span class="kw">_</span>];
<span class="kw">unsafe </span>{
    <span class="kw">let </span>(left, right) = ptr.split_at_mut(<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>left, [<span class="number">1</span>, <span class="number">0</span>]);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>right, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>]);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(raw_slice_split)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0A%0Afn+main()+%7B%0A++++let+mut+v+=+%5B1,+0,+3,+0,+5,+6%5D;%0A++++let+ptr+=+%26mut+v+as+*mut+%5B_%5D;%0A++++unsafe+%7B%0A++++++++let+(left,+right)+=+ptr.split_at_mut(2);%0A++++++++assert_eq!(%26*left,+%5B1,+0%5D);%0A++++++++assert_eq!(%26*right,+%5B3,+0,+5,+6%5D);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut_unchecked" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1815-1825">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_mut_unchecked" class="fn">split_at_mut_unchecked</a>(self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>, <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>raw_slice_split</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95595">#95595</a>)</span></div></span></summary><div class="docblock"><p>Divides one mutable raw slice into two at an index, without doing bounds checking.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>
<h5 id="safety-27"><a class="doc-anchor" href="#safety-27">¬ß</a>Safety</h5>
<p><code>mid</code> must be <a href="#method.add">in-bounds</a> of the underlying <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>.
Which means <code>self</code> must be dereferenceable and span a single allocation
that is at least <code>mid * size_of::&lt;T&gt;()</code> bytes long. Not upholding these
requirements is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointers are not used.</p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(raw_slice_split)]

</span><span class="kw">let </span><span class="kw-2">mut </span>v = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>];
<span class="comment">// scoped to restrict the lifetime of the borrows
</span><span class="kw">unsafe </span>{
    <span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>v <span class="kw">as </span><span class="kw-2">*mut </span>[<span class="kw">_</span>];
    <span class="kw">let </span>(left, right) = ptr.split_at_mut_unchecked(<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>left, [<span class="number">1</span>, <span class="number">0</span>]);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>right, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>]);
    (<span class="kw-2">&amp;mut *</span>left)[<span class="number">1</span>] = <span class="number">2</span>;
    (<span class="kw-2">&amp;mut *</span>right)[<span class="number">1</span>] = <span class="number">4</span>;
}
<span class="macro">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(raw_slice_split)%5D%0A%0A%0Afn+main()+%7B%0A++++let+mut+v+=+%5B1,+0,+3,+0,+5,+6%5D;%0A++++//+scoped+to+restrict+the+lifetime+of+the+borrows%0A++++unsafe+%7B%0A++++++++let+ptr+=+%26mut+v+as+*mut+%5B_%5D;%0A++++++++let+(left,+right)+=+ptr.split_at_mut_unchecked(2);%0A++++++++assert_eq!(%26*left,+%5B1,+0%5D);%0A++++++++assert_eq!(%26*right,+%5B3,+0,+5,+6%5D);%0A++++++++(%26mut+*left)%5B1%5D+=+2;%0A++++++++(%26mut+*right)%5B1%5D+=+4;%0A++++%7D%0A++++assert_eq!(v,+%5B1,+2,+3,+4,+5,+6%5D);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1842-1844">Source</a><h4 class="code-header">pub const fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to the slice‚Äôs buffer.</p>
<p>This is equivalent to casting <code>self</code> to <code>*mut T</code>, but more type-safe.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]
</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*mut </span>[i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.as_mut_ptr(), ptr::null_mut());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+slice:+*mut+%5Bi8%5D+=+ptr::slice_from_raw_parts_mut(ptr::null_mut(),+3);%0A++++assert_eq!(slice.as_mut_ptr(),+ptr::null_mut());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1869-1875">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.get_unchecked_mut" class="fn">get_unchecked_mut</a>&lt;I&gt;(self, index: I) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>I::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a><div class="where">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[T]</a>&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to an element or subslice, without doing bounds
checking.</p>
<p>Calling this method with an <a href="#method.add">out-of-bounds index</a> or when <code>self</code> is not dereferenceable
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting pointer is not used.</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]

</span><span class="kw">let </span>x = <span class="kw-2">&amp;mut </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as </span><span class="kw-2">*mut </span>[i32];

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(x.get_unchecked_mut(<span class="number">1</span>), x.as_mut_ptr().add(<span class="number">1</span>));
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0A%0Afn+main()+%7B%0A++++let+x+=+%26mut+%5B1,+2,+4%5D+as+*mut+%5Bi32%5D;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(x.get_unchecked_mut(1),+x.as_mut_ptr().add(1));%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_slice-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1883-1890">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_uninit_slice-1" class="fn">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a [<a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a shared slice to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_ref"><code>as_ref</code></a>, this does not require
that the value has to be initialized.</p>
<h5 id="safety-28"><a class="doc-anchor" href="#safety-28">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li>
<p>The pointer must be <a href="ptr/index.html#safety" title="mod core::ptr">valid</a> for reads for <code>ptr.len() * size_of::&lt;T&gt;()</code> many bytes,
and it must be properly aligned. This means in particular:</p>
</li>
<li>
<p>The entire memory range of this slice must be contained within a single <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>!
Slices can never span across multiple allocations.</p>
</li>
<li>
<p>The pointer must be aligned even for zero-length slices. One
reason for this is that enum layout optimizations may rely on references
(including slices of any length) being aligned and non-null to distinguish
them from other data. You can obtain a pointer that is usable as <code>data</code>
for zero-length slices using <a href="ptr/struct.NonNull.html#method.dangling" title="associated function core::ptr::NonNull::dangling"><code>NonNull::dangling()</code></a>.</p>
</li>
<li>
<p>The total size <code>ptr.len() * size_of::&lt;T&gt;()</code> of the slice must be no larger than <code>isize::MAX</code>.
See the safety documentation of <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a>.</p>
</li>
<li>
<p>You must enforce Rust‚Äôs aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, while this reference exists, the memory the pointer points to must
not get mutated (except inside <code>UnsafeCell</code>).</p>
</li>
</ul>
<p>This applies even if the result of this method is unused!</p>
<p>See also <a href="slice/fn.from_raw_parts.html" title="fn core::slice::from_raw_parts"><code>slice::from_raw_parts</code></a>.</p>
<h5 id="panics-during-const-evaluation-9"><a class="doc-anchor" href="#panics-during-const-evaluation-9">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null"><code>is_null</code></a> for more information.</p>
<h5 id="see-also-2"><a class="doc-anchor" href="#see-also-2">¬ß</a>See Also</h5>
<p>For the mutable counterpart see <a href="primitive.pointer.html#method.as_uninit_slice_mut" title="method pointer::as_uninit_slice_mut"><code>as_uninit_slice_mut</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_slice_mut" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1941-1948">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.as_uninit_slice_mut" class="fn">as_uninit_slice_mut</a>&lt;'a&gt;(
    self,
) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a mut [<a class="union" href="mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>Returns <code>None</code> if the pointer is null, or else returns a unique slice to
the value wrapped in <code>Some</code>. In contrast to <a href="#method.as_mut"><code>as_mut</code></a>, this does not require
that the value has to be initialized.</p>
<p>For the shared counterpart see <a href="#method.as_uninit_slice-1"><code>as_uninit_slice</code></a>.</p>
<h5 id="safety-29"><a class="doc-anchor" href="#safety-29">¬ß</a>Safety</h5>
<p>When calling this method, you have to ensure that <em>either</em> the pointer is null <em>or</em>
all of the following is true:</p>
<ul>
<li>
<p>The pointer must be <a href="ptr/index.html#safety" title="mod core::ptr">valid</a> for reads and writes for <code>ptr.len() * size_of::&lt;T&gt;()</code>
many bytes, and it must be properly aligned. This means in particular:</p>
<ul>
<li>
<p>The entire memory range of this slice must be contained within a single <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>!
Slices can never span across multiple allocations.</p>
</li>
<li>
<p>The pointer must be aligned even for zero-length slices. One
reason for this is that enum layout optimizations may rely on references
(including slices of any length) being aligned and non-null to distinguish
them from other data. You can obtain a pointer that is usable as <code>data</code>
for zero-length slices using <a href="ptr/struct.NonNull.html#method.dangling" title="associated function core::ptr::NonNull::dangling"><code>NonNull::dangling()</code></a>.</p>
</li>
</ul>
</li>
<li>
<p>The total size <code>ptr.len() * size_of::&lt;T&gt;()</code> of the slice must be no larger than <code>isize::MAX</code>.
See the safety documentation of <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a>.</p>
</li>
<li>
<p>You must enforce Rust‚Äôs aliasing rules, since the returned lifetime <code>'a</code> is
arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.
In particular, while this reference exists, the memory the pointer points to must
not get accessed (read or written) through any other pointer.</p>
</li>
</ul>
<p>This applies even if the result of this method is unused!</p>
<p>See also <a href="slice/fn.from_raw_parts_mut.html" title="fn core::slice::from_raw_parts_mut"><code>slice::from_raw_parts_mut</code></a>.</p>
<h5 id="panics-during-const-evaluation-10"><a class="doc-anchor" href="#panics-during-const-evaluation-10">¬ß</a>Panics during const evaluation</h5>
<p>This method will panic during const evaluation if the pointer cannot be
determined to be null or not. See <a href="#method.is_null-1"><code>is_null</code></a> for more information.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+T-2" class="impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1951-1958">Source</a><a href="#impl-*mut+T-2" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cast_array-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1955-1957">Source</a><h4 class="code-header">pub const fn <a href="#method.cast_array-1" class="fn">cast_array</a>&lt;const N: <a class="primitive" href="primitive.usize.html">usize</a>&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.array.html">[T; N]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>ptr_cast_array</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/144514">#144514</a>)</span></div></span></summary><div class="docblock"><p>Casts from a pointer-to-<code>T</code> to a pointer-to-<code>[T; N]</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+%5BT;+N%5D" class="impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1960-1999">Source</a><a href="#impl-*mut+%5BT;+N%5D" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, const N: <a class="primitive" href="primitive.usize.html">usize</a>&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.array.html">[T; N]</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr-1" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1976-1978">Source</a><h4 class="code-header">pub const fn <a href="#method.as_mut_ptr-1" class="fn">as_mut_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>array_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/119834">#119834</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to the array‚Äôs buffer.</p>
<p>This is equivalent to casting <code>self</code> to <code>*mut T</code>, but more type-safe.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(array_ptr_get)]
</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>arr: <span class="kw-2">*mut </span>[i8; <span class="number">3</span>] = ptr::null_mut();
<span class="macro">assert_eq!</span>(arr.as_mut_ptr(), ptr::null_mut());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(array_ptr_get)%5D%0A%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+arr:+*mut+%5Bi8;+3%5D+=+ptr::null_mut();%0A++++assert_eq!(arr.as_mut_ptr(),+ptr::null_mut());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_slice" class="method"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#1996-1998">Source</a><h4 class="code-header">pub const fn <a href="#method.as_mut_slice" class="fn">as_mut_slice</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>array_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/119834">#119834</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to a mutable slice containing the entire array.</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">¬ß</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(array_ptr_get)]

</span><span class="kw">let </span><span class="kw-2">mut </span>arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>[i32; <span class="number">3</span>] = <span class="kw-2">&amp;mut </span>arr;
<span class="kw">unsafe </span>{
    (<span class="kw-2">&amp;mut *</span>ptr.as_mut_slice())[..<span class="number">2</span>].copy_from_slice(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">4</span>]);
}
<span class="macro">assert_eq!</span>(arr, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(array_ptr_get)%5D%0A%0A%0Afn+main()+%7B%0A++++let+mut+arr+=+%5B1,+2,+5%5D;%0A++++let+ptr:+*mut+%5Bi32;+3%5D+=+%26mut+arr;%0A++++unsafe+%7B%0A++++++++(%26mut+*ptr.as_mut_slice())%5B..2%5D.copy_from_slice(%26%5B3,+4%5D);%0A++++%7D%0A++++assert_eq!(arr,+%5B3,+4,+5%5D);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">¬ß</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AtomicPrimitive-for-*mut+T" class="impl"><a class="src rightside" href="../src/core/sync/atomic.rs.html#328">Source</a><a href="#impl-AtomicPrimitive-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="sync/atomic/trait.AtomicPrimitive.html" title="trait core::sync::atomic::AtomicPrimitive">AtomicPrimitive</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.AtomicInner" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/sync/atomic.rs.html#328">Source</a><a href="#associatedtype.AtomicInner" class="anchor">¬ß</a><h4 class="code-header">type <a href="sync/atomic/trait.AtomicPrimitive.html#associatedtype.AtomicInner" class="associatedtype">AtomicInner</a> = <a class="struct" href="sync/atomic/struct.AtomicPtr.html" title="struct core::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>atomic_internals</code>)</span></div></span><div class='docblock'>Temporary implementation detail.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/142757" title="Tracking issue for const_clone">unstable</a>)</span> ¬∑ <a class="src" href="../src/core/clone.rs.html#650-655">Source</a></span><a href="#impl-Clone-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#652-654">Source</a><a href="#method.clone" class="anchor">¬ß</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/clone.rs.html#245-250">Source</a></span><a href="#method.clone_from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)<div class="where">where
    Self:,</div></h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/142757" title="Tracking issue for const_clone">unstable</a>)</span> ¬∑ <a class="src" href="../src/core/clone.rs.html#664-669">Source</a></span><a href="#impl-Clone-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone-1" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#666-668">Source</a><a href="#method.clone-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/clone.rs.html#245-250">Source</a></span><a href="#method.clone_from-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)<div class="where">where
    Self:,</div></h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/fmt/mod.rs.html#3058-3062">Source</a></span><a href="#impl-Debug-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/mod.rs.html#3059-3061">Source</a><a href="#method.fmt-2" class="anchor">¬ß</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/fmt/mod.rs.html#3064-3068">Source</a></span><a href="#impl-Debug-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/mod.rs.html#3065-3067">Source</a><a href="#method.fmt-3" class="anchor">¬ß</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.88.0">1.88.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1649-1654">Source</a></span><a href="#impl-Default-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="traitalias" href="ptr/traitalias.Thin.html" title="traitalias core::ptr::Thin">Thin</a>&gt; <a class="trait" href="default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1651-1653">Source</a><a href="#method.default" class="anchor">¬ß</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Returns the default value of <a href="ptr/fn.null.html" title="fn core::ptr::null"><code>null()</code></a>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.88.0">1.88.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#2082-2087">Source</a></span><a href="#impl-Default-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="traitalias" href="ptr/traitalias.Thin.html" title="traitalias core::ptr::Thin">Thin</a>&gt; <a class="trait" href="default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2084-2086">Source</a><a href="#method.default-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Returns the default value of <a href="ptr/fn.null_mut.html" title="fn core::ptr::null_mut"><code>null_mut()</code></a>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C*mut+T%3E-for-AtomicPtr%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0, const unstable">1.23.0 (const: <a href="https://github.com/rust-lang/rust/issues/143773" title="Tracking issue for const_convert">unstable</a>)</span> ¬∑ <a class="src" href="../src/core/sync/atomic.rs.html#2592-2598">Source</a></span><a href="#impl-From%3C*mut+T%3E-for-AtomicPtr%3CT%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="struct" href="sync/atomic/struct.AtomicPtr.html" title="struct core::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/core/sync/atomic.rs.html#2595-2597">Source</a><a href="#method.from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(p: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts a <code>*mut T</code> into an <code>AtomicPtr&lt;T&gt;</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/hash/mod.rs.html#957-964">Source</a></span><a href="#impl-Hash-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/core/hash/mod.rs.html#959-963">Source</a><a href="#method.hash" class="anchor">¬ß</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H: <a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> ¬∑ <a class="src" href="../src/core/hash/mod.rs.html#235-242">Source</a></span><a href="#method.hash_slice" class="anchor">¬ß</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H: <a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(data: &amp;[Self], state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/hash/mod.rs.html#967-974">Source</a></span><a href="#impl-Hash-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash-1" class="method trait-impl"><a class="src rightside" href="../src/core/hash/mod.rs.html#969-973">Source</a><a href="#method.hash-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H: <a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> ¬∑ <a class="src" href="../src/core/hash/mod.rs.html#235-242">Source</a></span><a href="#method.hash_slice-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H: <a class="trait" href="hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(data: &amp;[Self], state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1596-1608">Source</a></span><a href="#impl-Ord-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3><div class="docblock"><p>Pointer comparison is by address, as produced by the <code>[</code>&lt;*const T&gt;::addr<code>](pointer::addr)</code> method.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1599-1607">Source</a><a href="#method.cmp" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#1025-1030">Source</a></span><a href="#method.max" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#1064-1069">Source</a></span><a href="#method.min" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#1090-1102">Source</a></span><a href="#method.clamp" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#2029-2041">Source</a></span><a href="#impl-Ord-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3><div class="docblock"><p>Pointer comparison is by address, as produced by the <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>&lt;*mut T&gt;::addr</code></a> method.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2032-2040">Source</a><a href="#method.cmp-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#1025-1030">Source</a></span><a href="#method.max-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#1064-1069">Source</a></span><a href="#method.min-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#1090-1102">Source</a></span><a href="#method.clamp-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1574-1580">Source</a></span><a href="#impl-PartialEq-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3><div class="docblock"><p>Pointer equality is by address, as produced by the <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>&lt;*const T&gt;::addr</code></a> method.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1577-1579">Source</a><a href="#method.eq" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#264-266">Source</a></span><a href="#method.ne" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#2007-2013">Source</a></span><a href="#impl-PartialEq-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3><div class="docblock"><p>Pointer equality is by address, as produced by the <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>&lt;*mut T&gt;::addr</code></a> method.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2010-2012">Source</a><a href="#method.eq-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/cmp.rs.html#264-266">Source</a></span><a href="#method.ne-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1616-1646">Source</a></span><a href="#impl-PartialOrd-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3><div class="docblock"><p>Pointer comparison is by address, as produced by the <code>[</code>&lt;*const T&gt;::addr<code>](pointer::addr)</code> method.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1619-1621">Source</a><a href="#method.partial_cmp" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1625-1627">Source</a><a href="#method.lt" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1631-1633">Source</a><a href="#method.le" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1637-1639">Source</a><a href="#method.gt" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/const_ptr.rs.html#1643-1645">Source</a><a href="#method.ge" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#2049-2079">Source</a></span><a href="#impl-PartialOrd-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3><div class="docblock"><p>Pointer comparison is by address, as produced by the <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>&lt;*mut T&gt;::addr</code></a> method.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2052-2054">Source</a><a href="#method.partial_cmp-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2058-2060">Source</a><a href="#method.lt-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2064-2066">Source</a><a href="#method.le-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2070-2072">Source</a><a href="#method.gt-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><a class="src rightside" href="../src/core/ptr/mut_ptr.rs.html#2076-2078">Source</a><a href="#method.ge-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pointer-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/fmt/mod.rs.html#2990-3001">Source</a></span><a href="#impl-Pointer-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/mod.rs.html#2991-3000">Source</a><a href="#method.fmt" class="anchor">¬ß</a><h4 class="code-header">fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Pointer.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pointer-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/fmt/mod.rs.html#3035-3039">Source</a></span><a href="#impl-Pointer-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/core/fmt/mod.rs.html#3036-3038">Source</a><a href="#method.fmt-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="fmt/trait.Pointer.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SimdElement-for-*const+T" class="impl"><a class="src rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1214-1219">Source</a><a href="#impl-SimdElement-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="simd/trait.SimdElement.html" title="trait core::simd::SimdElement">SimdElement</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><div class="where">where
    T: <a class="trait" href="ptr/trait.Pointee.html" title="trait core::ptr::Pointee">Pointee</a>&lt;Metadata = <a class="primitive" href="primitive.unit.html">()</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Mask" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1218">Source</a><a href="#associatedtype.Mask" class="anchor">¬ß</a><h4 class="code-header">type <a href="simd/trait.SimdElement.html#associatedtype.Mask" class="associatedtype">Mask</a> = <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/86656">#86656</a>)</span></div></span><div class='docblock'>The mask element type corresponding to this element type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SimdElement-for-*mut+T" class="impl"><a class="src rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1226-1231">Source</a><a href="#impl-SimdElement-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="simd/trait.SimdElement.html" title="trait core::simd::SimdElement">SimdElement</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><div class="where">where
    T: <a class="trait" href="ptr/trait.Pointee.html" title="trait core::ptr::Pointee">Pointee</a>&lt;Metadata = <a class="primitive" href="primitive.unit.html">()</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Mask-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1230">Source</a><a href="#associatedtype.Mask-1" class="anchor">¬ß</a><h4 class="code-header">type <a href="simd/trait.SimdElement.html#associatedtype.Mask" class="associatedtype">Mask</a> = <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/86656">#86656</a>)</span></div></span><div class='docblock'>The mask element type corresponding to this element type.</div></details></div></details><section id="impl-CoerceUnsized%3C*const+U%3E-for-%26T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#58">Source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a T</a></h3></section><section id="impl-CoerceUnsized%3C*const+U%3E-for-%26mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#51">Source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a mut T</a></h3></section><section id="impl-CoerceUnsized%3C*const+U%3E-for-*const+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#69">Source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-CoerceUnsized%3C*const+U%3E-for-*mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#65">Source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-CoerceUnsized%3C*mut+U%3E-for-%26mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#48">Source</a><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-%26mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a mut T</a></h3></section><section id="impl-CoerceUnsized%3C*mut+U%3E-for-*mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#62">Source</a><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-Copy-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#476-486">Source</a></span><a href="#impl-Copy-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-Copy-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#476-486">Source</a></span><a href="#impl-Copy-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-DispatchFromDyn%3C*const+U%3E-for-*const+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#131">Source</a><a href="#impl-DispatchFromDyn%3C*const+U%3E-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait core::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-DispatchFromDyn%3C*mut+U%3E-for-*mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#134">Source</a><a href="#impl-DispatchFromDyn%3C*mut+U%3E-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait core::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-Eq-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/const_ptr.rs.html#1588">Source</a></span><a href="#impl-Eq-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3><div class="docblock"><p>Pointer equality is an equivalence relation.</p>
</div></section><section id="impl-Eq-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/ptr/mut_ptr.rs.html#2021">Source</a></span><a href="#impl-Eq-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3><div class="docblock"><p>Pointer equality is an equivalence relation.</p>
</div></section><section id="impl-Freeze-for-*const+T" class="impl"><a class="src rightside" href="../src/core/marker.rs.html#915-923">Source</a><a href="#impl-Freeze-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-Freeze-for-*mut+T" class="impl"><a class="src rightside" href="../src/core/marker.rs.html#915-923">Source</a><a href="#impl-Freeze-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-PinCoerceUnsized-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span> ¬∑ <a class="src" href="../src/core/pin.rs.html#1859">Source</a></span><a href="#impl-PinCoerceUnsized-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="pin/trait.PinCoerceUnsized.html" title="trait core::pin::PinCoerceUnsized">PinCoerceUnsized</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-PinCoerceUnsized-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.33.0">1.33.0</span> ¬∑ <a class="src" href="../src/core/pin.rs.html#1862">Source</a></span><a href="#impl-PinCoerceUnsized-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="pin/trait.PinCoerceUnsized.html" title="trait core::pin::PinCoerceUnsized">PinCoerceUnsized</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-Send-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#100">Source</a></span><a href="#impl-Send-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; !<a class="trait" href="marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-Send-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#102">Source</a></span><a href="#impl-Send-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; !<a class="trait" href="marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-Sync-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#677">Source</a></span><a href="#impl-Sync-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-Sync-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#679">Source</a></span><a href="#impl-Sync-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-Unpin-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#1041-1046">Source</a></span><a href="#impl-Unpin-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-Unpin-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span> ¬∑ <a class="src" href="../src/core/marker.rs.html#1041-1046">Source</a></span><a href="#impl-Unpin-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-UnwindSafe-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> ¬∑ <a class="src" href="../src/core/panic/unwind_safe.rs.html#185">Source</a></span><a href="#impl-UnwindSafe-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-UnwindSafe-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> ¬∑ <a class="src" href="../src/core/panic/unwind_safe.rs.html#187">Source</a></span><a href="#impl-UnwindSafe-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section><section id="impl-VaArgSafe-for-*const+T" class="impl"><a class="src rightside" href="../src/core/ffi/va_list.rs.html#232">Source</a><a href="#impl-VaArgSafe-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="ffi/va_list/trait.VaArgSafe.html" title="trait core::ffi::va_list::VaArgSafe">VaArgSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3></section><section id="impl-VaArgSafe-for-*mut+T" class="impl"><a class="src rightside" href="../src/core/ffi/va_list.rs.html#231">Source</a><a href="#impl-VaArgSafe-for-*mut+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="ffi/va_list/trait.VaArgSafe.html" title="trait core::ffi::va_list::VaArgSafe">VaArgSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">¬ß</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-*const+T" class="impl"><a href="#impl-RefUnwindSafe-for-*const+T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><div class="where">where
    T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">¬ß</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="../src/core/any.rs.html#138-142">Source</a><a href="#impl-Any-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../src/core/any.rs.html#139-141">Source</a><a href="#method.type_id" class="anchor">¬ß</a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#212-217">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#214-216">Source</a><a href="#method.borrow" class="anchor">¬ß</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/borrow.rs.html#221-225">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../src/core/borrow.rs.html#222-224">Source</a><a href="#method.borrow_mut" class="anchor">¬ß</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="../src/core/clone.rs.html#547-553">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="../src/core/clone.rs.html#549-552">Source</a><a href="#method.clone_to_uninit" class="anchor">¬ß</a><h4 class="code-header">unsafe fn <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#785-791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#788-790">Source</a><a href="#method.from-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#767-780">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#777-779">Source</a><a href="#method.into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#827-837">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">¬ß</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#834-836">Source</a><a href="#method.try_from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#811-821">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">¬ß</a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="../src/core/convert/mod.rs.html#818-820">Source</a><a href="#method.try_into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>