<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="References, `&#38;T` and `&#38;mut T`."><title>reference - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-0bd2dfd4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.95.0" data-rustdoc-version="1.95.0-nightly (e96bb7e44 2026-01-27)" data-channel="nightly" data-search-js="search-86d08462.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items1.95.0.js"></script><script defer src="../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc primitive"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">reference</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../core/index.html"><img class="rust-logo" src="../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../core/index.html">core</a><span class="version">1.95.0-nightly</span></h2></div><div class="version">(e96bb7e44	2026-01-27)</div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">reference</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#trait-implementations-1" title="Trait implementations">Trait implementations</a></li><li><a href="#safety" title="Safety">Safety</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-CoerceUnsized%3C%26U%3E-for-%26T" title="CoerceUnsized&#60;&#38;&#39;a U&#62;">CoerceUnsized&#60;&#38;&#39;a U&#62;</a></li><li><a href="#impl-CoerceUnsized%3C%26U%3E-for-%26mut+T" title="CoerceUnsized&#60;&#38;&#39;a U&#62;">CoerceUnsized&#60;&#38;&#39;a U&#62;</a></li><li><a href="#impl-CoerceUnsized%3C%26mut+U%3E-for-%26mut+T" title="CoerceUnsized&#60;&#38;&#39;a mut U&#62;">CoerceUnsized&#60;&#38;&#39;a mut U&#62;</a></li><li><a href="#impl-DispatchFromDyn%3C%26U%3E-for-%26T" title="DispatchFromDyn&#60;&#38;&#39;a U&#62;">DispatchFromDyn&#60;&#38;&#39;a U&#62;</a></li><li><a href="#impl-DispatchFromDyn%3C%26mut+U%3E-for-%26mut+T" title="DispatchFromDyn&#60;&#38;&#39;a mut U&#62;">DispatchFromDyn&#60;&#38;&#39;a mut U&#62;</a></li><li><a href="#impl-PartialEq%3C%26B%3E-for-%26A" title="PartialEq&#60;&#38;B&#62;">PartialEq&#60;&#38;B&#62;</a></li><li><a href="#impl-PartialEq%3C%26B%3E-for-%26mut+A" title="PartialEq&#60;&#38;B&#62;">PartialEq&#60;&#38;B&#62;</a></li><li><a href="#impl-PartialEq%3C%26mut+B%3E-for-%26A" title="PartialEq&#60;&#38;mut B&#62;">PartialEq&#60;&#38;mut B&#62;</a></li><li><a href="#impl-PartialEq%3C%26mut+B%3E-for-%26mut+A" title="PartialEq&#60;&#38;mut B&#62;">PartialEq&#60;&#38;mut B&#62;</a></li><li><a href="#impl-PartialOrd%3C%26B%3E-for-%26A" title="PartialOrd&#60;&#38;B&#62;">PartialOrd&#60;&#38;B&#62;</a></li><li><a href="#impl-PartialOrd%3C%26mut+B%3E-for-%26mut+A" title="PartialOrd&#60;&#38;mut B&#62;">PartialOrd&#60;&#38;mut B&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate core</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><h1>Primitive Type <span class="primitive">reference</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>References, <code>&amp;T</code> and <code>&amp;mut T</code>.</p>
<p>A reference represents a borrow of some owned value. You can get one by using the <code>&amp;</code> or <code>&amp;mut</code>
operators on a value, or by using a <a href="../std/keyword.ref.html"><code>ref</code></a> or
<code><a href="../std/keyword.ref.html">ref</a> <a href="../std/keyword.mut.html">mut</a></code> pattern.</p>
<p>For those familiar with pointers, a reference is just a pointer that is assumed to be
aligned, not null, and pointing to memory containing a valid value of <code>T</code> - for example,
<code>&amp;<a href="primitive.bool.html" title="primitive bool">bool</a></code> can only point to an allocation containing the integer values <code>1</code>
(<a href="../std/keyword.true.html"><code>true</code></a>) or <code>0</code> (<a href="../std/keyword.false.html"><code>false</code></a>), but
creating a <code>&amp;<a href="primitive.bool.html" title="primitive bool">bool</a></code> that points to an allocation containing
the value <code>3</code> causes undefined behavior.
In fact, <code><a href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;T&gt;</code> has the same memory representation as a
nullable but aligned pointer, and can be passed across FFI boundaries as such.</p>
<p>In most cases, references can be used much like the original value. Field access, method
calling, and indexing work the same (save for mutability rules, of course). In addition, the
comparison operators transparently defer to the referent’s implementation, allowing references
to be compared the same as owned values.</p>
<p>References have a lifetime attached to them, which represents the scope for which the borrow is
valid. A lifetime is said to “outlive” another one if its representative scope is as long or
longer than the other. The <code>'static</code> lifetime is the longest lifetime, which represents the
total life of the program. For example, string literals have a <code>'static</code> lifetime because the
text data is embedded into the binary of the program, rather than in an allocation that needs
to be dynamically managed.</p>
<p><code>&amp;mut T</code> references can be freely coerced into <code>&amp;T</code> references with the same referent type, and
references with longer lifetimes can be freely coerced into references with shorter ones.</p>
<p><a href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq"><code>PartialEq</code></a> will compare referenced values. It is possible to compare the reference address
using reference-pointer coercion and raw pointer equality via <a href="ptr/fn.eq.html" title="fn core::ptr::eq"><code>ptr::eq</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ptr;

<span class="kw">let </span>five = <span class="number">5</span>;
<span class="kw">let </span>other_five = <span class="number">5</span>;
<span class="kw">let </span>five_ref = <span class="kw-2">&amp;</span>five;
<span class="kw">let </span>same_five_ref = <span class="kw-2">&amp;</span>five;
<span class="kw">let </span>other_five_ref = <span class="kw-2">&amp;</span>other_five;

<span class="macro">assert!</span>(five_ref == same_five_ref);
<span class="macro">assert!</span>(five_ref == other_five_ref);

<span class="macro">assert!</span>(ptr::eq(five_ref, same_five_ref));
<span class="macro">assert!</span>(!ptr::eq(five_ref, other_five_ref));</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++use+std::ptr;%0A++++%0A++++let+five+=+5;%0A++++let+other_five+=+5;%0A++++let+five_ref+=+%26five;%0A++++let+same_five_ref+=+%26five;%0A++++let+other_five_ref+=+%26other_five;%0A++++%0A++++assert!(five_ref+==+same_five_ref);%0A++++assert!(five_ref+==+other_five_ref);%0A++++%0A++++assert!(ptr::eq(five_ref,+same_five_ref));%0A++++assert!(!ptr::eq(five_ref,+other_five_ref));%0A%7D&amp;edition=2024"></a></div>
<p>For more information on how to use references, see <a href="../book/ch04-02-references-and-borrowing.html">the book’s section on “References and
Borrowing”</a>.</p>
<h2 id="trait-implementations-1"><a class="doc-anchor" href="#trait-implementations-1">§</a>Trait implementations</h2>
<p>The following traits are implemented for all <code>&amp;T</code>, regardless of the type of its referent:</p>
<ul>
<li><a href="marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a></li>
<li><a href="clone/trait.Clone.html" title="trait core::clone::Clone"><code>Clone</code></a> (Note that this will not defer to <code>T</code>’s <code>Clone</code> implementation if it exists!)</li>
<li><a href="ops/trait.Deref.html" title="trait core::ops::Deref"><code>Deref</code></a></li>
<li><a href="borrow/trait.Borrow.html" title="trait core::borrow::Borrow"><code>Borrow</code></a></li>
<li><a href="fmt/trait.Pointer.html" title="trait core::fmt::Pointer"><code>fmt::Pointer</code></a></li>
</ul>
<p><code>&amp;mut T</code> references get all of the above except <code>Copy</code> and <code>Clone</code> (to prevent creating
multiple simultaneous mutable borrows), plus the following, regardless of the type of its
referent:</p>
<ul>
<li><a href="ops/trait.DerefMut.html" title="trait core::ops::DerefMut"><code>DerefMut</code></a></li>
<li><a href="borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut"><code>BorrowMut</code></a></li>
</ul>
<p>The following traits are implemented on <code>&amp;T</code> references if the underlying <code>T</code> also implements
that trait:</p>
<ul>
<li>All the traits in <a href="fmt/index.html" title="mod core::fmt"><code>std::fmt</code></a> except <a href="fmt/trait.Pointer.html" title="trait core::fmt::Pointer"><code>fmt::Pointer</code></a> (which is implemented regardless of the type of its referent) and <a href="fmt/trait.Write.html" title="trait core::fmt::Write"><code>fmt::Write</code></a></li>
<li><a href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a></li>
<li><a href="cmp/trait.Ord.html" title="trait core::cmp::Ord"><code>Ord</code></a></li>
<li><a href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq"><code>PartialEq</code></a></li>
<li><a href="cmp/trait.Eq.html" title="trait core::cmp::Eq"><code>Eq</code></a></li>
<li><a href="convert/trait.AsRef.html" title="trait core::convert::AsRef"><code>AsRef</code></a></li>
<li><a href="ops/trait.Fn.html" title="trait core::ops::Fn"><code>Fn</code></a> (in addition, <code>&amp;T</code> references get <a href="ops/trait.FnMut.html" title="trait core::ops::FnMut"><code>FnMut</code></a> and <a href="ops/trait.FnOnce.html" title="trait core::ops::FnOnce"><code>FnOnce</code></a> if <code>T: Fn</code>)</li>
<li><a href="hash/trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a></li>
<li><a href="../std/net/trait.ToSocketAddrs.html"><code>ToSocketAddrs</code></a></li>
<li><a href="marker/trait.Sync.html" title="trait core::marker::Sync"><code>Sync</code></a></li>
</ul>
<p><code>&amp;mut T</code> references get all of the above except <code>ToSocketAddrs</code>, plus the following, if <code>T</code>
implements that trait:</p>
<ul>
<li><a href="convert/trait.AsMut.html" title="trait core::convert::AsMut"><code>AsMut</code></a></li>
<li><a href="ops/trait.FnMut.html" title="trait core::ops::FnMut"><code>FnMut</code></a> (in addition, <code>&amp;mut T</code> references get <a href="ops/trait.FnOnce.html" title="trait core::ops::FnOnce"><code>FnOnce</code></a> if <code>T: FnMut</code>)</li>
<li><a href="fmt/trait.Write.html" title="trait core::fmt::Write"><code>fmt::Write</code></a></li>
<li><a href="iter/trait.Iterator.html" title="trait core::iter::Iterator"><code>Iterator</code></a></li>
<li><a href="iter/trait.DoubleEndedIterator.html" title="trait core::iter::DoubleEndedIterator"><code>DoubleEndedIterator</code></a></li>
<li><a href="iter/trait.ExactSizeIterator.html" title="trait core::iter::ExactSizeIterator"><code>ExactSizeIterator</code></a></li>
<li><a href="iter/trait.FusedIterator.html" title="trait core::iter::FusedIterator"><code>FusedIterator</code></a></li>
<li><a href="iter/trait.TrustedLen.html" title="trait core::iter::TrustedLen"><code>TrustedLen</code></a></li>
<li><a href="marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a></li>
<li><a href="../std/io/trait.Write.html"><code>io::Write</code></a></li>
<li><a href="../std/io/trait.Read.html"><code>Read</code></a></li>
<li><a href="../std/io/trait.Seek.html"><code>Seek</code></a></li>
<li><a href="../std/io/trait.BufRead.html"><code>BufRead</code></a></li>
</ul>
<p>In addition, <code>&amp;T</code> references implement <a href="marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a> if and only if <code>T</code> implements <a href="marker/trait.Sync.html" title="trait core::marker::Sync"><code>Sync</code></a>.</p>
<p>Note that due to method call deref coercion, simply calling a trait method will act like they
work on references as well as they do on owned values! The implementations described here are
meant for generic contexts, where the final type <code>T</code> is a type parameter or otherwise not
locally known.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>For all types, <code>T: ?Sized</code>, and for all <code>t: &amp;T</code> or <code>t: &amp;mut T</code>, when such values cross an API
boundary, the following invariants must generally be upheld:</p>
<ul>
<li><code>t</code> is non-null</li>
<li><code>t</code> is aligned to <code>align_of_val(t)</code></li>
<li>if <code>size_of_val(t) &gt; 0</code>, then <code>t</code> is dereferenceable for <code>size_of_val(t)</code> many bytes</li>
</ul>
<p>If <code>t</code> points at address <code>a</code>, being “dereferenceable” for N bytes means that the memory range
<code>[a, a + N)</code> is all contained within a single <a href="ptr/index.html#allocation" title="mod core::ptr">allocation</a>.</p>
<p>For instance, this means that unsafe code in a safe function may assume these invariants are
ensured of arguments passed by the caller, and it may assume that these invariants are ensured
of return values from any safe functions it calls.</p>
<p>For the other direction, things are more complicated: when unsafe code passes arguments
to safe functions or returns values from safe functions, they generally must <em>at least</em>
not violate these invariants. The full requirements are stronger, as the reference generally
must point to data that is safe to use as type <code>T</code>.</p>
<p>It is not decided yet whether unsafe code may violate these invariants temporarily on internal
data. As a consequence, unsafe code which violates these invariants temporarily on internal data
may be unsound or become unsound in future versions of Rust depending on how this question is
decided.</p>
</div></details><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26B%3E-for-%26A" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#2109-2121">Source</a></span><a href="#impl-PartialEq%3C%26B%3E-for-%26A" class="anchor">§</a><h3 class="code-header">impl&lt;A, B: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;B</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;A</a><div class="where">where
    A: <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2114-2116">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2118-2120">Source</a><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26B%3E-for-%26mut+A" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#2273-2285">Source</a></span><a href="#impl-PartialEq%3C%26B%3E-for-%26mut+A" class="anchor">§</a><h3 class="code-header">impl&lt;A, B: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;B</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;mut A</a><div class="where">where
    A: <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2278-2280">Source</a><a href="#method.eq-3" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2282-2284">Source</a><a href="#method.ne-3" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26mut+B%3E-for-%26A" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#2257-2269">Source</a></span><a href="#impl-PartialEq%3C%26mut+B%3E-for-%26A" class="anchor">§</a><h3 class="code-header">impl&lt;A, B: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;A</a><div class="where">where
    A: <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2262-2264">Source</a><a href="#method.eq-2" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2266-2268">Source</a><a href="#method.ne-2" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26mut+B%3E-for-%26mut+A" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#2184-2196">Source</a></span><a href="#impl-PartialEq%3C%26mut+B%3E-for-%26mut+A" class="anchor">§</a><h3 class="code-header">impl&lt;A, B: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;mut A</a><div class="where">where
    A: <a class="trait" href="cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2189-2191">Source</a><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2193-2195">Source</a><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C%26B%3E-for-%26A" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#2124-2164">Source</a></span><a href="#impl-PartialOrd%3C%26B%3E-for-%26A" class="anchor">§</a><h3 class="code-header">impl&lt;A, B: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;B</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;A</a><div class="where">where
    A: <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;B&gt; + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2129-2131">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2133-2135">Source</a><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2137-2139">Source</a><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2141-2143">Source</a><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2145-2147">Source</a><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C%26mut+B%3E-for-%26mut+A" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/143800" title="Tracking issue for const_cmp">unstable</a>)</span> · <a class="src" href="../src/core/cmp.rs.html#2199-2239">Source</a></span><a href="#impl-PartialOrd%3C%26mut+B%3E-for-%26mut+A" class="anchor">§</a><h3 class="code-header">impl&lt;A, B: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;mut A</a><div class="where">where
    A: <a class="trait" href="cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;B&gt; + <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2204-2206">Source</a><a href="#method.partial_cmp-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2208-2210">Source</a><a href="#method.lt-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2212-2214">Source</a><a href="#method.le-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2216-2218">Source</a><a href="#method.gt-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><a class="src rightside" href="../src/core/cmp.rs.html#2220-2222">Source</a><a href="#method.ge-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.reference.html">&amp;mut B</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><section id="impl-CoerceUnsized%3C%26U%3E-for-%26T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#55">Source</a><a href="#impl-CoerceUnsized%3C%26U%3E-for-%26T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, 'b: 'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'b T</a></h3></section><section id="impl-CoerceUnsized%3C%26U%3E-for-%26mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#45">Source</a><a href="#impl-CoerceUnsized%3C%26U%3E-for-%26mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, 'b: 'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'b mut T</a></h3></section><section id="impl-CoerceUnsized%3C%26mut+U%3E-for-%26mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#42">Source</a><a href="#impl-CoerceUnsized%3C%26mut+U%3E-for-%26mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait core::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a mut U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a mut T</a></h3></section><section id="impl-DispatchFromDyn%3C%26U%3E-for-%26T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#125">Source</a><a href="#impl-DispatchFromDyn%3C%26U%3E-for-%26T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait core::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a T</a></h3></section><section id="impl-DispatchFromDyn%3C%26mut+U%3E-for-%26mut+T" class="impl"><a class="src rightside" href="../src/core/ops/unsize.rs.html#128">Source</a><a href="#impl-DispatchFromDyn%3C%26mut+U%3E-for-%26mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a> + <a class="trait" href="marker/trait.Unsize.html" title="trait core::marker::Unsize">Unsize</a>&lt;U&gt;, U: <a class="trait" href="marker/trait.PointeeSized.html" title="trait core::marker::PointeeSized">PointeeSized</a>&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait core::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a mut U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a mut T</a></h3></section></div></section></div></main></body></html>