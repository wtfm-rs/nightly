<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The rustdoc book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-032533ff.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-818727da.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The rustdoc book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/rustdoc" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="what-is-rustdoc"><a class="header" href="#what-is-rustdoc">What is rustdoc?</a></h1>
<p>The standard Rust distribution ships with a tool called <code>rustdoc</code>. Its job is
to generate documentation for Rust projects. On a fundamental level, Rustdoc
takes as an argument either a crate root or a Markdown file, and produces HTML,
CSS, and JavaScript.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p>Let‚Äôs give it a try! Create a new project with Cargo:</p>
<pre><code class="language-bash">$ cargo new docs --lib
$ cd docs
</code></pre>
<p>In <code>src/lib.rs</code>, Cargo has generated some sample code. Delete
it and replace it with this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// foo is a function
fn foo() {}
<span class="boring">}</span></code></pre>
<p>Let‚Äôs run <code>rustdoc</code> on our code. To do so, we can call it with the path to
our crate root like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs
</code></pre>
<p>This will create a new directory, <code>doc</code>, with a website inside! In our case,
the main page is located in <code>doc/lib/index.html</code>. If you open that up in
a web browser, you will see a page with a search bar, and ‚ÄúCrate lib‚Äù at the
top, with no contents.</p>
<p>You can also use <code>cargo doc</code> to generate documentation for the whole project.
See <a href="#using-rustdoc-with-cargo">Using rustdoc with Cargo</a>.</p>
<h2 id="configuring-rustdoc"><a class="header" href="#configuring-rustdoc">Configuring rustdoc</a></h2>
<p>There are two problems with this: first, why does it
think that our crate is named ‚Äúlib‚Äù? Second, why does it not have any
contents?</p>
<p>The first problem is due to <code>rustdoc</code> trying to be helpful; like <code>rustc</code>,
it assumes that our crate‚Äôs name is the name of the file for the crate
root. To fix this, we can pass in a command-line flag:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --crate-name docs
</code></pre>
<p>Now, <code>doc/docs/index.html</code> will be generated, and the page says ‚ÄúCrate docs.‚Äù</p>
<p>For the second issue, it is because our function <code>foo</code> is not public; <code>rustdoc</code>
defaults to generating documentation for only public functions. If we change
our code‚Ä¶</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// foo is a function
pub fn foo() {}
<span class="boring">}</span></code></pre>
<p>‚Ä¶ and then re-run <code>rustdoc</code>:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --crate-name docs
</code></pre>
<p>We now have some generated documentation. Open up <code>doc/docs/index.html</code> and
check it out! It should show a link to the <code>foo</code> function‚Äôs page, which
is located at <code>doc/docs/fn.foo.html</code>. On that page, you‚Äôll see the ‚Äúfoo is
a function‚Äù we put inside the documentation comment in our crate.</p>
<h2 id="using-rustdoc-with-cargo"><a class="header" href="#using-rustdoc-with-cargo">Using rustdoc with Cargo</a></h2>
<p>Cargo also has integration with <code>rustdoc</code> to make it easier to generate
docs. Instead of the <code>rustdoc</code> command, we could have done this:</p>
<pre><code class="language-bash">$ cargo doc
</code></pre>
<p>If you want <code>cargo</code> to automatically open the generated documentation, you can use:</p>
<pre><code class="language-bash">$ cargo doc --open
</code></pre>
<p>Internally, <code>cargo doc</code> calls out to <code>rustdoc</code> like this:</p>
<pre><code class="language-bash">$ rustdoc --crate-name docs src/lib.rs -o &lt;path&gt;/docs/target/doc -L
dependency=&lt;path&gt;/docs/target/debug/deps
</code></pre>
<p>You can see this with <code>cargo doc --verbose</code>.</p>
<p>It generates the correct <code>--crate-name</code> for us, as well as pointing to
<code>src/lib.rs</code>. But what about those other arguments?</p>
<ul>
<li><code>-o</code> controls the <em>o</em>utput of our docs. Instead of a top-level
<code>doc</code> directory, notice that Cargo puts generated documentation under
<code>target</code>. That is the idiomatic place for generated files in Cargo projects.</li>
<li><code>-L</code> flag helps rustdoc find the dependencies your code relies on.
If our project used dependencies, we would get documentation for them as well!</li>
</ul>
<h2 id="outer-and-inner-documentation"><a class="header" href="#outer-and-inner-documentation">Outer and inner documentation</a></h2>
<p>The <code>///</code> syntax is used to document the item present after it.
That‚Äôs why it is called an outer documentation.
There is another syntax: <code>//!</code>, which is used to document the
item it is present inside. It is called an inner documentation.
It is often used when documenting the entire crate,
because nothing comes before it: it is the root of the crate.
So in order to document an entire crate, you need to use <code>//!</code> syntax.
For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! This is my first rust crate
<span class="boring">}</span></code></pre>
<p>When used in the crate root, it documents the item it is inside,
which is the crate itself.</p>
<p>For more information about the <code>//!</code> syntax, see <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#commenting-contained-items">the Book</a>.</p>
<h2 id="using-standalone-markdown-files"><a class="header" href="#using-standalone-markdown-files">Using standalone Markdown files</a></h2>
<p><code>rustdoc</code> can also generate HTML from standalone Markdown files. Let‚Äô s
give it a try: create a <code>README.md</code> file with these contents:</p>
<pre><code class="language-text"># Docs

This is a project to test out `rustdoc`.

[Here is a link!](https://www.rust-lang.org)

## Example

```rust
fn foo() -&gt; i32 {
    1 + 1
}
```
</code></pre>
<p>And call <code>rustdoc</code> on it:</p>
<pre><code class="language-bash">$ rustdoc README.md
</code></pre>
<p>You will find an HTML file in <code>docs/doc/README.html</code> generated from its
Markdown contents.</p>
<p>Cargo currently does not understand standalone Markdown files, unfortunately.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This covers the simplest use-cases of <code>rustdoc</code>. The rest of this book will
explain all of the options that <code>rustdoc</code> has, and how to use them.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command-line arguments</a></h1>
<p>Here‚Äôs the list of arguments you can pass to <code>rustdoc</code>:</p>
<h2 id="-h--help-help"><a class="header" href="#-h--help-help"><code>-h</code>/<code>--help</code>: help</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -h
$ rustdoc --help
</code></pre>
<p>This will show <code>rustdoc</code>‚Äôs built-in help, which largely consists of
a list of possible command-line flags.</p>
<p>Some of <code>rustdoc</code>‚Äôs flags are unstable; this page only shows stable
options, <code>--help</code> will show them all.</p>
<h2 id="-v--version-version-information"><a class="header" href="#-v--version-version-information"><code>-V</code>/<code>--version</code>: version information</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -V
$ rustdoc --version
</code></pre>
<p>This will show <code>rustdoc</code>‚Äôs version, which will look something
like this:</p>
<pre><code class="language-text">rustdoc 1.17.0 (56124baa9 2017-04-24)
</code></pre>
<h2 id="-v--verbose-more-verbose-output"><a class="header" href="#-v--verbose-more-verbose-output"><code>-v</code>/<code>--verbose</code>: more verbose output</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -v src/lib.rs
$ rustdoc --verbose src/lib.rs
</code></pre>
<p>This enables ‚Äúverbose mode‚Äù, which means that more information will be written
to standard out. What is written depends on the other flags you‚Äôve passed in.
For example, with <code>--version</code>:</p>
<pre><code class="language-text">$ rustdoc --verbose --version
rustdoc 1.17.0 (56124baa9 2017-04-24)
binary: rustdoc
commit-hash: hash
commit-date: date
host: host-tuple
release: 1.17.0
LLVM version: 3.9
</code></pre>
<h2 id="-o--out-dir-output-directory-path"><a class="header" href="#-o--out-dir-output-directory-path"><code>-o</code>/<code>--out-dir</code>: output directory path</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -o target/doc
$ rustdoc src/lib.rs --out-dir target/doc
</code></pre>
<p>By default, <code>rustdoc</code>‚Äôs output appears in a directory named <code>doc</code> in
the current working directory. With this flag, it will place all output
into the directory you specify.</p>
<h2 id="--crate-name-controlling-the-name-of-the-crate"><a class="header" href="#--crate-name-controlling-the-name-of-the-crate"><code>--crate-name</code>: controlling the name of the crate</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --crate-name mycrate
</code></pre>
<p>By default, <code>rustdoc</code> assumes that the name of your crate is the same name
as the <code>.rs</code> file. <code>--crate-name</code> lets you override this assumption with
whatever name you choose.</p>
<h2 id="--document-private-items-show-items-that-are-not-public"><a class="header" href="#--document-private-items-show-items-that-are-not-public"><code>--document-private-items</code>: Show items that are not public</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --document-private-items
</code></pre>
<p>By default, <code>rustdoc</code> only documents items that are publicly reachable.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn public() {} // this item is public and will be documented
mod private { // this item is private and will not be documented
    pub fn unreachable() {} // this item is public, but unreachable, so it will not be documented
}
<span class="boring">}</span></code></pre>
<p><code>--document-private-items</code> includes all non-public items in the generated documentation except for <code>#[doc(hidden)]</code> items.  Private items will be shown with a üîí icon.</p>
<h2 id="-l--library-path-where-to-look-for-dependencies"><a class="header" href="#-l--library-path-where-to-look-for-dependencies"><code>-L</code>/<code>--library-path</code>: where to look for dependencies</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -L target/debug/deps
$ rustdoc src/lib.rs --library-path target/debug/deps
</code></pre>
<p>If your crate has dependencies, <code>rustdoc</code> needs to know where to find them.
Passing <code>--library-path</code> gives <code>rustdoc</code> a list of places to look for these
dependencies.</p>
<p>This flag takes any number of directories as its argument, and will use all of
them when searching.</p>
<h2 id="--cfg-passing-configuration-flags"><a class="header" href="#--cfg-passing-configuration-flags"><code>--cfg</code>: passing configuration flags</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --cfg feature="foo"
</code></pre>
<p>This flag accepts the same values as <code>rustc --cfg</code>, and uses it to configure
compilation. The example above uses <code>feature</code>, but any of the <code>cfg</code> values
are acceptable.</p>
<h2 id="--check-cfg-check-configuration-flags"><a class="header" href="#--check-cfg-check-configuration-flags"><code>--check-cfg</code>: check configuration flags</a></h2>
<p>This flag accepts the same values as <code>rustc --check-cfg</code>, and uses it to
check configuration flags.</p>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --check-cfg='cfg(my_cfg, values("foo", "bar"))'
</code></pre>
<p>The example above check every well known names and values (<code>target_os</code>, <code>doc</code>, <code>test</code>, ‚Ä¶)
and check the values of <code>my_cfg</code>: <code>foo</code> and <code>bar</code>.</p>
<h2 id="--extern-specify-a-dependencys-location"><a class="header" href="#--extern-specify-a-dependencys-location"><code>--extern</code>: specify a dependency‚Äôs location</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --extern lazy-static=/path/to/lazy-static
</code></pre>
<p>Similar to <code>--library-path</code>, <code>--extern</code> is about specifying the location
of a dependency. <code>--library-path</code> provides directories to search in, <code>--extern</code>
instead lets you specify exactly which dependency is located where.</p>
<h2 id="-c--codegen-pass-codegen-options-to-rustc"><a class="header" href="#-c--codegen-pass-codegen-options-to-rustc"><code>-C</code>/<code>--codegen</code>: pass codegen options to rustc</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -C target_feature=+avx
$ rustdoc src/lib.rs --codegen target_feature=+avx

$ rustdoc --test src/lib.rs -C target_feature=+avx
$ rustdoc --test src/lib.rs --codegen target_feature=+avx

$ rustdoc --test README.md -C target_feature=+avx
$ rustdoc --test README.md --codegen target_feature=+avx
</code></pre>
<p>When rustdoc generates documentation, looks for documentation tests, or executes documentation
tests, it needs to compile some rust code, at least part-way. This flag allows you to tell rustdoc
to provide some extra codegen options to rustc when it runs these compilations. Most of the time,
these options won‚Äôt affect a regular documentation run, but if something depends on target features
to be enabled, or documentation tests need to use some additional options, this flag allows you to
affect that.</p>
<p>The arguments to this flag are the same as those for the <code>-C</code> flag on rustc. Run <code>rustc -C help</code> to
get the full list.</p>
<h2 id="--test-run-code-examples-as-tests"><a class="header" href="#--test-run-code-examples-as-tests"><code>--test</code>: run code examples as tests</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test
</code></pre>
<p>This flag will run your code examples as tests. For more, see <a href="#documentation-tests">the chapter
on documentation tests</a>.</p>
<p>See also <code>--test-args</code> and <code>--test-run-directory</code>.</p>
<h2 id="--test-args-pass-options-to-test-runner"><a class="header" href="#--test-args-pass-options-to-test-runner"><code>--test-args</code>: pass options to test runner</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test --test-args ignored
</code></pre>
<p>This flag will pass options to the test runner when running documentation tests.
For more, see <a href="#documentation-tests">the chapter on documentation tests</a>.</p>
<p>See also <code>--test</code>.</p>
<h2 id="--test-run-directory-run-code-examples-in-a-specific-directory"><a class="header" href="#--test-run-directory-run-code-examples-in-a-specific-directory"><code>--test-run-directory</code>: run code examples in a specific directory</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test --test-run-directory=/path/to/working/directory
</code></pre>
<p>This flag will run your code examples in the specified working directory.
For more, see <a href="#documentation-tests">the chapter on documentation tests</a>.</p>
<p>See also <code>--test</code>.</p>
<h2 id="--test-runtool---test-runtool-arg-program-to-run-tests-with-args-to-pass-to-it"><a class="header" href="#--test-runtool---test-runtool-arg-program-to-run-tests-with-args-to-pass-to-it"><code>--test-runtool</code>, <code>--test-runtool-arg</code>: program to run tests with; args to pass to it</a></h2>
<p>A doctest wrapper program can be specified with the <code>--test-runtool</code> flag.
Rustdoc will execute that wrapper instead of the doctest executable when
running tests. The first arguments to the wrapper will be any arguments
specified with the <code>--test-runtool-arg</code> flag, followed by the path to the
doctest executable to run.</p>
<p>Using these options looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test-runtool path/to/runner --test-runtool-arg --do-thing --test-runtool-arg --do-other-thing
</code></pre>
<p>For example, if you want to run your doctests under valgrind you might run:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test-runtool valgrind
</code></pre>
<p>Another use case would be to run a test inside an emulator, or through a Virtual Machine.</p>
<h2 id="--target-generate-documentation-for-the-specified-target-triple"><a class="header" href="#--target-generate-documentation-for-the-specified-target-triple"><code>--target</code>: generate documentation for the specified target triple</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --target x86_64-pc-windows-gnu
</code></pre>
<p>Similar to the <code>--target</code> flag for <code>rustc</code>, this generates documentation
for a target triple that‚Äôs different than your host triple.</p>
<p>All of the usual caveats of cross-compiling code apply.</p>
<h2 id="--default-theme-set-the-default-theme"><a class="header" href="#--default-theme-set-the-default-theme"><code>--default-theme</code>: set the default theme</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --default-theme=ayu
</code></pre>
<p>Sets the default theme (for users whose browser has not remembered a
previous theme selection from the on-page theme picker).</p>
<p>The supplied value should be the lowercase version of the theme name.
The set of available themes can be seen in the theme picker in the
generated output.</p>
<p>Note that the set of available themes - and their appearance - is not
necessarily stable from one rustdoc version to the next.  If the
requested theme does not exist, the builtin default (currently
<code>light</code>) is used instead.</p>
<h2 id="--markdown-css-include-more-css-files-when-rendering-markdown"><a class="header" href="#--markdown-css-include-more-css-files-when-rendering-markdown"><code>--markdown-css</code>: include more CSS files when rendering markdown</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc README.md --markdown-css foo.css
</code></pre>
<p>When rendering Markdown files, this will create a <code>&lt;link&gt;</code> element in the
<code>&lt;head&gt;</code> section of the generated HTML. For example, with the invocation above,</p>
<pre><code class="language-html">&lt;link rel="stylesheet" type="text/css" href="foo.css"&gt;
</code></pre>
<p>will be added.</p>
<p>When rendering Rust files, this flag is ignored.</p>
<h2 id="--html-in-header-include-more-html-in-head"><a class="header" href="#--html-in-header-include-more-html-in-head"><code>--html-in-header</code>: include more HTML in <code>&lt;head&gt;</code></a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --html-in-header header.html
$ rustdoc README.md --html-in-header header.html
</code></pre>
<p>This flag takes a list of files, and inserts them into the <code>&lt;head&gt;</code> section of
the rendered documentation.</p>
<h2 id="--html-before-content-include-more-html-before-the-content"><a class="header" href="#--html-before-content-include-more-html-before-the-content"><code>--html-before-content</code>: include more HTML before the content</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --html-before-content extra.html
$ rustdoc README.md --html-before-content extra.html
</code></pre>
<p>This flag takes a list of files, and inserts them inside the <code>&lt;body&gt;</code> tag but
before the other content <code>rustdoc</code> would normally produce in the rendered
documentation.</p>
<h2 id="--html-after-content-include-more-html-after-the-content"><a class="header" href="#--html-after-content-include-more-html-after-the-content"><code>--html-after-content</code>: include more HTML after the content</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --html-after-content extra.html
$ rustdoc README.md --html-after-content extra.html
</code></pre>
<p>This flag takes a list of files, and inserts them before the <code>&lt;/body&gt;</code> tag but
after the other content <code>rustdoc</code> would normally produce in the rendered
documentation.</p>
<h2 id="--markdown-playground-url-control-the-location-of-the-playground"><a class="header" href="#--markdown-playground-url-control-the-location-of-the-playground"><code>--markdown-playground-url</code>: control the location of the playground</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc README.md --markdown-playground-url https://play.rust-lang.org/
</code></pre>
<p>When rendering a Markdown file, this flag gives the base URL of the Rust
Playground, to use for generating <code>Run</code> buttons.</p>
<h2 id="--markdown-no-toc-dont-generate-a-table-of-contents"><a class="header" href="#--markdown-no-toc-dont-generate-a-table-of-contents"><code>--markdown-no-toc</code>: don‚Äôt generate a table of contents</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc README.md --markdown-no-toc
</code></pre>
<p>When generating documentation from a Markdown file, by default, <code>rustdoc</code> will
generate a table of contents. This flag suppresses that, and no TOC will be
generated.</p>
<h2 id="-e--extend-css-extend-rustdocs-css"><a class="header" href="#-e--extend-css-extend-rustdocs-css"><code>-e</code>/<code>--extend-css</code>: extend rustdoc‚Äôs CSS</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -e extra.css
$ rustdoc src/lib.rs --extend-css extra.css
</code></pre>
<p>With this flag, the contents of the files you pass are included at the bottom
of the <code>theme.css</code> file.</p>
<h2 id="--sysroot-override-the-system-root"><a class="header" href="#--sysroot-override-the-system-root"><code>--sysroot</code>: override the system root</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --sysroot /path/to/sysroot
</code></pre>
<p>Similar to <code>rustc --sysroot</code>, this lets you change the sysroot <code>rustdoc</code> uses
when compiling your code.</p>
<h2 id="--edition-control-the-edition-of-docs-and-doctests"><a class="header" href="#--edition-control-the-edition-of-docs-and-doctests"><code>--edition</code>: control the edition of docs and doctests</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --edition 2018
$ rustdoc --test src/lib.rs --edition 2018
</code></pre>
<p>This flag allows <code>rustdoc</code> to treat your rust code as the given edition. It will compile doctests with
the given edition as well. As with <code>rustc</code>, the default edition that <code>rustdoc</code> will use is <code>2015</code>
(the first edition).</p>
<h2 id="--theme-add-a-theme-to-the-documentation-output"><a class="header" href="#--theme-add-a-theme-to-the-documentation-output"><code>--theme</code>: add a theme to the documentation output</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --theme /path/to/your/custom-theme.css
</code></pre>
<p><code>rustdoc</code>‚Äôs default output includes two themes: <code>light</code> (the default) and
<code>dark</code>. This flag allows you to add custom themes to the output. Giving a CSS
file to this flag adds it to your documentation as an additional theme choice.
The theme‚Äôs name is determined by its filename; a theme file named
<code>custom-theme.css</code> will add a theme named <code>custom-theme</code> to the documentation.</p>
<h2 id="--check-theme-verify-custom-themes-against-the-default-theme"><a class="header" href="#--check-theme-verify-custom-themes-against-the-default-theme"><code>--check-theme</code>: verify custom themes against the default theme</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc --check-theme /path/to/your/custom-theme.css
</code></pre>
<p>While <code>rustdoc</code>‚Äôs HTML output is more-or-less consistent between versions, there
is no guarantee that a theme file will have the same effect. The <code>--theme</code> flag
will still allow you to add the theme to your documentation, but to ensure that
your theme works as expected, you can use this flag to verify that it implements
the same CSS rules as the official <code>light</code> theme.</p>
<p><code>--check-theme</code> is a separate mode in <code>rustdoc</code>. When <code>rustdoc</code> sees the
<code>--check-theme</code> flag, it discards all other flags and only performs the CSS rule
comparison operation.</p>
<h2 id="--crate-version-control-the-crate-version"><a class="header" href="#--crate-version-control-the-crate-version"><code>--crate-version</code>: control the crate version</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --crate-version 1.3.37
</code></pre>
<p>When <code>rustdoc</code> receives this flag, it will print an extra ‚ÄúVersion (version)‚Äù into the sidebar of
the crate root‚Äôs docs. You can use this flag to differentiate between different versions of your
library‚Äôs documentation.</p>
<h2 id="--load-source-code-from-the-standard-input"><a class="header" href="#--load-source-code-from-the-standard-input"><code>-</code>: load source code from the standard input</a></h2>
<p>If you specify <code>-</code> as the INPUT on the command line, then <code>rustdoc</code> will read the
source code from stdin (standard input stream) until the EOF, instead of the file
system with an otherwise specified path.</p>
<h2 id="path-load-command-line-flags-from-a-path"><a class="header" href="#path-load-command-line-flags-from-a-path"><code>@path</code>: load command-line flags from a path</a></h2>
<p>If you specify <code>@path</code> on the command-line, then it will open <code>path</code> and read
command line options from it. These options are one per line; a blank line indicates
an empty option. The file can use Unix or Windows style line endings, and must be
encoded as UTF-8.</p>
<h2 id="--passes-add-more-rustdoc-passes"><a class="header" href="#--passes-add-more-rustdoc-passes"><code>--passes</code>: add more rustdoc passes</a></h2>
<p>This flag is <strong>deprecated</strong>.
For more details on passes, see <a href="#passes">the chapter on them</a>.</p>
<h2 id="--no-defaults-dont-run-default-passes"><a class="header" href="#--no-defaults-dont-run-default-passes"><code>--no-defaults</code>: don‚Äôt run default passes</a></h2>
<p>This flag is <strong>deprecated</strong>.
For more details on passes, see <a href="#passes">the chapter on them</a>.</p>
<h2 id="-r--input-format-input-format"><a class="header" href="#-r--input-format-input-format"><code>-r</code>/<code>--input-format</code>: input format</a></h2>
<p>This flag is <strong>deprecated</strong> and <strong>has no effect</strong>.</p>
<p>Rustdoc only supports Rust source code and Markdown input formats. If the
file ends in <code>.md</code> or <code>.markdown</code>, <code>rustdoc</code> treats it as a Markdown file.
Otherwise, it assumes that the input file is Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-to-read-rustdoc-output"><a class="header" href="#how-to-read-rustdoc-output">How to read rustdoc output</a></h1>
<p>Rustdoc‚Äôs HTML output includes a friendly and useful navigation interface which
makes it easier for users to navigate and understand your code.
This chapter covers the major features of that interface,
and is a great starting point for documentation authors and users alike.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The <code>rustdoc</code> output is divided into three sections.
Along the left side of each page is a quick navigation bar,
which shows contextual information about the current entry.
The rest of the page is taken up by the search interface at the top
and the documentation for the current item below that.</p>
<h2 id="the-item-documentation"><a class="header" href="#the-item-documentation">The Item Documentation</a></h2>
<p>The majority of the screen is taken up with the documentation text for the item
currently being viewed.
At the top is some at-a-glance info and controls:</p>
<ul>
<li>the type and name of the item,
such as ‚ÄúStruct <code>std::time::Duration</code>‚Äù,</li>
<li>a button to copy the item‚Äôs path to the clipboard,
which is a clipboard item</li>
<li>a button to collapse or expand the top-level documentation for that item
(<code>[+]</code> or <code>[-]</code>),</li>
<li>a link to the source code (<code>[src]</code>),
if <a href="#html_no_source">configured</a>,
and present (the source may not be available if
the documentation was created with <code>cargo doc --no-deps</code>),</li>
<li>and the version in which the item became stable,
if it‚Äôs a stable item in the standard library.</li>
</ul>
<p>Below this is the main documentation for the item,
including a definition or function signature if appropriate,
followed by a list of fields or variants for Rust types.
Finally, the page lists associated functions and trait implementations,
including automatic and blanket implementations that <code>rustdoc</code> knows about.</p>
<h3 id="sections"><a class="header" href="#sections">Sections</a></h3>
<!-- FIXME: Implementations -->
<!-- FIXME: Trait Implementations -->
<!-- FIXME: Implementors -->
<!-- FIXME: Auto Trait Implementations -->
<h4 id="aliased-type"><a class="header" href="#aliased-type">Aliased Type</a></h4>
<p>A type alias is expanded at compile time to its
<a href="https://doc.rust-lang.org/reference/items/type-aliases.html">aliased type</a>.
That may involve substituting some or all of the type parameters in the target
type with types provided by the type alias definition. The Aliased Type section
shows the result of this expansion, including the types of public fields or
variants, which may depend on those substitutions.</p>
<h3 id="navigation"><a class="header" href="#navigation">Navigation</a></h3>
<p>Subheadings, variants, fields, and many other things in this documentation
are anchors and can be clicked on and deep-linked to,
which is a great way to communicate exactly what you‚Äôre talking about.
The typographical character ‚Äú¬ß‚Äù appears next to lines with anchors on them
when hovered or given keyboard focus.</p>
<h2 id="the-navigation-bar"><a class="header" href="#the-navigation-bar">The Navigation Bar</a></h2>
<p>For example, when looking at documentation for the crate root,
it shows all the crates documented in the documentation bundle,
and quick links to the modules, structs, traits, functions, and macros available
from the current crate.
At the top, it displays a <a href="#html_logo_url">configurable logo</a>
alongside the current crate‚Äôs name and version,
or the current item whose documentation is being displayed.</p>
<h2 id="the-theme-picker-and-search-interface"><a class="header" href="#the-theme-picker-and-search-interface">The Theme Picker and Search Interface</a></h2>
<p>When viewing <code>rustdoc</code>‚Äôs output in a browser with JavaScript enabled,
a dynamic interface appears at the top of the page composed of the <a href="#rustdoc-search">search</a>
interface, help screen, and <a href="#rustdoc-in-doc-settings">options</a>.</p>
<p>Paths are supported as well, you can look for <code>Vec::new</code> or <code>Option::Some</code> or
even <code>module::module_child::another_child::struct::field</code>. Whitespace characters
are considered the same as <code>::</code>, so if you write <code>Vec    new</code>, it will be
considered the same as <code>Vec::new</code>.</p>
<h3 id="shortcuts"><a class="header" href="#shortcuts">Shortcuts</a></h3>
<p>Pressing <code>S</code> while focused elsewhere on the page will move focus to the
search bar, and pressing <code>?</code> shows the help screen,
which includes all these shortcuts and more.</p>
<p>When the search results are focused,
the left and right arrows move between tabs and the up and down arrows move
among the results.
Pressing the enter or return key opens the highlighted result.</p>
<p>When looking at the documentation for an item, the plus and minus keys expand
and collapse all sections in the document.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustdoc-in-doc-settings"><a class="header" href="#rustdoc-in-doc-settings">Rustdoc in-doc settings</a></h1>
<p>Rustdoc‚Äôs HTML output includes a settings menu, and this chapter describes what
each setting in this menu does.</p>
<p>It can be accessed by clicking on the gear button
(<span class="fa-svg" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336c44.2 0 80-35.8 80-80s-35.8-80-80-80s-80 35.8-80 80s35.8 80 80 80z"/></svg></span>) in the upper right.</p>
<h2 id="changing-displayed-theme"><a class="header" href="#changing-displayed-theme">Changing displayed theme</a></h2>
<p>It is possible to change the theme. If you pick the ‚Äúsystem preference‚Äù, you
will be able to see two new sub-menus: ‚ÄúPreferred light theme‚Äù and ‚ÄúPreferred
dark theme‚Äù. It means that if your system preference is set to ‚Äúlight‚Äù, then
rustdoc will use the theme you selected in ‚ÄúPreferred light theme‚Äù.</p>
<h2 id="auto-hide-item-contents-for-large-items"><a class="header" href="#auto-hide-item-contents-for-large-items">Auto-hide item contents for large items</a></h2>
<p>If the type definition contains more than 12 items, and this setting is enabled,
it‚Äôll collapse them by default. You can see them by clicking on the <code>[+]</code> button
to expand them.</p>
<p>A good example of this setting in use can be seen in the
<a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>Iterator</code></a> doc
page:</p>
<p><img src="images/collapsed-long-item.png" alt="Collapsed long item"></p>
<h2 id="auto-hide-item-methods-documentation"><a class="header" href="#auto-hide-item-methods-documentation">Auto-hide item methods‚Äô documentation</a></h2>
<p>If enabled, this setting will collapse all trait implementations blocks. It is
convenient if you just want an overview of all the methods available. You can
still see a method‚Äôs documentation by expanding it.</p>
<h2 id="auto-hide-trait-implementation-documentation"><a class="header" href="#auto-hide-trait-implementation-documentation">Auto-hide trait implementation documentation</a></h2>
<p>If enabled, this setting will collapse all trait implementations blocks (you can
see them in the ‚ÄúTrait Implementations‚Äù section). It is convenient if you just
want an overview of all the trait implemented on a type. You can still see
a trait implementation‚Äôs associated items by expanding it.</p>
<p>Example:</p>
<p><img src="images/collapsed-trait-impls.png" alt="Collapsed trait implementations"></p>
<h2 id="directly-go-to-item-in-search-if-there-is-only-one-result"><a class="header" href="#directly-go-to-item-in-search-if-there-is-only-one-result">Directly go to item in search if there is only one result</a></h2>
<p>If this setting is enabled, you will directly be taken to the result page if
your search only returned one element. Useful if you know exactly what you‚Äôre
looking for and want to be taken there directly and not waste time selecting the
only search result.</p>
<h2 id="show-line-numbers-on-code-examples"><a class="header" href="#show-line-numbers-on-code-examples">Show line numbers on code examples</a></h2>
<p>If enabled, this setting will add line numbers to the code examples in the
documentation. It provides a visual aide for the code reading.</p>
<h2 id="disable-keyboard-shortcuts"><a class="header" href="#disable-keyboard-shortcuts">Disable keyboard shortcuts</a></h2>
<p>If this setting is enabled, the keyboard shortcuts will be disabled. It‚Äôs useful
in case some of these shortcuts are already used by a web extension you‚Äôre
using.</p>
<p>To see the full list of the rustdoc keyboard shortcuts, you can open the help
menu (the button with the question mark on the left of the setting menu button).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustdoc-search"><a class="header" href="#rustdoc-search">Rustdoc search</a></h1>
<p>Typing in the search bar instantly searches the available documentation,
matching either the name and path of an item, or a function‚Äôs approximate
type signature.</p>
<h2 id="search-by-name"><a class="header" href="#search-by-name">Search By Name</a></h2>
<p>To search by the name of an item (items include modules, types, traits,
functions, and macros), write its name or path. As a special case, the parts
of a path that normally get divided by <code>::</code> double colons can instead be
separated by spaces. For example:</p>
<ul>
<li><a href="../std/vec/struct.Vec.html?search=vec%20new&amp;filter-crate=std"><code>vec new</code></a> and <a href="../std/vec/struct.Vec.html?search=vec::new&amp;filter-crate=std"><code>vec::new</code></a> both show the function <code>std::vec::Vec::new</code>
as a result.</li>
<li><a href="../std/vec/struct.Vec.html?search=vec&amp;filter-crate=std"><code>vec</code></a>, <a href="../std/vec/struct.Vec.html?search=vec%20vec&amp;filter-crate=std"><code>vec vec</code></a>, <a href="../std/vec/struct.Vec.html?search=std::vec&amp;filter-crate=std"><code>std::vec</code></a>, and <a href="../std/vec/struct.Vec.html?search=std::vec::Vec&amp;filter-crate=std"><code>std::vec::Vec</code></a> all include the struct
<code>std::vec::Vec</code> itself in the results (and all but the last one also
include the module in the results).</li>
</ul>
<p>As a quick way to trim down the list of results, there‚Äôs a drop-down selector
below the search input, labeled ‚ÄúResults in [std]‚Äù. Clicking it can change
which crate is being searched.</p>
<p>Rustdoc uses a fuzzy matching function that can tolerate typos for this,
though it‚Äôs based on the length of the name that‚Äôs typed in, so a good example
of how this works would be <a href="../std/collections/struct.HashMap.html?search=HahsMap&amp;filter-crate=std"><code>HahsMap</code></a>. To avoid this, wrap the item in quotes,
searching for <code>"HahsMap"</code> (in this example, no results will be returned).</p>
<h3 id="tabs-in-the-search-by-name-interface"><a class="header" href="#tabs-in-the-search-by-name-interface">Tabs in the Search By Name interface</a></h3>
<p>In fact, using <a href="../std/collections/struct.HashMap.html?search=HahsMap&amp;filter-crate=std"><code>HahsMap</code></a> again as the example, it tells you that you‚Äôre
using ‚ÄúIn Names‚Äù by default, but also lists two other tabs below the crate
drop-down: ‚ÄúIn Parameters‚Äù and ‚ÄúIn Return Types‚Äù.</p>
<p>These two tabs are lists of functions, defined on the closest matching type
to the search (for <code>HahsMap</code>, it loudly auto-corrects to <code>hashmap</code>). This
auto-correct only kicks in if nothing is found that matches the literal.</p>
<p>These tabs are not just methods. For example, searching the alloc crate for
<a href="../alloc/index.html?search=Layout&amp;filter-crate=alloc"><code>Layout</code></a> also lists functions that accept layouts even though they‚Äôre
methods on the allocator or free functions.</p>
<h2 id="searching-by-type-signature"><a class="header" href="#searching-by-type-signature">Searching By Type Signature</a></h2>
<p>If you know more specifically what the function you want to look at does,
or you want to know how to get from one type to another,
Rustdoc can search by more than one type at once in the parameters and return
value. Multiple parameters are separated by <code>,</code> commas, and the return value
is written with after a <code>-&gt;</code> arrow.</p>
<p>Before describing the syntax in more detail, here‚Äôs a few sample searches of
the standard library and functions that are included in the results list:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Query</th><th>Results</th></tr>
</thead>
<tbody>
<tr><td><a href="../std/vec/struct.Vec.html?search=usize%20-%3E%20vec&amp;filter-crate=std"><code>usize -&gt; vec</code></a></td><td><code>slice::repeat</code> and <code>Vec::with_capacity</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=vec,%20vec%20-%3E%20bool&amp;filter-crate=std"><code>vec, vec -&gt; bool</code></a></td><td><code>Vec::eq</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=option&lt;T&gt;%2C%20fnonce%20-&gt;%20option&lt;U&gt;&amp;filter-crate=std"><code>option&lt;T&gt;, fnonce -&gt; option&lt;U&gt;</code></a></td><td><code>Option::map</code> and <code>Option::and_then</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=option&lt;T&gt;%2C+(fnonce+(T)+-&gt;+bool)+-&gt;+option&lt;T&gt;&amp;filter-crate=std"><code>option&lt;T&gt;, (fnonce (T) -&gt; bool) -&gt; option&lt;T&gt;</code></a></td><td><code>Option::filter</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=option&lt;T&gt;%2C+(T+-&gt;+bool)+-&gt;+option&lt;T&gt;&amp;filter-crate=std"><code>option&lt;T&gt;, (T -&gt; bool) -&gt; option&lt;T&gt;</code></a></td><td><code>Option::filter</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=option%20-%3E%20default&amp;filter-crate=std"><code>option -&gt; default</code></a></td><td><code>Option::unwrap_or_default</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=stdout%2C%20[u8]&amp;filter-crate=std"><code>stdout, [u8]</code></a></td><td><code>Stdout::write</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=any%20-%3E%20!&amp;filter-crate=std"><code>any -&gt; !</code></a></td><td><code>panic::panic_any</code></td></tr>
<tr><td><a href="../std/vec/struct.Vec.html?search=vec%3A%3Aintoiter&lt;T&gt;%20-&gt;%20[T]&amp;filter-crate=std"><code>vec::intoiter&lt;T&gt; -&gt; [T]</code></a></td><td><code>IntoIter::as_slice</code> and <code>IntoIter::next_chunk</code></td></tr>
<tr><td><a href="../std/index.html?search=iterator&lt;T&gt;%2C%20fnmut%20-&gt;%20T&amp;filter-crate=std"><code>iterator&lt;T&gt;, fnmut -&gt; T</code></a></td><td><code>Iterator::reduce</code> and <code>Iterator::find</code></td></tr>
</tbody>
</table>
</div>
<h3 id="non-functions-in-type-based-search"><a class="header" href="#non-functions-in-type-based-search">Non-functions in type-based search</a></h3>
<p>Certain items that are not functions are treated as though they
were a semantically equivalent function.</p>
<p>For example, struct fields are treated as though they were getter methods.
This means that a search for <code>CpuidResult -&gt; u32</code> will show
the <code>CpuidResult::eax</code> field in the results.</p>
<p>Additionally, <code>const</code> and <code>static</code> items are treated as nullary functions,
so <code>-&gt; u32</code> will match <code>u32::MAX</code>.</p>
<h3 id="how-type-based-search-works"><a class="header" href="#how-type-based-search-works">How type-based search works</a></h3>
<p>In a complex type-based search, Rustdoc always treats every item‚Äôs name as literal.
If a name is used and nothing in the docs matches the individual item, such as
a typo-ed <a href="../std/vec/struct.Vec.html?search=uize%20-%3E%20vec&amp;filter-crate=std"><code>uize -&gt; vec</code></a> search, the item <code>uize</code> is treated as a generic
type parameter (resulting in <code>vec::from</code> and other generic vec constructors).</p>
<p>After deciding which items are type parameters and which are actual types, it
then searches by matching up the function parameters (written before the <code>-&gt;</code>)
and the return types (written after the <code>-&gt;</code>). Type matching is order-agnostic,
and allows items to be left out of the query, but items that are present in the
query must be present in the function for it to match. The <code>self</code> parameter is
treated the same as any other parameter, and <code>Self</code> is resolved to the
underlying type‚Äôs name.</p>
<p>Function signature searches can query generics, wrapped in angle brackets, and
traits will be normalized like types in the search engine if no type parameters
match them. For example, a function with the signature
<code>fn my_function&lt;I: Iterator&lt;Item=u32&gt;&gt;(input: I) -&gt; usize</code>
can be matched with the following queries:</p>
<ul>
<li><code>Iterator&lt;Item=u32&gt; -&gt; usize</code></li>
<li><code>Iterator&lt;u32&gt; -&gt; usize</code> (you can leave out the <code>Item=</code> part)</li>
<li><code>Iterator -&gt; usize</code> (you can leave out iterator‚Äôs generic entirely)</li>
<li><code>T -&gt; usize</code> (you can match with a generic parameter)</li>
</ul>
<p>Each of the above queries is progressively looser, except the last one
would not match <code>dyn Iterator</code>, since that‚Äôs not a type parameter.</p>
<p>If a bound has multiple associated types, specifying the name allows you to
pick which one gets matched. If no name is specified, then the query will
match of any of them. For example,</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {
    type First;
    type Second;
}

/// This function can be found using the following search queries:
///
///     MyTrait&lt;First=u8, Second=u32&gt; -&gt; bool
///     MyTrait&lt;Second=u32&gt; -&gt; bool
///
/// The following queries, however, will *not* match it:
///
///     MyTrait&lt;First=u32&gt; -&gt; bool
///     MyTrait&lt;u32, u32&gt; -&gt; bool
///     MyTrait&lt;u32, First=u8&gt; -&gt; bool
///     MyTrait&lt;u32, u8&gt; -&gt; bool
pub fn my_fn(x: impl MyTrait&lt;First=u8, Second=u32&gt;) -&gt; bool { true }
<span class="boring">}</span></code></pre>
<p>Function parameters are order-agnostic, but sensitive to nesting
and number of matches. For example, a function with the signature
<code>fn read_all(&amp;mut self: impl Read) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;</code>
will match these queries:</p>
<ul>
<li><code>&amp;mut Read -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;</code></li>
<li><code>Read -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;</code></li>
<li><code>Read -&gt; Result&lt;Vec&lt;u8&gt;&gt;</code></li>
<li><code>Read -&gt; Vec&lt;u8&gt;</code></li>
</ul>
<p>But it <em>does not</em> match <code>Result&lt;Vec, u8&gt;</code> or <code>Result&lt;u8&lt;Vec&gt;&gt;</code>,
because those are nested incorrectly, and it does not match
<code>Result&lt;Error, Vec&lt;u8&gt;&gt;</code> or <code>Result&lt;Error&gt;</code>, because those are
in the wrong order. It also does not match <code>Read -&gt; u8</code>, because
only <a href="#wrappers-that-can-be-omitted">certain generic wrapper types</a> can be left out, and <code>Vec</code> isn‚Äôt
one of them.</p>
<p>To search for a function that accepts a function as a parameter,
like <code>Iterator::all</code>, wrap the nested signature in parenthesis,
as in <a href="../std/vec/struct.Vec.html?search=Iterator&lt;T&gt;%2C+(T+-&gt;+bool)+-&gt;+bool&amp;filter-crate=std"><code>Iterator&lt;T&gt;, (T -&gt; bool) -&gt; bool</code></a>.
You can also search for a specific closure trait,
such as <code>Iterator&lt;T&gt;, (FnMut(T) -&gt; bool) -&gt; bool</code>,
but you need to know which one you want.</p>
<h3 id="wrappers-that-can-be-omitted"><a class="header" href="#wrappers-that-can-be-omitted">Wrappers that can be omitted</a></h3>
<ul>
<li>References</li>
<li>Box</li>
<li>Rc</li>
<li>Arc</li>
<li>Option</li>
<li>Result</li>
<li>From</li>
<li>Into</li>
<li>Future</li>
</ul>
<h3 id="primitives-with-special-syntax"><a class="header" href="#primitives-with-special-syntax">Primitives with Special Syntax</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Shorthand</th><th>Explicit names</th></tr>
</thead>
<tbody>
<tr><td><code>&amp;</code></td><td><code>primitive:reference</code></td></tr>
<tr><td><code>&amp;T</code></td><td><code>primitive:reference&lt;T&gt;</code></td></tr>
<tr><td><code>&amp;mut</code></td><td><code>primitive:reference&lt;keyword:mut&gt;</code></td></tr>
<tr><td><code>&amp;mut T</code></td><td><code>primitive:reference&lt;keyword:mut, T&gt;</code></td></tr>
<tr><td><code>[]</code></td><td><code>primitive:slice</code> and/or <code>primitive:array</code></td></tr>
<tr><td><code>[T]</code></td><td><code>primitive:slice&lt;T&gt;</code> and/or <code>primitive:array&lt;T&gt;</code></td></tr>
<tr><td><code>()</code></td><td><code>primitive:unit</code> and/or <code>primitive:tuple</code></td></tr>
<tr><td><code>(T)</code></td><td><code>T</code></td></tr>
<tr><td><code>(T,)</code></td><td><code>primitive:tuple&lt;T&gt;</code></td></tr>
<tr><td><code>!</code></td><td><code>primitive:never</code></td></tr>
<tr><td><code>(T, U -&gt; V, W)</code></td><td><code>fn(T, U) -&gt; (V, W)</code>, <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code></td></tr>
</tbody>
</table>
</div>
<p>When searching for <code>[]</code>, Rustdoc will return search results with either slices
or arrays. If you know which one you want, you can force it to return results
for <code>primitive:slice</code> or <code>primitive:array</code> using the explicit name syntax.
Empty square brackets, <code>[]</code>, will match any slice or array regardless of what
it contains, or an item type can be provided, such as <code>[u8]</code> or <code>[T]</code>, to
explicitly find functions that operate on byte slices or generic slices,
respectively.</p>
<p>A single type expression wrapped in parens is the same as that type expression,
since parens act as the grouping operator. If they‚Äôre empty, though, they will
match both <code>unit</code> and <code>tuple</code>, and if there‚Äôs more than one type (or a trailing
or leading comma) it is the same as <code>primitive:tuple&lt;...&gt;</code>.</p>
<p>However, since items can be left out of the query, <code>(T)</code> will still return
results for types that match tuples, even though it also matches the type on
its own. That is, <code>(u32)</code> matches <code>(u32,)</code> for the exact same reason that it
also matches <code>Result&lt;u32, Error&gt;</code>.</p>
<p>The <code>-&gt;</code> operator has lower precedence than comma. If it‚Äôs not wrapped
in brackets, it delimits the return value for the function being searched for.
To search for functions that take functions as parameters, use parenthesis.</p>
<h3 id="limitations-and-quirks-of-type-based-search"><a class="header" href="#limitations-and-quirks-of-type-based-search">Limitations and quirks of type-based search</a></h3>
<p>Type-based search is still a buggy, experimental, work-in-progress feature.
Most of these limitations should be addressed in future version of Rustdoc.</p>
<ul>
<li>
<p>There‚Äôs no way to write trait constraints on generic parameters.
You can name traits directly, and if there‚Äôs a type parameter
with that bound, it‚Äôll match, but <code>option&lt;T&gt; -&gt; T where T: Default</code>
cannot be precisely searched for (use <code>option&lt;Default&gt; -&gt; Default</code>).</p>
</li>
<li>
<p>Supertraits, type aliases, and Deref are all ignored. Search mostly
operates on type signatures <em>as written</em>, and not as they are
represented within the compiler.</p>
</li>
<li>
<p>Type parameters match type parameters, such that <code>Option&lt;A&gt;</code> matches
<code>Option&lt;T&gt;</code>, but never match concrete types in function signatures.
A trait named as if it were a type, such as <code>Option&lt;Read&gt;</code>, will match
a type parameter constrained by that trait, such as
<code>Option&lt;T&gt; where T: Read</code>, as well as matching <code>dyn Trait</code> and
<code>impl Trait</code>.</p>
</li>
<li>
<p><code>impl Trait</code> in argument position is treated exactly like a type
parameter, but in return position it will not match type parameters.</p>
</li>
<li>
<p>Any type named in a complex type-based search will be assumed to be a
type parameter if nothing matching the name exactly is found. If you
want to force a type parameter, write <code>generic:T</code> and it will be used
as a type parameter even if a matching name is found. If you know
that you don‚Äôt want a type parameter, you can force it to match
something else by giving it a different prefix like <code>struct:T</code>.</p>
</li>
<li>
<p>Searching for lifetimes is not supported.</p>
</li>
<li>
<p>It‚Äôs impossible to search based on the length of an array.</p>
</li>
</ul>
<h2 id="item-filtering"><a class="header" href="#item-filtering">Item filtering</a></h2>
<p>Names in the search interface can be prefixed with an item type followed by a
colon (such as <code>mod:</code>) to restrict the results to just that kind of item. Also,
searching for <code>println!</code> will search for a macro named <code>println</code>, just like
searching for <code>macro:println</code> does. The complete list of available filters is
given under the <kbd>?</kbd> Help area, and in the detailed syntax below.</p>
<p>Item filters can be used in both name-based and type signature-based searches.</p>
<h2 id="search-query-syntax"><a class="header" href="#search-query-syntax">Search query syntax</a></h2>
<pre><code class="language-text">ident = *(ALPHA / DIGIT / "_")
path = ident *(DOUBLE-COLON ident) [BANG]
slice-like = OPEN-SQUARE-BRACKET [ nonempty-arg-list ] CLOSE-SQUARE-BRACKET
tuple-like = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN
borrow-ref = AMP *WS [MUT] *WS [arg]
arg = [type-filter *WS COLON *WS] (path [generics] / slice-like / tuple-like / borrow-ref)
type-sep = COMMA/WS *(COMMA/WS)
nonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep) [ return-args ]
generic-arg-list = *(type-sep) arg [ EQUAL arg ] *(type-sep arg [ EQUAL arg ]) *(type-sep)
normal-generics = OPEN-ANGLE-BRACKET [ generic-arg-list ] *(type-sep)
            CLOSE-ANGLE-BRACKET
fn-like-generics = OPEN-PAREN [ nonempty-arg-list ] CLOSE-PAREN [ RETURN-ARROW arg ]
generics = normal-generics / fn-like-generics
return-args = RETURN-ARROW *(type-sep) nonempty-arg-list

exact-search = [type-filter *WS COLON] [ RETURN-ARROW ] *WS QUOTE ident QUOTE [ generics ]
type-search = [ nonempty-arg-list ]

query = *WS (exact-search / type-search) *WS

type-filter = (
    "mod" /
    "externcrate" /
    "import" /
    "struct" /
    "enum" /
    "fn" /
    "type" /
    "static" /
    "trait" /
    "impl" /
    "tymethod" /
    "method" /
    "structfield" /
    "variant" /
    "macro" /
    "primitive" /
    "associatedtype" /
    "constant" /
    "associatedconstant" /
    "union" /
    "foreigntype" /
    "keyword" /
    "existential" /
    "attr" /
    "derive" /
    "traitalias" /
    "generic")

OPEN-ANGLE-BRACKET = "&lt;"
CLOSE-ANGLE-BRACKET = "&gt;"
OPEN-SQUARE-BRACKET = "["
CLOSE-SQUARE-BRACKET = "]"
OPEN-PAREN = "("
CLOSE-PAREN = ")"
COLON = ":"
DOUBLE-COLON = "::"
QUOTE = %x22
COMMA = ","
RETURN-ARROW = "-&gt;"
EQUAL = "="
BANG = "!"
AMP = "&amp;"
MUT = "mut"

ALPHA = %x41-5A / %x61-7A ; A-Z / a-z
DIGIT = %x30-39
WS = %x09 / " "
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-to-write-documentation"><a class="header" href="#how-to-write-documentation">How to write documentation</a></h1>
<p>Good documentation is not natural.  There are opposing goals that make writing
good documentation difficult.  It requires expertise in the subject but also
writing to a novice perspective.  Documentation therefore often glazes over
implementation detail, or leaves readers with unanswered questions.</p>
<p>There are a few tenets to Rust documentation that can help guide anyone through
the process of documenting libraries so that everyone has an ample opportunity
to use the code.</p>
<p>This chapter covers not only how to write documentation but specifically
how to write <strong>good</strong> documentation.  It is important to be as clear
as you can, and as complete as possible.  As a rule of thumb: the more
documentation you write for your crate the better.  If an item is public
then it should be documented.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Documenting a crate should begin with front-page documentation.  As an
example, the <a href="https://docs.rs/hashbrown/0.8.2/hashbrown/"><code>hashbrown</code></a> crate level documentation summarizes the role of
the crate, provides links to explain technical details, and explains why you
would want to use the crate.</p>
<p>After introducing the crate, it is important that the front-page gives
an example of how to use the crate in a real world setting.  Stick to the
library‚Äôs role in the example, but do so without shortcuts to benefit users who
may copy and paste the example to get started.</p>
<p><a href="https://docs.rs/futures/0.3.5/futures/"><code>futures</code></a> uses inline comments to explain line by line
the complexities of using a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>, because a person‚Äôs first exposure to
rust‚Äôs <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> may be this example.</p>
<p>The <a href="https://docs.rs/backtrace/0.3.50/backtrace/"><code>backtrace</code></a> documentation walks through the whole process, explaining
changes made to the <code>Cargo.toml</code> file, passing command line arguments to the
compiler, and shows a quick example of backtrace in the wild.</p>
<p>Finally, the front-page can eventually become a comprehensive reference
how to use a crate, like <a href="https://docs.rs/regex/1.3.9/regex/"><code>regex</code></a>.  In this front page, all
requirements are outlined, the edge cases shown, and practical examples
provided.  The front page goes on to show how to use regular expressions
then concludes with crate features.</p>
<p>Don‚Äôt worry about comparing your crate, which is just beginning, to other more
developed crates.  To get the documentation to something more polished, start
incrementally and put in an introduction, example, and features.  Rome was not
built in a day!</p>
<p>The first lines within the <code>lib.rs</code> will compose the front-page, and they
use a different convention than the rest of the rustdocs.  Lines should
start with <code>//!</code> which indicate module-level or crate-level documentation.
Here‚Äôs a quick example of the difference:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Fast and easy queue abstraction.
//!
//! Provides an abstraction over a queue.  When the abstraction is used
//! there are these advantages:
//! - Fast
//! - [`Easy`]
//!
//! [`Easy`]: http://thatwaseasy.example.com

/// This module makes it easy.
pub mod easy {

    /// Use the abstraction function to do this specific thing.
    pub fn abstraction() {}

}
<span class="boring">}</span></code></pre>
<p>Ideally, this first line of documentation is a sentence without highly
technical details, but with a good description of where this crate fits
within the rust ecosystem.  Users should know whether this crate meets their use
case after reading this line.</p>
<h2 id="documenting-components"><a class="header" href="#documenting-components">Documenting components</a></h2>
<p>Whether it is modules, structs, functions, or macros: the public
API of all code should have documentation. Rarely does anyone
complain about too much documentation!</p>
<p>It is recommended that each item‚Äôs documentation follows this basic structure:</p>
<pre><code class="language-text">[short sentence explaining what it is]

[more detailed explanation]

[at least one code example that users can copy/paste to try it]

[even more advanced explanations if necessary]
</code></pre>
<p>This basic structure should be straightforward to follow when writing your
documentation; while you might think that a code example is trivial,
the examples are really important because they can help users understand
what an item is, how it is used, and for what purpose it exists.</p>
<p>Let‚Äôs see an example coming from the <a href="https://doc.rust-lang.org/stable/std/index.html">standard library</a> by taking a look at the
<a href="https://doc.rust-lang.org/stable/std/env/fn.args.html"><code>std::env::args()</code></a> function:</p>
<pre><code class="language-markdown">Returns the arguments which this program was started with (normally passed
via the command line).

The first element is traditionally the path of the executable, but it can be
set to arbitrary text, and may not even exist. This means this property should
not be relied upon for security purposes.

On Unix systems shell usually expands unquoted arguments with glob patterns
(such as `*` and `?`). On Windows this is not done, and such arguments are
passed as-is.

# Panics

The returned iterator will panic during iteration if any argument to the
process is not valid unicode. If this is not desired,
use the [`args_os`] function instead.

# Examples

```
use std::env;

// Prints each argument on a separate line
for argument in env::args() {
    println!("{argument}");
}
```

[`args_os`]: ./fn.args_os.html
</code></pre>
<p>Everything before the first empty line will be reused to describe the component
in searches and module overviews.  For example, the function <code>std::env::args()</code>
above will be shown on the <a href="https://doc.rust-lang.org/stable/std/env/index.html#functions"><code>std::env</code></a> module documentation. It is good
practice to keep the summary to one line: concise writing is a goal of good
documentation.</p>
<p>Because the type system does a good job of defining what types a function
passes and returns, there is no benefit of explicitly writing it
into the documentation, especially since <code>rustdoc</code> adds hyper links to all types in the function signature.</p>
<p>In the example above, a ‚ÄòPanics‚Äô section explains when the code might abruptly exit,
which can help the reader prevent reaching a panic.  A panic section is recommended
every time edge cases in your code can be reached if known.</p>
<p>As you can see, it follows the structure detailed above: it starts with a short
sentence explaining what the functions does, then it provides more information
and finally provides a code example.</p>
<h2 id="markdown"><a class="header" href="#markdown">Markdown</a></h2>
<p><code>rustdoc</code> uses the <a href="https://commonmark.org/">CommonMark Markdown specification</a>. You might be
interested in taking a look at their website to see what‚Äôs possible:</p>
<ul>
<li><a href="https://commonmark.org/help/">CommonMark quick reference</a></li>
<li><a href="https://spec.commonmark.org/current/">current spec</a></li>
</ul>
<p>In addition to the standard CommonMark syntax, <code>rustdoc</code> supports several
extensions:</p>
<h3 id="strikethrough"><a class="header" href="#strikethrough">Strikethrough</a></h3>
<p>Text may be rendered with a horizontal line through the center by wrapping the
text with one or two tilde characters on each side:</p>
<pre><code class="language-text">An example of ~~strikethrough text~~. You can also use ~single tildes~.
</code></pre>
<p>This example will render as:</p>
<blockquote>
<p>An example of <del>strikethrough text</del>. You can also use <del>single tildes</del>.</p>
</blockquote>
<p>This follows the <a href="https://github.github.com/gfm/#strikethrough-extension-">GitHub Strikethrough extension</a>.</p>
<h3 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h3>
<p>A footnote generates a small numbered link in the text which when clicked
takes the reader to the footnote text at the bottom of the item. The footnote
label is written similarly to a link reference with a caret at the front. The
footnote text is written like a link reference definition, with the text
following the label. Example:</p>
<pre><code class="language-text">This is an example of a footnote[^note].

[^note]: This text is the contents of the footnote, which will be rendered
    towards the bottom.
</code></pre>
<p>This example will render as:</p>
<blockquote>
<p>This is an example of a footnote<sup class="footnote-reference" id="fr-note-1"><a href="#footnote-note">1</a></sup>.</p>
</blockquote>
<p>The footnotes are automatically numbered based on the order the footnotes are
written.</p>
<h3 id="tables"><a class="header" href="#tables">Tables</a></h3>
<p>Tables can be written using pipes and dashes to draw the rows and columns of
the table. These will be translated to HTML table matching the shape. Example:</p>
<pre><code class="language-text">| Header1 | Header2 |
|---------|---------|
| abc     | def     |
</code></pre>
<p>This example will render similarly to this:</p>
<blockquote>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Header1</th><th>Header2</th></tr>
</thead>
<tbody>
<tr><td>abc</td><td>def</td></tr>
</tbody>
</table>
</div>
</blockquote>
<p>See the specification for the <a href="https://github.github.com/gfm/#tables-extension-">GitHub Tables extension</a> for more
details on the exact syntax supported.</p>
<h3 id="task-lists"><a class="header" href="#task-lists">Task lists</a></h3>
<p>Task lists can be used as a checklist of items that have been completed.
Example:</p>
<pre><code class="language-md">- [x] Complete task
- [ ] Incomplete task
</code></pre>
<p>This will render as:</p>
<blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""> Complete task</li>
<li><input disabled="" type="checkbox"> Incomplete task</li>
</ul>
</blockquote>
<p>See the specification for the <a href="https://github.github.com/gfm/#task-list-items-extension-">task list extension</a> for more details.</p>
<h3 id="smart-punctuation"><a class="header" href="#smart-punctuation">Smart punctuation</a></h3>
<p>Some ASCII punctuation sequences will be automatically turned into fancy Unicode
characters:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ASCII sequence</th><th>Unicode</th></tr>
</thead>
<tbody>
<tr><td><code>--</code></td><td>‚Äì</td></tr>
<tr><td><code>---</code></td><td>‚Äî</td></tr>
<tr><td><code>...</code></td><td>‚Ä¶</td></tr>
<tr><td><code>"</code></td><td>‚Äú or ‚Äù, depending on context</td></tr>
<tr><td><code>'</code></td><td>‚Äò or ‚Äô, depending on context</td></tr>
</tbody>
</table>
</div>
<p>So, no need to manually enter those Unicode characters!</p>
<h3 id="adding-a-warning-block"><a class="header" href="#adding-a-warning-block">Adding a warning block</a></h3>
<p>If you want to make a warning or similar note stand out in the documentation,
you can wrap it like this:</p>
<pre><code class="language-md">/// documentation
///
/// &lt;div class="warning"&gt;A big warning!&lt;/div&gt;
///
/// more documentation
</code></pre>
<p>Please note that if you want to put markdown in the HTML tag and for it to
be interpreted as such, you need to have an empty line between the HTML tags
and your markdown content. For example if you want to use a link:</p>
<pre><code class="language-md">/// documentation
///
/// &lt;div class="warning"&gt;
///
/// Go to [this link](https://rust-lang.org)!
///
/// &lt;/div&gt;
///
/// more documentation
</code></pre>
<hr>
<ol class="footnote-definition">
<li id="footnote-note">
<p>This text is the contents of the footnote, which will be rendered
towards the bottom. <a href="#fr-note-1">‚Ü©</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="what-to-include-and-exclude"><a class="header" href="#what-to-include-and-exclude">What to include (and exclude)</a></h1>
<p>It is easy to say everything must be documented in a project and often times
that is correct, but how can we get there, and are there things that don‚Äôt
belong?</p>
<p>At the top of the <code>src/lib.rs</code> or <code>main.rs</code> file in your binary project, include
the following attribute:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(missing_docs)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>Now run <code>cargo doc</code> and examine the output.  Here‚Äôs a sample:</p>
<pre><code class="language-text"> Documenting docdemo v0.1.0 (/Users/username/docdemo)
warning: missing documentation for the crate
 --&gt; src/main.rs:1:1
  |
1 | / #![warn(missing_docs)]
2 | |
3 | | fn main() {
4 | |     println!("Hello, world!");
5 | | }
  | |_^
  |
note: the lint level is defined here
 --&gt; src/main.rs:1:9
  |
1 | #![warn(missing_docs)]
  |         ^^^^^^^^^^^^

warning: 1 warning emitted

    Finished dev [unoptimized + debuginfo] target(s) in 2.96s
</code></pre>
<p>As a library author, adding the lint <code>#![deny(missing_docs)]</code> is a great way to
ensure the project does not drift away from being documented well, and
<code>#![warn(missing_docs)]</code> is a good way to move towards comprehensive
documentation.</p>
<p>There are more lints in the upcoming chapter <a href="#lints">Lints</a>.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Of course this is contrived to be simple, but part of the power of documentation
is showing code that is easy to follow, rather than being realistic.  Docs often
take shortcuts with error handling because examples can become complicated to
follow with all the necessary set up required for a simple example.</p>
<p><code>Async</code> is a good example of this.  In order to execute an <code>async</code> example, an
executor needs to be available.  Examples will often shortcut this, and leave
users to figure out how to put the <code>async</code> code into their own runtime.</p>
<p>It is preferred that <code>unwrap()</code> not be used inside an example, and some of the
error handling components be hidden if they make the example too difficult to
follow.</p>
<pre><code class="language-text">/// Example
/// ```rust
/// let fourtytwo = "42".parse::&lt;u32&gt;()?;
/// println!("{} + 10 = {}", fourtytwo, fourtytwo+10);
/// ```
</code></pre>
<p>When rustdoc wraps that in a main function, it will fail to compile because the
<code>ParseIntError</code> trait is not implemented.  In order to help both your audience
and your test suite, this example needs some additional code:</p>
<pre><code class="language-text">/// Example
/// ```rust
/// # fn main() -&gt; Result&lt;(), std::num::ParseIntError&gt; {
/// let fortytwo = "42".parse::&lt;u32&gt;()?;
/// println!("{} + 10 = {}", fortytwo, fortytwo+10);
/// #     Ok(())
/// # }
/// ```
</code></pre>
<p>The example is the same on the doc page, but has that extra information
available to anyone trying to use your crate.  More about tests in the
upcoming <a href="#documentation-tests">Documentation tests</a> chapter.</p>
<h2 id="what-to-exclude"><a class="header" href="#what-to-exclude">What to Exclude</a></h2>
<p>Certain parts of your public interface may be included by default in the output
of rustdoc.  The attribute <code>#[doc(hidden)]</code> can hide implementation details
to encourage idiomatic use of the crate.</p>
<p>For example, an internal <code>macro!</code> that makes the crate easier to implement can
become a footgun for users when it appears in the public documentation.  An
internal <code>Error</code> type may exist, and <code>impl</code> details should be hidden, as
detailed in the <a href="https://rust-lang.github.io/api-guidelines/documentation.html#rustdoc-does-not-show-unhelpful-implementation-details-c-hidden">API Guidelines</a>.</p>
<h2 id="customizing-the-output"><a class="header" href="#customizing-the-output">Customizing the output</a></h2>
<p>It is possible to pass a custom css file to <code>rustdoc</code> and style the
documentation.</p>
<pre><code class="language-bash">rustdoc --extend-css custom.css src/lib.rs
</code></pre>
<p>A good example of using this feature to create a dark theme is documented <a href="https://blog.guillaume-gomez.fr/articles/2016-09-16+Generating+doc+with+rustdoc+and+a+custom+theme">on
this blog</a>.  Just remember, dark theme is already included in the rustdoc output
by clicking on the gear icon in the upper right. Adding additional options to the
themes are as easy as creating a custom theme <code>.css</code> file and using the following
syntax:</p>
<pre><code class="language-bash">rustdoc --theme awesome.css src/lib.rs
</code></pre>
<p>Here is an example of a new theme, <a href="https://github.com/rust-lang/rust/blob/HEAD/src/librustdoc/html/static/css/rustdoc.css#L2384-L2574">Ayu</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-doc-attribute"><a class="header" href="#the-doc-attribute">The <code>#[doc]</code> attribute</a></h1>
<p>The <code>#[doc]</code> attribute lets you control various aspects of how <code>rustdoc</code> does
its job.</p>
<p>The most basic function of <code>#[doc]</code> is to handle the actual documentation
text. That is, <code>///</code> is syntax sugar for <code>#[doc]</code> (as is <code>//!</code> for <code>#![doc]</code>).
This means that these two are the same:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This is a doc comment.
#[doc = r" This is a doc comment."]
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>(Note the leading space and the raw string literal in the attribute version.)</p>
<p>In most cases, <code>///</code> is easier to use than <code>#[doc]</code>. One case where the latter is easier is
when generating documentation in macros; the <code>collapse-docs</code> pass will combine multiple
<code>#[doc]</code> attributes into a single doc comment, letting you generate code like this:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc = "This is"]
#[doc = " a "]
#[doc = "doc comment"]
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>Which can feel more flexible. Note that this would generate this:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc = "This is\n a \ndoc comment"]
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>but given that docs are rendered via Markdown, it will remove these newlines.</p>
<p>Another use case is for including external files as documentation:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc = include_str!("../../README.md")]
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>The <code>doc</code> attribute has more options though! These don‚Äôt involve the text of
the output, but instead, various aspects of the presentation of the output.
We‚Äôve split them into two kinds below: attributes that are useful at the
crate level, and ones that are useful at the item level.</p>
<h2 id="at-the-crate-level"><a class="header" href="#at-the-crate-level">At the crate level</a></h2>
<p>These options control how the docs look at a crate level.</p>
<h3 id="html_favicon_url"><a class="header" href="#html_favicon_url"><code>html_favicon_url</code></a></h3>
<p>This form of the <code>doc</code> attribute lets you control the favicon of your docs.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(html_favicon_url = "https://example.com/favicon.ico")]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>This will put <code>&lt;link rel="icon" href="{}"&gt;</code> into your docs, where
the string for the attribute goes into the <code>{}</code>.</p>
<p>If you don‚Äôt use this attribute, a default favicon will be used.</p>
<h3 id="html_logo_url"><a class="header" href="#html_logo_url"><code>html_logo_url</code></a></h3>
<p>This form of the <code>doc</code> attribute lets you control the logo in the upper
left hand side of the docs.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(html_logo_url = "https://example.com/logo.jpg")]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>This will put <code>&lt;a href='../index.html'&gt;&lt;img src='{}' alt='logo' width='100'&gt;&lt;/a&gt;</code> into
your docs, where the string for the attribute goes into the <code>{}</code>.</p>
<p>If you don‚Äôt use this attribute, there will be no logo.</p>
<h3 id="html_playground_url"><a class="header" href="#html_playground_url"><code>html_playground_url</code></a></h3>
<p>This form of the <code>doc</code> attribute lets you control where the ‚Äúrun‚Äù buttons
on your documentation examples make requests to.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(html_playground_url = "https://playground.example.com/")]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>Now, when you press ‚Äúrun‚Äù, the button will make a request to this domain. The request
URL will contain 3 query parameters:</p>
<ol>
<li><code>code</code> for the code in the documentation</li>
<li><code>version</code> for the Rust channel, e.g. nightly, which is decided by whether <code>code</code> contain unstable features</li>
<li><code>edition</code> for the Rust edition, e.g. 2024</li>
</ol>
<p>If you don‚Äôt use this attribute, there will be no run buttons.</p>
<h3 id="issue_tracker_base_url"><a class="header" href="#issue_tracker_base_url"><code>issue_tracker_base_url</code></a></h3>
<p>This form of the <code>doc</code> attribute is mostly only useful for the standard library;
When a feature is unstable, an issue number for tracking the feature must be
given. <code>rustdoc</code> uses this number, plus the base URL given here, to link to
the tracking issue.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(issue_tracker_base_url = "https://github.com/rust-lang/rust/issues/")]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<h3 id="html_root_url"><a class="header" href="#html_root_url"><code>html_root_url</code></a></h3>
<p>The <code>#[doc(html_root_url = "‚Ä¶")]</code> attribute value indicates the URL for
generating links to external crates. When rustdoc needs to generate a link to
an item in an external crate, it will first check if the extern crate has been
documented locally on-disk, and if so link directly to it. Failing that, it
will use the URL given by the <code>--extern-html-root-url</code> command-line flag if
available. If that is not available, then it will use the <code>html_root_url</code>
value in the extern crate if it is available. If that is not available, then
the extern items will not be linked.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(html_root_url = "https://docs.rs/serde/1.0")]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<h3 id="html_no_source"><a class="header" href="#html_no_source"><code>html_no_source</code></a></h3>
<p>By default, <code>rustdoc</code> will include the source code of your program, with links
to it in the docs. But if you include this:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(html_no_source)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>it will not.</p>
<h3 id="testno_crate_inject"><a class="header" href="#testno_crate_inject"><code>test(no_crate_inject)</code></a></h3>
<p>By default, <code>rustdoc</code> will automatically add a line with <code>extern crate my_crate;</code> into each doctest.
But if you include this:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(test(no_crate_inject))]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>it will not.</p>
<h2 id="at-the-item-level"><a class="header" href="#at-the-item-level">At the item level</a></h2>
<p>These forms of the <code>#[doc]</code> attribute are used on individual items, to control how
they are documented.</p>
<h3 id="inline-and-no_inline"><a class="header" href="#inline-and-no_inline"><code>inline</code> and <code>no_inline</code></a></h3>
<p><span id="docno_inlinedocinline"></span></p>
<p>These attributes are used on <code>use</code> statements, and control where the documentation shows
up. For example, consider this Rust code:</p>
<pre class="playground"><code class="language-rust no_run">pub use bar::Bar;

/// bar docs
pub mod bar {
    /// the docs for Bar
    pub struct Bar;
}
<span class="boring">fn main() {}</span></code></pre>
<p>The documentation will generate a ‚ÄúRe-exports‚Äù section, and say <code>pub use bar::Bar;</code>, where
<code>Bar</code> is a link to its page.</p>
<p>If we change the <code>use</code> line like this:</p>
<pre class="playground"><code class="language-rust no_run">#[doc(inline)]
pub use bar::Bar;
<span class="boring">pub mod bar { pub struct Bar; }
</span><span class="boring">fn main() {}</span></code></pre>
<p>Instead, <code>Bar</code> will appear in a <code>Structs</code> section, just like <code>Bar</code> was defined at the
top level, rather than <code>pub use</code>‚Äôd.</p>
<p>Let‚Äôs change our original example, by making <code>bar</code> private:</p>
<pre class="playground"><code class="language-rust no_run">pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}
<span class="boring">fn main() {}</span></code></pre>
<p>Here, because <code>bar</code> is not public, <code>bar</code> wouldn‚Äôt have its own page, so there‚Äôs nowhere
to link to. <code>rustdoc</code> will inline these definitions, and so we end up in the same case
as the <code>#[doc(inline)]</code> above; <code>Bar</code> is in a <code>Structs</code> section, as if it were defined at
the top level. If we add the <code>no_inline</code> form of the attribute:</p>
<pre class="playground"><code class="language-rust no_run">#[doc(no_inline)]
pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}
<span class="boring">fn main() {}</span></code></pre>
<p>Now we‚Äôll have a <code>Re-exports</code> line, and <code>Bar</code> will not link to anywhere.</p>
<p>One special case: In Rust 2018 and later, if you <code>pub use</code> one of your dependencies, <code>rustdoc</code> will
not eagerly inline it as a module unless you add <code>#[doc(inline)]</code>.</p>
<p>If you want to know more about inlining rules, take a look at the
<a href="#re-exports"><code>re-exports</code> chapter</a>.</p>
<h3 id="hidden"><a class="header" href="#hidden"><code>hidden</code></a></h3>
<p><span id="dochidden"></span></p>
<p>Any item annotated with <code>#[doc(hidden)]</code> will not appear in the documentation,
unless the <a href="#document-hidden-items"><code>--document-hidden-items</code></a> flag is used.</p>
<p>You can find more information in the <a href="#re-exports"><code>re-exports</code> chapter</a>.</p>
<h3 id="alias"><a class="header" href="#alias"><code>alias</code></a></h3>
<p>This attribute adds an alias in the search index.</p>
<p>Let‚Äôs take an example:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc(alias = "TheAlias")]
pub struct SomeType;
<span class="boring">}</span></code></pre>
<p>So now, if you enter ‚ÄúTheAlias‚Äù in the search, it‚Äôll display <code>SomeType</code>.
Of course, if you enter <code>SomeType</code> it‚Äôll return <code>SomeType</code> as expected!</p>
<h4 id="ffi-example"><a class="header" href="#ffi-example">FFI example</a></h4>
<p>This doc attribute is especially useful when writing bindings for a C library.
For example, let‚Äôs say we have a C function that looks like this:</p>
<pre><code class="language-c">int lib_name_do_something(Obj *obj);
</code></pre>
<p>It takes a pointer to an <code>Obj</code> type and returns an integer. In Rust, it might
be written like this:</p>
<pre><code class="language-ignore (using non-existing ffi types)">pub struct Obj {
    inner: *mut ffi::Obj,
}

impl Obj {
    pub fn do_something(&amp;mut self) -&gt; i32 {
        unsafe { ffi::lib_name_do_something(self.inner) }
    }
}
</code></pre>
<p>The function has been turned into a method to make it more convenient to use.
However, if you want to look for the Rust equivalent of <code>lib_name_do_something</code>,
you have no way to do so.</p>
<p>To get around this limitation, we just add <code>#[doc(alias = "lib_name_do_something")]</code>
on the <code>do_something</code> method and then it‚Äôs all good!
Users can now look for <code>lib_name_do_something</code> in our crate directly and find
<code>Obj::do_something</code>.</p>
<h3 id="testattr"><a class="header" href="#testattr"><code>test(attr(...))</code></a></h3>
<p>This form of the <code>doc</code> attribute allows you to add arbitrary attributes to all your doctests. For
example, if you want your doctests to fail if they have dead code, you could add this:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![doc(test(attr(deny(dead_code))))]

<span class="boring">fn main() {
</span>mod my_mod {
    #![doc(test(attr(allow(dead_code))))] // but allow `dead_code` for this module
}
<span class="boring">}</span></code></pre>
<p><code>test(attr(..))</code> attributes are appended to the parent module‚Äôs, they do not replace the current
list of attributes. In the previous example, both attributes would be present:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For every doctest in `my_mod`

#![deny(dead_code)] // from the crate-root
#![allow(dead_code)] // from `my_mod`
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="re-exports"><a class="header" href="#re-exports">Re-exports</a></h1>
<p>Let‚Äôs start by explaining what are re-exports. To do so, we will use an example where we are
writing a library (named <code>lib</code>) with some types dispatched in sub-modules:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod sub_module1 {
    pub struct Foo;
}
pub mod sub_module2 {
    pub struct AnotherFoo;
}
<span class="boring">}</span></code></pre>
<p>Users can import them like this:</p>
<pre><code class="language-rust ignore (inline)">use lib::sub_module1::Foo;
use lib::sub_module2::AnotherFoo;</code></pre>
<p>But what if you want the types to be available directly at the crate root or if we don‚Äôt want the
modules to be visible for users? That‚Äôs where re-exports come in:</p>
<pre><code class="language-rust ignore (inline)">// `sub_module1` and `sub_module2` are not visible outside.
mod sub_module1 {
    pub struct Foo;
}
mod sub_module2 {
    pub struct AnotherFoo;
}
// We re-export both types:
pub use crate::sub_module1::Foo;
pub use crate::sub_module2::AnotherFoo;</code></pre>
<p>And now users will be able to do:</p>
<pre><code class="language-rust ignore (inline)">use lib::{Foo, AnotherFoo};</code></pre>
<p>And since both <code>sub_module1</code> and <code>sub_module2</code> are private, users won‚Äôt be able to import them.</p>
<p>Now what‚Äôs interesting is that the generated documentation for this crate will show both <code>Foo</code> and
<code>AnotherFoo</code> directly at the crate root, meaning they have been inlined. There are a few rules to
know whether or not a re-exported item will be inlined.</p>
<h2 id="inlining-rules"><a class="header" href="#inlining-rules">Inlining rules</a></h2>
<p>If a public item comes from a private module, it will be inlined:</p>
<pre><code class="language-rust ignore (inline)">mod private_module {
    pub struct Public;
}
pub mod public_mod {
    // `Public` will inlined here since `private_module` is private.
    pub use super::private_module::Public;
}
// `Public` will not be inlined here since `public_mod` is public.
pub use self::public_mod::Public;</code></pre>
<p>Likewise, if an item inherits <code>#[doc(hidden)]</code> from any of its ancestors, it will be inlined:</p>
<pre><code class="language-rust ignore (inline)">#[doc(hidden)]
pub mod public_mod {
    pub struct Public;
}
// `Public` be inlined since its parent (`public_mod`) has `#[doc(hidden)]`.
pub use self::public_mod::Public;</code></pre>
<p>If an item has <code>#[doc(hidden)]</code>, it won‚Äôt be inlined (nor visible in the generated documentation):</p>
<pre><code class="language-rust ignore (inline)">// This struct won't be visible.
#[doc(hidden)]
pub struct Hidden;

// This re-export won't be visible.
pub use self::Hidden as InlinedHidden;</code></pre>
<p>However, if you still want the re-export itself to be visible, you can add the <code>#[doc(inline)]</code>
attribute on it:</p>
<pre><code class="language-rust ignore (inline)">// This struct won't be visible.
#[doc(hidden)]
pub struct Hidden;

#[doc(inline)]
pub use self::Hidden as InlinedHidden;</code></pre>
<p>In this case, you will have <code>pub use self::Hidden as InlinedHidden;</code> in the generated documentation
but no link to the <code>Hidden</code> item.</p>
<p>So back to <code>#[doc(hidden)]</code>: if you have multiple re-exports and some of them have
<code>#[doc(hidden)]</code>, then these ones (and only these) won‚Äôt appear in the documentation:</p>
<pre><code class="language-rust ignore (inline)">mod private_mod {
    /// First
    pub struct InPrivate;
}

/// Second
#[doc(hidden)]
pub use self::private_mod::InPrivate as Hidden;
/// Third
pub use self::Hidden as Visible;</code></pre>
<p>In this case, <code>InPrivate</code> will be inlined as <code>Visible</code>. However, its documentation will be
<code>First Third</code> and not <code>First Second Third</code> because the re-export with <code>Second</code> as documentation has
<code>#[doc(hidden)]</code>, therefore, all its attributes are ignored.</p>
<h2 id="inlining-with-docinline"><a class="header" href="#inlining-with-docinline">Inlining with <code>#[doc(inline)]</code></a></h2>
<p>You can use the <code>#[doc(inline)]</code> attribute if you want to force an item to be inlined:</p>
<pre><code class="language-rust ignore (inline)">pub mod public_mod {
    pub struct Public;
}
#[doc(inline)]
pub use self::public_mod::Public;</code></pre>
<p>With this code, even though <code>public_mod::Public</code> is public and present in the documentation, the
<code>Public</code> type will be present both at the crate root and in the <code>public_mod</code> module.</p>
<h2 id="preventing-inlining-with-docno_inline"><a class="header" href="#preventing-inlining-with-docno_inline">Preventing inlining with <code>#[doc(no_inline)]</code></a></h2>
<p>On the opposite of the <code>#[doc(inline)]</code> attribute, if you want to prevent an item from being
inlined, you can use <code>#[doc(no_inline)]</code>:</p>
<pre><code class="language-rust ignore (inline)">mod private_mod {
    pub struct Public;
}
#[doc(no_inline)]
pub use self::private_mod::Public;</code></pre>
<p>In the generated documentation, you will see a re-export at the crate root and not the type
directly.</p>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>When an item is inlined, its doc comments and most of its attributes will be inlined along with it:</p>
<pre><code class="language-rust ignore (inline)">mod private_mod {
    /// First
    #[cfg(a)]
    pub struct InPrivate;
    /// Second
    #[cfg(b)]
    pub use self::InPrivate as Second;
}

/// Third
#[doc(inline)]
#[cfg(c)]
pub use self::private_mod::Second as Visible;</code></pre>
<p>In this case, <code>Visible</code> will have as documentation <code>First Second Third</code> and will also have as <code>cfg</code>:
<code>#[cfg(a, b, c)]</code>.</p>
<p><a href="#linking-to-items-by-name">Intra-doc links</a> are resolved relative to where the doc comment is
defined.</p>
<p>There are a few attributes which are not inlined though:</p>
<ul>
<li><code>#[doc(alias="")]</code></li>
<li><code>#[doc(inline)]</code></li>
<li><code>#[doc(no_inline)]</code></li>
<li><code>#[doc(hidden)]</code> (because the re-export itself and its attributes are ignored).</li>
</ul>
<p>All other attributes are inherited when inlined, so that the documentation matches the behavior if
the inlined item was directly defined at the spot where it‚Äôs shown.</p>
<p>These rules also apply if the item is inlined with a glob re-export:</p>
<pre><code class="language-rust ignore (inline)">mod private_mod {
    /// First
    #[cfg(a)]
    pub struct InPrivate;
}

#[cfg(c)]
pub use self::private_mod::*;</code></pre>
<p>Otherwise, the attributes displayed will be from the re-exported item and the attributes on the
re-export itself will be ignored:</p>
<pre><code class="language-rust ignore (inline)">mod private_mod {
    /// First
    #[cfg(a)]
    pub struct InPrivate;
}

#[cfg(c)]
pub use self::private_mod::InPrivate;</code></pre>
<p>In the above case, <code>cfg(c)</code> will not be displayed in the docs.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="linking-to-items-by-name"><a class="header" href="#linking-to-items-by-name">Linking to items by name</a></h1>
<p>Rustdoc is capable of directly linking to other rustdoc pages using the path of
the item as a link. This is referred to as an ‚Äòintra-doc link‚Äô.</p>
<p>For example, in the following code all of the links will link to the rustdoc page for <code>Bar</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This struct is not [Bar]
pub struct Foo1;

/// This struct is also not [bar](Bar)
pub struct Foo2;

/// This struct is also not [bar][b]
///
/// [b]: Bar
pub struct Foo3;

/// This struct is also not [`Bar`]
pub struct Foo4;

/// This struct *is* [`Bar`]!
pub struct Bar;
<span class="boring">}</span></code></pre>
<p>Unlike normal Markdown, <code>[bar][Bar]</code> syntax is also supported without needing a
<code>[Bar]: ...</code> reference link.</p>
<p>Backticks around the link will be stripped, so <code>[`Option`]</code> will correctly
link to <code>Option</code>.</p>
<h2 id="valid-links"><a class="header" href="#valid-links">Valid links</a></h2>
<p>You can refer to anything in scope, and use paths, including <code>Self</code>, <code>self</code>, <code>super</code>, and
<code>crate</code>. Associated items (functions, types, and constants) are supported, but <a href="https://github.com/rust-lang/rust/pull/79682">not for blanket
trait implementations</a>. Rustdoc also supports linking to all primitives listed in
<a href="../std/index.html#primitives">the standard library documentation</a>.</p>
<p>You can also refer to items with generic parameters like <code>Vec&lt;T&gt;</code>. The link will
resolve as if you had written <code>[`Vec&lt;T&gt;`](Vec)</code>. Fully-qualified syntax (for example,
<code>&lt;Vec as IntoIterator&gt;::into_iter()</code>) is <a href="https://github.com/rust-lang/rust/issues/74563">not yet supported</a>, however.</p>
<pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::mpsc::Receiver;

/// This is a version of [`Receiver&lt;T&gt;`] with support for [`std::future`].
///
/// You can obtain a [`std::future::Future`] by calling [`Self::recv()`].
pub struct AsyncReceiver&lt;T&gt; {
    sender: Receiver&lt;T&gt;
}

impl&lt;T&gt; AsyncReceiver&lt;T&gt; {
    pub async fn recv() -&gt; T {
        unimplemented!()
    }
}
<span class="boring">}</span></code></pre>
<p>Rustdoc allows using URL fragment specifiers, just like a normal link:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This is a special implementation of [positional parameters].
///
/// [positional parameters]: std::fmt#formatting-parameters
struct MySpecialFormatter;
<span class="boring">}</span></code></pre>
<h2 id="namespaces-and-disambiguators"><a class="header" href="#namespaces-and-disambiguators">Namespaces and Disambiguators</a></h2>
<p>Paths in Rust have three namespaces: type, value, and macro. Item names must be unique within
their namespace, but can overlap with items in other namespaces. In case of ambiguity,
rustdoc will warn about the ambiguity and suggest a disambiguator.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See also: [`Foo`](struct@Foo)
struct Bar;

/// This is different from [`Foo`](fn@Foo)
struct Foo {}

fn Foo() {}
<span class="boring">}</span></code></pre>
<p>These prefixes will be stripped when displayed in the documentation, so <code>[struct@Foo]</code> will be
rendered as <code>Foo</code>. The following prefixes are available: <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>union</code>,
<code>mod</code>, <code>module</code>, <code>const</code>, <code>constant</code>, <code>fn</code>, <code>function</code>, <code>field</code>, <code>variant</code>, <code>method</code>, <code>derive</code>,
<code>type</code>, <code>value</code>, <code>macro</code>, <code>tyalias</code>, <code>typealias</code>, <code>prim</code> or <code>primitive</code>.</p>
<p>You can also disambiguate for functions by adding <code>()</code> after the function name,
or for macros by adding <code>!</code> after the macro name. The macro <code>!</code> can be followed by <code>()</code>, <code>{}</code>,
or <code>[]</code>. Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This is different from [`foo!()`].
fn foo() {}

/// This is different from [`foo()`]
macro_rules! foo {
  () =&gt; {}
}
<span class="boring">}</span></code></pre>
<p>There is one case where the disambiguation will be performed automatically: if an intra doc
link is resolved at the same time as a trait and as a derive proc-macro. In this case, it‚Äôll
always generate a link to the trait and not emit a ‚Äúmissing disambiguation‚Äù warning. A good
example of this case is when you link to the <code>Clone</code> trait: there is also a <code>Clone</code>
proc-macro but it ignores it in this case. If you want to link to the proc-macro, you can
use the <code>macro@</code> disambiguator.</p>
<h2 id="warnings-re-exports-and-scoping"><a class="header" href="#warnings-re-exports-and-scoping">Warnings, re-exports, and scoping</a></h2>
<p>Links are resolved in the scope of the module where the item is defined, even
when the item is re-exported. If a link from another crate fails to resolve, no
warning is given.</p>
<pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod inner {
    /// Link to [f()]
    pub struct S;
    pub fn f() {}
}
pub use inner::S; // the link to `f` will still resolve correctly
<span class="boring">}</span></code></pre>
<p>When re-exporting an item, rustdoc allows adding additional documentation to it.
That additional documentation will be resolved in the scope of the re-export, not
the original, allowing you to link to items in the new crate. The new links
will still give a warning if they fail to resolve.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// See also [foo()]
pub use std::process::Command;

pub fn foo() {}
<span class="boring">}</span></code></pre>
<p>This is especially useful for proc-macros, which must always be defined in their own dedicated crate.</p>
<p>Note: Because of how <code>macro_rules!</code> macros are scoped in Rust, the intra-doc links of a
<code>macro_rules!</code> macro will be resolved <a href="https://github.com/rust-lang/rust/issues/72243">relative to the crate root</a>, as opposed to the
module it is defined in.</p>
<p>If links do not look ‚Äòsufficiently like‚Äô an intra-doc link, they will be ignored and no warning
will be given, even if the link fails to resolve. For example, any link containing <code>/</code> or <code>[]</code>
characters will be ignored.</p>
<h2 id="what-happens-in-case-an-intra-doc-link-cannot-be-generated"><a class="header" href="#what-happens-in-case-an-intra-doc-link-cannot-be-generated">What happens in case an intra-doc link cannot be generated</a></h2>
<p>In some cases (items behind a <code>cfg</code> for example), an intra-doc link cannot be generated to item.
There are different ways to create a link in markdown, and depending on the one you use, it will
render differently in this case:</p>
<pre><code class="language-md">1. [a]
2. [b][c]
3. [d](e)
4. [f]

[f]: g
</code></pre>
<p><code>1.</code> and <code>2.</code> will be displayed as is in the rendered documentation (ie, <code>[a]</code> and <code>[b][c]</code>)
whereas <code>3.</code> and <code>4.</code> will be replaced by a link targeting <code>e</code> for <code>[d](e)</code> and <code>g</code> for <code>[f]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation tests</a></h1>
<p><code>rustdoc</code> supports executing your documentation examples as tests. This makes sure
that examples within your documentation are up to date and working.</p>
<p>The basic idea is this:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Examples
///
/// ```
/// let x = 5;
/// ```
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>The triple backticks start and end code blocks. If this were in a file named <code>foo.rs</code>,
running <code>rustdoc --test foo.rs</code> will extract this example, and then run it as a test.</p>
<p>Please note that by default, if no language is set for the block code, rustdoc
assumes it is Rust code. So the following:</p>
<pre><code class="language-markdown">```rust
let x = 5;
```
</code></pre>
<p>is strictly equivalent to:</p>
<pre><code class="language-markdown">```
let x = 5;
```
</code></pre>
<p>There‚Äôs some subtlety though! Read on for more details.</p>
<h2 id="passing-or-failing-a-doctest"><a class="header" href="#passing-or-failing-a-doctest">Passing or failing a doctest</a></h2>
<p>Like regular unit tests, regular doctests are considered to ‚Äúpass‚Äù
if they compile and run without panicking.
So if you want to demonstrate that some computation gives a certain result,
the <code>assert!</code> family of macros works the same as other Rust code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = "foo";
assert_eq!(foo, "foo");
<span class="boring">}</span></code></pre>
<p>This way, if the computation ever returns something different,
the code panics and the doctest fails.</p>
<h2 id="pre-processing-examples"><a class="header" href="#pre-processing-examples">Pre-processing examples</a></h2>
<p>In the example above, you‚Äôll note something strange: there‚Äôs no <code>main</code>
function! Forcing you to write <code>main</code> for every example, no matter how small,
adds friction and clutters the output. So <code>rustdoc</code> processes your examples
slightly before running them. Here‚Äôs the full algorithm <code>rustdoc</code> uses to
preprocess examples:</p>
<ol>
<li>Some common <code>allow</code> attributes are inserted, including
<code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>,
<code>unused_attributes</code>, and <code>dead_code</code>. Small examples often trigger
these lints.</li>
<li>Any attributes specified with <code>#![doc(test(attr(...)))]</code> are added.</li>
<li>Any leading <code>#![foo]</code> attributes are left intact as crate attributes.</li>
<li>If the example does not contain <code>extern crate</code>, and
<code>#![doc(test(no_crate_inject))]</code> was not specified, then <code>extern crate &lt;mycrate&gt;;</code> is inserted (note the lack of <code>#[macro_use]</code>).</li>
<li>Finally, if the example does not contain <code>fn main</code>, the remainder of the
text is wrapped in <code>fn main() { your_code }</code>.</li>
</ol>
<p>For more about that caveat in rule 4, see ‚ÄúDocumenting Macros‚Äù below.</p>
<h2 id="hiding-portions-of-the-example"><a class="header" href="#hiding-portions-of-the-example">Hiding portions of the example</a></h2>
<p>Sometimes, you need some setup code, or other things that would distract
from your example, but are important to make the tests work. Consider
an example block that looks like this:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// /// Some documentation.
/// # fn foo() {} // this function will be hidden
/// println!("Hello, World!");
/// ```
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>It will render like this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Some documentation.
<span class="boring">fn foo() {}
</span>println!("Hello, World!");
<span class="boring">}</span></code></pre>
<p>Yes, that‚Äôs right: you can add lines that start with <code># </code>, and they will
be hidden from the output, but will be used when compiling your code. You
can use this to your advantage. In this case, documentation comments need
to apply to some kind of function, so if I want to show you just a
documentation comment, I need to add a little function definition below
it. At the same time, it‚Äôs only there to satisfy the compiler, so hiding
it makes the example more clear. You can use this technique to explain
longer examples in detail, while still preserving the testability of your
documentation.</p>
<p>For example, imagine that we wanted to document this code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 6;
println!("{}", x + y);
<span class="boring">}</span></code></pre>
<p>We might want the documentation to end up looking like this:</p>
<blockquote>
<p>First, we set <code>x</code> to five:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">let y = 6;
</span><span class="boring">println!("{}", x + y);
</span><span class="boring">}</span></code></pre>
<p>Next, we set <code>y</code> to six:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 5;
</span>let y = 6;
<span class="boring">println!("{}", x + y);
</span><span class="boring">}</span></code></pre>
<p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 5;
</span><span class="boring">let y = 6;
</span>println!("{}", x + y);
<span class="boring">}</span></code></pre>
</blockquote>
<p>To keep each code block testable, we want the whole program in each block, but
we don‚Äôt want the reader to see every line every time.  Here‚Äôs what we put in
our source code:</p>
<pre><code class="language-markdown">First, we set `x` to five:

```
let x = 5;
# let y = 6;
# println!("{}", x + y);
```

Next, we set `y` to six:

```
# let x = 5;
let y = 6;
# println!("{}", x + y);
```

Finally, we print the sum of `x` and `y`:

```
# let x = 5;
# let y = 6;
println!("{}", x + y);
```
</code></pre>
<p>By repeating all parts of the example, you can ensure that your example still
compiles, while only showing the parts that are relevant to that part of your
explanation.</p>
<p>The <code>#</code>-hiding of lines can be prevented by using two consecutive hashes
<code>##</code>. This only needs to be done with the first <code>#</code> which would‚Äôve
otherwise caused hiding. If we have a string literal like the following,
which has a line that starts with a <code>#</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "foo
# bar # baz";
<span class="boring">}</span></code></pre>
<p>We can document it by escaping the initial <code>#</code>:</p>
<pre><code class="language-text">/// let s = "foo
/// ## bar # baz";
</code></pre>
<p>Here is an example with a macro rule which matches on tokens starting with <code>#</code>:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// macro_rules! ignore { (##tag) =&gt; {}; }
/// ignore! {
///     ###tag
/// }
/// ```
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>As you can see, the rule is expecting two <code>#</code>, so when calling it, we need to add an extra <code>#</code>
because the first one is used as escape.</p>
<h2 id="using--in-doc-tests"><a class="header" href="#using--in-doc-tests">Using <code>?</code> in doc tests</a></h2>
<p>When writing an example, it is rarely useful to include a complete error
handling, as it would add significant amounts of boilerplate code. Instead, you
may want the following:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// use std::io;
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// ```
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>The problem is that <code>?</code> returns a <code>Result&lt;T, E&gt;</code> and test functions don‚Äôt
return anything, so this will give a mismatched types error.</p>
<p>You can get around this limitation by manually adding a <code>main</code> that returns
<code>Result&lt;T, E&gt;</code>, because <code>Result&lt;T, E&gt;</code> implements the <code>Termination</code> trait:</p>
<pre class="playground"><code class="language-rust no_run">/// A doc test using ?
///
/// ```
/// use std::io;
///
/// fn main() -&gt; io::Result&lt;()&gt; {
///     let mut input = String::new();
///     io::stdin().read_line(&amp;mut input)?;
///     Ok(())
/// }
/// ```
<span class="boring">fn f() {}</span></code></pre>
<p>Together with the <code># </code> from the section above, you arrive at a solution that
appears to the reader as the initial idea but works with doc tests:</p>
<pre class="playground"><code class="language-rust no_run">/// ```
/// use std::io;
/// # fn main() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// # Ok(())
/// # }
/// ```
<span class="boring">fn f() {}</span></code></pre>
<p>As of version 1.34.0, one can also omit the <code>fn main()</code>, but you will have to
disambiguate the error type:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// use std::io;
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// # Ok::&lt;(), io::Error&gt;(())
/// ```
<span class="boring">fn f() {}
</span><span class="boring">}</span></code></pre>
<p>This is an unfortunate consequence of the <code>?</code> operator adding an implicit
conversion, so type inference fails because the type is not unique. Please note
that you must write the <code>(())</code> in one sequence without intermediate whitespace
so that <code>rustdoc</code> understands you want an implicit <code>Result</code>-returning function.</p>
<h2 id="showing-warnings-in-doctests"><a class="header" href="#showing-warnings-in-doctests">Showing warnings in doctests</a></h2>
<p>You can show warnings in doctests by running <code>rustdoc --test --test-args=--show-output</code>
(or, if you‚Äôre using cargo, <code>cargo test --doc -- --show-output</code>).
By default, this will still hide <code>unused</code> warnings, since so many examples use private functions;
you can add <code>#![warn(unused)]</code> to the top of your example if you want to see unused variables or dead code warnings.
You can also use <a href="#testattr"><code>#![doc(test(attr(warn(unused))))]</code></a> in the crate root to enable warnings globally.</p>
<h2 id="documenting-macros"><a class="header" href="#documenting-macros">Documenting macros</a></h2>
<p>Here‚Äôs an example of documenting a macro:</p>
<pre class="playground"><code class="language-rust">/// Panic with a given message unless an expression evaluates to true.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, ‚ÄúMath is broken.‚Äù);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, ‚ÄúI‚Äôm broken.‚Äù);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) =&gt; ({ if ! $condition { panic!($($rest),+); } });
}
<span class="boring">fn main() {}</span></code></pre>
<p>You‚Äôll note three things: we need to add our own <code>extern crate</code> line, so that
we can add the <code>#[macro_use]</code> attribute. Second, we‚Äôll need to add our own
<code>main()</code> as well (for reasons discussed above). Finally, a judicious use of
<code>#</code> to comment out those two things, so they don‚Äôt show up in the output.</p>
<h2 id="attributes-1"><a class="header" href="#attributes-1">Attributes</a></h2>
<p>Code blocks can be annotated with attributes that help <code>rustdoc</code> do the right
thing when testing your code:</p>
<p>The <code>ignore</code> attribute tells Rust to ignore your code. This is almost never
what you want as it‚Äôs the most generic. Instead, consider annotating it
with <code>text</code> if it‚Äôs not code or using <code>#</code>s to get a working example that
only shows the part you care about.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```ignore
/// fn foo() {
/// ```
<span class="boring">fn foo() {}
</span><span class="boring">}</span></code></pre>
<p><code>should_panic</code> tells <code>rustdoc</code> that the code should compile correctly but
panic during execution. If the code doesn‚Äôt panic, the test will fail.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```should_panic
/// assert!(false);
/// ```
<span class="boring">fn foo() {}
</span><span class="boring">}</span></code></pre>
<p>The <code>no_run</code> attribute will compile your code but not run it. This is
important for examples such as ‚ÄúHere‚Äôs how to retrieve a web page,‚Äù
which you would want to ensure compiles, but might be run in a test
environment that has no network access. This attribute can also be
used to demonstrate code snippets that can cause Undefined Behavior.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```no_run
/// loop {
///     println!("Hello, world");
/// }
/// ```
<span class="boring">fn foo() {}
</span><span class="boring">}</span></code></pre>
<p><code>compile_fail</code> tells <code>rustdoc</code> that the compilation should fail. If it
compiles, then the test will fail. However, please note that code failing
with the current Rust release may work in a future release, as new features
are added.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```compile_fail
/// let x = 5;
/// x += 2; // shouldn't compile!
/// ```
<span class="boring">fn foo() {}
</span><span class="boring">}</span></code></pre>
<p><code>edition2015</code>, <code>edition2018</code>, <code>edition2021</code>, and <code>edition2024</code> tell <code>rustdoc</code>
that the code sample should be compiled using the respective edition of Rust.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Only runs on the 2018 edition.
///
/// ```edition2018
/// let result: Result&lt;i32, ParseIntError&gt; = try {
///     "1".parse::&lt;i32&gt;()?
///         + "2".parse::&lt;i32&gt;()?
///         + "3".parse::&lt;i32&gt;()?
/// };
/// ```
<span class="boring">fn foo() {}
</span><span class="boring">}</span></code></pre>
<p>Starting in the 2024 edition<sup class="footnote-reference" id="fr-edition-note-1"><a href="#footnote-edition-note">1</a></sup>, compatible doctests are merged as one before being
run. We combine doctests for performance reasons: the slowest part of doctests is to compile them.
Merging all of them into one file and compiling this new file, then running the doctests is much
faster. Whether doctests are merged or not, they are run in their own process.</p>
<p>An example of time spent when running doctests:</p>
<p><a href="https://crates.io/crates/sysinfo">sysinfo crate</a>:</p>
<pre><code class="language-text">wall-time duration: 4.59s
total compile time: 27.067s
total runtime: 3.969s
</code></pre>
<p>Rust core library:</p>
<pre><code class="language-text">wall-time duration: 102s
total compile time: 775.204s
total runtime: 15.487s
</code></pre>
<p>In some cases, doctests cannot be merged. For example, if you have:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! ```
//! let location = std::panic::Location::caller();
//! assert_eq!(location.line(), 4);
//! ```
<span class="boring">}</span></code></pre>
<p>The problem with this code is that, if you change any other doctests, it‚Äôll likely break when
running <code>rustdoc --test</code>, making it tricky to maintain.</p>
<p>This is where the <code>standalone_crate</code> attribute comes in: it tells <code>rustdoc</code> that a doctest
should not be merged with the others. So the previous code should use it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! ```standalone_crate
//! let location = std::panic::Location::caller();
//! assert_eq!(location.line(), 4);
//! ```
<span class="boring">}</span></code></pre>
<p>In this case, it means that the line information will not change if you add/remove other
doctests.</p>
<h3 id="ignoring-targets"><a class="header" href="#ignoring-targets">Ignoring targets</a></h3>
<p>Attributes starting with <code>ignore-</code> can be used to ignore doctests for specific
targets. For example, <code>ignore-x86_64</code> will avoid building doctests when the
target name contains <code>x86_64</code>.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```ignore-x86_64
/// assert!(2 == 2);
/// ```
struct Foo;
<span class="boring">}</span></code></pre>
<p>This doctest will not be built for targets such as <code>x86_64-unknown-linux-gnu</code>.</p>
<p>Multiple ignore attributes can be specified to ignore multiple targets:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```ignore-x86_64,ignore-windows
/// assert!(2 == 2);
/// ```
struct Foo;
<span class="boring">}</span></code></pre>
<p>If you want to preserve backwards compatibility for older versions of rustdoc,
you can specify both <code>ignore</code> and <code>ignore-</code>, such as:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```ignore,ignore-x86_64
/// assert!(2 == 2);
/// ```
struct Foo;
<span class="boring">}</span></code></pre>
<p>In older versions, this will be ignored on all targets, but starting with
version 1.88.0, <code>ignore-x86_64</code> will override <code>ignore</code>.</p>
<h3 id="custom-css-classes-for-code-blocks"><a class="header" href="#custom-css-classes-for-code-blocks">Custom CSS classes for code blocks</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```custom,{class=language-c}
/// int main(void) { return 0; }
/// ```
pub struct Bar;
<span class="boring">}</span></code></pre>
<p>The text <code>int main(void) { return 0; }</code> is rendered without highlighting in a code block
with the class <code>language-c</code>. This can be used to highlight other languages through JavaScript
libraries for example.</p>
<p>Without the <code>custom</code> attribute, it would be generated as a Rust code example with an additional
<code>language-C</code> CSS class. Therefore, if you specifically don‚Äôt want it to be a Rust code example,
don‚Äôt forget to add the <code>custom</code> attribute.</p>
<p>To be noted that you can replace <code>class=</code> with <code>.</code> to achieve the same result:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```custom,{.language-c}
/// int main(void) { return 0; }
/// ```
pub struct Bar;
<span class="boring">}</span></code></pre>
<p>To be noted, <code>rust</code> and <code>.rust</code>/<code>class=rust</code> have different effects: <code>rust</code> indicates that this is
a Rust code block whereas the two others add a ‚Äúrust‚Äù CSS class on the code block.</p>
<p>You can also use double quotes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```"not rust" {."hello everyone"}
/// int main(void) { return 0; }
/// ```
pub struct Bar;
<span class="boring">}</span></code></pre>
<h2 id="syntax-reference"><a class="header" href="#syntax-reference">Syntax reference</a></h2>
<p>The <em>exact</em> syntax for code blocks, including the edge cases, can be found
in the <a href="https://spec.commonmark.org/0.29/#fenced-code-blocks">Fenced Code Blocks</a>
section of the CommonMark specification.</p>
<p>Rustdoc also accepts <em>indented</em> code blocks as an alternative to fenced
code blocks: instead of surrounding your code with three backticks, you
can indent each line by four or more spaces.</p>
<pre><code class="language-markdown">    let foo = "foo";
    assert_eq!(foo, "foo");
</code></pre>
<p>These, too, are documented in the CommonMark specification, in the
<a href="https://spec.commonmark.org/0.29/#indented-code-blocks">Indented Code Blocks</a>
section.</p>
<p>However, it‚Äôs preferable to use fenced code blocks over indented code blocks.
Not only are fenced code blocks considered more idiomatic for Rust code,
but there is no way to use attributes such as <code>ignore</code> or <code>should_panic</code> with
indented code blocks.</p>
<h3 id="include-items-only-when-collecting-doctests"><a class="header" href="#include-items-only-when-collecting-doctests">Include items only when collecting doctests</a></h3>
<p>Rustdoc‚Äôs documentation tests can do some things that regular unit tests can‚Äôt, so it can
sometimes be useful to extend your doctests with samples that wouldn‚Äôt otherwise need to be in
documentation. To this end, Rustdoc allows you to have certain items only appear when it‚Äôs
collecting doctests, so you can utilize doctest functionality without forcing the test to appear in
docs, or to find an arbitrary private item to include it on.</p>
<p>When compiling a crate for use in doctests (with <code>--test</code> option), <code>rustdoc</code> will set <code>#[cfg(doctest)]</code>.
Note that they will still link against only the public items of your crate; if you need to test
private items, you need to write a unit test.</p>
<p>In this example, we‚Äôre adding doctests that we know won‚Äôt compile, to verify that our struct can
only take in valid data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// We have a struct here. Remember it doesn't accept negative numbers!
pub struct MyStruct(pub usize);

/// ```compile_fail
/// let x = my_crate::MyStruct(-5);
/// ```
#[cfg(doctest)]
pub struct MyStructOnlyTakesUsize;
<span class="boring">}</span></code></pre>
<p>Note that the struct <code>MyStructOnlyTakesUsize</code> here isn‚Äôt actually part of your public crate
API. The use of <code>#[cfg(doctest)]</code> makes sure that this struct only exists while <code>rustdoc</code> is
collecting doctests. This means that its doctest is executed when <code>--test</code> is passed to rustdoc,
but is hidden from the public documentation.</p>
<p>Another possible use of <code>#[cfg(doctest)]</code> is to test doctests that are included in your README file
without including it in your main documentation. For example, you could write this into your
<code>lib.rs</code> to test your README as part of your doctests:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc = include_str!("../README.md")]
#[cfg(doctest)]
pub struct ReadmeDoctests;
<span class="boring">}</span></code></pre>
<p>This will include your README as documentation on the hidden struct <code>ReadmeDoctests</code>, which will
then be tested alongside the rest of your doctests.</p>
<h2 id="controlling-the-compilation-and-run-directories"><a class="header" href="#controlling-the-compilation-and-run-directories">Controlling the compilation and run directories</a></h2>
<p>By default, <code>rustdoc --test</code> will compile and run documentation test examples
from the same working directory.
The compilation directory is being used for compiler diagnostics, the <code>file!()</code> macro and
the output of <code>rustdoc</code> test runner itself, whereas the run directory has an influence on file-system
operations within documentation test examples, such as <code>std::fs::read_to_string</code>.</p>
<p>The <code>--test-run-directory</code> flag allows controlling the run directory separately from the compilation directory.
This is particularly useful in workspaces, where compiler invocations and thus diagnostics should be
relative to the workspace directory, but documentation test examples should run relative to the crate directory.</p>
<hr>
<ol class="footnote-definition">
<li id="footnote-edition-note">
<p>This is based on the edition of the whole crate, not the edition of the individual
test case that may be specified in its code attribute. <a href="#fr-edition-note-1">‚Ü©</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lints"><a class="header" href="#lints">Lints</a></h1>
<p><code>rustdoc</code> provides lints to help you writing and testing your documentation. You
can use them like any other lints by doing this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(rustdoc::broken_intra_doc_links)] // allows the lint, no diagnostics will be reported
#![warn(rustdoc::broken_intra_doc_links)] // warn if there are broken intra-doc links
#![deny(rustdoc::broken_intra_doc_links)] // error if there are broken intra-doc links
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>Note that, except for <code>missing_docs</code>, these lints are only available when running <code>rustdoc</code>, not <code>rustc</code>.</p>
<p>Here is the list of the lints provided by <code>rustdoc</code>:</p>
<h2 id="broken_intra_doc_links"><a class="header" href="#broken_intra_doc_links"><code>broken_intra_doc_links</code></a></h2>
<p>This lint <strong>warns by default</strong>. This lint detects when an <a href="#linking-to-items-by-name">intra-doc link</a> fails to be resolved. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// I want to link to [`Nonexistent`] but it doesn't exist!
pub fn foo() {}
<span class="boring">}</span></code></pre>
<p>You‚Äôll get a warning saying:</p>
<pre><code class="language-text">warning: unresolved link to `Nonexistent`
 --&gt; test.rs:1:24
  |
1 | /// I want to link to [`Nonexistent`] but it doesn't exist!
  |                        ^^^^^^^^^^^^^ no item named `Nonexistent` in `test`
</code></pre>
<p>It will also warn when there is an ambiguity and suggest how to disambiguate:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// [`Foo`]
pub fn function() {}

pub enum Foo {}

pub fn Foo(){}
<span class="boring">}</span></code></pre>
<pre><code class="language-text">warning: `Foo` is both an enum and a function
 --&gt; test.rs:1:6
  |
1 | /// [`Foo`]
  |      ^^^^^ ambiguous link
  |
  = note: `#[warn(rustdoc::broken_intra_doc_links)]` on by default
help: to link to the enum, prefix with the item type
  |
1 | /// [`enum@Foo`]
  |      ^^^^^^^^^^
help: to link to the function, add parentheses
  |
1 | /// [`Foo()`]
  |      ^^^^^^^

</code></pre>
<h2 id="private_intra_doc_links"><a class="header" href="#private_intra_doc_links"><code>private_intra_doc_links</code></a></h2>
<p>This lint <strong>warns by default</strong>. This lint detects when <a href="#linking-to-items-by-name">intra-doc links</a> from public to private items.
For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(rustdoc::private_intra_doc_links)] // note: unnecessary - warns by default.

<span class="boring">fn main() {
</span>/// [private]
pub fn public() {}
fn private() {}
<span class="boring">}</span></code></pre>
<p>This gives a warning that the link will be broken when it appears in your documentation:</p>
<pre><code class="language-text">warning: public documentation for `public` links to private item `private`
 --&gt; priv.rs:1:6
  |
1 | /// [private]
  |      ^^^^^^^ this item is private
  |
  = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default
  = note: this link will resolve properly if you pass `--document-private-items`
</code></pre>
<p>Note that this has different behavior depending on whether you pass <code>--document-private-items</code> or not!
If you document private items, then it will still generate a link, despite the warning:</p>
<pre><code class="language-text">warning: public documentation for `public` links to private item `private`
 --&gt; priv.rs:1:6
  |
1 | /// [private]
  |      ^^^^^^^ this item is private
  |
  = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default
  = note: this link resolves only because you passed `--document-private-items`, but will break without
</code></pre>
<h2 id="missing_docs"><a class="header" href="#missing_docs"><code>missing_docs</code></a></h2>
<p>This lint is <strong>allowed by default</strong>. It detects items missing documentation.
For example:</p>
<pre class="playground"><code class="language-rust">#![warn(missing_docs)]

pub fn undocumented() {}
<span class="boring">fn main() {}</span></code></pre>
<p>The <code>undocumented</code> function will then have the following warning:</p>
<pre><code class="language-text">warning: missing documentation for a function
  --&gt; your-crate/lib.rs:3:1
   |
 3 | pub fn undocumented() {}
   | ^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Note that unlike other rustdoc lints, this lint is also available from <code>rustc</code> directly.</p>
<h2 id="missing_crate_level_docs"><a class="header" href="#missing_crate_level_docs"><code>missing_crate_level_docs</code></a></h2>
<p>This lint is <strong>allowed by default</strong>. It detects if there is no documentation
at the crate root. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(rustdoc::missing_crate_level_docs)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>This will generate the following warning:</p>
<pre><code class="language-text">warning: no documentation found for this crate's top-level module
  |
  = help: The following guide may be of use:
          https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation.html
</code></pre>
<p>This is currently ‚Äúallow‚Äù by default, but it is intended to make this a
warning in the future. This is intended as a means to introduce new users on
<em>how</em> to document their crate by pointing them to some instructions on how to
get started, without providing overwhelming warnings like <code>missing_docs</code>
might.</p>
<h2 id="missing_doc_code_examples"><a class="header" href="#missing_doc_code_examples"><code>missing_doc_code_examples</code></a></h2>
<p>This lint is <strong>allowed by default</strong> and is <strong>nightly-only</strong>. It detects when a documentation block
is missing a code example. For example:</p>
<pre class="playground"><code class="language-rust">#![warn(rustdoc::missing_doc_code_examples)]

/// There is no code example!
pub fn no_code_example() {}
<span class="boring">fn main() {}</span></code></pre>
<p>The <code>no_code_example</code> function will then have the following warning:</p>
<pre><code class="language-text">warning: Missing code example in this documentation
  --&gt; your-crate/lib.rs:3:1
   |
LL | /// There is no code example!
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>To fix the lint, you need to add a code example into the documentation block:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// There is no code example!
///
/// ```
/// println!("calling no_code_example...");
/// no_code_example();
/// println!("we called no_code_example!");
/// ```
pub fn no_code_example() {}
<span class="boring">}</span></code></pre>
<h2 id="private_doc_tests"><a class="header" href="#private_doc_tests"><code>private_doc_tests</code></a></h2>
<p>This lint is <strong>allowed by default</strong>. It detects documentation tests when they
are on a private item. For example:</p>
<pre class="playground"><code class="language-rust">#![warn(rustdoc::private_doc_tests)]

mod foo {
    /// private doc test
    ///
    /// ```
    /// assert!(false);
    /// ```
    fn bar() {}
}
<span class="boring">fn main() {}</span></code></pre>
<p>Which will give:</p>
<pre><code class="language-text">warning: Documentation test in private item
  --&gt; your-crate/lib.rs:4:1
   |
 4 | /     /// private doc test
 5 | |     ///
 6 | |     /// ```
 7 | |     /// assert!(false);
 8 | |     /// ```
   | |___________^
</code></pre>
<h2 id="invalid_codeblock_attributes"><a class="header" href="#invalid_codeblock_attributes"><code>invalid_codeblock_attributes</code></a></h2>
<p>This lint <strong>warns by default</strong>. It detects code block attributes in
documentation examples that have potentially mis-typed values. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(rustdoc::invalid_codeblock_attributes)]  // note: unnecessary - warns by default.

<span class="boring">fn main() {
</span>/// Example.
///
/// ```should-panic
/// assert_eq!(1, 2);
/// ```
pub fn foo() {}
<span class="boring">}</span></code></pre>
<p>Which will give:</p>
<pre><code class="language-text">warning: unknown attribute `should-panic`. Did you mean `should_panic`?
 --&gt; src/lib.rs:1:1
  |
1 | / /// Example.
2 | | ///
3 | | /// ```should-panic
4 | | /// assert_eq!(1, 2);
5 | | /// ```
  | |_______^
  |
  = note: `#[warn(rustdoc::invalid_codeblock_attributes)]` on by default
  = help: the code block will either not be tested if not marked as a rust one or won't fail if it doesn't panic when running
</code></pre>
<p>In the example above, the correct form is <code>should_panic</code>. This helps detect
typo mistakes for some common attributes.</p>
<h2 id="invalid_html_tags"><a class="header" href="#invalid_html_tags"><code>invalid_html_tags</code></a></h2>
<p>This lint <strong>warns by default</strong>. It detects unclosed
or invalid HTML tags. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(rustdoc::invalid_html_tags)]

<span class="boring">fn main() {
</span>/// &lt;h1&gt;
/// &lt;/script&gt;
pub fn foo() {}
<span class="boring">}</span></code></pre>
<p>Which will give:</p>
<pre><code class="language-text">warning: unopened HTML tag `script`
 --&gt; foo.rs:1:1
  |
1 | / /// &lt;h1&gt;
2 | | /// &lt;/script&gt;
  | |_____________^
  |
  note: the lint level is defined here
 --&gt; foo.rs:1:9
  |
1 | #![warn(rustdoc::invalid_html_tags)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unclosed HTML tag `h1`
 --&gt; foo.rs:1:1
  |
1 | / /// &lt;h1&gt;
2 | | /// &lt;/script&gt;
  | |_____________^

warning: 2 warnings emitted
</code></pre>
<h2 id="invalid_rust_codeblocks"><a class="header" href="#invalid_rust_codeblocks"><code>invalid_rust_codeblocks</code></a></h2>
<p>This lint <strong>warns by default</strong>. It detects Rust code blocks in documentation
examples that are invalid (e.g. empty, not parsable as Rust). For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Empty code blocks (with and without the `rust` marker):
///
/// ```rust
/// ```
///
/// Invalid syntax in code blocks:
///
/// ```rust
/// '&lt;
/// ```
pub fn foo() {}
<span class="boring">}</span></code></pre>
<p>Which will give:</p>
<pre><code class="language-text">warning: Rust code block is empty
 --&gt; lint.rs:3:5
  |
3 |   /// ```rust
  |  _____^
4 | | /// ```
  | |_______^
  |
  = note: `#[warn(rustdoc::invalid_rust_codeblocks)]` on by default

warning: could not parse code block as Rust code
  --&gt; lint.rs:8:5
   |
8  |   /// ```rust
   |  _____^
9  | | /// '&lt;
10 | | /// ```
   | |_______^
   |
   = note: error from rustc: unterminated character literal
</code></pre>
<h2 id="bare_urls"><a class="header" href="#bare_urls"><code>bare_urls</code></a></h2>
<p>This lint is <strong>warn-by-default</strong>. It detects URLs which are not links.
For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(rustdoc::bare_urls)] // note: unnecessary - warns by default.

<span class="boring">fn main() {
</span>/// http://example.org
/// [http://example.net]
pub fn foo() {}
<span class="boring">}</span></code></pre>
<p>Which will give:</p>
<pre><code class="language-text">warning: this URL is not a hyperlink
 --&gt; links.rs:1:5
  |
1 | /// http://example.org
  |     ^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `&lt;http://example.org&gt;`
  |
  = note: `#[warn(rustdoc::bare_urls)]` on by default

warning: this URL is not a hyperlink
 --&gt; links.rs:3:6
  |
3 | /// [http://example.net]
  |      ^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `&lt;http://example.net&gt;`

warning: 2 warnings emitted
</code></pre>
<h2 id="unescaped_backticks"><a class="header" href="#unescaped_backticks"><code>unescaped_backticks</code></a></h2>
<p>This lint is <strong>allowed by default</strong>. It detects backticks (`) that are not escaped.
This usually means broken inline code. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(rustdoc::unescaped_backticks)]

<span class="boring">fn main() {
</span>/// `add(a, b) is the same as `add(b, a)`.
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }
<span class="boring">}</span></code></pre>
<p>Which will give:</p>
<pre><code class="language-text">warning: unescaped backtick
 --&gt; src/lib.rs:3:41
  |
3 | /// `add(a, b) is the same as `add(b, a)`.
  |                                         ^
  |
note: the lint level is defined here
 --&gt; src/lib.rs:1:9
  |
1 | #![warn(rustdoc::unescaped_backticks)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: a previous inline code might be longer than expected
  |
3 | /// `add(a, b)` is the same as `add(b, a)`.
  |               +
help: if you meant to use a literal backtick, escape it
  |
3 | /// `add(a, b) is the same as `add(b, a)\`.
  |                                         +

warning: 1 warning emitted
</code></pre>
<h2 id="redundant_explicit_links"><a class="header" href="#redundant_explicit_links"><code>redundant_explicit_links</code></a></h2>
<p>This lint is <strong>warn-by-default</strong>. It detects explicit links that are the same
as computed automatic links.
This usually means the explicit links are removable. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(rustdoc::redundant_explicit_links)] // note: unnecessary - warns by default.

<span class="boring">fn main() {
</span>/// add takes 2 [`usize`](usize) and performs addition
/// on them, then returns result.
pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}
<span class="boring">}</span></code></pre>
<p>Which will give:</p>
<pre><code class="language-text">error: redundant explicit rustdoc link
  --&gt; src/lib.rs:3:27
   |
3  | /// add takes 2 [`usize`](usize) and performs addition
   |                           ^^^^^
   |
   = note: Explicit link does not affect the original link
note: the lint level is defined here
  --&gt; src/lib.rs:1:9
   |
1  | #![deny(rustdoc::redundant_explicit_links)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: Remove explicit link instead
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scraped-examples"><a class="header" href="#scraped-examples">Scraped examples</a></h1>
<p>Rustdoc has an unstable feature where it can automatically scrape examples of items being documented from the <code>examples/</code> directory of a Cargo workspace. These examples will be included within the generated documentation for that item. For example, if your library contains a public function:</p>
<pre><code class="language-rust ignore (needs-other-file)">// a_crate/src/lib.rs
pub fn a_func() {}</code></pre>
<p>And you have an example calling this function:</p>
<pre><code class="language-rust ignore (needs-other-file)">// a_crate/examples/ex.rs
fn main() {
  a_crate::a_func();
}</code></pre>
<p>Then this code snippet will be included in the documentation for <code>a_func</code>. This documentation is inserted by Rustdoc and cannot be manually edited by the crate author.</p>
<h2 id="how-to-use-this-feature"><a class="header" href="#how-to-use-this-feature">How to use this feature</a></h2>
<p>This feature is unstable, so you can enable it by calling Rustdoc with the unstable <code>rustdoc-scrape-examples</code> flag:</p>
<pre><code class="language-bash">cargo doc -Zunstable-options -Zrustdoc-scrape-examples
</code></pre>
<p>To enable this feature on <a href="https://docs.rs">docs.rs</a>, add this to your Cargo.toml:</p>
<pre><code class="language-toml">[package.metadata.docs.rs]
cargo-args = ["-Zunstable-options", "-Zrustdoc-scrape-examples"]
</code></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>When you run <code>cargo doc</code>, Rustdoc will analyze all the crates that match Cargo‚Äôs <code>--examples</code> filter for instances of items being documented. Then Rustdoc will include the source code of these instances in the generated documentation.</p>
<p>Rustdoc has a few techniques to ensure these examples don‚Äôt overwhelm documentation readers, and that it doesn‚Äôt blow up the page size:</p>
<ol>
<li>For a given item, a maximum of 5 examples are included in the page. The remaining examples are just links to source code.</li>
<li>Only one example is shown by default, and the remaining examples are hidden behind a toggle.</li>
<li>For a given file that contains examples, only the item containing the examples will be included in the generated documentation.</li>
</ol>
<p>For a given item, Rustdoc sorts its examples based on the size of the example ‚Äî smaller ones are shown first.</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="my-example-is-not-showing-up-in-the-documentation"><a class="header" href="#my-example-is-not-showing-up-in-the-documentation">My example is not showing up in the documentation</a></h3>
<p>This feature uses Cargo‚Äôs convention for finding examples. You should ensure that <code>cargo check --examples</code> includes your example file.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced features</a></h1>
<p>The features listed on this page fall outside the rest of the main categories.</p>
<h2 id="cfgdoc-documenting-platform-specific-or-feature-specific-information"><a class="header" href="#cfgdoc-documenting-platform-specific-or-feature-specific-information"><code>#[cfg(doc)]</code>: Documenting platform-specific or feature-specific information</a></h2>
<p>For conditional compilation, Rustdoc treats your crate the same way the compiler does. Only things
from the host target are available (or from the given <code>--target</code> if present), and everything else is
‚Äúfiltered out‚Äù from the crate. This can cause problems if your crate is providing different things
on different targets and you want your documentation to reflect all the available items you
provide.</p>
<p>If you want to make sure an item is seen by Rustdoc regardless of what platform it‚Äôs targeting,
you can apply <code>#[cfg(doc)]</code> to it. Rustdoc sets this whenever it‚Äôs building documentation, so
anything that uses that flag will make it into documentation it generates. To apply this to an item
with other <code>#[cfg]</code> filters on it, you can write something like <code>#[cfg(any(windows, doc))]</code>.
This will preserve the item either when built normally on Windows, or when being documented
anywhere.</p>
<p>Please note that this <code>cfg</code> is not passed to doctests.</p>
<p>Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Token struct that can only be used on Windows.
#[cfg(any(windows, doc))]
pub struct WindowsToken;
/// Token struct that can only be used on Unix.
#[cfg(any(unix, doc))]
pub struct UnixToken;
<span class="boring">}</span></code></pre>
<p>Here, the respective tokens can only be used by dependent crates on their respective platforms, but
they will both appear in documentation.</p>
<h3 id="interactions-between-platform-specific-docs"><a class="header" href="#interactions-between-platform-specific-docs">Interactions between platform-specific docs</a></h3>
<p>Rustdoc does not have a magic way to compile documentation ‚Äòas-if‚Äô you‚Äôd run it once for each
platform (such a magic wand has been called the <a href="https://github.com/rust-lang/rust/issues/1998">‚Äòholy grail of rustdoc‚Äô</a>). Instead,
it sees <em>all</em> of your code at once, the same way the Rust compiler would if you passed it
<code>--cfg doc</code>. The main difference is that rustdoc doesn‚Äôt run all the compiler passes, meaning
that some invalid code won‚Äôt emit an error.</p>
<h2 id="add-aliases-for-an-item-in-documentation-search"><a class="header" href="#add-aliases-for-an-item-in-documentation-search">Add aliases for an item in documentation search</a></h2>
<p>This feature allows you to add alias(es) to an item when using the <code>rustdoc</code> search through the
<code>doc(alias)</code> attribute. Example:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc(alias = "x")]
#[doc(alias = "big")]
pub struct BigX;
<span class="boring">}</span></code></pre>
<p>Then, when looking for it through the <code>rustdoc</code> search, if you enter ‚Äúx‚Äù or
‚Äúbig‚Äù, search will show the <code>BigX</code> struct first.</p>
<p>There are some limitations on the doc alias names though: they cannot contain quotes (<code>'</code>, <code>"</code>)
or most whitespace. ASCII space is allowed if it does not start or end the alias.</p>
<p>You can add multiple aliases at the same time by using a list:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc(alias("x", "big"))]
pub struct BigX;
<span class="boring">}</span></code></pre>
<h2 id="custom-search-engines"><a class="header" href="#custom-search-engines">Custom search engines</a></h2>
<p>If you find yourself often referencing online Rust docs you might enjoy using a custom search
engine. This allows you to use the navigation bar directly to search a <code>rustdoc</code> website.
Most browsers support this feature by letting you define a URL template containing <code>%s</code>
which will be substituted for the search term. As an example, for the standard library you could use
this template:</p>
<pre><code class="language-text">https://doc.rust-lang.org/stable/std/?search=%s
</code></pre>
<p>Note that this will take you to a results page listing all matches. If you want to navigate to the first
result right away (which is often the best match) use the following instead:</p>
<pre><code class="language-text">https://doc.rust-lang.org/stable/std/?search=%s&amp;go_to_first=true
</code></pre>
<p>This URL adds the <code>go_to_first=true</code> query parameter which can be appended to any <code>rustdoc</code> search URL
to automatically go to the first result.</p>
<h2 id="repr-documenting-the-representation-of-a-type"><a class="header" href="#repr-documenting-the-representation-of-a-type"><code>#[repr(...)]</code>: Documenting the representation of a type</a></h2>
<p>Generally, rustdoc only displays the representation of a given type if none of its variants are
<code>#[doc(hidden)]</code> and if all of its fields are public and not <code>#[doc(hidden)]</code> since it‚Äôs likely
not meant to be considered part of the public ABI otherwise.</p>
<p>Note that there‚Äôs no way to overwrite that heuristic and force rustdoc to show the representation
regardless.</p>
<h3 id="reprtransparent"><a class="header" href="#reprtransparent"><code>#[repr(transparent)]</code></a></h3>
<p>You can read more about <code>#[repr(transparent)]</code> itself in the <a href="https://doc.rust-lang.org/reference/type-layout.html#the-transparent-representation">Rust Reference</a> and
in the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent">Rustonomicon</a>.</p>
<p>Since this representation is only considered part of the public ABI if the single field with non-trivial
size or alignment is public and if the documentation does not state otherwise, rustdoc helpfully displays
the attribute if and only if the non-1-ZST field is public and not <code>#[doc(hidden)]</code> or
‚Äì in case all fields are 1-ZST fields ‚Äî at least one field is public and not <code>#[doc(hidden)]</code>.
The term <em>1-ZST</em> refers to types that are one-aligned and zero-sized.</p>
<p>It would seem that one can manually hide the attribute with <code>#[cfg_attr(not(doc), repr(transparent))]</code>
if one wishes to declare the representation as private even if the non-1-ZST field is public.
However, due to <a href="https://github.com/rust-lang/rust/issues/114952">current limitations</a>, this method is not always guaranteed to work.
Therefore, if you would like to do so, you should always write that down in prose independently of whether
you use <code>cfg_attr</code> or not.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable features</a></h1>
<p>Rustdoc is under active development, and like the Rust compiler, some features are only available
on nightly releases. Some of these features are new and need some more testing before they‚Äôre able to be
released to the world at large, and some of them are tied to features in the Rust compiler that are unstable. Several features here require a matching <code>#![feature(...)]</code> attribute to
enable, and thus are more fully documented in the <a href="../unstable-book/index.html">Unstable Book</a>. Those sections will link over
there as necessary.</p>
<h2 id="nightly-gated-functionality"><a class="header" href="#nightly-gated-functionality">Nightly-gated functionality</a></h2>
<p>These features just require a nightly build to operate. Unlike the other features on this page,
these don‚Äôt need to be ‚Äúturned on‚Äù with a command-line flag or a <code>#![feature(...)]</code> attribute in
your crate. This can give them some subtle fallback modes when used on a stable release, so be
careful!</p>
<h3 id="error-numbers-for-compile-fail-doctests"><a class="header" href="#error-numbers-for-compile-fail-doctests">Error numbers for <code>compile-fail</code> doctests</a></h3>
<p>As detailed in <a href="#attributes-1">the chapter on documentation tests</a>, you can add a
<code>compile_fail</code> attribute to a doctest to state that the test should fail to compile. However, on
nightly, you can optionally add an error number to state that a doctest should emit a specific error
number:</p>
<pre><code class="language-markdown">```compile_fail,E0044
extern { fn some_func&lt;T&gt;(x: T); }
```
</code></pre>
<p>This is used by the error index to ensure that the samples that correspond to a given error number
properly emit that error code. However, these error codes aren‚Äôt guaranteed to be the only thing
that a piece of code emits from version to version, so this is unlikely to be stabilized in the
future.</p>
<p>Attempting to use these error numbers on stable will result in the code sample being interpreted as
plain text.</p>
<h3 id="missing_doc_code_examples-lint"><a class="header" href="#missing_doc_code_examples-lint"><code>missing_doc_code_examples</code> lint</a></h3>
<p>This lint will emit a warning if an item doesn‚Äôt have a code example in its documentation.
It can be enabled using:</p>
<pre><code class="language-rust ignore (nightly)">#![deny(rustdoc::missing_doc_code_examples)]</code></pre>
<p>It is not emitted for items that cannot be instantiated/called such as fields, variants, modules,
associated trait/impl items, impl blocks, statics and constants.
It is also not emitted for foreign items, aliases, extern crates and imports.</p>
<h2 id="extensions-to-the-doc-attribute"><a class="header" href="#extensions-to-the-doc-attribute">Extensions to the <code>#[doc]</code> attribute</a></h2>
<p>These features operate by extending the <code>#[doc]</code> attribute, and thus can be caught by the compiler
and enabled with a <code>#![feature(...)]</code> attribute in your crate.</p>
<h3 id="adding-your-trait-to-the-notable-traits-dialog"><a class="header" href="#adding-your-trait-to-the-notable-traits-dialog">Adding your trait to the ‚ÄúNotable traits‚Äù dialog</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/45040">#45040</a></li>
</ul>
<p>Rustdoc keeps a list of a few traits that are believed to be ‚Äúfundamental‚Äù to
types that implement them. These traits are intended to be the primary interface
for their implementers, and are often most of the API available to be documented
on their types. For this reason, Rustdoc will track when a given type implements
one of these traits and call special attention to it when a function returns one
of these types. This is the ‚ÄúNotable traits‚Äù dialog, accessible as a circled <code>i</code>
button next to the function, which, when clicked, shows the dialog.</p>
<p>In the standard library, some of the traits that are part of this list are
<code>Iterator</code>, <code>Future</code>, <code>io::Read</code>, and <code>io::Write</code>. However, rather than being
implemented as a hard-coded list, these traits have a special marker attribute
on them: <code>#[doc(notable_trait)]</code>. This means that you can apply this attribute
to your own trait to include it in the ‚ÄúNotable traits‚Äù dialog in documentation.</p>
<p>The <code>#[doc(notable_trait)]</code> attribute currently requires the <code>#![feature(doc_notable_trait)]</code>
feature gate. For more information, see <a href="../unstable-book/language-features/doc-notable-trait.html">its chapter in the Unstable Book</a>
and <a href="https://github.com/rust-lang/rust/issues/45040">its tracking issue</a>.</p>
<h3 id="exclude-certain-dependencies-from-documentation"><a class="header" href="#exclude-certain-dependencies-from-documentation">Exclude certain dependencies from documentation</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/44027">#44027</a></li>
</ul>
<p>The standard library uses several dependencies which, in turn, use several types and traits from the
standard library. In addition, there are several compiler-internal crates that are not considered to
be part of the official standard library, and thus would be a distraction to include in
documentation. It‚Äôs not enough to exclude their crate documentation, since information about trait
implementations appears on the pages for both the type and the trait, which can be in different
crates!</p>
<p>To prevent internal types from being included in documentation, the standard library adds an
attribute to their <code>extern crate</code> declarations: <code>#[doc(masked)]</code>. This causes Rustdoc to ‚Äúmask out‚Äù
types from these crates when building lists of trait implementations.</p>
<p>The <code>#[doc(masked)]</code> attribute is intended to be used internally, and requires the
<code>#![feature(doc_masked)]</code> feature gate.  For more information, see <a href="../unstable-book/language-features/doc-masked.html">its chapter in the Unstable
Book</a> and <a href="https://github.com/rust-lang/rust/issues/44027">its tracking issue</a>.</p>
<h3 id="document-primitives"><a class="header" href="#document-primitives">Document primitives</a></h3>
<p>This is for Rust compiler internal use only.</p>
<p>Since primitive types are defined in the compiler, there‚Äôs no place to attach documentation
attributes. The <code>#[rustc_doc_primitive = "..."]</code> attribute is used by the standard library to
provide a way to generate documentation for primitive types, and requires <code>#![feature(rustc_attrs)]</code>
to enable.</p>
<h3 id="document-keywords"><a class="header" href="#document-keywords">Document keywords</a></h3>
<p>This is for internal use in the std library.</p>
<p>Rust keywords are documented in the standard library (look for <code>match</code> for example).</p>
<p>To do so, the <code>#[doc(keyword = "...")]</code> attribute is used. Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(rustdoc_internals)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>/// Some documentation about the keyword.
#[doc(keyword = "break")]
mod empty_mod {}
<span class="boring">}</span></code></pre>
<h3 id="document-builtin-attributes"><a class="header" href="#document-builtin-attributes">Document builtin attributes</a></h3>
<p>This is for internal use in the std library.</p>
<p>Rust builtin attributes are documented in the standard library (look for <code>repr</code> for example).</p>
<p>To do so, the <code>#[doc(attribute = "...")]</code> attribute is used. Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(rustdoc_internals)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>/// Some documentation about the attribute.
#[doc(attribute = "repr")]
mod empty_mod {}
<span class="boring">}</span></code></pre>
<h3 id="use-the-rust-logo-as-the-crate-logo"><a class="header" href="#use-the-rust-logo-as-the-crate-logo">Use the Rust logo as the crate logo</a></h3>
<p>This is for official Rust project use only.</p>
<p>Internal Rustdoc pages like settings.html and scrape-examples-help.html show the Rust logo.
This logo is tracked as a static resource. The attribute <code>#![doc(rust_logo)]</code> makes this same
built-in resource act as the main logo.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(rustdoc_internals)]
#![allow(internal_features)]
#![doc(rust_logo)]
<span class="boring">fn main() {
</span>//! This crate has the Rust(tm) branding on it.
<span class="boring">}</span></code></pre>
<h2 id="effects-of-other-nightly-features"><a class="header" href="#effects-of-other-nightly-features">Effects of other nightly features</a></h2>
<p>These nightly-only features are not primarily related to Rustdoc,
but have convenient effects on the documentation produced.</p>
<h3 id="fundamental-types"><a class="header" href="#fundamental-types"><code>fundamental</code> types</a></h3>
<p>Annotating a type with <code>#[fundamental]</code> primarily influences coherence rules about generic types,
i.e., they alter whether other crates can provide implementations for that type.
The unstable book <a href="https://doc.rust-lang.org/unstable-book/language-features/fundamental.html">links to further information</a>.</p>
<p>For documentation, this has an additional side effect:
If a method is implemented on <code>F&lt;T&gt;</code> (or <code>F&lt;&amp;T&gt;</code>),
where <code>F</code> is a fundamental type,
then the method is not only documented at the page about <code>F</code>,
but also on the page about <code>T</code>.
In a sense, it makes the type transparent to Rustdoc.
This is especially convenient for types that work as annotated pointers,
such as <code>Pin&lt;&amp;mut T&gt;</code>,
as it ensures that methods only implemented through those annotated pointers
can still be found with the type they act on.</p>
<p>If the <code>fundamental</code> feature‚Äôs effect on coherence is not intended,
such a type can be marked as fundamental only for purposes of documentation
by introducing a custom feature and
limiting the use of <code>fundamental</code> to when documentation is built.</p>
<h2 id="unstable-command-line-arguments"><a class="header" href="#unstable-command-line-arguments">Unstable command-line arguments</a></h2>
<p>These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are
themselves marked as unstable. To use any of these options, pass <code>-Z unstable-options</code> as well as
the flag in question to Rustdoc on the command-line. To do this from Cargo, you can either use the
<code>RUSTDOCFLAGS</code> environment variable or the <code>cargo rustdoc</code> command.</p>
<h3 id="--merge---parts-out-dir-and---include-parts-dir"><a class="header" href="#--merge---parts-out-dir-and---include-parts-dir"><code>--merge</code>, <code>--parts-out-dir</code>, and <code>--include-parts-dir</code></a></h3>
<p>These options control how rustdoc handles files that combine data from multiple crates.</p>
<p>By default, they act like <code>--merge=shared</code> is set, and <code>--parts-out-dir</code> and <code>--include-parts-dir</code>
are turned off. The <code>--merge=shared</code> mode causes rustdoc to load the existing data in the out-dir,
combine the new crate data into it, and write the result. This is very easy to use in scripts that
manually invoke rustdoc, but it‚Äôs also slow, because it performs O(crates) work on
every crate, meaning it performs O(crates<sup>2</sup>) work.</p>
<pre><code class="language-console">$ rustdoc crate1.rs --out-dir=doc
$ cat doc/search.index/crateNames/*
rd_("fcrate1")
$ rustdoc crate2.rs --out-dir=doc
$ cat doc/search.index/crateNames/*
rd_("fcrate1fcrate2")
</code></pre>
<p>To delay shared-data merging until the end of a build, so that you only have to perform O(crates)
work, use <code>--merge=none</code> on every crate except the last one, which will use <code>--merge=finalize</code>.</p>
<pre><code class="language-console">$ rustdoc +nightly crate1.rs --merge=none --parts-out-dir=crate1.d -Zunstable-options
$ cat doc/search.index/crateNames/*
cat: 'doc/search.index/crateNames/*': No such file or directory
$ rustdoc +nightly crate2.rs --merge=finalize --include-parts-dir=crate1.d -Zunstable-options
$ cat doc/search.index/crateNames/*
rd_("fcrate1fcrate2")
</code></pre>
<h3 id="--document-hidden-items-show-items-that-are-dochidden"><a class="header" href="#--document-hidden-items-show-items-that-are-dochidden"><code>--document-hidden-items</code>: Show items that are <code>#[doc(hidden)]</code></a></h3>
<p><span id="document-hidden-items"></span></p>
<p>By default, <code>rustdoc</code> does not document items that are annotated with
<a href="#hidden"><code>#[doc(hidden)]</code></a>.</p>
<p><code>--document-hidden-items</code> causes all items to be documented as if they did not have <code>#[doc(hidden)]</code>, except that hidden items will be shown with a üëª icon.</p>
<p>Here is a table that fully describes which items are documented with each combination of <code>--document-hidden-items</code> and <code>--document-private-items</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>rustdoc flags</th><th>items that will be documented</th></tr>
</thead>
<tbody>
<tr><td>neither flag</td><td>only public items that are not hidden</td></tr>
<tr><td>only <code>--document-hidden-items</code></td><td>all public items</td></tr>
<tr><td>only <code>--document-private-items</code></td><td>all items that are not hidden</td></tr>
<tr><td>both flags</td><td>all items</td></tr>
</tbody>
</table>
</div>
<h3 id="--markdown-before-content-include-rendered-markdown-before-the-content"><a class="header" href="#--markdown-before-content-include-rendered-markdown-before-the-content"><code>--markdown-before-content</code>: include rendered Markdown before the content</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/44027">#44027</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --markdown-before-content extra.md
$ rustdoc README.md -Z unstable-options --markdown-before-content extra.md
</code></pre>
<p>Just like <code>--html-before-content</code>, this allows you to insert extra content inside the <code>&lt;body&gt;</code> tag
but before the other content <code>rustdoc</code> would normally produce in the rendered documentation.
However, instead of directly inserting the file verbatim, <code>rustdoc</code> will pass the files through a
Markdown renderer before inserting the result into the file.</p>
<h3 id="--markdown-after-content-include-rendered-markdown-after-the-content"><a class="header" href="#--markdown-after-content-include-rendered-markdown-after-the-content"><code>--markdown-after-content</code>: include rendered Markdown after the content</a></h3>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --markdown-after-content extra.md
$ rustdoc README.md -Z unstable-options --markdown-after-content extra.md
</code></pre>
<p>Just like <code>--html-after-content</code>, this allows you to insert extra content before the <code>&lt;/body&gt;</code> tag
but after the other content <code>rustdoc</code> would normally produce in the rendered documentation.
However, instead of directly inserting the file verbatim, <code>rustdoc</code> will pass the files through a
Markdown renderer before inserting the result into the file.</p>
<h3 id="--playground-url-control-the-location-of-the-playground"><a class="header" href="#--playground-url-control-the-location-of-the-playground"><code>--playground-url</code>: control the location of the playground</a></h3>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --playground-url https://play.rust-lang.org/
</code></pre>
<p>When rendering a crate‚Äôs docs, this flag gives the base URL of the Rust Playground, to use for
generating <code>Run</code> buttons. Unlike <code>--markdown-playground-url</code>, this argument works for standalone
Markdown files <em>and</em> Rust crates. This works the same way as adding <code>#![doc(html_playground_url = "url")]</code> to your crate root, as mentioned in <a href="#html_playground_url">the chapter about the <code>#[doc]</code>
attribute</a>. Please be aware that the official Rust Playground at
https://play.rust-lang.org does not have every crate available, so if your examples require your
crate, make sure the playground you provide has your crate available.</p>
<p>If both <code>--playground-url</code> and <code>--markdown-playground-url</code> are present when rendering a standalone
Markdown file, the URL given to <code>--markdown-playground-url</code> will take precedence. If both
<code>--playground-url</code> and <code>#![doc(html_playground_url = "url")]</code> are present when rendering crate docs,
the attribute will take precedence.</p>
<h2 id="--sort-modules-by-appearance-control-how-items-on-module-pages-are-sorted"><a class="header" href="#--sort-modules-by-appearance-control-how-items-on-module-pages-are-sorted"><code>--sort-modules-by-appearance</code>: control how items on module pages are sorted</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --sort-modules-by-appearance
</code></pre>
<p>Ordinarily, when <code>rustdoc</code> prints items in module pages, it will sort them alphabetically (taking
some consideration for their stability, and names that end in a number). Giving this flag to
<code>rustdoc</code> will disable this sorting and instead make it print the items in the order they appear in
the source.</p>
<h2 id="--show-type-layout-add-a-section-to-each-types-docs-describing-its-memory-layout"><a class="header" href="#--show-type-layout-add-a-section-to-each-types-docs-describing-its-memory-layout"><code>--show-type-layout</code>: add a section to each type‚Äôs docs describing its memory layout</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/113248">#113248</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --show-type-layout
</code></pre>
<p>When this flag is passed, rustdoc will add a ‚ÄúLayout‚Äù section at the bottom of
each type‚Äôs docs page that includes a summary of the type‚Äôs memory layout as
computed by rustc. For example, rustdoc will show the size in bytes that a value
of that type will take in memory.</p>
<p>Note that most layout information is <strong>completely unstable</strong> and may even differ
between compilations.</p>
<h2 id="--resource-suffix-modifying-the-name-of-cssjavascript-in-crate-docs"><a class="header" href="#--resource-suffix-modifying-the-name-of-cssjavascript-in-crate-docs"><code>--resource-suffix</code>: modifying the name of CSS/JavaScript in crate docs</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/54765">#54765</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --resource-suffix suf
</code></pre>
<p>When rendering docs, <code>rustdoc</code> creates several CSS and JavaScript files as part of the output. Since
all these files are linked from every page, changing where they are can be cumbersome if you need to
specially cache them. This flag will rename all these files in the output to include the suffix in
the filename. For example, <code>light.css</code> would become <code>light-suf.css</code> with the above command.</p>
<h2 id="--extern-html-root-url-control-how-rustdoc-links-to-non-local-crates"><a class="header" href="#--extern-html-root-url-control-how-rustdoc-links-to-non-local-crates"><code>--extern-html-root-url</code>: control how rustdoc links to non-local crates</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --extern-html-root-url some-crate=https://example.com/some-crate/1.0.1
</code></pre>
<p>Ordinarily, when rustdoc wants to link to a type from a different crate, it looks in two places:
docs that already exist in the output directory, or the <code>#![doc(doc_html_root)]</code> set in the other
crate. However, if you want to link to docs that exist in neither of those places, you can use these
flags to control that behavior. When the <code>--extern-html-root-url</code> flag is given with a name matching
one of your dependencies, rustdoc use that URL for those docs. Keep in mind that if those docs exist
in the output directory, those local docs will still override this flag.</p>
<p>The names in this flag are first matched against the names given in the <code>--extern name=</code> flags,
which allows selecting between multiple crates with the same name (e.g. multiple versions of
the same crate). For transitive dependencies that haven‚Äôt been loaded via an <code>--extern</code> flag, matching
falls backs to using crate names only, without ability to distinguish between multiple crates with
the same name.</p>
<h2 id="-z-force-unstable-if-unmarked"><a class="header" href="#-z-force-unstable-if-unmarked"><code>-Z force-unstable-if-unmarked</code></a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z force-unstable-if-unmarked
</code></pre>
<p>This is an internal flag intended for the standard library and compiler that applies an
<code>#[unstable]</code> attribute to any dependent crate that doesn‚Äôt have another stability attribute. This
allows <code>rustdoc</code> to be able to generate documentation for the compiler crates and the standard
library, as an equivalent command-line argument is provided to <code>rustc</code> when building those crates.</p>
<h2 id="--index-page-provide-a-top-level-landing-page-for-docs"><a class="header" href="#--index-page-provide-a-top-level-landing-page-for-docs"><code>--index-page</code>: provide a top-level landing page for docs</a></h2>
<p>This feature allows you to generate an index-page with a given markdown file. A good example of it
is the <a href="https://doc.rust-lang.org/nightly/index.html">rust documentation index</a>.</p>
<p>With this, you‚Äôll have a page which you can customize as much as you want at the top of your crates.</p>
<p>Using <code>index-page</code> option enables <code>enable-index-page</code> option as well.</p>
<h2 id="--enable-index-page-generate-a-default-index-page-for-docs"><a class="header" href="#--enable-index-page-generate-a-default-index-page-for-docs"><code>--enable-index-page</code>: generate a default index page for docs</a></h2>
<p>This feature allows the generation of a default index-page which lists the generated crates.</p>
<h2 id="--no-capture-disable-output-capture-for-test"><a class="header" href="#--no-capture-disable-output-capture-for-test"><code>--no-capture</code>: disable output capture for test</a></h2>
<p>When this flag is used with <code>--test</code>, the output (stdout and stderr) of your tests won‚Äôt be
captured by rustdoc. Instead, the output will be directed to your terminal,
as if you had run the test executable manually. This is especially useful
for debugging your tests!</p>
<h2 id="--check-only-checks-the-documentation"><a class="header" href="#--check-only-checks-the-documentation"><code>--check</code>: only checks the documentation</a></h2>
<p>When this flag is supplied, rustdoc will type check and lint your code, but will not generate any
documentation or run your doctests.</p>
<p>Using this flag looks like:</p>
<pre><code class="language-bash">rustdoc -Z unstable-options --check src/lib.rs
</code></pre>
<h2 id="--static-root-path-control-how-static-files-are-loaded-in-html-output"><a class="header" href="#--static-root-path-control-how-static-files-are-loaded-in-html-output"><code>--static-root-path</code>: control how static files are loaded in HTML output</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --static-root-path '/cache/'
</code></pre>
<p>This flag controls how rustdoc links to its static files on HTML pages. If you‚Äôre hosting a lot of
crates‚Äô docs generated by the same version of rustdoc, you can use this flag to cache rustdoc‚Äôs CSS,
JavaScript, and font files in a single location, rather than duplicating it once per ‚Äúdoc root‚Äù
(grouping of crate docs generated into the same output directory, like with <code>cargo doc</code>). Per-crate
files like the search index will still load from the documentation root, but anything that gets
renamed with <code>--resource-suffix</code> will load from the given path.</p>
<h2 id="--persist-doctests-persist-doctest-executables-after-running"><a class="header" href="#--persist-doctests-persist-doctest-executables-after-running"><code>--persist-doctests</code>: persist doctest executables after running</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/56925">#56925</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test -Z unstable-options --persist-doctests target/rustdoctest
</code></pre>
<p>This flag allows you to keep doctest executables around after they‚Äôre compiled or run.
Usually, rustdoc will immediately discard a compiled doctest after it‚Äôs been tested, but
with this option, you can keep those binaries around for farther testing.</p>
<h2 id="--show-coverage-calculate-the-percentage-of-items-with-documentation"><a class="header" href="#--show-coverage-calculate-the-percentage-of-items-with-documentation"><code>--show-coverage</code>: calculate the percentage of items with documentation</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/58154">#58154</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --show-coverage
</code></pre>
<p>It generates something like this:</p>
<pre><code class="language-bash">+-------------------------------------+------------+------------+------------+------------+
| File                                | Documented | Percentage |   Examples | Percentage |
+-------------------------------------+------------+------------+------------+------------+
| lib.rs                              |          4 |     100.0% |          1 |      25.0% |
+-------------------------------------+------------+------------+------------+------------+
| Total                               |          4 |     100.0% |          1 |      25.0% |
+-------------------------------------+------------+------------+------------+------------+
</code></pre>
<p>If you want to determine how many items in your crate are documented, pass this flag to rustdoc.
When it receives this flag, it will count the public items in your crate that have documentation,
and print out the counts and a percentage instead of generating docs.</p>
<p>Some methodology notes about what rustdoc counts in this metric:</p>
<ul>
<li>Rustdoc will only count items from your crate (i.e. items re-exported from other crates don‚Äôt
count).</li>
<li>Docs written directly onto inherent impl blocks are not counted, even though their doc comments
are displayed, because the common pattern in Rust code is to write all inherent methods into the
same impl block.</li>
<li>Items in a trait implementation are not counted, as those impls will inherit any docs from the
trait itself.</li>
<li>By default, only public items are counted. To count private items as well, pass
<code>--document-private-items</code> at the same time.</li>
</ul>
<p>Public items that are not documented can be seen with the built-in <code>missing_docs</code> lint. Private
items that are not documented can be seen with Clippy‚Äôs <code>missing_docs_in_private_items</code> lint.</p>
<p>Calculating code examples follows these rules:</p>
<ol>
<li>These items aren‚Äôt accounted by default:</li>
</ol>
<ul>
<li>struct/union field</li>
<li>enum variant</li>
<li>constant</li>
<li>static</li>
<li>typedef</li>
</ul>
<ol start="2">
<li>If one of the previously listed items has a code example, then it‚Äôll be counted.</li>
</ol>
<h3 id="json-output"><a class="header" href="#json-output">JSON output</a></h3>
<p>When using <code>--output-format json</code> with this option, it will display the coverage information in
JSON format. For example, here is the JSON for a file with one documented item and one
undocumented item:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This item has documentation
pub fn foo() {}

pub fn no_documentation() {}
<span class="boring">}</span></code></pre>
<pre><code class="language-json">{"no_std.rs":{"total":3,"with_docs":1,"total_examples":3,"with_examples":0}}
</code></pre>
<p>Note that the third item is the crate root, which in this case is undocumented.</p>
<p>If you want the JSON output to be displayed on <code>stdout</code> instead of having a file generated, you can
use <code>-o -</code>.</p>
<h2 id="-w--output-format-output-format"><a class="header" href="#-w--output-format-output-format"><code>-w</code>/<code>--output-format</code>: output format</a></h2>
<h3 id="json"><a class="header" href="#json">json</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/76578">#76578</a></li>
</ul>
<p><code>--output-format json</code> emits documentation in the experimental
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">JSON format</a>.</p>
<p>JSON Output for toolchain crates (<code>std</code>, <code>alloc</code>, <code>core</code>, <code>test</code>, and <code>proc_macro</code>)
is available via the <code>rust-docs-json</code> rustup component.</p>
<pre><code class="language-shell">rustup component add --toolchain nightly rust-docs-json
</code></pre>
<p>Then the json files will be present in the <code>share/doc/rust/json/</code> directory
of the rustup toolchain directory.</p>
<p>It can also be used with <code>--show-coverage</code>. Take a look at its
<a href="#--show-coverage-calculate-the-percentage-of-items-with-documentation">documentation</a> for more
information.</p>
<h3 id="doctest"><a class="header" href="#doctest">doctest</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/134529">#134529</a></li>
</ul>
<p><code>--output-format doctest</code> emits JSON on stdout which gives you information about doctests in the
provided crate.</p>
<p>You can use this option like this:</p>
<pre><code class="language-bash">rustdoc -Zunstable-options --output-format=doctest src/lib.rs
</code></pre>
<p>For this rust code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// #![allow(dead_code)]
/// let x = 12;
/// Ok(())
/// ```
pub trait Trait {}
<span class="boring">}</span></code></pre>
<p>The generated output (formatted) will look like this:</p>
<pre><code class="language-json">{
  "format_version": 2,
  "doctests": [
    {
      "file": "src/lib.rs",
      "line": 1,
      "doctest_attributes": {
        "original": "",
        "should_panic": false,
        "no_run": false,
        "ignore": "None",
        "rust": true,
        "test_harness": false,
        "compile_fail": false,
        "standalone_crate": false,
        "error_codes": [],
        "edition": null,
        "added_css_classes": [],
        "unknown": []
      },
      "original_code": "#![allow(dead_code)]\nlet x = 12;\nOk(())",
      "doctest_code": {
        "crate_level": "#![allow(unused)]\n#![allow(dead_code)]\n\n",
        "code": "let x = 12;\nOk(())",
        "wrapper": {
          "before": "fn main() { fn _inner() -&gt; core::result::Result&lt;(), impl core::fmt::Debug&gt; {\n",
          "after": "\n} _inner().unwrap() }",
          "returns_result": true
        }
      },
      "name": "src/lib.rs - (line 1)"
    }
  ]
}
</code></pre>
<ul>
<li><code>format_version</code> gives you the current version of the generated JSON. If we change the output in any way, the number will increase.</li>
<li><code>doctests</code> contains the list of doctests present in the crate.
<ul>
<li><code>file</code> is the file path where the doctest is located.</li>
<li><code>line</code> is the line where the doctest starts (so where the ``` is located in the current code).</li>
<li><code>doctest_attributes</code> contains computed information about the attributes used on the doctests. For more information about doctest attributes, take a look <a href="#attributes-1">here</a>.</li>
<li><code>original_code</code> is the code as written in the source code before rustdoc modifies it.</li>
<li><code>doctest_code</code> is the code modified by rustdoc that will be run. If there is a fatal syntax error, this field will not be present.
<ul>
<li><code>crate_level</code> is the crate level code (like attributes or <code>extern crate</code>) that will be added at the top-level of the generated doctest.</li>
<li><code>code</code> is ‚Äúnaked‚Äù doctest without anything from <code>crate_level</code> and <code>wrapper</code> content.</li>
<li><code>wrapper</code> contains extra code that will be added before and after <code>code</code>.
<ul>
<li><code>returns_result</code> is a boolean. If <code>true</code>, it means that the doctest returns a <code>Result</code> type.</li>
</ul>
</li>
</ul>
</li>
<li><code>name</code> is the name generated by rustdoc which represents this doctest.</li>
</ul>
</li>
</ul>
<h3 id="html"><a class="header" href="#html">html</a></h3>
<p><code>--output-format html</code> has no effect, as the default output is HTML. This is
accepted on stable, even though the other options for this flag aren‚Äôt.</p>
<h2 id="--with-examples-include-examples-of-uses-of-items-as-documentation"><a class="header" href="#--with-examples-include-examples-of-uses-of-items-as-documentation"><code>--with-examples</code>: include examples of uses of items as documentation</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/88791">#88791</a></li>
</ul>
<p>This option, combined with <code>--scrape-examples-target-crate</code> and
<code>--scrape-examples-output-path</code>, is used to implement the functionality in <a href="https://github.com/rust-lang/rfcs/pull/3123">RFC
#3123</a>. Uses of an item (currently
functions / call-sites) are found in a crate and its reverse-dependencies, and
then the uses are included as documentation for that item. This feature is
intended to be used via <code>cargo doc --scrape-examples</code>, but the rustdoc-only
workflow looks like:</p>
<pre><code class="language-bash">$ rustdoc examples/ex.rs -Z unstable-options \
    --extern foobar=target/deps/libfoobar.rmeta \
    --scrape-examples-target-crate foobar \
    --scrape-examples-output-path output.calls
$ rustdoc src/lib.rs -Z unstable-options --with-examples output.calls
</code></pre>
<p>First, the library must be checked to generate an <code>rmeta</code>. Then a
reverse-dependency like <code>examples/ex.rs</code> is given to rustdoc with the target
crate being documented (<code>foobar</code>) and a path to output the calls
(<code>output.calls</code>). Then, the generated calls file can be passed via
<code>--with-examples</code> to the subsequent documentation of <code>foobar</code>.</p>
<p>To scrape examples from test code, e.g. functions marked <code>#[test]</code>, then
add the <code>--scrape-tests</code> flag.</p>
<h2 id="--generate-link-to-definition-generate-links-on-types-in-source-code"><a class="header" href="#--generate-link-to-definition-generate-links-on-types-in-source-code"><code>--generate-link-to-definition</code>: Generate links on types in source code</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/89095">#89095</a></li>
</ul>
<p>This flag enables the generation of links in the source code pages which allow the reader
to jump to a type definition.</p>
<h3 id="--test-builder-rustc-like-program-to-build-tests"><a class="header" href="#--test-builder-rustc-like-program-to-build-tests"><code>--test-builder</code>: <code>rustc</code>-like program to build tests</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/102981">#102981</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc --test-builder /path/to/rustc src/lib.rs
</code></pre>
<p>Rustdoc will use the provided program to compile tests instead of the default <code>rustc</code> program from
the sysroot.</p>
<h3 id="--test-builder-wrapper-wrap-calls-to-the-test-builder"><a class="header" href="#--test-builder-wrapper-wrap-calls-to-the-test-builder"><code>--test-builder-wrapper</code>: wrap calls to the test builder</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/102981">#102981</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -Zunstable-options --test-builder-wrapper /path/to/rustc-wrapper src/lib.rs
$ rustdoc -Zunstable-options \
    --test-builder-wrapper rustc-wrapper1 \
    --test-builder-wrapper rustc-wrapper2 \
    --test-builder rustc \
    src/lib.rs
</code></pre>
<p>Similar to cargo <code>build.rustc-wrapper</code> option, this flag takes a <code>rustc</code> wrapper program.
The first argument to the program will be the test builder program.</p>
<p>This flag can be passed multiple times to nest wrappers.</p>
<h2 id="passing-arguments-to-rustc-when-compiling-doctests"><a class="header" href="#passing-arguments-to-rustc-when-compiling-doctests">Passing arguments to rustc when compiling doctests</a></h2>
<p>You can use the <code>--doctest-build-arg</code> flag if you want to add options when compiling the
doctest. For example if you have:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// #![deny(warnings)]
/// #![feature(async_await)]
///
/// let x = 12;
/// ```
pub struct Bar;
<span class="boring">}</span></code></pre>
<p>And you run <code>rustdoc --test</code> on it, you will get:</p>
<pre><code class="language-console">running 1 test
test foo.rs - Bar (line 1) ... FAILED

failures:

---- foo.rs - Bar (line 1) stdout ----
error: the feature `async_await` has been stable since 1.39.0 and no longer requires an attribute to enable
 --&gt; foo.rs:2:12
  |
3 | #![feature(async_await)]
  |            ^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; foo.rs:1:9
  |
2 | #![deny(warnings)]
  |         ^^^^^^^^
  = note: `#[deny(stable_features)]` implied by `#[deny(warnings)]`

error: aborting due to 1 previous error

Couldn't compile the test.

failures:
    foo.rs - Bar (line 1)

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s
</code></pre>
<p>But if you can limit the lint level to warning by using <code>--doctest-build-arg=--cap-lints=warn</code>:</p>
<pre><code class="language-console">$ rustdoc --test --doctest-build-arg=--cap-lints=warn file.rs

running 1 test
test tests/rustdoc-ui/doctest/rustflags.rs - Bar (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.06s
</code></pre>
<p>In order to pass multiple arguments to the underlying compiler,
pass <code>--doctest-build-arg ARG</code> for each argument <code>ARG</code>.</p>
<h2 id="--generate-macro-expansion-generate-macros-expansion-toggles-in-source-code"><a class="header" href="#--generate-macro-expansion-generate-macros-expansion-toggles-in-source-code"><code>--generate-macro-expansion</code>: Generate macros expansion toggles in source code</a></h2>
<p>This flag enables the generation of toggles to expand macros in the HTML source code pages.</p>
<h2 id="doccfg-and-docauto_cfg"><a class="header" href="#doccfg-and-docauto_cfg"><code>#[doc(cfg)]</code> and <code>#[doc(auto_cfg)]</code></a></h2>
<p>This feature aims at providing rustdoc users the possibility to add visual markers to the rendered documentation to know under which conditions an item is available (currently possible through the following unstable feature: <code>doc_cfg</code>).</p>
<p>It does not aim to allow having a same item with different <code>cfg</code>s to appear more than once in the generated documentation.</p>
<p>It does not aim to document items which are <em>inactive</em> under the current configuration (i.e., ‚Äú<code>cfg</code>ed out‚Äù).</p>
<p>This features adds the following attributes:</p>
<ul>
<li><code>#[doc(auto_cfg)]</code>/<code>#[doc(auto_cfg = true)]</code>/<code>#[doc(auto_cfg = false)]</code></li>
<li><code>#[doc(cfg(...))]</code></li>
<li><code>#![doc(auto_cfg(hide(...)))]</code> / <code>#[doc(auto_cfg(show(...)))]</code></li>
</ul>
<p>All of these attributes can be added to a module or to the crate root, and they will be inherited by the child items unless another attribute overrides it. This is why ‚Äúopposite‚Äù attributes like <code>auto_cfg(hide(...))</code> and <code>auto_cfg(show(...))</code> are provided: they allow a child item to override its parent.</p>
<h3 id="doccfg"><a class="header" href="#doccfg"><code>#[doc(cfg(...))]</code></a></h3>
<p>This attribute provides a standardized format to override <code>#[cfg()]</code> attributes to document conditionally available items. Example:</p>
<pre><code class="language-rust ignore (nightly)">// the "real" cfg condition
#[cfg(feature = "futures-io")]
// the `doc(cfg())` so it's displayed to the readers
#[doc(cfg(feature = "futures-io"))]
pub mod futures {}</code></pre>
<p>It will display in the documentation for this module:</p>
<pre><code class="language-text">This is supported on feature="futures-io" only.
</code></pre>
<p>You can use it to display information in generated documentation, whether or not there is a <code>#[cfg()]</code> attribute:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(cfg(feature = "futures-io"))]
pub mod futures {}</code></pre>
<p>It will be displayed exactly the same as the previous code.</p>
<p>This attribute has the same syntax as conditional compilation, but it only causes documentation to be added. This means <code>#[doc(cfg(not(windows)))]</code> will not cause your docs to be hidden on non-windows targets, even though <code>#[cfg(not(windows))]</code> does do that.</p>
<p>If <code>doc(auto_cfg)</code> is enabled on the item, <code>doc(cfg)</code> will override it anyway so in the two previous examples, even if the <code>doc(auto_cfg)</code> feature was enabled, it would still display the same thing.</p>
<p>This attribute works on modules and on items.</p>
<h3 id="docauto_cfghide"><a class="header" href="#docauto_cfghide"><code>#[doc(auto_cfg(hide(...)))]</code></a></h3>
<p>This attribute is used to prevent some <code>cfg</code> to be generated in the visual markers. It only applies to <code>#[doc(auto_cfg = true)]</code>, not to <code>#[doc(cfg(...))]</code>. So in the previous example:</p>
<pre><code class="language-rust ignore (nightly)">#[cfg(any(unix, feature = "futures-io"))]
pub mod futures {}</code></pre>
<p>It currently displays both <code>unix</code> and <code>feature = "futures-io"</code> into the documentation, which is not great. To prevent the <code>unix</code> cfg to ever be displayed, you can use this attribute at the crate root level:</p>
<pre><code class="language-rust ignore (nightly)">#![doc(auto_cfg(hide(unix)))]</code></pre>
<p>Or directly on a given item/module as it covers any of the item‚Äôs descendants:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix)))]
#[cfg(any(unix, feature = "futures-io"))]
pub mod futures {
    // `futures` and all its descendants won't display "unix" in their cfgs.
}</code></pre>
<p>Then, the <code>unix</code> cfg will never be displayed into the documentation.</p>
<p>Rustdoc currently hides <code>doc</code> and <code>doctest</code> attributes by default and reserves the right to change the list of ‚Äúhidden by default‚Äù attributes.</p>
<p>The attribute accepts only a list of identifiers or key/value items. So you can write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix, doctest, feature = "something")))]
#[doc(auto_cfg(hide()))]</code></pre>
<p>But you cannot write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(not(unix))))]</code></pre>
<p>So if we use <code>doc(auto_cfg(hide(unix)))</code>, it means it will hide all mentions of <code>unix</code>:</p>
<pre><code class="language-rust ignore (nightly)">#[cfg(unix)] // nothing displayed
#[cfg(any(unix))] // nothing displayed
#[cfg(any(unix, windows))] // only `windows` displayed</code></pre>
<p>However, it only impacts the <code>unix</code> cfg, not the feature:</p>
<pre><code class="language-rust ignore (nightly)">#[cfg(feature = "unix")] // `feature = "unix"` is displayed</code></pre>
<p>If <code>cfg_auto(show(...))</code> and <code>cfg_auto(hide(...))</code> are used to show/hide a same <code>cfg</code> on a same item, it‚Äôll emit an error. Example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix)))]
#[doc(auto_cfg(show(unix)))] // Error!
pub fn foo() {}</code></pre>
<p>Using this attribute will re-enable <code>auto_cfg</code> if it was disabled at this location:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)] // Disabling `auto_cfg`
pub fn foo() {}</code></pre>
<p>And using <code>doc(auto_cfg)</code> will re-enable it:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)] // Disabling `auto_cfg`
pub mod module {
    #[doc(auto_cfg(hide(unix)))] // `auto_cfg` is re-enabled.
    pub fn foo() {}
}</code></pre>
<p>However, using <code>doc(auto_cfg = ...)</code> and <code>doc(auto_cfg(...))</code> on the same item will emit an error:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)]
#[doc(auto_cfg(hide(unix)))] // error
pub fn foo() {}</code></pre>
<p>The reason behind this is that <code>doc(auto_cfg = ...)</code> enables or disables the feature, whereas <code>doc(auto_cfg(...))</code> enables it unconditionally, making the first attribute to appear useless as it will be overidden by the next <code>doc(auto_cfg)</code> attribute.</p>
<h3 id="docauto_cfgshow"><a class="header" href="#docauto_cfgshow"><code>#[doc(auto_cfg(show(...)))]</code></a></h3>
<p>This attribute does the opposite of <code>#[doc(auto_cfg(hide(...)))]</code>: if you used <code>#[doc(auto_cfg(hide(...)))]</code> and want to revert its effect on an item and its descendants, you can use <code>#[doc(auto_cfg(show(...)))]</code>.
It only applies to <code>#[doc(auto_cfg = true)]</code>, not to <code>#[doc(cfg(...))]</code>.</p>
<p>For example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix)))]
#[cfg(any(unix, feature = "futures-io"))]
pub mod futures {
    // `futures` and all its descendants won't display "unix" in their cfgs.
    #[doc(auto_cfg(show(unix)))]
    pub mod child {
        // `child` and all its descendants will display "unix" in their cfgs.
    }
}</code></pre>
<p>The attribute accepts only a list of identifiers or key/value items. So you can write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(show(unix, doctest, feature = "something")))]
#[doc(auto_cfg(show()))]</code></pre>
<p>But you cannot write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(show(not(unix))))]</code></pre>
<p>If <code>auto_cfg(show(...))</code> and <code>auto_cfg(hide(...))</code> are used to show/hide a same <code>cfg</code> on a same item, it‚Äôll emit an error. Example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(show(unix)))]
#[doc(auto_cfg(hide(unix)))] // Error!
pub fn foo() {}</code></pre>
<p>Using this attribute will re-enable <code>auto_cfg</code> if it was disabled at this location:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)] // Disabling `auto_cfg`
#[doc(auto_cfg(show(unix)))] // `auto_cfg` is re-enabled.
pub fn foo() {}</code></pre>
<h3 id="docauto_cfgdocauto_cfg--truedocauto_cfg--false"><a class="header" href="#docauto_cfgdocauto_cfg--truedocauto_cfg--false"><code>#[doc(auto_cfg)</code>/<code>#[doc(auto_cfg = true)]</code>/<code>#[doc(auto_cfg = false)]</code></a></h3>
<p>By default, <code>#[doc(auto_cfg)]</code> is enabled at the crate-level. When it‚Äôs enabled, Rustdoc will automatically display <code>cfg(...)</code> compatibility information as-if the same <code>#[doc(cfg(...))]</code> had been specified.</p>
<p>This attribute impacts the item on which it is used and its descendants.</p>
<p>So if we take back the previous example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "futures-io")]
pub mod futures {}
<span class="boring">}</span></code></pre>
<p>There‚Äôs no need to ‚Äúduplicate‚Äù the <code>cfg</code> into a <code>doc(cfg())</code> to make Rustdoc display it.</p>
<p>In some situations, the detailed conditional compilation rules used to implement the feature might not serve as good documentation (for example, the list of supported platforms might be very long, and it might be better to document them in one place). To turn it off, add the <code>#[doc(auto_cfg = false)]</code> attribute on the item.</p>
<p>If no argument is specified (ie <code>#[doc(auto_cfg)]</code>), it‚Äôs the same as writing <code>#[doc(auto_cfg = true)]</code>.</p>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>Rustdoc merges <code>cfg</code> attributes from parent modules to its children. For example, in this case, the module <code>non_unix</code> will describe the entire compatibility matrix for the module, and not just its directly attached information:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(cfg(any(windows, unix)))]
pub mod desktop {
    #[doc(cfg(not(unix)))]
    pub mod non_unix {
        // ...
    }
}</code></pre>
<p>This code will display:</p>
<pre><code class="language-text">Available on (Windows or Unix) and non-Unix only.
</code></pre>
<h3 id="re-exports-and-inlining"><a class="header" href="#re-exports-and-inlining">Re-exports and inlining</a></h3>
<p><code>cfg</code> attributes of a re-export are never merged with the re-exported item(s) attributes except if the re-export has the <code>#[doc(inline)]</code> attribute. In this case, the <code>cfg</code> of the re-exported item will be merged with the re-export‚Äôs.</p>
<p>When talking about ‚Äúattributes merge‚Äù, we mean that if the re-export has <code>#[cfg(unix)]</code> and the re-exported item has <code>#[cfg(feature = "foo")]</code>, you will only see <code>cfg(unix)</code> on the re-export and only <code>cfg(feature = "foo")</code> on the re-exported item, unless the re-export has <code>#[doc(inline)]</code>, then you will only see the re-exported item with both <code>cfg(unix)</code> and <code>cfg(feature = "foo")</code>.</p>
<p>Example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(cfg(any(windows, unix)))]
pub mod desktop {
    #[doc(cfg(not(unix)))]
    pub mod non_unix {
        // code
    }
}

#[doc(cfg(target_os = "freebsd"))]
pub use desktop::non_unix as non_unix_desktop;
#[doc(cfg(target_os = "macos"))]
#[doc(inline)]
pub use desktop::non_unix as inlined_non_unix_desktop;</code></pre>
<p>In this example, <code>non_unix_desktop</code> will only display <code>cfg(target_os = "freeebsd")</code> and not display any <code>cfg</code> from <code>desktop::non_unix</code>.</p>
<p>On the contrary, <code>inlined_non_unix_desktop</code> will have cfgs from both the re-export and the re-exported item.</p>
<p>So that also means that if a crate re-exports a foreign item, unless it has <code>#[doc(inline)]</code>, the <code>cfg</code> and <code>doc(cfg)</code> attributes will not be visible:</p>
<pre><code class="language-rust ignore (nightly)">// dep:
#[cfg(feature = "a")]
pub struct S;

// crate using dep:

// There will be no mention of `feature = "a"` in the documentation.
pub use dep::S as Y;</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deprecated-features"><a class="header" href="#deprecated-features">Deprecated features</a></h1>
<h2 id="passes"><a class="header" href="#passes">Passes</a></h2>
<p>Rustdoc has a concept called ‚Äúpasses‚Äù. These are transformations that
<code>rustdoc</code> runs on your documentation before producing its final output.</p>
<p>Customizing passes is <strong>deprecated</strong>. The available passes are not considered stable and may
change in any release.</p>
<p>In the past the most common use case for customizing passes was to omit the <code>strip-private</code> pass.
You can do this more easily, and without risk of the pass being changed, by passing
<a href="#--document-private-items-show-items-that-are-not-public"><code>--document-private-items</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<p>There are many great <code>rustdoc</code> references out there.
If you know of other great resources, please submit a pull request!</p>
<h2 id="official"><a class="header" href="#official">Official</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">Learn Rust</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/meta/doc.html">Rust By Example</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">Rust Reference</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html">RFC 1574: More API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Intra Rustdoc Links</a></li>
</ul>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/documentation.html">API Guidelines</a></li>
<li><a href="https://github.com/rust-lang/rfcs/issues?q=label%3AT-rustdoc">GitHub tagged RFCs</a></li>
<li><a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AT-rustdoc">GitHub tagged issues</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1687">RFC (stalled) front page styleguide</a></li>
<li><a href="https://blog.guillaume-gomez.fr/articles/2020-03-12+Guide+on+how+to+write+documentation+for+a+Rust+crate">Guide on how to write documentation for a Rust crate</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
