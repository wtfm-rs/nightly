<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clippy Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-f6791987.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-0b42a744.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Clippy Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust-clippy/tree/master/book" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="clippy"><a class="header" href="#clippy">Clippy</a></h1>
<p><a href="https://github.com/rust-lang/rust-clippy#license"><img src="https://img.shields.io/crates/l/clippy.svg" alt="License: MIT OR Apache-2.0"></a></p>
<p>A collection of lints to catch common mistakes and improve your
<a href="https://github.com/rust-lang/rust">Rust</a> code.</p>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html">There are over 800 lints included in this crate!</a></p>
<p>Lints are divided into categories, each with a default <a href="https://doc.rust-lang.org/rustc/lints/levels.html">lint
level</a>. You can choose how
much Clippy is supposed to <del>annoy</del> help you by changing the lint level by
category.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Description</th><th>Default level</th></tr>
</thead>
<tbody>
<tr><td><code>clippy::all</code></td><td>all lints that are on by default (correctness, suspicious, style, complexity, perf)</td><td><strong>warn/deny</strong></td></tr>
<tr><td><code>clippy::correctness</code></td><td>code that is outright wrong or useless</td><td><strong>deny</strong></td></tr>
<tr><td><code>clippy::suspicious</code></td><td>code that is most likely wrong or useless</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::style</code></td><td>code that should be written in a more idiomatic way</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::complexity</code></td><td>code that does something simple but in a complex way</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::perf</code></td><td>code that can be written to run faster</td><td><strong>warn</strong></td></tr>
<tr><td><code>clippy::pedantic</code></td><td>lints which are rather strict or have occasional false positives</td><td>allow</td></tr>
<tr><td><code>clippy::restriction</code></td><td>lints which prevent the use of language and library features<sup class="footnote-reference" id="fr-restrict-1"><a href="#footnote-restrict">1</a></sup></td><td>allow</td></tr>
<tr><td><code>clippy::nursery</code></td><td>new lints that are still under development</td><td>allow</td></tr>
<tr><td><code>clippy::cargo</code></td><td>lints for the cargo manifest</td><td>allow</td></tr>
</tbody>
</table>
</div>
<p>More to come, please <a href="https://github.com/rust-lang/rust-clippy/issues">file an issue</a> if you have ideas!</p>
<p>The <code>restriction</code> category should, <em>emphatically</em>, not be enabled as a whole. The contained
lints may lint against perfectly reasonable code, may not have an alternative suggestion,
and may contradict any other lints (including other categories). Lints should be considered
on a case-by-case basis before enabling.</p>
<hr>
<ol class="footnote-definition">
<li id="footnote-restrict">
<p>Some use cases for <code>restriction</code> lints include:</p>
<ul>
<li>Strict coding styles (e.g. <a href="https://rust-lang.github.io/rust-clippy/master/index.html#else_if_without_else"><code>clippy::else_if_without_else</code></a>).</li>
<li>Additional restrictions on CI (e.g. <a href="https://rust-lang.github.io/rust-clippy/master/index.html#todo"><code>clippy::todo</code></a>).</li>
<li>Preventing panicking in certain functions (e.g. <a href="https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used"><code>clippy::unwrap_used</code></a>).</li>
<li>Running a lint only on a subset of code (e.g. <code>#[forbid(clippy::float_arithmetic)]</code> on a module).</li>
</ul>
 <a href="#fr-restrict-1">↩</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>If you’re using <code>rustup</code> to install and manage your Rust toolchains, Clippy is
usually <strong>already installed</strong>. In that case you can skip this chapter and go to
the <a href="#usage">Usage</a> chapter.</p>
<blockquote>
<p>Note: If you used the <code>minimal</code> profile when installing a Rust toolchain,
Clippy is not automatically installed.</p>
</blockquote>
<h2 id="using-rustup"><a class="header" href="#using-rustup">Using Rustup</a></h2>
<p>If Clippy was not installed for a toolchain, it can be installed with</p>
<pre><code>$ rustup component add clippy [--toolchain=&lt;name&gt;]
</code></pre>
<h2 id="from-source"><a class="header" href="#from-source">From Source</a></h2>
<p>Take a look at the <a href="#install-from-source">Basics</a> chapter in the Clippy developer guide to find step-by-step
instructions on how to build and install Clippy from source.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>This chapter describes how to use Clippy to get the most out of it. Clippy can
be used as a <code>cargo</code> subcommand or, like <code>rustc</code>, directly with the
<code>clippy-driver</code> binary.</p>
<blockquote>
<p><em>Note:</em> This chapter assumes that you have Clippy installed already. If you’re
not sure, take a look at the <a href="#installation">Installation</a> chapter.</p>
</blockquote>
<h2 id="cargo-subcommand"><a class="header" href="#cargo-subcommand">Cargo subcommand</a></h2>
<p>The easiest and most common way to run Clippy is through <code>cargo</code>. To do that,
just run</p>
<pre><code class="language-bash">cargo clippy
</code></pre>
<h3 id="lint-configuration"><a class="header" href="#lint-configuration">Lint configuration</a></h3>
<p>The above command will run the default set of lints, which are included in the
lint group <code>clippy::all</code>. You might want to use even more lints, or you may not
agree with every Clippy lint, and for that there are ways to configure lint
levels.</p>
<blockquote>
<p><em>Note:</em> Clippy is meant to be used with a generous sprinkling of
<code>#[allow(..)]</code>s through your code. So if you disagree with a lint, don’t feel
bad disabling them for parts of your code or the whole project.</p>
</blockquote>
<h4 id="command-line"><a class="header" href="#command-line">Command line</a></h4>
<p>You can configure lint levels on the command line by adding
<code>-A/W/D clippy::lint_name</code> like this:</p>
<pre><code class="language-bash">cargo clippy -- -Aclippy::style -Wclippy::box_default -Dclippy::perf
</code></pre>
<p>For <a href="#continuous-integration">CI</a> all warnings can be elevated to errors which will in turn fail
the build and cause Clippy to exit with a code other than <code>0</code>.</p>
<pre><code>cargo clippy -- -Dwarnings
</code></pre>
<blockquote>
<p><em>Note:</em> Adding <code>-D warnings</code> will cause your build to fail if <strong>any</strong> warnings
are found in your code. That includes warnings found by rustc (e.g.
<code>dead_code</code>, etc.).</p>
</blockquote>
<p>For more information on configuring lint levels, see the <a href="https://doc.rust-lang.org/rustc/lints/levels.html#configuring-warning-levels">rustc documentation</a>.</p>
<h4 id="even-more-lints"><a class="header" href="#even-more-lints">Even more lints</a></h4>
<p>Clippy has lint groups which are allow-by-default. This means, that you will
have to enable the lints in those groups manually.</p>
<p>For a full list of all lints with their description and examples, please refer
to <a href="https://rust-lang.github.io/rust-clippy/master/index.html">Clippy’s lint list</a>. The two most important allow-by-default groups are
described below:</p>
<h5 id="clippypedantic"><a class="header" href="#clippypedantic"><code>clippy::pedantic</code></a></h5>
<p>The first group is the <code>pedantic</code> group. This group contains really opinionated
lints, that may have some intentional false positives in order to prevent false
negatives. So while this group is ready to be used in production, you can expect
to sprinkle multiple <code>#[allow(..)]</code>s in your code. If you find any false
positives, you’re still welcome to report them to us for future improvements.</p>
<blockquote>
<p>FYI: Clippy uses the whole group to lint itself.</p>
</blockquote>
<h5 id="clippyrestriction"><a class="header" href="#clippyrestriction"><code>clippy::restriction</code></a></h5>
<p>The second group is the <code>restriction</code> group. This group contains lints that
“restrict” the language in some way. For example the <code>clippy::unwrap</code> lint from
this group won’t allow you to use <code>.unwrap()</code> in your code. You may want to look
through the lints in this group and enable the ones that fit your need.</p>
<blockquote>
<p><em>Note:</em> You shouldn’t enable the whole lint group, but cherry-pick lints from
this group. Some lints in this group will even contradict other Clippy lints!</p>
</blockquote>
<h4 id="too-many-lints"><a class="header" href="#too-many-lints">Too many lints</a></h4>
<p>The most opinionated warn-by-default group of Clippy is the <code>clippy::style</code>
group. Some people prefer to disable this group completely and then cherry-pick
some lints they like from this group. The same is of course possible with every
other of Clippy’s lint groups.</p>
<blockquote>
<p><em>Note:</em> We try to keep the warn-by-default groups free from false positives
(FP). If you find that a lint wrongly triggers, please report it in an issue
(if there isn’t an issue for that FP already)</p>
</blockquote>
<h4 id="source-code"><a class="header" href="#source-code">Source Code</a></h4>
<p>You can configure lint levels in source code the same way you can configure
<code>rustc</code> lints:</p>
<pre><code class="language-rust ignore">#![allow(clippy::style)]

#[warn(clippy::box_default)]
fn main() {
    let _ = Box::&lt;String&gt;::new(Default::default());
    // ^ warning: `Box::new(_)` of default value
}</code></pre>
<h3 id="automatically-applying-clippy-suggestions"><a class="header" href="#automatically-applying-clippy-suggestions">Automatically applying Clippy suggestions</a></h3>
<p>Clippy can automatically apply some lint suggestions, just like the compiler. Note that <code>--fix</code> implies
<code>--all-targets</code>, so it can fix as much code as it can.</p>
<pre><code class="language-terminal">cargo clippy --fix
</code></pre>
<h3 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h3>
<p>All the usual workspace options should work with Clippy. For example the
following command will run Clippy on the <code>example</code> crate in your workspace:</p>
<pre><code class="language-terminal">cargo clippy -p example
</code></pre>
<p>As with <code>cargo check</code>, this includes dependencies that are members of the
workspace, like path dependencies. If you want to run Clippy <strong>only</strong> on the
given crate, use the <code>--no-deps</code> option like this:</p>
<pre><code class="language-terminal">cargo clippy -p example -- --no-deps
</code></pre>
<h2 id="using-clippy-without-cargo-clippy-driver"><a class="header" href="#using-clippy-without-cargo-clippy-driver">Using Clippy without <code>cargo</code>: <code>clippy-driver</code></a></h2>
<p>Clippy can also be used in projects that do not use cargo. To do so, run
<code>clippy-driver</code> with the same arguments you use for <code>rustc</code>. For example:</p>
<pre><code class="language-terminal">clippy-driver --edition 2018 -Cpanic=abort foo.rs
</code></pre>
<blockquote>
<p><em>Note:</em> <code>clippy-driver</code> is designed for running Clippy and should not be used
as a general replacement for <code>rustc</code>. <code>clippy-driver</code> may produce artifacts
that are not optimized as expected, for example.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuring-clippy"><a class="header" href="#configuring-clippy">Configuring Clippy</a></h1>
<blockquote>
<p><strong>Note:</strong> The configuration file is unstable and may be deprecated in the future.</p>
</blockquote>
<p>Some lints can be configured in a TOML file named <code>clippy.toml</code> or <code>.clippy.toml</code>, which is searched for in:</p>
<ol>
<li>The directory specified by the <code>CLIPPY_CONF_DIR</code> environment variable, or</li>
<li>The directory specified by the
<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html">CARGO_MANIFEST_DIR</a> environment variable, or</li>
<li>The current directory.</li>
</ol>
<p>It contains a basic <code>variable = value</code> mapping e.g.</p>
<pre><code class="language-toml">avoid-breaking-exported-api = false
disallowed-names = ["toto", "tata", "titi"]
</code></pre>
<p>The <a href="#lint-configuration-options">table of configurations</a>
contains all config values, their default, and a list of lints they affect.
Each <a href="https://rust-lang.github.io/rust-clippy/master/index.html#Configuration">configurable lint</a>
, also contains information about these values.</p>
<p>For configurations that are a list type with default values such as
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_names">disallowed-names</a>,
you can use the unique value <code>".."</code> to extend the default values instead of replacing them.</p>
<pre><code class="language-toml"># default of disallowed-names is ["foo", "baz", "quux"]
disallowed-names = ["bar", ".."] # -&gt; ["bar", "foo", "baz", "quux"]
</code></pre>
<p>To deactivate the “for further information visit <em>lint-link</em>” message you can define the <code>CLIPPY_DISABLE_DOCS_LINKS</code>
environment variable.</p>
<h3 id="allowingdenying-lints"><a class="header" href="#allowingdenying-lints">Allowing/Denying Lints</a></h3>
<h4 id="attributes-in-code"><a class="header" href="#attributes-in-code">Attributes in Code</a></h4>
<p>You can add attributes to your code to <code>allow</code>/<code>warn</code>/<code>deny</code> Clippy lints:</p>
<ul>
<li>
<p>the whole set of <code>warn</code>-by-default lints using the <code>clippy</code> lint group (<code>#![allow(clippy::all)]</code>)</p>
</li>
<li>
<p>all lints using both the <code>clippy</code> and <code>clippy::pedantic</code> lint groups (<code>#![warn(clippy::all, clippy::pedantic)]</code>. Note
that <code>clippy::pedantic</code> contains some very aggressive lints prone to false positives.</p>
</li>
<li>
<p>only some lints (<code>#![deny(clippy::single_match, clippy::box_vec)]</code>, etc.)</p>
</li>
<li>
<p><code>allow</code>/<code>warn</code>/<code>deny</code> can be limited to a single function or module using <code>#[allow(...)]</code>, etc.</p>
</li>
</ul>
<p>Note: <code>allow</code> means to suppress the lint for your code. With <code>warn</code> the lint will only emit a warning, while with <code>deny</code>
the lint will emit an error, when triggering for your code. An error causes Clippy to exit with an error code, so is
most useful in scripts used in CI/CD.</p>
<h4 id="command-line-flags"><a class="header" href="#command-line-flags">Command Line Flags</a></h4>
<p>If you do not want to include your lint levels in the code, you can globally enable/disable lints by passing extra flags
to Clippy during the run:</p>
<p>To allow <code>lint_name</code>, run</p>
<pre><code class="language-terminal">cargo clippy -- -A clippy::lint_name
</code></pre>
<p>And to warn on <code>lint_name</code>, run</p>
<pre><code class="language-terminal">cargo clippy -- -W clippy::lint_name
</code></pre>
<p>This also works with lint groups. For example, you can run Clippy with warnings for all pedantic lints enabled:</p>
<pre><code class="language-terminal">cargo clippy -- -W clippy::pedantic
</code></pre>
<p>If you care only about a certain lints, you can allow all others and then explicitly warn on the lints you are
interested in:</p>
<pre><code class="language-terminal">cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...
</code></pre>
<h4 id="lints-section-in-cargotoml"><a class="header" href="#lints-section-in-cargotoml">Lints Section in <code>Cargo.toml</code></a></h4>
<p>Finally, lints can be allowed/denied using <a href="https://doc.rust-lang.org/nightly/cargo/reference/manifest.html#the-lints-section">the lints
section</a>) in the <code>Cargo.toml</code> file:</p>
<p>To deny <code>clippy::enum_glob_use</code>, put the following in the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lints.clippy]
enum_glob_use = "deny"
</code></pre>
<p>For more details and options, refer to the Cargo documentation.</p>
<h3 id="specifying-the-minimum-supported-rust-version"><a class="header" href="#specifying-the-minimum-supported-rust-version">Specifying the minimum supported Rust version</a></h3>
<p>Projects that intend to support old versions of Rust can disable lints pertaining to newer features by specifying the
minimum supported Rust version (MSRV) in the Clippy configuration file.</p>
<pre><code class="language-toml">msrv = "1.30.0"
</code></pre>
<p>The MSRV can also be specified as an attribute, like below.</p>
<pre><code class="language-rust ignore">#![feature(custom_inner_attributes)]
#![clippy::msrv = "1.30.0"]

fn main() {
    ...
}</code></pre>
<p>You can also omit the patch version when specifying the MSRV, so <code>msrv = 1.30</code>
is equivalent to <code>msrv = 1.30.0</code>.</p>
<p>Note: <code>custom_inner_attributes</code> is an unstable feature, so it has to be enabled explicitly.</p>
<p>Lints that recognize this configuration option can be
found <a href="https://rust-lang.github.io/rust-clippy/master/index.html#msrv">here</a></p>
<h3 id="disabling-evaluation-of-certain-code"><a class="header" href="#disabling-evaluation-of-certain-code">Disabling evaluation of certain code</a></h3>
<blockquote>
<p><strong>Note:</strong> This should only be used in cases where other solutions, like <code>#[allow(clippy::all)]</code>, are not sufficient.</p>
</blockquote>
<p>Very rarely, you may wish to prevent Clippy from evaluating certain sections of code entirely. You can do this with
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a> by checking that the
<code>clippy</code> cfg is not set. You may need to provide a stub so that the code compiles:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(clippy))]
include!(concat!(env!("OUT_DIR"), "/my_big_function-generated.rs"));

#[cfg(clippy)]
fn my_big_function(_input: &amp;str) -&gt; Option&lt;MyStruct&gt; {
    None
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file is generated by `cargo bless --test config-metadata`.
Please use that command to update the file and do not edit it by hand.
-->
<h1 id="lint-configuration-options"><a class="header" href="#lint-configuration-options">Lint Configuration Options</a></h1>
<p>The following list shows each configuration option, along with a description, its default value, an example
and lints affected.</p>
<hr>
<h2 id="absolute-paths-allowed-crates"><a class="header" href="#absolute-paths-allowed-crates"><code>absolute-paths-allowed-crates</code></a></h2>
<p>Which crates to allow absolute paths from</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#absolute_paths"><code>absolute_paths</code></a></li>
</ul>
<h2 id="absolute-paths-max-segments"><a class="header" href="#absolute-paths-max-segments"><code>absolute-paths-max-segments</code></a></h2>
<p>The maximum number of segments a path can have before being linted, anything above this will
be linted.</p>
<p><strong>Default Value:</strong> <code>2</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#absolute_paths"><code>absolute_paths</code></a></li>
</ul>
<h2 id="accept-comment-above-attributes"><a class="header" href="#accept-comment-above-attributes"><code>accept-comment-above-attributes</code></a></h2>
<p>Whether to accept a safety comment to be placed above the attributes for the <code>unsafe</code> block</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#undocumented_unsafe_blocks"><code>undocumented_unsafe_blocks</code></a></li>
</ul>
<h2 id="accept-comment-above-statement"><a class="header" href="#accept-comment-above-statement"><code>accept-comment-above-statement</code></a></h2>
<p>Whether to accept a safety comment to be placed above the statement containing the <code>unsafe</code> block</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#undocumented_unsafe_blocks"><code>undocumented_unsafe_blocks</code></a></li>
</ul>
<h2 id="allow-comparison-to-zero"><a class="header" href="#allow-comparison-to-zero"><code>allow-comparison-to-zero</code></a></h2>
<p>Don’t lint when comparing the result of a modulo operation to zero.</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#modulo_arithmetic"><code>modulo_arithmetic</code></a></li>
</ul>
<h2 id="allow-dbg-in-tests"><a class="header" href="#allow-dbg-in-tests"><code>allow-dbg-in-tests</code></a></h2>
<p>Whether <code>dbg!</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#dbg_macro"><code>dbg_macro</code></a></li>
</ul>
<h2 id="allow-exact-repetitions"><a class="header" href="#allow-exact-repetitions"><code>allow-exact-repetitions</code></a></h2>
<p>Whether an item should be allowed to have the same name as its containing module</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#module_name_repetitions"><code>module_name_repetitions</code></a></li>
</ul>
<h2 id="allow-expect-in-consts"><a class="header" href="#allow-expect-in-consts"><code>allow-expect-in-consts</code></a></h2>
<p>Whether <code>expect</code> should be allowed in code always evaluated at compile time</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#expect_used"><code>expect_used</code></a></li>
</ul>
<h2 id="allow-expect-in-tests"><a class="header" href="#allow-expect-in-tests"><code>allow-expect-in-tests</code></a></h2>
<p>Whether <code>expect</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#expect_used"><code>expect_used</code></a></li>
</ul>
<h2 id="allow-indexing-slicing-in-tests"><a class="header" href="#allow-indexing-slicing-in-tests"><code>allow-indexing-slicing-in-tests</code></a></h2>
<p>Whether <code>indexing_slicing</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing"><code>indexing_slicing</code></a></li>
</ul>
<h2 id="allow-large-stack-frames-in-tests"><a class="header" href="#allow-large-stack-frames-in-tests"><code>allow-large-stack-frames-in-tests</code></a></h2>
<p>Whether functions inside <code>#[cfg(test)]</code> modules or test functions should be checked.</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_frames"><code>large_stack_frames</code></a></li>
</ul>
<h2 id="allow-mixed-uninlined-format-args"><a class="header" href="#allow-mixed-uninlined-format-args"><code>allow-mixed-uninlined-format-args</code></a></h2>
<p>Whether to allow mixed uninlined format args, e.g. <code>format!("{} {}", a, foo.bar)</code></p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args"><code>uninlined_format_args</code></a></li>
</ul>
<h2 id="allow-one-hash-in-raw-strings"><a class="header" href="#allow-one-hash-in-raw-strings"><code>allow-one-hash-in-raw-strings</code></a></h2>
<p>Whether to allow <code>r#""#</code> when <code>r""</code> can be used</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#needless_raw_string_hashes"><code>needless_raw_string_hashes</code></a></li>
</ul>
<h2 id="allow-panic-in-tests"><a class="header" href="#allow-panic-in-tests"><code>allow-panic-in-tests</code></a></h2>
<p>Whether <code>panic</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#panic"><code>panic</code></a></li>
</ul>
<h2 id="allow-print-in-tests"><a class="header" href="#allow-print-in-tests"><code>allow-print-in-tests</code></a></h2>
<p>Whether print macros (ex. <code>println!</code>) should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#print_stderr"><code>print_stderr</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#print_stdout"><code>print_stdout</code></a></li>
</ul>
<h2 id="allow-private-module-inception"><a class="header" href="#allow-private-module-inception"><code>allow-private-module-inception</code></a></h2>
<p>Whether to allow module inception if it’s not public.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#module_inception"><code>module_inception</code></a></li>
</ul>
<h2 id="allow-renamed-params-for"><a class="header" href="#allow-renamed-params-for"><code>allow-renamed-params-for</code></a></h2>
<p>List of trait paths to ignore when checking renamed function parameters.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><code class="language-toml">allow-renamed-params-for = [ "std::convert::From" ]
</code></pre>
<h4 id="noteworthy"><a class="header" href="#noteworthy">Noteworthy</a></h4>
<ul>
<li>By default, the following traits are ignored: <code>From</code>, <code>TryFrom</code>, <code>FromStr</code></li>
<li><code>".."</code> can be used as part of the list to indicate that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value.</li>
</ul>
<p><strong>Default Value:</strong> <code>["core::convert::From", "core::convert::TryFrom", "core::str::FromStr"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#renamed_function_params"><code>renamed_function_params</code></a></li>
</ul>
<h2 id="allow-unwrap-in-consts"><a class="header" href="#allow-unwrap-in-consts"><code>allow-unwrap-in-consts</code></a></h2>
<p>Whether <code>unwrap</code> should be allowed in code always evaluated at compile time</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used"><code>unwrap_used</code></a></li>
</ul>
<h2 id="allow-unwrap-in-tests"><a class="header" href="#allow-unwrap-in-tests"><code>allow-unwrap-in-tests</code></a></h2>
<p>Whether <code>unwrap</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used"><code>unwrap_used</code></a></li>
</ul>
<h2 id="allow-useless-vec-in-tests"><a class="header" href="#allow-useless-vec-in-tests"><code>allow-useless-vec-in-tests</code></a></h2>
<p>Whether <code>useless_vec</code> should ignore test functions or <code>#[cfg(test)]</code></p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#useless_vec"><code>useless_vec</code></a></li>
</ul>
<h2 id="allowed-dotfiles"><a class="header" href="#allowed-dotfiles"><code>allowed-dotfiles</code></a></h2>
<p>Additional dotfiles (files or directories starting with a dot) to allow</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#path_ends_with_ext"><code>path_ends_with_ext</code></a></li>
</ul>
<h2 id="allowed-duplicate-crates"><a class="header" href="#allowed-duplicate-crates"><code>allowed-duplicate-crates</code></a></h2>
<p>A list of crate names to allow duplicates of</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#multiple_crate_versions"><code>multiple_crate_versions</code></a></li>
</ul>
<h2 id="allowed-idents-below-min-chars"><a class="header" href="#allowed-idents-below-min-chars"><code>allowed-idents-below-min-chars</code></a></h2>
<p>Allowed names below the minimum allowed characters. The value <code>".."</code> can be used as part of
the list to indicate, that the configured values should be appended to the default
configuration of Clippy. By default, any configuration will replace the default value.</p>
<p><strong>Default Value:</strong> <code>["i", "j", "x", "y", "z", "w", "n"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#min_ident_chars"><code>min_ident_chars</code></a></li>
</ul>
<h2 id="allowed-prefixes"><a class="header" href="#allowed-prefixes"><code>allowed-prefixes</code></a></h2>
<p>List of prefixes to allow when determining whether an item’s name ends with the module’s name.
If the rest of an item’s name is an allowed prefix (e.g. item <code>ToFoo</code> or <code>to_foo</code> in module <code>foo</code>),
then don’t emit a warning.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><code class="language-toml">allowed-prefixes = [ "to", "from" ]
</code></pre>
<h4 id="noteworthy-1"><a class="header" href="#noteworthy-1">Noteworthy</a></h4>
<ul>
<li>By default, the following prefixes are allowed: <code>to</code>, <code>as</code>, <code>into</code>, <code>from</code>, <code>try_into</code> and <code>try_from</code></li>
<li>PascalCase variant is included automatically for each snake_case variant (e.g. if <code>try_into</code> is included,
<code>TryInto</code> will also be included)</li>
<li>Use <code>".."</code> as part of the list to indicate that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value</li>
</ul>
<p><strong>Default Value:</strong> <code>["to", "as", "into", "from", "try_into", "try_from"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#module_name_repetitions"><code>module_name_repetitions</code></a></li>
</ul>
<h2 id="allowed-scripts"><a class="header" href="#allowed-scripts"><code>allowed-scripts</code></a></h2>
<p>The list of unicode scripts allowed to be used in the scope.</p>
<p><strong>Default Value:</strong> <code>["Latin"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_script_idents"><code>disallowed_script_idents</code></a></li>
</ul>
<h2 id="allowed-wildcard-imports"><a class="header" href="#allowed-wildcard-imports"><code>allowed-wildcard-imports</code></a></h2>
<p>List of path segments allowed to have wildcard imports.</p>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<pre><code class="language-toml">allowed-wildcard-imports = [ "utils", "common" ]
</code></pre>
<h4 id="noteworthy-2"><a class="header" href="#noteworthy-2">Noteworthy</a></h4>
<ol>
<li>This configuration has no effects if used with <code>warn_on_all_wildcard_imports = true</code>.</li>
<li>Paths with any segment that containing the word ‘prelude’
are already allowed by default.</li>
</ol>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#wildcard_imports"><code>wildcard_imports</code></a></li>
</ul>
<h2 id="arithmetic-side-effects-allowed"><a class="header" href="#arithmetic-side-effects-allowed"><code>arithmetic-side-effects-allowed</code></a></h2>
<p>Suppress checking of the passed type names in all types of operations.</p>
<p>If a specific operation is desired, consider using <code>arithmetic_side_effects_allowed_binary</code> or <code>arithmetic_side_effects_allowed_unary</code> instead.</p>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<pre><code class="language-toml">arithmetic-side-effects-allowed = ["SomeType", "AnotherType"]
</code></pre>
<h4 id="noteworthy-3"><a class="header" href="#noteworthy-3">Noteworthy</a></h4>
<p>A type, say <code>SomeType</code>, listed in this configuration has the same behavior of
<code>["SomeType" , "*"], ["*", "SomeType"]</code> in <code>arithmetic_side_effects_allowed_binary</code>.</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#arithmetic_side_effects"><code>arithmetic_side_effects</code></a></li>
</ul>
<h2 id="arithmetic-side-effects-allowed-binary"><a class="header" href="#arithmetic-side-effects-allowed-binary"><code>arithmetic-side-effects-allowed-binary</code></a></h2>
<p>Suppress checking of the passed type pair names in binary operations like addition or
multiplication.</p>
<p>Supports the “*” wildcard to indicate that a certain type won’t trigger the lint regardless
of the involved counterpart. For example, <code>["SomeType", "*"]</code> or <code>["*", "AnotherType"]</code>.</p>
<p>Pairs are asymmetric, which means that <code>["SomeType", "AnotherType"]</code> is not the same as
<code>["AnotherType", "SomeType"]</code>.</p>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<pre><code class="language-toml">arithmetic-side-effects-allowed-binary = [["SomeType" , "f32"], ["AnotherType", "*"]]
</code></pre>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#arithmetic_side_effects"><code>arithmetic_side_effects</code></a></li>
</ul>
<h2 id="arithmetic-side-effects-allowed-unary"><a class="header" href="#arithmetic-side-effects-allowed-unary"><code>arithmetic-side-effects-allowed-unary</code></a></h2>
<p>Suppress checking of the passed type names in unary operations like “negation” (<code>-</code>).</p>
<h4 id="example-5"><a class="header" href="#example-5">Example</a></h4>
<pre><code class="language-toml">arithmetic-side-effects-allowed-unary = ["SomeType", "AnotherType"]
</code></pre>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#arithmetic_side_effects"><code>arithmetic_side_effects</code></a></li>
</ul>
<h2 id="array-size-threshold"><a class="header" href="#array-size-threshold"><code>array-size-threshold</code></a></h2>
<p>The maximum allowed size for arrays on the stack</p>
<p><strong>Default Value:</strong> <code>16384</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays"><code>large_const_arrays</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays"><code>large_stack_arrays</code></a></li>
</ul>
<h2 id="avoid-breaking-exported-api"><a class="header" href="#avoid-breaking-exported-api"><code>avoid-breaking-exported-api</code></a></h2>
<p>Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#box_collection"><code>box_collection</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names"><code>enum_variant_names</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value"><code>large_types_passed_by_value</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#linkedlist"><code>linkedlist</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_ref_mut"><code>needless_pass_by_ref_mut</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#option_option"><code>option_option</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#owned_cow"><code>owned_cow</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#rc_buffer"><code>rc_buffer</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#rc_mutex"><code>rc_mutex</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#redundant_allocation"><code>redundant_allocation</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#ref_option"><code>ref_option</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#single_call_fn"><code>single_call_fn</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref"><code>trivially_copy_pass_by_ref</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_box_returns"><code>unnecessary_box_returns</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_wraps"><code>unnecessary_wraps</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unused_self"><code>unused_self</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#upper_case_acronyms"><code>upper_case_acronyms</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#vec_box"><code>vec_box</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention"><code>wrong_self_convention</code></a></li>
</ul>
<h2 id="await-holding-invalid-types"><a class="header" href="#await-holding-invalid-types"><code>await-holding-invalid-types</code></a></h2>
<p>The list of types which may not be held across an await point.</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_invalid_type"><code>await_holding_invalid_type</code></a></li>
</ul>
<h2 id="cargo-ignore-publish"><a class="header" href="#cargo-ignore-publish"><code>cargo-ignore-publish</code></a></h2>
<p>For internal testing only, ignores the current <code>publish</code> settings in the Cargo manifest.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata"><code>cargo_common_metadata</code></a></li>
</ul>
<h2 id="check-incompatible-msrv-in-tests"><a class="header" href="#check-incompatible-msrv-in-tests"><code>check-incompatible-msrv-in-tests</code></a></h2>
<p>Whether to check MSRV compatibility in <code>#[test]</code> and <code>#[cfg(test)]</code> code.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#incompatible_msrv"><code>incompatible_msrv</code></a></li>
</ul>
<h2 id="check-inconsistent-struct-field-initializers"><a class="header" href="#check-inconsistent-struct-field-initializers"><code>check-inconsistent-struct-field-initializers</code></a></h2>
<p>Whether to suggest reordering constructor fields when initializers are present.</p>
<p>Warnings produced by this configuration aren’t necessarily fixed by just reordering the fields. Even if the
suggested code would compile, it can change semantics if the initializer expressions have side effects. The
following example <a href="https://github.com/rust-lang/rust-clippy/issues/11846#issuecomment-1820747924">from rust-clippy#11846</a> shows how the suggestion can run into borrow check errors:</p>
<pre class="playground"><code class="language-rust edition2024">struct MyStruct {
    vector: Vec&lt;u32&gt;,
    length: usize
}
fn main() {
    let vector = vec![1,2,3];
    MyStruct { length: vector.len(), vector};
}</code></pre>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_struct_constructor"><code>inconsistent_struct_constructor</code></a></li>
</ul>
<h2 id="check-private-items"><a class="header" href="#check-private-items"><code>check-private-items</code></a></h2>
<p>Whether to also run the listed lints on private items.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc"><code>missing_errors_doc</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc"><code>missing_panics_doc</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc"><code>missing_safety_doc</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_safety_doc"><code>unnecessary_safety_doc</code></a></li>
</ul>
<h2 id="cognitive-complexity-threshold"><a class="header" href="#cognitive-complexity-threshold"><code>cognitive-complexity-threshold</code></a></h2>
<p>The maximum cognitive complexity a function can have</p>
<p><strong>Default Value:</strong> <code>25</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity"><code>cognitive_complexity</code></a></li>
</ul>
<h2 id="const-literal-digits-threshold"><a class="header" href="#const-literal-digits-threshold"><code>const-literal-digits-threshold</code></a></h2>
<p>The minimum digits a const float literal must have to supress the <code>excessive_precicion</code> lint</p>
<p><strong>Default Value:</strong> <code>30</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision"><code>excessive_precision</code></a></li>
</ul>
<h2 id="disallowed-macros"><a class="header" href="#disallowed-macros"><code>disallowed-macros</code></a></h2>
<p>The list of disallowed macros, written as fully qualified paths.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>path</code> (required): the fully qualified path to the macro that should be disallowed</li>
<li><code>reason</code> (optional): explanation why this macro is disallowed</li>
<li><code>replacement</code> (optional): suggested alternative macro</li>
<li><code>allow-invalid</code> (optional, <code>false</code> by default): when set to <code>true</code>, it will ignore this entry
if the path doesn’t exist, instead of emitting an error</li>
</ul>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_macros"><code>disallowed_macros</code></a></li>
</ul>
<h2 id="disallowed-methods"><a class="header" href="#disallowed-methods"><code>disallowed-methods</code></a></h2>
<p>The list of disallowed methods, written as fully qualified paths.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>path</code> (required): the fully qualified path to the method that should be disallowed</li>
<li><code>reason</code> (optional): explanation why this method is disallowed</li>
<li><code>replacement</code> (optional): suggested alternative method</li>
<li><code>allow-invalid</code> (optional, <code>false</code> by default): when set to <code>true</code>, it will ignore this entry
if the path doesn’t exist, instead of emitting an error</li>
</ul>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_methods"><code>disallowed_methods</code></a></li>
</ul>
<h2 id="disallowed-names"><a class="header" href="#disallowed-names"><code>disallowed-names</code></a></h2>
<p>The list of disallowed names to lint about. NB: <code>bar</code> is not here since it has legitimate uses. The value
<code>".."</code> can be used as part of the list to indicate that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value.</p>
<p><strong>Default Value:</strong> <code>["foo", "baz", "quux"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_names"><code>disallowed_names</code></a></li>
</ul>
<h2 id="disallowed-types"><a class="header" href="#disallowed-types"><code>disallowed-types</code></a></h2>
<p>The list of disallowed types, written as fully qualified paths.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>path</code> (required): the fully qualified path to the type that should be disallowed</li>
<li><code>reason</code> (optional): explanation why this type is disallowed</li>
<li><code>replacement</code> (optional): suggested alternative type</li>
<li><code>allow-invalid</code> (optional, <code>false</code> by default): when set to <code>true</code>, it will ignore this entry
if the path doesn’t exist, instead of emitting an error</li>
</ul>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_types"><code>disallowed_types</code></a></li>
</ul>
<h2 id="doc-valid-idents"><a class="header" href="#doc-valid-idents"><code>doc-valid-idents</code></a></h2>
<p>The list of words this lint should not consider as identifiers needing ticks. The value
<code>".."</code> can be used as part of the list to indicate, that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value. For example:</p>
<ul>
<li><code>doc-valid-idents = ["ClipPy"]</code> would replace the default list with <code>["ClipPy"]</code>.</li>
<li><code>doc-valid-idents = ["ClipPy", ".."]</code> would append <code>ClipPy</code> to the default list.</li>
</ul>
<p><strong>Default Value:</strong> <code>["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "MHz", "GHz", "THz", "AccessKit", "CoAP", "CoreFoundation", "CoreGraphics", "CoreText", "DevOps", "Direct2D", "Direct3D", "DirectWrite", "DirectX", "ECMAScript", "GPLv2", "GPLv3", "GitHub", "GitLab", "IPv4", "IPv6", "InfiniBand", "RoCE", "ClojureScript", "CoffeeScript", "JavaScript", "PostScript", "PureScript", "TypeScript", "PowerPC", "WebAssembly", "NaN", "NaNs", "OAuth", "GraphQL", "OCaml", "OpenAL", "OpenDNS", "OpenGL", "OpenMP", "OpenSSH", "OpenSSL", "OpenStreetMap", "OpenTelemetry", "OpenType", "WebGL", "WebGL2", "WebGPU", "WebRTC", "WebSocket", "WebTransport", "WebP", "OpenExr", "YCbCr", "sRGB", "TensorFlow", "TrueType", "iOS", "macOS", "FreeBSD", "NetBSD", "OpenBSD", "NixOS", "TeX", "LaTeX", "BibTeX", "BibLaTeX", "MinGW", "CamelCase"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown"><code>doc_markdown</code></a></li>
</ul>
<h2 id="enable-raw-pointer-heuristic-for-send"><a class="header" href="#enable-raw-pointer-heuristic-for-send"><code>enable-raw-pointer-heuristic-for-send</code></a></h2>
<p>Whether to apply the raw pointer heuristic to determine if a type is <code>Send</code>.</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#non_send_fields_in_send_ty"><code>non_send_fields_in_send_ty</code></a></li>
</ul>
<h2 id="enforce-iter-loop-reborrow"><a class="header" href="#enforce-iter-loop-reborrow"><code>enforce-iter-loop-reborrow</code></a></h2>
<p>Whether to recommend using implicit into iter for reborrowed values.</p>
<h4 id="example-6"><a class="header" href="#example-6">Example</a></h4>
<pre><code class="language-no_run">let mut vec = vec![1, 2, 3];
let rmvec = &amp;mut vec;
for _ in rmvec.iter() {}
for _ in rmvec.iter_mut() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-no_run">let mut vec = vec![1, 2, 3];
let rmvec = &amp;mut vec;
for _ in &amp;*rmvec {}
for _ in &amp;mut *rmvec {}
</code></pre>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#explicit_iter_loop"><code>explicit_iter_loop</code></a></li>
</ul>
<h2 id="enforced-import-renames"><a class="header" href="#enforced-import-renames"><code>enforced-import-renames</code></a></h2>
<p>The list of imports to always rename, a fully qualified path followed by the rename.</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_enforced_import_renames"><code>missing_enforced_import_renames</code></a></li>
</ul>
<h2 id="enum-variant-name-threshold"><a class="header" href="#enum-variant-name-threshold"><code>enum-variant-name-threshold</code></a></h2>
<p>The minimum number of enum variants for the lints about variant names to trigger</p>
<p><strong>Default Value:</strong> <code>3</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names"><code>enum_variant_names</code></a></li>
</ul>
<h2 id="enum-variant-size-threshold"><a class="header" href="#enum-variant-size-threshold"><code>enum-variant-size-threshold</code></a></h2>
<p>The maximum size of an enum’s variant to avoid box suggestion</p>
<p><strong>Default Value:</strong> <code>200</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant"><code>large_enum_variant</code></a></li>
</ul>
<h2 id="excessive-nesting-threshold"><a class="header" href="#excessive-nesting-threshold"><code>excessive-nesting-threshold</code></a></h2>
<p>The maximum amount of nesting a block can reside in</p>
<p><strong>Default Value:</strong> <code>0</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#excessive_nesting"><code>excessive_nesting</code></a></li>
</ul>
<h2 id="future-size-threshold"><a class="header" href="#future-size-threshold"><code>future-size-threshold</code></a></h2>
<p>The maximum byte size a <code>Future</code> can have, before it triggers the <code>clippy::large_futures</code> lint</p>
<p><strong>Default Value:</strong> <code>16384</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_futures"><code>large_futures</code></a></li>
</ul>
<h2 id="ignore-interior-mutability"><a class="header" href="#ignore-interior-mutability"><code>ignore-interior-mutability</code></a></h2>
<p>A list of paths to types that should be treated as if they do not contain interior mutability</p>
<p><strong>Default Value:</strong> <code>["bytes::Bytes"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const"><code>borrow_interior_mutable_const</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const"><code>declare_interior_mutable_const</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond"><code>ifs_same_cond</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#mutable_key_type"><code>mutable_key_type</code></a></li>
</ul>
<h2 id="inherent-impl-lint-scope"><a class="header" href="#inherent-impl-lint-scope"><code>inherent-impl-lint-scope</code></a></h2>
<p>Sets the scope (“crate”, “file”, or “module”) in which duplicate inherent <code>impl</code> blocks for the same type are linted.</p>
<p><strong>Default Value:</strong> <code>"crate"</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#multiple_inherent_impl"><code>multiple_inherent_impl</code></a></li>
</ul>
<h2 id="large-error-ignored"><a class="header" href="#large-error-ignored"><code>large-error-ignored</code></a></h2>
<p>A list of paths to types that should be ignored as overly large <code>Err</code>-variants in a
<code>Result</code> returned from a function</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#result_large_err"><code>result_large_err</code></a></li>
</ul>
<h2 id="large-error-threshold"><a class="header" href="#large-error-threshold"><code>large-error-threshold</code></a></h2>
<p>The maximum size of the <code>Err</code>-variant in a <code>Result</code> returned from a function</p>
<p><strong>Default Value:</strong> <code>128</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#result_large_err"><code>result_large_err</code></a></li>
</ul>
<h2 id="lint-commented-code"><a class="header" href="#lint-commented-code"><code>lint-commented-code</code></a></h2>
<p>Whether collapsible <code>if</code> and <code>else if</code> chains are linted if they contain comments inside the parts
that would be collapsed.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if"><code>collapsible_else_if</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if"><code>collapsible_if</code></a></li>
</ul>
<h2 id="literal-representation-threshold"><a class="header" href="#literal-representation-threshold"><code>literal-representation-threshold</code></a></h2>
<p>The lower bound for linting decimal literals</p>
<p><strong>Default Value:</strong> <code>16384</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation"><code>decimal_literal_representation</code></a></li>
</ul>
<h2 id="matches-for-let-else"><a class="header" href="#matches-for-let-else"><code>matches-for-let-else</code></a></h2>
<p>Whether the matches should be considered by the lint, and whether there should
be filtering for common types.</p>
<p><strong>Default Value:</strong> <code>"WellKnownTypes"</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_let_else"><code>manual_let_else</code></a></li>
</ul>
<h2 id="max-fn-params-bools"><a class="header" href="#max-fn-params-bools"><code>max-fn-params-bools</code></a></h2>
<p>The maximum number of bool parameters a function can have</p>
<p><strong>Default Value:</strong> <code>3</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#fn_params_excessive_bools"><code>fn_params_excessive_bools</code></a></li>
</ul>
<h2 id="max-include-file-size"><a class="header" href="#max-include-file-size"><code>max-include-file-size</code></a></h2>
<p>The maximum size of a file included via <code>include_bytes!()</code> or <code>include_str!()</code>, in bytes</p>
<p><strong>Default Value:</strong> <code>1000000</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_include_file"><code>large_include_file</code></a></li>
</ul>
<h2 id="max-struct-bools"><a class="header" href="#max-struct-bools"><code>max-struct-bools</code></a></h2>
<p>The maximum number of bool fields a struct can have</p>
<p><strong>Default Value:</strong> <code>3</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#struct_excessive_bools"><code>struct_excessive_bools</code></a></li>
</ul>
<h2 id="max-suggested-slice-pattern-length"><a class="header" href="#max-suggested-slice-pattern-length"><code>max-suggested-slice-pattern-length</code></a></h2>
<p>When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in
the slice pattern that is suggested. If more elements are necessary, the lint is suppressed.
For example, <code>[_, _, _, e, ..]</code> is a slice pattern with 4 elements.</p>
<p><strong>Default Value:</strong> <code>3</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#index_refutable_slice"><code>index_refutable_slice</code></a></li>
</ul>
<h2 id="max-trait-bounds"><a class="header" href="#max-trait-bounds"><code>max-trait-bounds</code></a></h2>
<p>The maximum number of bounds a trait can have to be linted</p>
<p><strong>Default Value:</strong> <code>3</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds"><code>type_repetition_in_bounds</code></a></li>
</ul>
<h2 id="min-ident-chars-threshold"><a class="header" href="#min-ident-chars-threshold"><code>min-ident-chars-threshold</code></a></h2>
<p>Minimum chars an ident can have, anything below or equal to this will be linted.</p>
<p><strong>Default Value:</strong> <code>1</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#min_ident_chars"><code>min_ident_chars</code></a></li>
</ul>
<h2 id="missing-docs-allow-unused"><a class="header" href="#missing-docs-allow-unused"><code>missing-docs-allow-unused</code></a></h2>
<p>Whether to allow fields starting with an underscore to skip documentation requirements</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items"><code>missing_docs_in_private_items</code></a></li>
</ul>
<h2 id="missing-docs-in-crate-items"><a class="header" href="#missing-docs-in-crate-items"><code>missing-docs-in-crate-items</code></a></h2>
<p>Whether to <strong>only</strong> check for missing documentation in items visible within the current
crate. For example, <code>pub(crate)</code> items.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items"><code>missing_docs_in_private_items</code></a></li>
</ul>
<h2 id="module-item-order-groupings"><a class="header" href="#module-item-order-groupings"><code>module-item-order-groupings</code></a></h2>
<p>The named groupings of different source item kinds within modules.</p>
<p><strong>Default Value:</strong> <code>[["modules", ["extern_crate", "mod", "foreign_mod"]], ["use", ["use"]], ["macros", ["macro"]], ["global_asm", ["global_asm"]], ["UPPER_SNAKE_CASE", ["static", "const"]], ["PascalCase", ["ty_alias", "enum", "struct", "union", "trait", "trait_alias", "impl"]], ["lower_snake_case", ["fn"]]]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#arbitrary_source_item_ordering"><code>arbitrary_source_item_ordering</code></a></li>
</ul>
<h2 id="module-items-ordered-within-groupings"><a class="header" href="#module-items-ordered-within-groupings"><code>module-items-ordered-within-groupings</code></a></h2>
<p>Whether the items within module groups should be ordered alphabetically or not.</p>
<p>This option can be configured to “all”, “none”, or a list of specific grouping names that should be checked
(e.g. only “enums”).</p>
<p><strong>Default Value:</strong> <code>"none"</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#arbitrary_source_item_ordering"><code>arbitrary_source_item_ordering</code></a></li>
</ul>
<h2 id="msrv"><a class="header" href="#msrv"><code>msrv</code></a></h2>
<p>The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p><strong>Default Value:</strong> <code>current version</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#allow_attributes"><code>allow_attributes</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#allow_attributes_without_reason"><code>allow_attributes_without_reason</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#almost_complete_range"><code>almost_complete_range</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant"><code>approx_constant</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#assigning_clones"><code>assigning_clones</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#borrow_as_ptr"><code>borrow_as_ptr</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#cast_abs_to_unsigned"><code>cast_abs_to_unsigned</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#checked_conversions"><code>checked_conversions</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#cloned_instead_of_copied"><code>cloned_instead_of_copied</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match"><code>collapsible_match</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_str_replace"><code>collapsible_str_replace</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr"><code>deprecated_cfg_attr</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls"><code>derivable_impls</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#err_expect"><code>err_expect</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#filter_map_next"><code>filter_map_next</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into"><code>from_over_into</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#if_then_some_else_none"><code>if_then_some_else_none</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#index_refutable_slice"><code>index_refutable_slice</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#inefficient_to_string"><code>inefficient_to_string</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#io_other_error"><code>io_other_error</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#iter_kv_map"><code>iter_kv_map</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#legacy_numeric_constants"><code>legacy_numeric_constants</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#len_zero"><code>len_zero</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#lines_filter_map_ok"><code>lines_filter_map_ok</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_abs_diff"><code>manual_abs_diff</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits"><code>manual_bits</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_c_str_literals"><code>manual_c_str_literals</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp"><code>manual_clamp</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil"><code>manual_div_ceil</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten"><code>manual_flatten</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_hash_one"><code>manual_hash_one</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_is_ascii_check"><code>manual_is_ascii_check</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_is_power_of_two"><code>manual_is_power_of_two</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_let_else"><code>manual_let_else</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_midpoint"><code>manual_midpoint</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive"><code>manual_non_exhaustive</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_option_as_slice"><code>manual_option_as_slice</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_pattern_char_comparison"><code>manual_pattern_char_comparison</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains"><code>manual_range_contains</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_rem_euclid"><code>manual_rem_euclid</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_repeat_n"><code>manual_repeat_n</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_retain"><code>manual_retain</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_slice_fill"><code>manual_slice_fill</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_slice_size_calculation"><code>manual_slice_size_calculation</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once"><code>manual_split_once</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat"><code>manual_str_repeat</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip"><code>manual_strip</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#manual_try_fold"><code>manual_try_fold</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#map_clone"><code>map_clone</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or"><code>map_unwrap_or</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#map_with_unused_argument_over_ranges"><code>map_with_unused_argument_over_ranges</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro"><code>match_like_matches_macro</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_option_with_some"><code>mem_replace_option_with_some</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_with_default"><code>mem_replace_with_default</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_const_for_fn"><code>missing_const_for_fn</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow"><code>needless_borrow</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#non_std_lazy_statics"><code>non_std_lazy_statics</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref"><code>option_as_ref_deref</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#or_fun_call"><code>or_fun_call</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#ptr_as_ptr"><code>ptr_as_ptr</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#question_mark"><code>question_mark</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names"><code>redundant_field_names</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes"><code>redundant_static_lifetimes</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#repeat_vec_with_capacity"><code>repeat_vec_with_capacity</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push"><code>same_item_push</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#seek_from_current"><code>seek_from_current</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some"><code>to_digit_is_some</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref"><code>transmute_ptr_to_ref</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#tuple_array_conversions"><code>tuple_array_conversions</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds"><code>type_repetition_in_bounds</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unchecked_time_subtraction"><code>unchecked_time_subtraction</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args"><code>uninlined_format_args</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations"><code>unnecessary_lazy_evaluations</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap"><code>unnecessary_unwrap</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unnested_or_patterns"><code>unnested_or_patterns</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unused_trait_names"><code>unused_trait_names</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#use_self"><code>use_self</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#zero_ptr"><code>zero_ptr</code></a></li>
</ul>
<h2 id="pass-by-value-size-limit"><a class="header" href="#pass-by-value-size-limit"><code>pass-by-value-size-limit</code></a></h2>
<p>The minimum size (in bytes) to consider a type for passing by reference instead of by value.</p>
<p><strong>Default Value:</strong> <code>256</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value"><code>large_types_passed_by_value</code></a></li>
</ul>
<h2 id="pub-underscore-fields-behavior"><a class="header" href="#pub-underscore-fields-behavior"><code>pub-underscore-fields-behavior</code></a></h2>
<p>Lint “public” fields in a struct that are prefixed with an underscore based on their
exported visibility, or whether they are marked as “pub”.</p>
<p><strong>Default Value:</strong> <code>"PubliclyExported"</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#pub_underscore_fields"><code>pub_underscore_fields</code></a></li>
</ul>
<h2 id="recursive-self-in-type-definitions"><a class="header" href="#recursive-self-in-type-definitions"><code>recursive-self-in-type-definitions</code></a></h2>
<p>Whether the type itself in a struct or enum should be replaced with <code>Self</code> when encountering recursive types.</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#use_self"><code>use_self</code></a></li>
</ul>
<h2 id="semicolon-inside-block-ignore-singleline"><a class="header" href="#semicolon-inside-block-ignore-singleline"><code>semicolon-inside-block-ignore-singleline</code></a></h2>
<p>Whether to lint only if it’s multiline.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#semicolon_inside_block"><code>semicolon_inside_block</code></a></li>
</ul>
<h2 id="semicolon-outside-block-ignore-multiline"><a class="header" href="#semicolon-outside-block-ignore-multiline"><code>semicolon-outside-block-ignore-multiline</code></a></h2>
<p>Whether to lint only if it’s singleline.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#semicolon_outside_block"><code>semicolon_outside_block</code></a></li>
</ul>
<h2 id="single-char-binding-names-threshold"><a class="header" href="#single-char-binding-names-threshold"><code>single-char-binding-names-threshold</code></a></h2>
<p>The maximum number of single char bindings a scope may have</p>
<p><strong>Default Value:</strong> <code>4</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names"><code>many_single_char_names</code></a></li>
</ul>
<h2 id="source-item-ordering"><a class="header" href="#source-item-ordering"><code>source-item-ordering</code></a></h2>
<p>Which kind of elements should be ordered internally, possible values being <code>enum</code>, <code>impl</code>, <code>module</code>, <code>struct</code>, <code>trait</code>.</p>
<p><strong>Default Value:</strong> <code>["enum", "impl", "module", "struct", "trait"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#arbitrary_source_item_ordering"><code>arbitrary_source_item_ordering</code></a></li>
</ul>
<h2 id="stack-size-threshold"><a class="header" href="#stack-size-threshold"><code>stack-size-threshold</code></a></h2>
<p>The maximum allowed stack size for functions in bytes</p>
<p><strong>Default Value:</strong> <code>512000</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_frames"><code>large_stack_frames</code></a></li>
</ul>
<h2 id="standard-macro-braces"><a class="header" href="#standard-macro-braces"><code>standard-macro-braces</code></a></h2>
<p>Enforce the named macros always use the braces specified.</p>
<p>A <code>MacroMatcher</code> can be added like so <code>{ name = "macro_name", brace = "(" }</code>. If the macro
could be used with a full path two <code>MacroMatcher</code>s have to be added one with the full path
<code>crate_name::macro_name</code> and one with just the macro name.</p>
<p><strong>Default Value:</strong> <code>[]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#nonstandard_macro_braces"><code>nonstandard_macro_braces</code></a></li>
</ul>
<h2 id="struct-field-name-threshold"><a class="header" href="#struct-field-name-threshold"><code>struct-field-name-threshold</code></a></h2>
<p>The minimum number of struct fields for the lints about field names to trigger</p>
<p><strong>Default Value:</strong> <code>3</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#struct_field_names"><code>struct_field_names</code></a></li>
</ul>
<h2 id="suppress-restriction-lint-in-const"><a class="header" href="#suppress-restriction-lint-in-const"><code>suppress-restriction-lint-in-const</code></a></h2>
<p>Whether to suppress a restriction lint in constant code. In same
cases the restructured operation might not be unavoidable, as the
suggested counterparts are unavailable in constant code. This
configuration will cause restriction lints to trigger even
if no suggestion can be made.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing"><code>indexing_slicing</code></a></li>
</ul>
<h2 id="too-large-for-stack"><a class="header" href="#too-large-for-stack"><code>too-large-for-stack</code></a></h2>
<p>The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap</p>
<p><strong>Default Value:</strong> <code>200</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local"><code>boxed_local</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#useless_vec"><code>useless_vec</code></a></li>
</ul>
<h2 id="too-many-arguments-threshold"><a class="header" href="#too-many-arguments-threshold"><code>too-many-arguments-threshold</code></a></h2>
<p>The maximum number of argument a function or method can have</p>
<p><strong>Default Value:</strong> <code>7</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments"><code>too_many_arguments</code></a></li>
</ul>
<h2 id="too-many-lines-threshold"><a class="header" href="#too-many-lines-threshold"><code>too-many-lines-threshold</code></a></h2>
<p>The maximum number of lines a function or method can have</p>
<p><strong>Default Value:</strong> <code>100</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines"><code>too_many_lines</code></a></li>
</ul>
<h2 id="trait-assoc-item-kinds-order"><a class="header" href="#trait-assoc-item-kinds-order"><code>trait-assoc-item-kinds-order</code></a></h2>
<p>The order of associated items in traits.</p>
<p><strong>Default Value:</strong> <code>["const", "type", "fn"]</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#arbitrary_source_item_ordering"><code>arbitrary_source_item_ordering</code></a></li>
</ul>
<h2 id="trivial-copy-size-limit"><a class="header" href="#trivial-copy-size-limit"><code>trivial-copy-size-limit</code></a></h2>
<p>The maximum size (in bytes) to consider a <code>Copy</code> type for passing by value instead of by
reference.</p>
<p><strong>Default Value:</strong> <code>target_pointer_width</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref"><code>trivially_copy_pass_by_ref</code></a></li>
</ul>
<h2 id="type-complexity-threshold"><a class="header" href="#type-complexity-threshold"><code>type-complexity-threshold</code></a></h2>
<p>The maximum complexity a type can have</p>
<p><strong>Default Value:</strong> <code>250</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#type_complexity"><code>type_complexity</code></a></li>
</ul>
<h2 id="unnecessary-box-size"><a class="header" href="#unnecessary-box-size"><code>unnecessary-box-size</code></a></h2>
<p>The byte size a <code>T</code> in <code>Box&lt;T&gt;</code> can have, below which it triggers the <code>clippy::unnecessary_box</code> lint</p>
<p><strong>Default Value:</strong> <code>128</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_box_returns"><code>unnecessary_box_returns</code></a></li>
</ul>
<h2 id="unreadable-literal-lint-fractions"><a class="header" href="#unreadable-literal-lint-fractions"><code>unreadable-literal-lint-fractions</code></a></h2>
<p>Should the fraction of a decimal be linted to include separators.</p>
<p><strong>Default Value:</strong> <code>true</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#unreadable_literal"><code>unreadable_literal</code></a></li>
</ul>
<h2 id="upper-case-acronyms-aggressive"><a class="header" href="#upper-case-acronyms-aggressive"><code>upper-case-acronyms-aggressive</code></a></h2>
<p>Enables verbose mode. Triggers if there is more than one uppercase char next to each other</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#upper_case_acronyms"><code>upper_case_acronyms</code></a></li>
</ul>
<h2 id="vec-box-size-threshold"><a class="header" href="#vec-box-size-threshold"><code>vec-box-size-threshold</code></a></h2>
<p>The size of the boxed type in bytes, where boxing in a <code>Vec</code> is allowed</p>
<p><strong>Default Value:</strong> <code>4096</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#vec_box"><code>vec_box</code></a></li>
</ul>
<h2 id="verbose-bit-mask-threshold"><a class="header" href="#verbose-bit-mask-threshold"><code>verbose-bit-mask-threshold</code></a></h2>
<p>The maximum allowed size of a bit mask before suggesting to use ‘trailing_zeros’</p>
<p><strong>Default Value:</strong> <code>1</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#verbose_bit_mask"><code>verbose_bit_mask</code></a></li>
</ul>
<h2 id="warn-on-all-wildcard-imports"><a class="header" href="#warn-on-all-wildcard-imports"><code>warn-on-all-wildcard-imports</code></a></h2>
<p>Whether to emit warnings on all wildcard imports, including those from <code>prelude</code>, from <code>super</code> in tests,
or for <code>pub use</code> reexports.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#wildcard_imports"><code>wildcard_imports</code></a></li>
</ul>
<h2 id="warn-unsafe-macro-metavars-in-private-macros"><a class="header" href="#warn-unsafe-macro-metavars-in-private-macros"><code>warn-unsafe-macro-metavars-in-private-macros</code></a></h2>
<p>Whether to also emit warnings for unsafe blocks with metavariable expansions in <strong>private</strong> macros.</p>
<p><strong>Default Value:</strong> <code>false</code></p>
<hr>
<p><strong>Affected lints:</strong></p>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#macro_metavars_in_unsafe"><code>macro_metavars_in_unsafe</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="clippys-lints"><a class="header" href="#clippys-lints">Clippy’s Lints</a></h1>
<p>Clippy offers a bunch of additional lints, to help its users write more correct
and idiomatic Rust code. A full list of all lints, that can be filtered by
category, lint level or keywords, can be found in the <a href="https://rust-lang.github.io/rust-clippy/">Clippy lint
documentation</a>.</p>
<p>This chapter will give an overview of the different lint categories, which kind
of lints they offer and recommended actions when you should see a lint out of
that category. For examples, see the <a href="https://rust-lang.github.io/rust-clippy/">Clippy lint documentation</a> and filter by
category.</p>
<p>The different lint groups were defined in the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#lint-audit-and-categories">Clippy 1.0 RFC</a>.</p>
<h2 id="correctness"><a class="header" href="#correctness">Correctness</a></h2>
<p>The <code>clippy::correctness</code> group is the only lint group in Clippy which lints are
deny-by-default and abort the compilation when triggered. This is for good
reason: If you see a <code>correctness</code> lint, it means that your code is outright
wrong or useless, and you should try to fix it.</p>
<p>Lints in this category are carefully picked and should be free of false
positives. So just <code>#[allow]</code>ing those lints is not recommended.</p>
<h2 id="suspicious"><a class="header" href="#suspicious">Suspicious</a></h2>
<p>The <code>clippy::suspicious</code> group is similar to the correctness lints in that it
contains lints that trigger on code that is really <em>sus</em> and should be fixed. As
opposed to correctness lints, it might be possible that the linted code is
intentionally written like it is.</p>
<p>It is still recommended to fix code that is linted by lints out of this group
instead of <code>#[allow]</code>ing the lint. In case you intentionally have written code
that offends the lint you should specifically and locally <code>#[allow]</code> the lint
and add give a reason why the code is correct as written.</p>
<h2 id="complexity"><a class="header" href="#complexity">Complexity</a></h2>
<p>The <code>clippy::complexity</code> group offers lints that give you suggestions on how to
simplify your code. It mostly focuses on code that can be written in a shorter
and more readable way, while preserving the semantics.</p>
<p>If you should see a complexity lint, it usually means that you can remove or
replace some code, and it is recommended to do so. However, if you need the more
complex code for some expressiveness reason, it is recommended to allow
complexity lints on a case-by-case basis.</p>
<h2 id="perf"><a class="header" href="#perf">Perf</a></h2>
<p>The <code>clippy::perf</code> group gives you suggestions on how you can increase the
performance of your code. Those lints are mostly about code that the compiler
can’t trivially optimize, but has to be written in a slightly different way to
make the optimizer job easier.</p>
<p>Perf lints are usually easy to apply, and it is recommended to do so.</p>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>The <code>clippy::style</code> group is mostly about writing idiomatic code. Because style
is subjective, this lint group is the most opinionated warn-by-default group in
Clippy.</p>
<p>If you see a style lint, applying the suggestion usually makes your code more
readable and idiomatic. But because we know that this is opinionated, feel free
to sprinkle <code>#[allow]</code>s for style lints in your code or <code>#![allow]</code> a style lint
on your whole crate if you disagree with the suggested style completely.</p>
<h2 id="pedantic"><a class="header" href="#pedantic">Pedantic</a></h2>
<p>The <code>clippy::pedantic</code> group makes Clippy even more <em>pedantic</em>. You can enable
the whole group with <code>#![warn(clippy::pedantic)]</code> in the <code>lib.rs</code>/<code>main.rs</code> of
your crate. This lint group is for Clippy power users that want an in depth
check of their code.</p>
<blockquote>
<p><em>Note:</em> Instead of enabling the whole group (like Clippy itself does), you may
want to cherry-pick lints out of the pedantic group.</p>
</blockquote>
<p>If you enable this group, expect to also use <code>#[allow]</code> attributes generously
throughout your code. Lints in this group are designed to be pedantic and false
positives sometimes are intentional in order to prevent false negatives.</p>
<h2 id="restriction"><a class="header" href="#restriction">Restriction</a></h2>
<p>The <code>clippy::restriction</code> group contains lints that will <em>restrict</em> you from
using certain parts of the Rust language. It is <strong>not</strong> recommended to enable
the whole group, but rather cherry-pick lints that are useful for your code base
and your use case.</p>
<blockquote>
<p><em>Note:</em> Clippy will produce a warning if it finds a
<code>#![warn(clippy::restriction)]</code> attribute in your code!</p>
</blockquote>
<p>Lints from this group will restrict you in some way. If you enable a restriction
lint for your crate it is recommended to also fix code that this lint triggers
on. However, those lints are really strict by design, and you might want to
<code>#[allow]</code> them in some special cases, with a comment justifying that.</p>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>The <code>clippy::cargo</code> group gives you suggestions on how to improve your
<code>Cargo.toml</code> file. This might be especially interesting if you want to publish
your crate and are not sure if you have all useful information in your
<code>Cargo.toml</code>.</p>
<h2 id="nursery"><a class="header" href="#nursery">Nursery</a></h2>
<p>The <code>clippy::nursery</code> group contains lints which are buggy or need more work. It is <strong>not</strong>
recommended to enable the whole group, but rather cherry-pick lints that are useful for your
code base and your use case.</p>
<h2 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h2>
<p>The <code>clippy::deprecated</code> is empty lints that exist to ensure that <code>#[allow(lintname)]</code> still
compiles after the lint was deprecated. Deprecation “removes” lints by removing their
functionality and marking them as deprecated, which may cause further warnings but cannot
cause a compiler error.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="attributes-for-crate-authors"><a class="header" href="#attributes-for-crate-authors">Attributes for Crate Authors</a></h1>
<p>In some cases it is possible to extend Clippy coverage to 3rd party libraries.
To do this, Clippy provides attributes that can be applied to items in the 3rd party crate.</p>
<h2 id="clippyformat_args"><a class="header" href="#clippyformat_args"><code>#[clippy::format_args]</code></a></h2>
<p><em>Available since Clippy v1.85</em></p>
<p>This attribute can be added to a macro that supports <code>format!</code>, <code>println!</code>, or similar syntax.
It tells Clippy that the macro is a formatting macro, and that the arguments to the macro
should be linted as if they were arguments to <code>format!</code>. Any lint that would apply to a
<code>format!</code> call will also apply to the macro call. The macro may have additional arguments
before the format string, and these will be ignored.</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A macro that prints a message if a condition is true.
#[macro_export]
#[clippy::format_args]
macro_rules! print_if {
    ($condition:expr, $($args:tt)+) =&gt; {{
        if $condition {
            println!($($args)+)
        }
    }};
}
<span class="boring">}</span></code></pre>
<h2 id="clippyhas_significant_drop"><a class="header" href="#clippyhas_significant_drop"><code>#[clippy::has_significant_drop]</code></a></h2>
<p><em>Available since Clippy v1.60</em></p>
<p>The <code>clippy::has_significant_drop</code> attribute can be added to types whose Drop impls have an important side effect,
such as unlocking a mutex, making it important for users to be able to accurately understand their lifetimes.
When a temporary is returned in a function call in a match scrutinee, its lifetime lasts until the end of the match
block, which may be surprising.</p>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example</a></h3>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[clippy::has_significant_drop]
struct CounterWrapper&lt;'a&gt; {
    counter: &amp;'a Counter,
}

impl&lt;'a&gt; Drop for CounterWrapper&lt;'a&gt; {
    fn drop(&amp;mut self) {
        self.counter.i.fetch_sub(1, Ordering::Relaxed);
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<p>It is recommended to run Clippy on CI with <code>-Dwarnings</code>, so that Clippy lints
prevent CI from passing. To enforce errors on warnings on all <code>cargo</code> commands
not just <code>cargo clippy</code>, you can set the env var <code>RUSTFLAGS="-Dwarnings"</code>.</p>
<p>We recommend to use Clippy from the same toolchain, that you use for compiling
your crate for maximum compatibility. E.g. if your crate is compiled with the
<code>stable</code> toolchain, you should also use <code>stable</code> Clippy.</p>
<blockquote>
<p><em>Note:</em> New Clippy lints are first added to the <code>nightly</code> toolchain. If you
want to help with improving Clippy and have CI resources left, please consider
adding a <code>nightly</code> Clippy check to your CI and report problems like false
positives back to us. With that we can fix bugs early, before they can get to
stable.</p>
</blockquote>
<p>This chapter will give an overview on how to use Clippy on different popular CI
providers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h1>
<p>GitHub hosted runners using the latest stable version of Rust have Clippy pre-installed.
It is as simple as running <code>cargo clippy</code> to run lints against the codebase.</p>
<pre><code class="language-yml">on: push
name: Clippy check

# Make sure CI fails on all warnings, including Clippy lints
env:
  RUSTFLAGS: "-Dwarnings"

jobs:
  clippy_check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - name: Run Clippy
        run: cargo clippy --all-targets --all-features
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gitlab-ci"><a class="header" href="#gitlab-ci">GitLab CI</a></h1>
<p>You can add Clippy to GitLab CI by using the latest stable <a href="https://hub.docker.com/_/rust">rust docker image</a>,
as it is shown in the <code>.gitlab-ci.yml</code> CI configuration file below,</p>
<pre><code class="language-yml"># Make sure CI fails on all warnings, including Clippy lints
variables:
  RUSTFLAGS: "-Dwarnings"

clippy_check:
  image: rust:latest
  script:
    - rustup component add clippy
    - cargo clippy --all-targets --all-features
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="travis-ci"><a class="header" href="#travis-ci">Travis CI</a></h1>
<p>You can add Clippy to Travis CI in the same way you use it locally:</p>
<pre><code class="language-yml">language: rust
rust:
  - stable
  - beta
before_script:
  - rustup component add clippy
script:
  - cargo clippy
  # if you want the build job to fail when encountering warnings, use
  - cargo clippy -- -D warnings
  # in order to also check tests and non-default crate features, use
  - cargo clippy --all-targets --all-features -- -D warnings
  - cargo test
  # etc.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="clippy-development"><a class="header" href="#clippy-development">Clippy Development</a></h1>
<p>Hello fellow Rustacean! If you made it here, you’re probably interested in
making Clippy better by contributing to it. In that case, welcome to the
project!</p>
<blockquote>
<p><em>Note:</em> If you’re just interested in using Clippy, there’s nothing to see from
this point onward, and you should return to one of the earlier chapters.</p>
</blockquote>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>If this is your first time contributing to Clippy, you should first read the
<a href="#basics-for-hacking-on-clippy">Basics docs</a>. This will explain the basics on how to get the source
code and how to compile and test the code.</p>
<h2 id="additional-readings-for-beginners"><a class="header" href="#additional-readings-for-beginners">Additional Readings for Beginners</a></h2>
<p>If a dear reader of this documentation has never taken a class on compilers
and interpreters, it might be confusing as to why AST level deals with only
the language’s syntax. And some readers might not even understand what lexing,
parsing, and AST mean.</p>
<p>This documentation serves by no means as a crash course on compilers or language design.
And for details specifically related to Rust, the <a href="https://rustc-dev-guide.rust-lang.org/">Rustc Development Guide</a>
is a far better choice to peruse.</p>
<p>The <a href="https://rustc-dev-guide.rust-lang.org/syntax-intro.html">Syntax and AST</a> chapter and the <a href="https://rustc-dev-guide.rust-lang.org/hir.html">High-Level IR</a> chapter are
great introduction to the concepts mentioned in this chapter.</p>
<p>Some readers might also find the <a href="https://craftinginterpreters.com/a-map-of-the-territory.html">introductory chapter</a> of
Robert Nystrom’s <em>Crafting Interpreters</em> a helpful overview of compiled and
interpreted languages before jumping back to the Rustc guide.</p>
<h2 id="writing-code"><a class="header" href="#writing-code">Writing code</a></h2>
<p>If you have done the basic setup, it’s time to start hacking.</p>
<p>The <a href="#adding-a-new-lint">Adding lints</a> chapter is a walk through on how to add a
new lint to Clippy. This is also interesting if you just want to fix a lint,
because it also covers how to test lints and gives an overview of the bigger
picture.</p>
<p>If you want to add a new lint or change existing ones apart from bugfixing, it’s
also a good idea to give the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#stability-guarantees">stability guarantees</a> and
<a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#lint-audit-and-categories">lint categories</a> sections of the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md">Clippy 1.0 RFC</a> a
quick read. The lint categories are also described <a href="#clippys-lints">earlier in this
book</a>.</p>
<blockquote>
<p><em>Note:</em> Some higher level things about contributing to Clippy are still
covered in the <a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> document. Some of those will be moved to
the book over time, like:</p>
<ul>
<li>Finding something to fix</li>
<li>IDE setup</li>
<li>High level overview on how Clippy works</li>
<li>Triage procedure</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="basics-for-hacking-on-clippy"><a class="header" href="#basics-for-hacking-on-clippy">Basics for hacking on Clippy</a></h1>
<p>This document explains the basics for hacking on Clippy. Besides others, this
includes how to build and test Clippy. For a more in depth description on the
codebase take a look at <a href="#adding-a-new-lint">Adding Lints</a> or <a href="#common-tools-for-writing-lints">Common Tools</a>.</p>
<ul>
<li><a href="#basics-for-hacking-on-clippy">Basics for hacking on Clippy</a>
<ul>
<li><a href="#get-the-code">Get the Code</a></li>
<li><a href="#building-and-testing">Building and Testing</a></li>
<li><a href="#cargo-dev"><code>cargo dev</code></a></li>
<li><a href="#lintcheck">lintcheck</a></li>
<li><a href="#pr">PR</a></li>
<li><a href="#common-abbreviations">Common Abbreviations</a></li>
<li><a href="#install-from-source">Install from source</a></li>
</ul>
</li>
</ul>
<h2 id="get-the-code"><a class="header" href="#get-the-code">Get the Code</a></h2>
<p>First, make sure you have checked out the latest version of Clippy. If this is
your first time working on Clippy, create a fork of the repository and clone it
afterwards with the following command:</p>
<pre><code class="language-bash">git clone git@github.com:&lt;your-username&gt;/rust-clippy
</code></pre>
<p>If you’ve already cloned Clippy in the past, update it to the latest version:</p>
<pre><code class="language-bash"># If the upstream remote has not been added yet
git remote add upstream https://github.com/rust-lang/rust-clippy
# upstream has to be the remote of the rust-lang/rust-clippy repo
git fetch upstream
# make sure that you are on the master branch
git checkout master
# rebase your master branch on the upstream master
git rebase upstream/master
# push to the master branch of your fork
git push
</code></pre>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and Testing</a></h2>
<p>You can build and test Clippy like every other Rust project:</p>
<pre><code class="language-bash">cargo build  # builds Clippy
cargo test   # tests Clippy
</code></pre>
<p>Since Clippy’s test suite is pretty big, there are some commands that only run a
subset of Clippy’s tests:</p>
<pre><code class="language-bash"># only run UI tests
cargo uitest
# only run UI tests starting with `test_`
TESTNAME="test_" cargo uitest
# only run dogfood tests
cargo dev dogfood
</code></pre>
<p>If the output of a <a href="https://rustc-dev-guide.rust-lang.org/tests/adding.html#ui-test-walkthrough">UI test</a> differs from the expected output, you can update
the reference file with:</p>
<pre><code class="language-bash">cargo bless
</code></pre>
<p>For example, this is necessary if you fix a typo in an error message of a lint,
or if you modify a test file to add a test case.</p>
<blockquote>
<p><em>Note:</em> This command may update more files than you intended. In that case
only commit the files you wanted to update.</p>
</blockquote>
<h2 id="cargo-dev"><a class="header" href="#cargo-dev"><code>cargo dev</code></a></h2>
<p>Clippy has some dev tools to make working on Clippy more convenient. These tools
can be accessed through the <code>cargo dev</code> command. Available tools are listed
below. To get more information about these commands, just call them with
<code>--help</code>.</p>
<pre><code class="language-bash"># formats the whole Clippy codebase and all tests
cargo dev fmt
# register or update lint names/groups/...
cargo dev update_lints
# create a new lint and register it
cargo dev new_lint
# deprecate a lint and attempt to remove code relating to it
cargo dev deprecate
# automatically formatting all code before each commit
cargo dev setup git-hook
# (experimental) Setup Clippy to work with RustRover
cargo dev setup intellij
# runs the `dogfood` tests
cargo dev dogfood
</code></pre>
<p>More about <a href="https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#rustrover">intellij</a> command usage and reasons.</p>
<h2 id="lintcheck"><a class="header" href="#lintcheck">lintcheck</a></h2>
<p><code>cargo lintcheck</code> will build and run Clippy on a fixed set of crates and
generate a log of the results.  You can <code>git diff</code> the updated log against its
previous version and see what impact your lint made on a small set of crates.
If you add a new lint, please audit the resulting warnings and make sure there
are no false positives and that the suggestions are valid.</p>
<p>Refer to the tools <a href="https://github.com/rust-lang/rust-clippy/blob/master/lintcheck/README.md">README</a> for more details.</p>
<h2 id="pr"><a class="header" href="#pr">PR</a></h2>
<p>We follow a rustc no merge-commit policy. See
<a href="https://rustc-dev-guide.rust-lang.org/contributing.html#opening-a-pr">https://rustc-dev-guide.rust-lang.org/contributing.html#opening-a-pr</a>.</p>
<h2 id="common-abbreviations"><a class="header" href="#common-abbreviations">Common Abbreviations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Abbreviation</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>UB</td><td>Undefined Behavior</td></tr>
<tr><td>FP</td><td>False Positive</td></tr>
<tr><td>FN</td><td>False Negative</td></tr>
<tr><td>ICE</td><td>Internal Compiler Error</td></tr>
<tr><td>AST</td><td>Abstract Syntax Tree</td></tr>
<tr><td>MIR</td><td>Mid-Level Intermediate Representation</td></tr>
<tr><td>HIR</td><td>High-Level Intermediate Representation</td></tr>
<tr><td>TCX</td><td>Type context</td></tr>
</tbody>
</table>
</div>
<p>This is a concise list of abbreviations that can come up during Clippy
development. An extensive general list can be found in the <a href="https://rustc-dev-guide.rust-lang.org/appendix/glossary.html">rustc-dev-guide
glossary</a>. Always feel free to ask if an abbreviation or meaning is
unclear to you.</p>
<h2 id="install-from-source"><a class="header" href="#install-from-source">Install from source</a></h2>
<p>If you are hacking on Clippy and want to install it from source, do the
following:</p>
<p>From the Clippy project root, run the following command to build the Clippy
binaries and copy them into the toolchain directory. This will create a new
toolchain called <code>clippy</code> by default, see <code>cargo dev setup toolchain --help</code>
for other options.</p>
<pre><code class="language-terminal">cargo dev setup toolchain
</code></pre>
<p>Now you may run <code>cargo +clippy clippy</code> in any project using the new toolchain.</p>
<pre><code class="language-terminal">cd my-project
cargo +clippy clippy
</code></pre>
<p>…or <code>clippy-driver</code></p>
<pre><code class="language-terminal">clippy-driver +clippy &lt;filename&gt;
</code></pre>
<p>If you no longer need the toolchain it can be uninstalled using <code>rustup</code>:</p>
<pre><code class="language-terminal">rustup toolchain uninstall clippy
</code></pre>
<blockquote>
<p><strong>DO NOT</strong> install using <code>cargo install --path . --force</code> since this will
overwrite rustup
<a href="https://rust-lang.github.io/rustup/concepts/proxies.html">proxies</a>. That is,
<code>~/.cargo/bin/cargo-clippy</code> and <code>~/.cargo/bin/clippy-driver</code> should be hard or
soft links to <code>~/.cargo/bin/rustup</code>. You can repair these by running <code>rustup update</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adding-a-new-lint"><a class="header" href="#adding-a-new-lint">Adding a new lint</a></h1>
<p>You are probably here because you want to add a new lint to Clippy. If this is
the first time you’re contributing to Clippy, this document guides you through
creating an example lint from scratch.</p>
<p>To get started, we will create a lint that detects functions called <code>foo</code>,
because that’s clearly a non-descriptive name.</p>
<ul>
<li><a href="#adding-a-new-lint">Adding a new lint</a>
<ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#getting-started-1">Getting Started</a>
<ul>
<li><a href="#defining-our-lint">Defining Our Lint</a>
<ul>
<li><a href="#standalone">Standalone</a></li>
<li><a href="#specific-type">Specific Type</a></li>
<li><a href="#tests-location">Tests Location</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#testing">Testing</a>
<ul>
<li><a href="#cargo-lints">Cargo lints</a></li>
</ul>
</li>
<li><a href="#rustfix-tests">Rustfix tests</a></li>
<li><a href="#testing-manually">Testing manually</a></li>
<li><a href="#lint-declaration">Lint declaration</a></li>
<li><a href="#lint-registration">Lint registration</a></li>
<li><a href="#lint-passes">Lint passes</a></li>
<li><a href="#emitting-a-lint">Emitting a lint</a></li>
<li><a href="#adding-the-lint-logic">Adding the lint logic</a></li>
<li><a href="#specifying-the-lints-minimum-supported-rust-version-msrv">Specifying the lint’s minimum supported Rust version (MSRV)</a></li>
<li><a href="#author-lint">Author lint</a></li>
<li><a href="#print-hir-lint">Print HIR lint</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#running-rustfmt">Running rustfmt</a></li>
<li><a href="#debugging">Debugging</a></li>
<li><a href="#conflicting-lints">Conflicting lints</a></li>
<li><a href="#pr-checklist">PR Checklist</a></li>
<li><a href="#adding-configuration-to-a-lint">Adding configuration to a lint</a></li>
<li><a href="#cheat-sheet">Cheat Sheet</a></li>
</ul>
</li>
</ul>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>See the <a href="#get-the-code">Basics</a> documentation.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>There is a bit of boilerplate code that needs to be set up when creating a new
lint. Fortunately, you can use the Clippy dev tools to handle this for you. We
are naming our new lint <code>foo_functions</code> (lints are generally written in snake
case), and we don’t need type information, so it will have an early pass type
(more on this later). If you’re unsure if the name you chose fits the lint,
take a look at our <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming guidelines</a>.</p>
<h2 id="defining-our-lint"><a class="header" href="#defining-our-lint">Defining Our Lint</a></h2>
<p>To get started, there are two ways to define our lint.</p>
<h3 id="standalone"><a class="header" href="#standalone">Standalone</a></h3>
<p>Command: <code>cargo dev new_lint --name=foo_functions --pass=early --category=pedantic</code>
(category will default to nursery if not provided)</p>
<p>This command will create a new file: <code>clippy_lints/src/foo_functions.rs</code>, as well
as <a href="#lint-registration">register the lint</a>.</p>
<h3 id="specific-type"><a class="header" href="#specific-type">Specific Type</a></h3>
<p>Command: <code>cargo dev new_lint --name=foo_functions --type=functions --category=pedantic</code></p>
<p>This command will create a new file: <code>clippy_lints/src/{type}/foo_functions.rs</code>.</p>
<p>Notice how this command has a <code>--type</code> flag instead of <code>--pass</code>. Unlike a standalone
definition, this lint won’t be registered in the traditional sense. Instead, you will
call your lint from within the type’s lint pass, found in <code>clippy_lints/src/{type}/mod.rs</code>.</p>
<p>A “type” is just the name of a directory in <code>clippy_lints/src</code>, like <code>functions</code> in
the example command. These are groupings of lints with common behaviors, so if your
lint falls into one, it would be best to add it to that type.</p>
<h3 id="tests-location"><a class="header" href="#tests-location">Tests Location</a></h3>
<p>Both commands will create a file: <code>tests/ui/foo_functions.rs</code>. For cargo lints,
two project hierarchies (fail/pass) will be created by default under <code>tests/ui-cargo</code>.</p>
<p>Next, we’ll open up these files and add our lint!</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Let’s write some tests first that we can execute while we iterate on our lint.</p>
<p>Clippy uses UI tests for testing. UI tests check that the output of Clippy is
exactly as expected. Each test is just a plain Rust file that contains the code
we want to check. The output of Clippy is compared against a <code>.stderr</code> file.
Note that you don’t have to create this file yourself, we’ll get to generating
the <code>.stderr</code> files further down.</p>
<p>We start by opening the test file created at <code>tests/ui/foo_functions.rs</code>.</p>
<p>Update the file with some examples to get started:</p>
<pre class="playground"><code class="language-rust edition2024">#![allow(unused)]
#![warn(clippy::foo_functions)]

// Impl methods
struct A;
impl A {
    pub fn fo(&amp;self) {}
    pub fn foo(&amp;self) {}
    //~^ foo_functions
    pub fn food(&amp;self) {}
}

// Default trait methods
trait B {
    fn fo(&amp;self) {}
    fn foo(&amp;self) {}
    //~^ foo_functions
    fn food(&amp;self) {}
}

// Plain functions
fn fo() {}
fn foo() {}
//~^ foo_functions
fn food() {}

fn main() {
    // We also don't want to lint method calls
    foo();
    let a = A;
    a.foo();
}</code></pre>
<p>Note that we are adding comment annotations with the name of our lint to mark
lines where we expect an error. Except for very specific situations
(<code>//@check-pass</code>), at least one error marker must be present in a test file for
it to be accepted.</p>
<p>Once we have implemented our lint we can run <code>TESTNAME=foo_functions cargo uibless</code> to generate the <code>.stderr</code> file. If our lint makes use of structured
suggestions then this command will also generate the corresponding <code>.fixed</code>
file.</p>
<p>While we are working on implementing our lint, we can keep running the UI test.
That allows us to check if the output is turning into what we want by checking the
<code>.stderr</code> file that gets updated on every test run.</p>
<p>Once we have implemented our lint running <code>TESTNAME=foo_functions cargo uitest</code>
should pass on its own. When we commit our lint, we need to commit the generated
<code>.stderr</code> and if applicable <code>.fixed</code> files, too. In general, you should only
commit files changed by <code>cargo bless</code> for the specific lint you are creating/editing.</p>
<blockquote>
<p><em>Note:</em> you can run multiple test files by specifying a comma separated list:
<code>TESTNAME=foo_functions,test2,test3</code>.</p>
</blockquote>
<h3 id="cargo-lints"><a class="header" href="#cargo-lints">Cargo lints</a></h3>
<p>For cargo lints, the process of testing differs in that we are interested in the
<code>Cargo.toml</code> manifest file. We also need a minimal crate associated with that
manifest.</p>
<p>If our new lint is named e.g. <code>foo_categories</code>, after running <code>cargo dev new_lint --name=foo_categories --type=cargo --category=cargo</code> we will find by
default two new crates, each with its manifest file:</p>
<ul>
<li><code>tests/ui-cargo/foo_categories/fail/Cargo.toml</code>: this file should cause the
new lint to raise an error.</li>
<li><code>tests/ui-cargo/foo_categories/pass/Cargo.toml</code>: this file should not trigger
the lint.</li>
</ul>
<p>If you need more cases, you can copy one of those crates (under
<code>foo_categories</code>) and rename it.</p>
<p>The process of generating the <code>.stderr</code> file is the same, and prepending the
<code>TESTNAME</code> variable to <code>cargo uitest</code> works too.</p>
<h2 id="rustfix-tests"><a class="header" href="#rustfix-tests">Rustfix tests</a></h2>
<p>If the lint you are working on is making use of structured suggestions, the test
will create a <code>.fixed</code> file by running <a href="https://github.com/rust-lang/cargo/tree/master/crates/rustfix">rustfix</a> for that test.
Rustfix will apply the suggestions
from the lint to the code of the test file and compare that to the contents of a
<code>.fixed</code> file.</p>
<p>Use <code>cargo bless</code> to automatically generate the <code>.fixed</code> file while running
the tests.</p>
<h2 id="testing-manually"><a class="header" href="#testing-manually">Testing manually</a></h2>
<p>Manually testing against an example file can be useful if you have added some
<code>println!</code>s and the test suite output becomes unreadable. To try Clippy with
your local modifications, run the following from the Clippy directory:</p>
<pre><code class="language-bash">cargo dev lint input.rs
</code></pre>
<p>To run Clippy on an existing project rather than a single file you can use</p>
<pre><code class="language-bash">cargo dev lint /path/to/project
</code></pre>
<p>Or set up a rustup toolchain that points to the local Clippy binaries</p>
<pre><code class="language-bash">cargo dev setup toolchain

# Then in `/path/to/project` you can run
cargo +clippy clippy
</code></pre>
<h2 id="lint-declaration"><a class="header" href="#lint-declaration">Lint declaration</a></h2>
<p>Let’s start by opening the new file created in the <code>clippy_lints</code> crate at
<code>clippy_lints/src/foo_functions.rs</code>. That’s the crate where all the lint code
is. This file has already imported some initial things we will need:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_lint::{EarlyLintPass, EarlyContext};
use rustc_session::declare_lint_pass;
use rustc_ast::ast::*;
<span class="boring">}</span></code></pre>
<p>The next step is to update the lint declaration. Lints are declared using the
<a href="https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L60"><code>declare_clippy_lint!</code></a> macro, and we just need to update
the auto-generated lint declaration to have a real description, something like
this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_clippy_lint! {
    /// ### What it does
    ///
    /// ### Why is this bad?
    ///
    /// ### Example
    /// ```rust
    /// // example code
    /// ```
    #[clippy::version = "1.29.0"]
    pub FOO_FUNCTIONS,
    pedantic,
    "function named `foo`, which is not a descriptive name"
}
<span class="boring">}</span></code></pre>
<ul>
<li>The section of lines prefixed with <code>///</code> constitutes the lint documentation
section. This is the default documentation style and will be displayed <a href="https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure">like
this</a>. To render and open this documentation locally in a
browser, run <code>cargo dev serve</code>.</li>
<li>The <code>#[clippy::version]</code> attribute will be rendered as part of the lint
documentation. The value should be set to the current Rust version that the
lint is developed in, it can be retrieved by running <code>rustc -vV</code> in the
rust-clippy directory. The version is listed under <em>release</em>. (Use the version
without the <code>-nightly</code>) suffix.</li>
<li><code>FOO_FUNCTIONS</code> is the name of our lint. Be sure to follow the <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming
guidelines</a> here when naming your lint. In short, the name should
state the thing that is being checked for and read well when used with
<code>allow</code>/<code>warn</code>/<code>deny</code>.</li>
<li><code>pedantic</code> sets the lint level to <code>Allow</code>. The exact mapping can be found
<a href="#clippy">here</a></li>
<li>The last part should be a text that explains what exactly is wrong with the
code</li>
</ul>
<p>The rest of this file contains an empty implementation for our lint pass, which
in this case is <code>EarlyLintPass</code> and should look like this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// clippy_lints/src/foo_functions.rs

// .. imports and lint declaration ..

declare_lint_pass!(FooFunctions =&gt; [FOO_FUNCTIONS]);

impl EarlyLintPass for FooFunctions {}
<span class="boring">}</span></code></pre>
<h2 id="lint-registration"><a class="header" href="#lint-registration">Lint registration</a></h2>
<p>When using <code>cargo dev new_lint</code>, the lint is automatically registered and
nothing more has to be done.</p>
<p>When declaring a new lint by hand and <code>cargo dev update_lints</code> is used, the lint
pass may have to be registered manually in the <code>register_lints</code> function in
<code>clippy_lints/src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">store.register_early_pass(|| Box::new(foo_functions::FooFunctions));</code></pre>
<p>As one may expect, there is a corresponding <code>register_late_pass</code> method
available as well. Without a call to one of <code>register_early_pass</code> or
<code>register_late_pass</code>, the lint pass in question will not be run.</p>
<p>One reason that <code>cargo dev update_lints</code> does not automate this step is that
multiple lints can use the same lint pass, so registering the lint pass may
already be done when adding a new lint. Another reason that this step is not
automated is that the order that the passes are registered determines the order
the passes actually run, which in turn affects the order that any emitted lints
are output in.</p>
<h2 id="lint-passes"><a class="header" href="#lint-passes">Lint passes</a></h2>
<p>Writing a lint that only checks for the name of a function means that we only
have to deal with the AST and don’t have to deal with the type system at all.
This is good, because it makes writing this particular lint less complicated.</p>
<p>We have to make this decision with every new Clippy lint. It boils down to using
either <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a> or <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a>.</p>
<p><code>EarlyLintPass</code> runs before type checking and
<a href="https://rustc-dev-guide.rust-lang.org/hir.html">HIR</a> lowering, while <code>LateLintPass</code>
runs after these stages, providing access to type information. The <code>cargo dev new_lint</code> command
defaults to the recommended <code>LateLintPass</code>, but you can specify <code>--pass=early</code> if your lint
only needs AST level analysis.</p>
<p>Since we don’t need type information for checking the function name, we used
<code>--pass=early</code> when running the new lint automation and all the imports were
added accordingly.</p>
<h2 id="emitting-a-lint"><a class="header" href="#emitting-a-lint">Emitting a lint</a></h2>
<p>With UI tests and the lint declaration in place, we can start working on the
implementation of the lint logic.</p>
<p>Let’s start by implementing the <code>EarlyLintPass</code> for our <code>FooFunctions</code>:</p>
<pre><code class="language-rust ignore">impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        // TODO: Emit lint here
    }
}</code></pre>
<p>We implement the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn"><code>check_fn</code></a> method from the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a> trait. This gives us access to various
information about the function that is currently being checked. More on that in
the next section. Let’s worry about the details later and emit our lint for
<em>every</em> function definition first.</p>
<p>Depending on how complex we want our lint message to be, we can choose from a
variety of lint emission functions. They can all be found in
<a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs"><code>clippy_utils/src/diagnostics.rs</code></a>.</p>
<p><code>span_lint_and_help</code> seems most appropriate in this case. It allows us to
provide an extra help message, and we can’t really suggest a better name
automatically. This is how it looks:</p>
<pre><code class="language-rust ignore">impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        span_lint_and_help(
            cx,
            FOO_FUNCTIONS,
            span,
            "function named `foo`",
            None,
            "consider using a more meaningful name"
        );
    }
}</code></pre>
<p>Running our UI test should now produce output that contains the lint message.</p>
<p>According to <a href="https://rustc-dev-guide.rust-lang.org/diagnostics.html">the rustc-dev-guide</a>, the text should be matter of fact and avoid
capitalization and periods, unless multiple sentences are needed. When code or
an identifier must appear in a message or label, it should be surrounded with
single grave accents `.</p>
<h2 id="adding-the-lint-logic"><a class="header" href="#adding-the-lint-logic">Adding the lint logic</a></h2>
<p>Writing the logic for your lint will most likely be different from our example,
so this section is kept rather short.</p>
<p>Using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn"><code>check_fn</code></a> method gives us access to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html"><code>FnKind</code></a>
that has the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html#variant.Fn"><code>FnKind::Fn</code></a> variant. It provides access to the name of the
function/method via an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html"><code>Ident</code></a>.</p>
<p>With that we can expand our <code>check_fn</code> method to:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl EarlyLintPass for FooFunctions {
    fn check_fn(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, fn_kind: FnKind&lt;'_&gt;, span: Span, _: NodeId) {
        if is_foo_fn(fn_kind) {
            span_lint_and_help(
                cx,
                FOO_FUNCTIONS,
                span,
                "function named `foo`",
                None,
                "consider using a more meaningful name"
            );
        }
    }
}
<span class="boring">}</span></code></pre>
<p>We separate the lint conditional from the lint emissions because it makes the
code a bit easier to read. In some cases this separation would also allow to
write some unit tests (as opposed to only UI tests) for the separate function.</p>
<p>In our example, <code>is_foo_fn</code> looks like:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// use statements, impl EarlyLintPass, check_fn, ..

fn is_foo_fn(fn_kind: FnKind&lt;'_&gt;) -&gt; bool {
    match fn_kind {
        FnKind::Fn(_, _, Fn { ident, .. }) =&gt; {
            // check if `fn` name is `foo`
            ident.name.as_str() == "foo"
        }
        // ignore closures
        FnKind::Closure(..) =&gt; false
    }
}
<span class="boring">}</span></code></pre>
<p>Now we should also run the full test suite with <code>cargo test</code>. At this point
running <code>cargo test</code> should produce the expected output. Remember to run <code>cargo bless</code> to update the <code>.stderr</code> file.</p>
<p><code>cargo test</code> (as opposed to <code>cargo uitest</code>) will also ensure that our lint
implementation is not violating any Clippy lints itself.</p>
<p>That should be it for the lint implementation. Running <code>cargo test</code> should now
pass.</p>
<h2 id="specifying-the-lints-minimum-supported-rust-version-msrv"><a class="header" href="#specifying-the-lints-minimum-supported-rust-version-msrv">Specifying the lint’s minimum supported Rust version (MSRV)</a></h2>
<p>Sometimes a lint makes suggestions that require a certain version of Rust. For
example, the <code>manual_strip</code> lint suggests using <code>str::strip_prefix</code> and
<code>str::strip_suffix</code> which is only available after Rust 1.45. In such cases, you
need to ensure that the MSRV configured for the project is &gt;= the MSRV of the
required Rust feature. If multiple features are required, just use the one with
a lower MSRV.</p>
<p>First, add an MSRV alias for the required feature in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_config/msrvs/index.html"><code>clippy_utils::msrvs</code></a>.
This can be accessed later as <code>msrvs::STR_STRIP_PREFIX</code>, for example.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>msrv_aliases! {
    ..
    1,45,0 { STR_STRIP_PREFIX }
}
<span class="boring">}</span></code></pre>
<p>In order to access the project-configured MSRV, you need to have an <code>msrv</code> field
in the LintPass struct, and a constructor to initialize the field. The <code>msrv</code>
value is passed to the constructor in <code>clippy_lints/lib.rs</code>.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ManualStrip {
    msrv: Msrv,
}

impl ManualStrip {
    pub fn new(conf: &amp;'static Conf) -&gt; Self {
        Self { msrv: conf.msrv }
    }
}
<span class="boring">}</span></code></pre>
<p>The project’s MSRV can then be matched against the feature MSRV in the LintPass
using the <code>Msrv::meets</code> method.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !self.msrv.meets(cx, msrvs::STR_STRIP_PREFIX) {
    return;
}
<span class="boring">}</span></code></pre>
<p>Early lint passes should instead use <code>MsrvStack</code> coupled with
<code>extract_msrv_attr!()</code></p>
<p>Once the <code>msrv</code> is added to the lint, a relevant test case should be added to
the lint’s test file, <code>tests/ui/manual_strip.rs</code> in this example. It should
have a case for the version below the MSRV and one with the same contents but
for the MSRV version itself.</p>
<pre><code class="language-rust ignore">...

#[clippy::msrv = "1.44"]
fn msrv_1_44() {
    /* something that would trigger the lint */
}

#[clippy::msrv = "1.45"]
fn msrv_1_45() {
    /* something that would trigger the lint */
}</code></pre>
<p>As a last step, the lint should be added to the lint documentation. This is done
in <code>clippy_config/src/conf.rs</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_Conf! {
    #[lints(
        allow_attributes,
        allow_attributes_without_reason,
        ..
        &lt;the newly added lint name&gt;,
        ..
        unused_trait_names,
        use_self,
    )]
    msrv: Msrv = Msrv::default(),
    ...
}
<span class="boring">}</span></code></pre>
<p>Afterwards update the documentation for the book as described in <a href="#adding-configuration-to-a-lint">Adding configuration to a lint</a>.</p>
<h2 id="author-lint"><a class="header" href="#author-lint">Author lint</a></h2>
<p>If you have trouble implementing your lint, there is also the internal <code>author</code>
lint to generate Clippy code that detects the offending pattern. It does not
work for all the Rust syntax, but can give a good starting point.</p>
<p>The quickest way to use it, is the <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2024&amp;gist=9a12cb60e5c6ad4e3003ac6d5e63cf55">Rust playground:
play.rust-lang.org</a>. Put the code you want to lint into the
editor and add the <code>#[clippy::author]</code> attribute above the item. Then run Clippy
via <code>Tools -&gt; Clippy</code> and you should see the generated code in the output below.</p>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2024&amp;gist=9a12cb60e5c6ad4e3003ac6d5e63cf55">Here</a> is an example on the playground.</p>
<p>If the command was executed successfully, you can copy the code over to where
you are implementing your lint.</p>
<h2 id="print-hir-lint"><a class="header" href="#print-hir-lint">Print HIR lint</a></h2>
<p>To implement a lint, it’s helpful to first understand the internal
representation that rustc uses. Clippy has the <code>#[clippy::dump]</code> attribute that
prints the <a href="https://rustc-dev-guide.rust-lang.org/hir.html"><em>High-Level Intermediate Representation (HIR)</em></a> of the item,
statement, or expression that the attribute is attached to. To attach the
attribute to expressions you often need to enable
<code>#![feature(stmt_expr_attributes)]</code>.</p>
<p><a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2024&amp;gist=daf14db3a7f39ca467cd1b86c34b9afb">Here</a> you can find an example, just select <em>Tools</em> and run
<em>Clippy</em>.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The final thing before submitting our PR is to add some documentation to our
lint declaration.</p>
<p>Please document your lint with a doc comment akin to the following:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_clippy_lint! {
    /// ### What it does
    /// Checks for ... (describe what the lint matches).
    ///
    /// ### Why is this bad?
    /// Supply the reason for linting the code.
    ///
    /// ### Example
    ///
    /// ```rust,ignore
    /// // A short example of code that triggers the lint
    /// ```
    ///
    /// Use instead:
    /// ```rust,ignore
    /// // A short example of improved code that doesn't trigger the lint
    /// ```
    #[clippy::version = "1.29.0"]
    pub FOO_FUNCTIONS,
    pedantic,
    "function named `foo`, which is not a descriptive name"
}
<span class="boring">}</span></code></pre>
<p>If the lint is in the <code>restriction</code> group because it lints things that are not
necessarily “bad” but are more of a style choice, then replace the
“Why is this bad?” section heading with “Why restrict this?”, to avoid writing
“Why is this bad? It isn’t, but …”.</p>
<p>Once your lint is merged, this documentation will show up in the <a href="https://rust-lang.github.io/rust-clippy/master/index.html">lint
list</a>.</p>
<h2 id="running-rustfmt"><a class="header" href="#running-rustfmt">Running rustfmt</a></h2>
<p><a href="https://github.com/rust-lang/rustfmt">Rustfmt</a> is a tool for formatting Rust code according to style guidelines. Your
code has to be formatted by <code>rustfmt</code> before a PR can be merged. Clippy uses
nightly <code>rustfmt</code> in the CI.</p>
<p>It can be installed via <code>rustup</code>:</p>
<pre><code class="language-bash">rustup component add rustfmt --toolchain=nightly
</code></pre>
<p>Use <code>cargo dev fmt</code> to format the whole codebase. Make sure that <code>rustfmt</code> is
installed for the nightly toolchain.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>If you want to debug parts of your lint implementation, you can use the <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a>
macro anywhere in your code. Running the tests should then include the debug
output in the <code>stdout</code> part.</p>
<h2 id="conflicting-lints"><a class="header" href="#conflicting-lints">Conflicting lints</a></h2>
<p>There are several lints that deal with the same pattern but suggest different approaches. In other words, some lints
may suggest modifications that go in the opposite direction to what some other lints already propose for the same
code, creating conflicting diagnostics.</p>
<p>When you are creating a lint that ends up in this scenario, the following tips should be encouraged to guide
classification:</p>
<ul>
<li>The only case where they should be in the same category is if that category is <code>restriction</code>. For example,
<code>semicolon_inside_block</code> and <code>semicolon_outside_block</code>.</li>
<li>For all the other cases, they should be in different categories with different levels of allowance. For example,
<code>implicit_return</code> (restriction, allow) and <code>needless_return</code> (style, warn).</li>
</ul>
<p>For lints that are in different categories, it is also recommended that at least one of them should be in the
<code>restriction</code> category. The reason for this is that the <code>restriction</code> group is the only group where we don’t
recommend to enable the entire set, but cherry pick lints out of.</p>
<h2 id="pr-checklist"><a class="header" href="#pr-checklist">PR Checklist</a></h2>
<p>Before submitting your PR make sure you followed all the basic requirements:</p>
<!-- Sync this with `.github/PULL_REQUEST_TEMPLATE` -->
<ul>
<li>[ ] Followed <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming conventions</a></li>
<li>[ ] Added passing UI tests (including committed <code>.stderr</code> file)</li>
<li>[ ] <code>cargo test</code> passes locally</li>
<li>[ ] Executed <code>cargo dev update_lints</code></li>
<li>[ ] Added lint documentation</li>
<li>[ ] Run <code>cargo dev fmt</code></li>
</ul>
<h2 id="adding-configuration-to-a-lint"><a class="header" href="#adding-configuration-to-a-lint">Adding configuration to a lint</a></h2>
<p>Clippy supports the configuration of lints values using a <code>clippy.toml</code> file which is searched for in:</p>
<ol>
<li>The directory specified by the <code>CLIPPY_CONF_DIR</code> environment variable, or</li>
<li>The directory specified by the
<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html">CARGO_MANIFEST_DIR</a> environment variable, or</li>
<li>The current directory.</li>
</ol>
<p>Adding a configuration to a lint can be useful for
thresholds or to constrain some behavior that can be seen as a false positive
for some users. Adding a configuration is done in the following steps:</p>
<ol>
<li>
<p>Adding a new configuration entry to <a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_config/src/conf.rs"><code>clippy_config::conf</code></a> like this:</p>
<pre><code class="language-rust ignore">/// Lint: LINT_NAME.
///
/// &lt;The configuration field doc comment&gt;
(configuration_ident: Type = DefaultValue),</code></pre>
<p>The doc comment is automatically added to the documentation of the listed
lints. The default value will be formatted using the <code>Debug</code> implementation
of the type.</p>
</li>
<li>
<p>Adding the configuration value to the lint impl struct:</p>
<ol>
<li>
<p>This first requires the definition of a lint impl struct. Lint impl
structs are usually generated with the <code>declare_lint_pass!</code> macro. This
struct needs to be defined manually to add some kind of metadata to it:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generated struct definition
declare_lint_pass!(StructName =&gt; [
    LINT_NAME
]);

// New manual definition struct
pub struct StructName {}

impl_lint_pass!(StructName =&gt; [
    LINT_NAME
]);
<span class="boring">}</span></code></pre>
</li>
<li>
<p>Next add the configuration value and a corresponding creation method like
this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StructName {
    configuration_ident: Type,
}

// ...

impl StructName {
    pub fn new(conf: &amp;'static Conf) -&gt; Self {
        Self {
            configuration_ident: conf.configuration_ident,
        }
    }
}
<span class="boring">}</span></code></pre>
</li>
</ol>
</li>
<li>
<p>Passing the configuration value to the lint impl struct:</p>
<p>First find the struct construction in the <a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lib.rs"><code>clippy_lints</code> lib file</a>. The
configuration value is now cloned or copied into a local value that is then
passed to the impl struct like this:</p>
<pre><code class="language-rust ignore">// Default generated registration:
store.register_*_pass(|| box module::StructName);

// New registration with configuration value
store.register_*_pass(move || box module::StructName::new(conf));</code></pre>
<p>Congratulations the work is almost done. The configuration value can now be
accessed in the linting code via <code>self.configuration_ident</code>.</p>
</li>
<li>
<p>Adding tests:</p>
<ol>
<li>The default configured value can be tested like any normal lint in
<a href="https://github.com/rust-lang/rust-clippy/blob/master/tests/ui"><code>tests/ui</code></a>.</li>
<li>The configuration itself will be tested separately in <a href="https://github.com/rust-lang/rust-clippy/blob/master/tests/ui-toml"><code>tests/ui-toml</code></a>.
Simply add a new subfolder with a fitting name. This folder contains a
<code>clippy.toml</code> file with the configuration value and a rust file that
should be linted by Clippy. The test can otherwise be written as usual.</li>
</ol>
</li>
<li>
<p>Update <a href="#lint-configuration-options">Lint Configuration</a></p>
<p>Run <code>cargo bless --test config-metadata</code> to generate documentation changes for the book.</p>
</li>
</ol>
<h2 id="cheat-sheet"><a class="header" href="#cheat-sheet">Cheat Sheet</a></h2>
<p>Here are some pointers to things you are likely going to need for every lint:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/index.html">Clippy utils</a> - Various helper functions. Maybe the function you need
is already in here (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/ty/fn.implements_trait.html"><code>implements_trait</code></a>, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/source/fn.snippet.html"><code>snippet</code></a>, etc)</li>
<li><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs">Clippy diagnostics</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/94927">Let chains</a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> and
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html"><code>Span</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html"><code>Applicability</code></a></li>
<li><a href="#common-tools-for-writing-lints">Common tools for writing lints</a> helps with
common operations</li>
<li><a href="https://rustc-dev-guide.rust-lang.org/">The rustc-dev-guide</a> explains a lot of internal compiler
concepts</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/">The nightly rustc docs</a> which has been linked to throughout
this guide</li>
</ul>
<p>For <code>EarlyLintPass</code> lints:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/index.html"><code>rustc_ast::ast</code></a></li>
</ul>
<p>For <code>LateLintPass</code> lints:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/index.html"><code>Ty::TyKind</code></a></li>
</ul>
<p>While most of Clippy’s lint utils are documented, most of rustc’s internals lack
documentation currently. This is unfortunate, but in most cases you can probably
get away with copying things from existing similar lints. If you are stuck,
don’t hesitate to ask on <a href="https://rust-lang.zulipchat.com/#narrow/stream/clippy">Zulip</a> or in the issue/PR.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="define-new-lints"><a class="header" href="#define-new-lints">Define New Lints</a></h1>
<p>The first step in the journey of a new lint is the definition
and registration of the lint in Clippy’s codebase.
We can use the Clippy dev tools to handle this step since setting up the
lint involves some boilerplate code.</p>
<h4 id="lint-types"><a class="header" href="#lint-types">Lint types</a></h4>
<p>A lint type is the category of items and expressions in which your lint focuses on.</p>
<p>As of the writing of this documentation update, there are 11 <em>types</em> of lints
besides the numerous standalone lints living under <code>clippy_lints/src/</code>:</p>
<ul>
<li><code>cargo</code></li>
<li><code>casts</code></li>
<li><code>functions</code></li>
<li><code>loops</code></li>
<li><code>matches</code></li>
<li><code>methods</code></li>
<li><code>misc_early</code></li>
<li><code>operators</code></li>
<li><code>transmute</code></li>
<li><code>types</code></li>
<li><code>unit_types</code></li>
</ul>
<p>These types group together lints that share some common behaviors. For instance,
<code>functions</code> groups together lints that deal with some aspects of functions in
Rust, like definitions, signatures and attributes.</p>
<p>For more information, feel free to compare the lint files under any category
with <a href="https://rust-lang.github.io/rust-clippy/master/">All Clippy lints</a> or ask one of the maintainers.</p>
<h2 id="lint-name"><a class="header" href="#lint-name">Lint name</a></h2>
<p>A good lint name is important, make sure to check the <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming
guidelines</a>. Don’t worry, if the lint name doesn’t fit, a Clippy
team member will alert you in the PR process.</p>
<hr>
<p>We’ll name our example lint that detects functions named “foo” <code>foo_functions</code>.
Check the <a href="https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints">lint naming guidelines</a> to see why this name makes
sense.</p>
<h2 id="add-and-register-the-lint"><a class="header" href="#add-and-register-the-lint">Add and Register the Lint</a></h2>
<p>Now that a name is chosen, we shall register <code>foo_functions</code> as a lint to the
codebase. There are two ways to register a lint.</p>
<h3 id="standalone-1"><a class="header" href="#standalone-1">Standalone</a></h3>
<p>If you believe that this new lint is a standalone lint (that doesn’t belong to
any specific <a href="#lint-types">type</a> like <code>functions</code> or <code>loops</code>), you can run the
following command in your Clippy project:</p>
<pre><code class="language-sh">$ cargo dev new_lint --name=lint_name --pass=late --category=pedantic
</code></pre>
<p>There are two things to note here:</p>
<ol>
<li><code>--pass</code>: We set <code>--pass=late</code> in this command to do a late lint pass. The
alternative is an <code>early</code> lint pass. We will discuss this difference in the
<a href="#lint-passes-1">Lint Passes</a> chapter.</li>
<li><code>--category</code>: If not provided, the <code>category</code> of this new lint will default
to <code>nursery</code>.</li>
</ol>
<p>The <code>cargo dev new_lint</code> command will create a new file:
<code>clippy_lints/src/foo_functions.rs</code> as well as <a href="#lint-registration-1">register the
lint</a>.</p>
<p>Overall, you should notice that the following files are modified or created:</p>
<pre><code class="language-sh">$ git status
On branch foo_functions
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
	modified:   CHANGELOG.md
	modified:   clippy_lints/src/lib.register_lints.rs
	modified:   clippy_lints/src/lib.register_pedantic.rs
	modified:   clippy_lints/src/lib.rs

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
	clippy_lints/src/foo_functions.rs
	tests/ui/foo_functions.rs
</code></pre>
<h3 id="specific-type-1"><a class="header" href="#specific-type-1">Specific Type</a></h3>
<blockquote>
<p><strong>Note</strong>: Lint types are listed in the <a href="#lint-types">“Lint types”</a> section</p>
</blockquote>
<p>If you believe that this new lint belongs to a specific type of lints,
you can run <code>cargo dev new_lint</code> with a <code>--type</code> option.</p>
<p>Since our <code>foo_functions</code> lint is related to function calls, one could
argue that we should put it into a group of lints that detect some behaviors
of functions, we can put it in the <code>functions</code> group.</p>
<p>Let’s run the following command in your Clippy project:</p>
<pre><code class="language-sh">$ cargo dev new_lint --name=foo_functions --type=functions --category=pedantic
</code></pre>
<p>This command will create, among other things, a new file:
<code>clippy_lints/src/{type}/foo_functions.rs</code>.
In our case, the path will be <code>clippy_lints/src/functions/foo_functions.rs</code>.</p>
<p>Notice how this command has a <code>--type</code> flag instead of <code>--pass</code>. Unlike a standalone
definition, this lint won’t be registered in the traditional sense. Instead, you will
call your lint from within the type’s lint pass, found in <code>clippy_lints/src/{type}/mod.rs</code>.</p>
<p>A <em>type</em> is just the name of a directory in <code>clippy_lints/src</code>, like <code>functions</code> in
the example command. Clippy groups together some lints that share common behaviors,
so if your lint falls into one, it would be best to add it to that type.</p>
<p>Overall, you should notice that the following files are modified or created:</p>
<pre><code class="language-sh">$ git status
On branch foo_functions
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
	modified:   CHANGELOG.md
	modified:   clippy_lints/src/declared_lints.rs
	modified:   clippy_lints/src/functions/mod.rs

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
	clippy_lints/src/functions/foo_functions.rs
	tests/ui/foo_functions.rs
</code></pre>
<h2 id="the-declare_clippy_lint-macro"><a class="header" href="#the-declare_clippy_lint-macro">The <code>declare_clippy_lint</code> macro</a></h2>
<p>After <code>cargo dev new_lint</code>, you should see a macro with the name
<code>declare_clippy_lint</code>. It will be in the same file if you defined a standalone
lint, and it will be in <code>mod.rs</code> if you defined a type-specific lint.</p>
<p>The macro looks something like this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>declare_clippy_lint! {
    /// ### What it does
    ///
    /// // Describe here what does the lint do.
    ///
    /// Triggers when detects...
    ///
    /// ### Why is this bad?
    ///
    /// // Describe why this pattern would be bad
    ///
    /// It can lead to...
    ///
    /// ### Example
    /// ```rust
    /// // example code where Clippy issues a warning
    /// ```
    /// Use instead:
    /// ```rust
    /// // example code which does not raise Clippy warning
    /// ```
    #[clippy::version = "1.70.0"] // &lt;- In which version was this implemented, keep it up to date!
    pub LINT_NAME, // &lt;- The lint name IN_ALL_CAPS
    pedantic, // &lt;- The lint group
    "default lint description" // &lt;- A lint description, e.g. "A function has an unit return type."
}
<span class="boring">}</span></code></pre>
<h2 id="lint-registration-1"><a class="header" href="#lint-registration-1">Lint registration</a></h2>
<p>If we run the <code>cargo dev new_lint</code> command for a new lint, the lint will be
automatically registered and there is nothing more to do.</p>
<p>However, sometimes we might want to declare a new lint by hand. In this case,
we’d use <code>cargo dev update_lints</code> command afterwards.</p>
<p>When a lint is manually declared, we might need to register the lint pass
manually in the <code>register_lints</code> function in <code>clippy_lints/src/lib.rs</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>store.register_late_pass(|_| Box::new(foo_functions::FooFunctions));
<span class="boring">}</span></code></pre>
<p>As you might have guessed, where there’s something late, there is something
early: in Clippy there is a <code>register_early_pass</code> method as well. More on early
vs. late passes in the <a href="#lint-passes-1">Lint Passes</a> chapter.</p>
<p>Without a call to one of <code>register_early_pass</code> or <code>register_late_pass</code>, the lint
pass in question will not be run.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<p>Developing lints for Clippy is a Test-Driven Development (TDD) process because
our first task before implementing any logic for a new lint is to write some test cases.</p>
<h2 id="develop-lints-with-tests"><a class="header" href="#develop-lints-with-tests">Develop Lints with Tests</a></h2>
<p>When we develop Clippy, we enter a complex and chaotic realm full of
programmatic issues, stylistic errors, illogical code and non-adherence to convention.
Tests are the first layer of order we can leverage to define when and where
we want a new lint to trigger or not.</p>
<p>Moreover, writing tests first help Clippy developers to find a balance for
the first iteration of and further enhancements for a lint.
With test cases on our side, we will not have to worry about over-engineering
a lint on its first version nor missing out some obvious edge cases of the lint.
This approach empowers us to iteratively enhance each lint.</p>
<h2 id="clippy-ui-tests"><a class="header" href="#clippy-ui-tests">Clippy UI Tests</a></h2>
<p>We use <strong>UI tests</strong> for testing in Clippy. These UI tests check that the output
of Clippy is exactly as we expect it to be. Each test is just a plain Rust file
that contains the code we want to check.</p>
<p>The output of Clippy is compared against a <code>.stderr</code> file. Note that you don’t
have to create this file yourself. We’ll get to generating the <code>.stderr</code> files
with the command <a href="#cargo-bless"><code>cargo bless</code></a> (seen later on).</p>
<h3 id="write-test-cases"><a class="header" href="#write-test-cases">Write Test Cases</a></h3>
<p>Let us now think about some tests for our imaginary <code>foo_functions</code> lint. We
start by opening the test file <code>tests/ui/foo_functions.rs</code> that was created by
<code>cargo dev new_lint</code>.</p>
<p>Update the file with some examples to get started:</p>
<pre class="playground"><code class="language-rust edition2024">#![warn(clippy::foo_functions)] // &lt; Add this, so the lint is guaranteed to be enabled in this file

// Impl methods
struct A;
impl A {
    pub fn fo(&amp;self) {}
    pub fn foo(&amp;self) {}
    //~^ foo_functions
    pub fn food(&amp;self) {}
}

// Default trait methods
trait B {
    fn fo(&amp;self) {}
    fn foo(&amp;self) {}
    //~^ foo_functions
    fn food(&amp;self) {}
}

// Plain functions
fn fo() {}
fn foo() {}
//~^ foo_functions
fn food() {}

fn main() {
    // We also don't want to lint method calls
    foo();
    let a = A;
    a.foo();
}</code></pre>
<p>Without actual lint logic to emit the lint when we see a <code>foo</code> function name,
this test will fail, because we expect errors at lines marked with
<code>//~^ foo_functions</code>. However, we can now run the test with the following command:</p>
<pre><code class="language-sh">$ TESTNAME=foo_functions cargo uitest
</code></pre>
<p>Clippy will compile and it will fail complaining it didn’t receive any errors:</p>
<pre><code>...Clippy warnings and test outputs...
error: diagnostic code `clippy::foo_functions` not found on line 8
 --&gt; tests/ui/foo_functions.rs:9:10
  |
9 |     //~^ foo_functions
  |          ^^^^^^^^^^^^^ expected because of this pattern
  |

error: diagnostic code `clippy::foo_functions` not found on line 16
  --&gt; tests/ui/foo_functions.rs:17:10
   |
17 |     //~^ foo_functions
   |          ^^^^^^^^^^^^^ expected because of this pattern
   |

error: diagnostic code `clippy::foo_functions` not found on line 23
  --&gt; tests/ui/foo_functions.rs:24:6
   |
24 | //~^ foo_functions
   |      ^^^^^^^^^^^^^ expected because of this pattern
   |

</code></pre>
<p>This is normal. After all, we wrote a bunch of Rust code but we haven’t really
implemented any logic for Clippy to detect <code>foo</code> functions and emit a lint.</p>
<p>As we gradually implement our lint logic, we will keep running this UI test command.
Clippy will begin outputting information that allows us to check if the output is
turning into what we want it to be.</p>
<h3 id="example-output"><a class="header" href="#example-output">Example output</a></h3>
<p>As our <code>foo_functions</code> lint is tested, the output would look something like this:</p>
<pre><code>failures:
---- compile_test stdout ----
normalized stderr:
error: function called "foo"
  --&gt; tests/ui/foo_functions.rs:6:12
   |
LL |     pub fn foo(&amp;self) {}
   |            ^^^
   |
   = note: `-D clippy::foo-functions` implied by `-D warnings`
error: function called "foo"
  --&gt; tests/ui/foo_functions.rs:13:8
   |
LL |     fn foo(&amp;self) {}
   |        ^^^
error: function called "foo"
  --&gt; tests/ui/foo_functions.rs:19:4
   |
LL | fn foo() {}
   |    ^^^
error: aborting due to 3 previous errors
</code></pre>
<p>Note the <em>failures</em> label at the top of the fragment, we’ll get rid of it
(saving this output) in the next section.</p>
<blockquote>
<p><em>Note:</em> You can run multiple test files by specifying a comma separated list:
<code>TESTNAME=foo_functions,bar_methods,baz_structs</code>.</p>
</blockquote>
<h3 id="cargo-bless"><a class="header" href="#cargo-bless"><code>cargo bless</code></a></h3>
<p>Once we are satisfied with the output, we need to run this command to
generate or update the <code>.stderr</code> file for our lint:</p>
<pre><code class="language-sh">$ TESTNAME=foo_functions cargo uibless
</code></pre>
<p>This writes the emitted lint suggestions and fixes to the <code>.stderr</code> file, with
the reason for the lint, suggested fixes, and line numbers, etc.</p>
<p>Running <code>TESTNAME=foo_functions cargo uitest</code> should pass then. When we commit
our lint, we need to commit the generated <code>.stderr</code> files, too.</p>
<p>In general, you should only commit files changed by <code>cargo bless</code> for the
specific lint you are creating/editing.</p>
<blockquote>
<p><em>Note:</em> If the generated <code>.stderr</code>, and <code>.fixed</code> files are empty,
they should be removed.</p>
</blockquote>
<h2 id="toml-tests"><a class="header" href="#toml-tests"><code>toml</code> Tests</a></h2>
<p>Some lints can be configured through a <code>clippy.toml</code> file. Those configuration
values are tested in <code>tests/ui-toml</code>.</p>
<p>To add a new test there, create a new directory and add the files:</p>
<ul>
<li><code>clippy.toml</code>: Put here the configuration value you want to test.</li>
<li><code>lint_name.rs</code>: A test file where you put the testing code, that should see a
different lint behavior according to the configuration set in the
<code>clippy.toml</code> file.</li>
</ul>
<p>The potential <code>.stderr</code> and <code>.fixed</code> files can again be generated with <code>cargo bless</code>.</p>
<h2 id="cargo-lints-1"><a class="header" href="#cargo-lints-1">Cargo Lints</a></h2>
<p>The process of testing is different for Cargo lints in that now we are
interested in the <code>Cargo.toml</code> manifest file. In this case, we also need a
minimal crate associated with that manifest. Those tests are generated in
<code>tests/ui-cargo</code>.</p>
<p>Imagine we have a new example lint that is named <code>foo_categories</code>, we can run:</p>
<pre><code class="language-sh">$ cargo dev new_lint --name=foo_categories --pass=late --category=cargo
</code></pre>
<p>After running <code>cargo dev new_lint</code> we will find by default two new crates,
each with its manifest file:</p>
<ul>
<li><code>tests/ui-cargo/foo_categories/fail/Cargo.toml</code>: this file should cause the
new lint to raise an error.</li>
<li><code>tests/ui-cargo/foo_categories/pass/Cargo.toml</code>: this file should not trigger
the lint.</li>
</ul>
<p>If you need more cases, you can copy one of those crates (under
<code>foo_categories</code>) and rename it.</p>
<p>The process of generating the <code>.stderr</code> file is the same as for other lints
and prepending the <code>TESTNAME</code> variable to <code>cargo uitest</code> works for Cargo lints too.</p>
<h2 id="rustfix-tests-1"><a class="header" href="#rustfix-tests-1">Rustfix Tests</a></h2>
<p>If the lint you are working on is making use of structured suggestions,
<a href="https://github.com/rust-lang/cargo/tree/master/crates/rustfix"><code>rustfix</code></a> will apply the suggestions from the lint to the test file code and
compare that to the contents of a <code>.fixed</code> file.</p>
<p>Structured suggestions tell a user how to fix or re-write certain code that has
been linted with <a href="https://doc.rust-lang.org/beta/nightly-rustc/clippy_utils/diagnostics/fn.span_lint_and_sugg.html"><code>span_lint_and_sugg</code></a>.</p>
<p>Should <code>span_lint_and_sugg</code> be used to generate a suggestion, but not all
suggestions lead to valid code, you can use the <code>//@no-rustfix</code> comment on top
of the test file, to not run <code>rustfix</code> on that file.</p>
<p>We’ll talk about suggestions more in depth in a <a href="#emitting-a-lint-1">later chapter</a>.</p>
<p>Use <code>cargo bless</code> to automatically generate the <code>.fixed</code> file after running
the tests.</p>
<h2 id="testing-manually-1"><a class="header" href="#testing-manually-1">Testing Manually</a></h2>
<p>Manually testing against an example file can be useful if you have added some
<code>println!</code>s and the test suite output becomes unreadable.</p>
<p>To try Clippy with your local modifications, run from the working copy root.</p>
<pre><code class="language-sh">$ cargo dev lint input.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lint-passes-1"><a class="header" href="#lint-passes-1">Lint passes</a></h1>
<p>Before working on the logic of a new lint, there is an important decision
that every Clippy developer must make: to use
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a> or <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a>.</p>
<p>In short, the <code>LateLintPass</code> has access to type and symbol information while the
<code>EarlyLintPass</code> doesn’t. If you don’t need access to type information, use the
<code>EarlyLintPass</code>.</p>
<p>Let us expand on these two traits more below.</p>
<h2 id="earlylintpass"><a class="header" href="#earlylintpass"><code>EarlyLintPass</code></a></h2>
<p>If you examine the documentation on <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html"><code>EarlyLintPass</code></a> closely,
you’ll see that every method defined for this trait utilizes a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/context/struct.EarlyContext.html"><code>EarlyContext</code></a>. In <code>EarlyContext</code>’s documentation, it states:</p>
<blockquote>
<p>Context for lint checking of the AST, after expansion, before lowering to HIR.</p>
</blockquote>
<p>Voilà. <code>EarlyLintPass</code> works only on the Abstract Syntax Tree (AST) level.
And AST is generated during the <a href="https://rustc-dev-guide.rust-lang.org/overview.html#lexing-and-parsing">lexing and parsing</a> phase
of code compilation. Therefore, it doesn’t know what a symbol means or information about types, and it should
be our trait choice for a new lint if the lint only deals with syntax-related issues.</p>
<p>While linting speed has not been a concern for Clippy,
the <code>EarlyLintPass</code> is faster, and it should be your choice
if you know for sure a lint does not need type information.</p>
<p>As a reminder, run the following command to generate boilerplate for lints
that use <code>EarlyLintPass</code>:</p>
<pre><code class="language-sh">$ cargo dev new_lint --name=&lt;your_new_lint&gt; --pass=early --category=&lt;your_category_choice&gt;
</code></pre>
<h3 id="example-for-earlylintpass"><a class="header" href="#example-for-earlylintpass">Example for <code>EarlyLintPass</code></a></h3>
<p>Take a look at the following code:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = OurUndefinedType;
x.non_existing_method();
<span class="boring">}</span></code></pre>
<p>From the AST perspective, both lines are “grammatically” correct.
The assignment uses a <code>let</code> and ends with a semicolon. The invocation
of a method looks fine, too. As programmers, we might raise a few
questions already, but the parser is okay with it. This is what we
mean when we say <code>EarlyLintPass</code> deals with only syntax on the AST level.</p>
<p>Alternatively, think of the <code>foo_functions</code> lint we mentioned in
the <a href="#define-new-lints">Define New Lints</a> chapter.</p>
<p>We want the <code>foo_functions</code> lint to detect functions with <code>foo</code> as their name.
Writing a lint that only checks for the name of a function means that we only
work with the AST and don’t have to access the type system at all (the type system is where
<code>LateLintPass</code> comes into the picture).</p>
<h2 id="latelintpass"><a class="header" href="#latelintpass"><code>LateLintPass</code></a></h2>
<p>In contrast to <code>EarlyLintPass</code>, <code>LateLintPass</code> contains type information.</p>
<p>If you examine the documentation on <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a> closely,
you see that every method defined in this trait utilizes a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/context/struct.LateContext.html"><code>LateContext</code></a>.</p>
<p>In <code>LateContext</code>’s documentation we will find methods that
deal with type-checking, which do not exist in <code>EarlyContext</code>, such as:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/context/struct.LateContext.html#method.maybe_typeck_results"><code>maybe_typeck_results</code></a></li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/context/struct.LateContext.html#method.typeck_results"><code>typeck_results</code></a></li>
</ul>
<h3 id="example-for-latelintpass"><a class="header" href="#example-for-latelintpass">Example for <code>LateLintPass</code></a></h3>
<p>Let us take a look with the following example:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = OurUndefinedType;
x.non_existing_method();
<span class="boring">}</span></code></pre>
<p>These two lines of code are syntactically correct code from the perspective
of the AST. We have an assignment and invoke a method on the variable that
is of a type. Grammatically, everything is in order for the parser.</p>
<p>However, going down a level and looking at the type information,
the compiler will notice that both <code>OurUndefinedType</code> and <code>non_existing_method()</code>
<strong>are undefined</strong>.</p>
<p>As Clippy developers, to access such type information, we must implement
<code>LateLintPass</code> on our lint.
When you browse through Clippy’s lints, you will notice that almost every lint
is implemented in a <code>LateLintPass</code>, specifically because we often need to check
not only for syntactic issues but also type information.</p>
<p>Another limitation of the <code>EarlyLintPass</code> is that the nodes are only identified
by their position in the AST. This means that you can’t just get an <code>id</code> and
request a certain node. For most lints that is fine, but we have some lints
that require the inspection of other nodes, which is easier at the HIR level.
In these cases, <code>LateLintPass</code> is the better choice.</p>
<p>As a reminder, run the following command to generate boilerplate for lints
that use <code>LateLintPass</code>:</p>
<pre><code class="language-sh">$ cargo dev new_lint --name=&lt;your_new_lint&gt; --pass=late --category=&lt;your_category_choice&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="emitting-a-lint-1"><a class="header" href="#emitting-a-lint-1">Emitting a lint</a></h1>
<p>Once we have <a href="#define-new-lints">defined a lint</a>, written <a href="#testing-1">UI
tests</a> and chosen <a href="#lint-passes-1">the lint pass</a> for the lint,
we can begin the implementation of the lint logic so that we can emit it and
gradually work towards a lint that behaves as expected.</p>
<p>Note that we will not go into concrete implementation of a lint logic in this
chapter. We will go into details in later chapters as well as in two examples of
real Clippy lints.</p>
<p>To emit a lint, we must implement a pass (see <a href="#lint-passes-1">Lint Passes</a>) for
the lint that we have declared. In this example we’ll implement a “late” lint,
so take a look at the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html">LateLintPass</a> documentation, which
provides an abundance of methods that we can implement for our lint.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait LateLintPass&lt;'tcx&gt;: LintPass {
    // Trait methods
}
<span class="boring">}</span></code></pre>
<p>By far the most common method used for Clippy lints is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html#method.check_expr"><code>check_expr</code>
method</a>, this is because Rust is an expression language and,
more often than not, the lint we want to work on must examine expressions.</p>
<blockquote>
<p><em>Note:</em> If you don’t fully understand what expressions are in Rust, take a
look at the official documentation on <a href="https://doc.rust-lang.org/reference/expressions.html">expressions</a></p>
</blockquote>
<p>Other common ones include the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html#method.check_fn"><code>check_fn</code> method</a> and the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html#method.check_item"><code>check_item</code> method</a>.</p>
<h3 id="emitting-a-lint-1-1"><a class="header" href="#emitting-a-lint-1-1">Emitting a lint</a></h3>
<p>Inside the trait method that we implement, we can write down the lint logic and
emit the lint with suggestions.</p>
<p>Clippy’s <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/diagnostics/index.html">diagnostics</a> provides quite a few diagnostic functions that we can use
to emit lints. Take a look at the documentation to pick one that suits your
lint’s needs the best. Some common ones you will encounter in the Clippy
repository includes:</p>
<ul>
<li><a href="https://doc.rust-lang.org/beta/nightly-rustc/clippy_utils/diagnostics/fn.span_lint.html"><code>span_lint</code></a>: Emits a lint without providing any other information</li>
<li><a href="https://doc.rust-lang.org/beta/nightly-rustc/clippy_utils/diagnostics/fn.span_lint_and_note.html"><code>span_lint_and_note</code></a>: Emits a lint and adds a note</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/diagnostics/fn.span_lint_and_help.html"><code>span_lint_and_help</code></a>: Emits a lint and provides a helpful message</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/diagnostics/fn.span_lint_and_sugg.html"><code>span_lint_and_sugg</code></a>: Emits a lint and provides a suggestion to fix the code</li>
<li><a href="https://doc.rust-lang.org/beta/nightly-rustc/clippy_utils/diagnostics/fn.span_lint_and_then.html"><code>span_lint_and_then</code></a>: Like <code>span_lint</code>, but allows for a lot of output
customization.</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for LintName {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, expr: &amp;'tcx Expr&lt;'_&gt;)  {
        // Imagine that `some_lint_expr_logic` checks for requirements for emitting the lint
        if some_lint_expr_logic(expr) {
            span_lint_and_help(
                cx, // &lt; The context
                LINT_NAME, // &lt; The name of the lint in ALL CAPS
                expr.span, // &lt; The span to lint
                "message on why the lint is emitted",
                None, // &lt; An optional help span (to highlight something in the lint)
                "message that provides a helpful suggestion",
            );
        }
    }
}
<span class="boring">}</span></code></pre>
<blockquote>
<p>Note: The message should be matter of fact and avoid capitalization and
punctuation. If multiple sentences are needed, the messages should probably be
split up into an error + a help / note / suggestion message.</p>
</blockquote>
<h2 id="suggestions-automatic-fixes"><a class="header" href="#suggestions-automatic-fixes">Suggestions: Automatic fixes</a></h2>
<p>Some lints know what to change in order to fix the code. For example, the lint
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#range_plus_one"><code>range_plus_one</code></a> warns for ranges where the user wrote <code>x..y + 1</code> instead of using an <a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html">inclusive range</a> (<code>x..=y</code>). The fix to
this code would be changing the <code>x..y + 1</code> expression to <code>x..=y</code>. <strong>This is
where suggestions come in</strong>.</p>
<p>A suggestion is a change that the lint provides to fix the issue it is linting.
The output looks something like this (from the example earlier):</p>
<pre><code class="language-text">error: an inclusive range would be more readable
  --&gt; tests/ui/range_plus_minus_one.rs:37:14
   |
LL |     for _ in 1..1 + 1 {}
   |              ^^^^^^^^ help: use: `1..=1`
</code></pre>
<p><strong>Not all suggestions are always right</strong>, some of them require human
supervision, that’s why we have <a href="https://doc.rust-lang.org/beta/nightly-rustc/rustc_errors/enum.Applicability.html">Applicability</a>.</p>
<p>Applicability indicates confidence in the correctness of the suggestion, some
are always right (<code>Applicability::MachineApplicable</code>), but we use
<code>Applicability::MaybeIncorrect</code> and others when talking about a suggestion that
may be incorrect.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<p>The same lint <code>LINT_NAME</code> but that emits a suggestion would look something like this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for LintName {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, expr: &amp;'tcx Expr&lt;'_&gt;)  {
        // Imagine that `some_lint_expr_logic` checks for requirements for emitting the lint
        if some_lint_expr_logic(expr) {
            span_lint_and_sugg( // &lt; Note this change
                cx,
                LINT_NAME,
                span,
                "message on why the lint is emitted",
                "use",
                format!("foo + {} * bar", snippet(cx, expr.span, "&lt;default&gt;")), // &lt; Suggestion
                Applicability::MachineApplicable,
            );
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Suggestions generally use the <a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a> macro to interpolate the
old values with the new ones. To get code snippets, use one of the <code>snippet*</code>
functions from <code>clippy_utils::source</code>.</p>
<h2 id="how-to-choose-between-notes-help-messages-and-suggestions"><a class="header" href="#how-to-choose-between-notes-help-messages-and-suggestions">How to choose between notes, help messages and suggestions</a></h2>
<p>Notes are presented separately from the main lint message, they provide useful
information that the user needs to understand why the lint was activated. They
are the most helpful when attached to a span.</p>
<p>Examples:</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<pre><code class="language-text">error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.
  --&gt; tests/ui/drop_forget_ref.rs:10:5
   |
10 |     forget(&amp;SomeStruct);
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `-D clippy::forget-ref` implied by `-D warnings`
note: argument has type &amp;SomeStruct
  --&gt; tests/ui/drop_forget_ref.rs:10:12
   |
10 |     forget(&amp;SomeStruct);
   |            ^^^^^^^^^^^
</code></pre>
<h3 id="help-messages"><a class="header" href="#help-messages">Help Messages</a></h3>
<p>Help messages are specifically to help the user. These are used in situation
where you can’t provide a specific machine applicable suggestion. They can also
be attached to a span.</p>
<p>Example:</p>
<pre><code class="language-text">error: constant division of 0.0 with 0.0 will always result in NaN
  --&gt; tests/ui/zero_div_zero.rs:6:25
   |
6  |     let other_f64_nan = 0.0f64 / 0.0;
   |                         ^^^^^^^^^^^^
   |
   = help: consider using `f64::NAN` if you would like a constant representing NaN
</code></pre>
<h3 id="suggestions"><a class="header" href="#suggestions">Suggestions</a></h3>
<p>Suggestions are the most helpful, they are changes to the source code to fix the
error. The magic in suggestions is that tools like <code>rustfix</code> can detect them and
automatically fix your code.</p>
<p>Example:</p>
<pre><code class="language-text">error: This `.fold` can be more succinctly expressed as `.any`
--&gt; tests/ui/methods.rs:390:13
    |
390 |     let _ = (0..3).fold(false, |acc, x| acc || x &gt; 2);
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.any(|x| x &gt; 2)`
    |
</code></pre>
<h3 id="snippets"><a class="header" href="#snippets">Snippets</a></h3>
<p>Snippets are pieces of the source code (as a string), they are extracted
generally using the <a href="https://doc.rust-lang.org/beta/nightly-rustc/clippy_utils/source/fn.snippet.html"><code>snippet</code></a> function.</p>
<p>For example, if you want to know how an item looks (and you know the item’s
span), you could use <code>snippet(cx, span, "..")</code>.</p>
<h2 id="final-run-ui-tests-to-emit-the-lint"><a class="header" href="#final-run-ui-tests-to-emit-the-lint">Final: Run UI Tests to Emit the Lint</a></h2>
<p>Now, if we run our <a href="#testing-1">UI test</a>, we should see that Clippy now
produces output that contains the lint message we designed.</p>
<p>The next step is to implement the logic properly, which is a detail that we will
cover in the next chapters.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-checking"><a class="header" href="#type-checking">Type Checking</a></h1>
<p>When we work on a new lint or improve an existing lint, we might want
to retrieve the type <code>Ty</code> of an expression <code>Expr</code> for a variety of
reasons. This can be achieved by utilizing the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html"><code>LateContext</code></a>
that is available for <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a>.</p>
<h2 id="latecontext-and-typeckresults"><a class="header" href="#latecontext-and-typeckresults"><code>LateContext</code> and <code>TypeckResults</code></a></h2>
<p>The lint context <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html"><code>LateContext</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a>
(returned by <code>LateContext::typeck_results</code>) are the two most useful data structures
in <code>LateLintPass</code>. They allow us to jump to type definitions and other compilation
stages such as HIR.</p>
<blockquote>
<p>Note: <code>LateContext.typeck_results</code>’s return value is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a>
and is created in the type checking step, it includes useful information such as types of
expressions, ways to resolve methods and so on.</p>
</blockquote>
<p><code>TypeckResults</code> contains useful methods such as <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty"><code>expr_ty</code></a>,
which gives us access to the underlying structure <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html"><code>Ty</code></a> of a given expression.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn expr_ty(&amp;self, expr: &amp;Expr&lt;'_&gt;) -&gt; Ty&lt;'tcx&gt;
<span class="boring">}</span></code></pre>
<p>As a side note, besides <code>expr_ty</code>, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a> contains a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/typeck_results/struct.TypeckResults.html#method.pat_ty"><code>pat_ty()</code></a> method that is useful for retrieving a type from a pattern.</p>
<h2 id="ty"><a class="header" href="#ty"><code>Ty</code></a></h2>
<p><code>Ty</code> struct contains the type information of an expression.
Let’s take a look at <code>rustc_middle</code>’s <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html"><code>Ty</code></a> struct to examine this struct:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ty&lt;'tcx&gt;(Interned&lt;'tcx, WithStableHash&lt;TyS&lt;'tcx&gt;&gt;&gt;);
<span class="boring">}</span></code></pre>
<p>At a first glance, this struct looks quite esoteric. But at a closer look,
we will see that this struct contains many useful methods for type checking.</p>
<p>For instance, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html#method.is_char"><code>is_char</code></a> checks if the given <code>Ty</code> struct corresponds
to the primitive character type.</p>
<h3 id="is_-usage"><a class="header" href="#is_-usage"><code>is_*</code> Usage</a></h3>
<p>In some scenarios, all we need to do is check if the <code>Ty</code> of an expression
is a specific type, such as <code>char</code> type, so we could write the following:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        // Get type of `expr`
        let ty = cx.typeck_results().expr_ty(expr);

        // Check if the `Ty` of this expression is of character type
        if ty.is_char() {
            println!("Our expression is a char!");
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Furthermore, if we examine the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_middle/ty/sty.rs.html#1831-1834">source code</a> for <code>is_char</code>,
we find something very interesting:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub fn is_char(self) -&gt; bool {
    matches!(self.kind(), Char)
}
<span class="boring">}</span></code></pre>
<p>Indeed, we just discovered <code>Ty</code>’s <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html#method.kind"><code>kind()</code> method</a>, which provides us
with <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/ty_kind/enum.TyKind.html"><code>TyKind</code></a> of a <code>Ty</code>.</p>
<h2 id="tykind"><a class="header" href="#tykind"><code>TyKind</code></a></h2>
<p><code>TyKind</code> defines the kinds of types in Rust’s type system.
Peeking into <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/ty_kind/enum.TyKind.html"><code>TyKind</code> documentation</a>, we will see that it is an
enum of over 25 variants, including items such as <code>Bool</code>, <code>Int</code>, <code>Ref</code>, etc.</p>
<h3 id="kind-usage"><a class="header" href="#kind-usage"><code>kind</code> Usage</a></h3>
<p>The <code>TyKind</code> of <code>Ty</code> can be returned by calling <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html#method.kind"><code>Ty.kind()</code> method</a>.
We often use this method to perform pattern matching in Clippy.</p>
<p>For instance, if we want to check for a <code>struct</code>, we could examine if the
<code>ty.kind</code> corresponds to an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/ty_kind/enum.TyKind.html#variant.Adt"><code>Adt</code></a> (algebraic data type) and if its
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adt/struct.AdtDef.html"><code>AdtDef</code></a> is a struct:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        // Get type of `expr`
        let ty = cx.typeck_results().expr_ty(expr);
        // Match its kind to enter the type
        match ty.kind() {
            ty::Adt(adt_def, _) if adt_def.is_struct() =&gt; println!("Our `expr` is a struct!"),
            _ =&gt; ()
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="hirty-and-tyty"><a class="header" href="#hirty-and-tyty"><code>hir::Ty</code> and <code>ty::Ty</code></a></h2>
<p>We’ve been talking about <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html"><code>ty::Ty</code></a> this whole time without addressing <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Ty.html"><code>hir::Ty</code></a>, but the latter
is also important to understand.</p>
<p><code>hir::Ty</code> would represent <em>what</em> the user wrote, while <code>ty::Ty</code> is how the compiler sees the type and has more
information. Example:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: u32) -&gt; u32 { x }
<span class="boring">}</span></code></pre>
<p>Here the HIR sees the types without “thinking” about them, it knows that the function takes an <code>u32</code> and returns
an <code>u32</code>. As far as <code>hir::Ty</code> is concerned those might be different types. But at the <code>ty::Ty</code> level the compiler
understands that they’re the same type, in-depth lifetimes, etc…</p>
<p>To get from a <code>hir::Ty</code> to a <code>ty::Ty</code>, you can use the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir_analysis/fn.lower_ty.html"><code>lower_ty</code></a> function outside of bodies or
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.node_type"><code>TypeckResults::node_type()</code></a> method inside of bodies.</p>
<blockquote>
<p><strong>Warning</strong>: Don’t use <code>lower_ty</code> inside of bodies, because this can cause ICEs.</p>
</blockquote>
<h2 id="creating-types-programmatically"><a class="header" href="#creating-types-programmatically">Creating Types programmatically</a></h2>
<p>A common usecase for creating types programmatically is when we want to check if a type implements a trait (see
<a href="#trait-checking">Trait Checking</a>).</p>
<p>Here’s an example of how to create a <code>Ty</code> for a slice of <code>u8</code>, i.e. <code>[u8]</code></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_middle::ty::Ty;
// assume we have access to a LateContext
let ty = Ty::new_slice(cx.tcx, Ty::new_u8());
<span class="boring">}</span></code></pre>
<p>In general, we rely on <code>Ty::new_*</code> methods. These methods define the basic building-blocks that the
type-system and trait-system use to define and understand the written code.</p>
<h2 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h2>
<p>Below are some useful links to further explore the concepts covered
in this chapter:</p>
<ul>
<li><a href="https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation">Stages of compilation</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html">Diagnostic items</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/type-checking.html">Type checking</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/ty.html">Ty module</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="trait-checking"><a class="header" href="#trait-checking">Trait Checking</a></h1>
<p>Besides <a href="#type-checking">type checking</a>, we might want to examine if
a specific type <code>Ty</code> implements certain trait when implementing a lint.
There are three approaches to achieve this, depending on if the target trait
that we want to examine has a <a href="https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html">diagnostic item</a>,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/lang_items/struct.LanguageItems.html">lang item</a>, or neither.</p>
<h2 id="using-diagnostic-items"><a class="header" href="#using-diagnostic-items">Using Diagnostic Items</a></h2>
<p>As explained in the <a href="https://rustc-dev-guide.rust-lang.org/">Rust Compiler Development Guide</a>, diagnostic items
are introduced for identifying types via <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html">Symbols</a>.</p>
<p>For instance, if we want to examine whether an expression implements
the <code>Iterator</code> trait, we could simply write the following code,
providing the <code>LateContext</code> (<code>cx</code>), our expression at hand, and
the symbol of the trait in question:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::sym;
use clippy_utils::ty::implements_trait;
use rustc_hir::Expr;
use rustc_lint::{LateContext, LateLintPass};

impl LateLintPass&lt;'_&gt; for CheckIteratorTraitLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        let implements_iterator = (cx.tcx.get_diagnostic_item(sym::Iterator))
            .is_some_and(|id| implements_trait(cx, cx.typeck_results().expr_ty(expr), id, &amp;[]));
        if implements_iterator {
            // [...]
        }

    }
}
<span class="boring">}</span></code></pre>
<blockquote>
<p><strong>Note</strong>: Refer to <a href="https://doc.rust-lang.org/beta/nightly-rustc/rustc_span/symbol/sym/index.html">this index</a> for all the defined <code>Symbol</code>s.</p>
</blockquote>
<h2 id="using-lang-items"><a class="header" href="#using-lang-items">Using Lang Items</a></h2>
<p>Besides diagnostic items, we can also use <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/lang_items/struct.LanguageItems.html"><code>lang_items</code></a>.
Take a look at the documentation to find that <code>LanguageItems</code> contains
all language items defined in the compiler.</p>
<p>Using one of its <code>*_trait</code> method, we could obtain the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html">DefId</a> of any
specific item, such as <code>Clone</code>, <code>Copy</code>, <code>Drop</code>, <code>Eq</code>, which are familiar
to many Rustaceans.</p>
<p>For instance, if we want to examine whether an expression <code>expr</code> implements
<code>Drop</code> trait, we could access <code>LanguageItems</code> via our <code>LateContext</code>’s
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html">TyCtxt</a>, which provides a <code>lang_items</code> method that will return the id of
<code>Drop</code> trait to us. Then, by calling Clippy utils function <code>implements_trait</code>
we can check that the <code>Ty</code> of the <code>expr</code> implements the trait:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::ty::implements_trait;
use rustc_hir::Expr;
use rustc_lint::{LateContext, LateLintPass};

impl LateLintPass&lt;'_&gt; for CheckDropTraitLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        let ty = cx.typeck_results().expr_ty(expr);
        if cx.tcx.lang_items()
            .drop_trait()
            .map_or(false, |id| implements_trait(cx, ty, id, &amp;[])) {
                println!("`expr` implements `Drop` trait!");
            }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="using-type-path"><a class="header" href="#using-type-path">Using Type Path</a></h2>
<p>If neither diagnostic item nor a language item is available, we can use
<a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/paths.rs"><code>clippy_utils::paths</code></a> to determine get a trait’s <code>DefId</code>.</p>
<blockquote>
<p><strong>Note</strong>: This approach should be avoided if possible, the best thing to do would be to make a PR to <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> adding a diagnostic item.</p>
</blockquote>
<p>Below, we check if the given <code>expr</code> implements <a href="https://doc.rust-lang.org/std/iter/trait.Step.html"><code>core::iter::Step</code></a>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::paths;
use clippy_utils::ty::implements_trait;
use rustc_hir::Expr;
use rustc_lint::{LateContext, LateLintPass};

impl LateLintPass&lt;'_&gt; for CheckIterStep {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        let ty = cx.typeck_results().expr_ty(expr);
        if let Some(trait_def_id) = paths::ITER_STEP.first(cx)
            &amp;&amp; implements_trait(cx, ty, trait_def_id, &amp;[])
        {
            println!("`expr` implements the `core::iter::Step` trait!");
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="creating-types-programmatically-1"><a class="header" href="#creating-types-programmatically-1">Creating Types Programmatically</a></h2>
<p>Traits are often generic over a type parameter, e.g. <code>Borrow&lt;T&gt;</code> is generic
over <code>T</code>. Rust allows us to implement a trait for a specific type. For example,
we can implement <code>Borrow&lt;[u8]&gt;</code> for a hypothetical type <code>Foo</code>. Let’s suppose
that we would like to find whether our type actually implements <code>Borrow&lt;[u8]&gt;</code>.</p>
<p>To do so, we can use the same <code>implements_trait</code> function as above, and supply
a type parameter that represents <code>[u8]</code>. Since <code>[u8]</code> is a specialization of
<code>[T]</code>, we can use the  <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html#method.new_slice"><code>Ty::new_slice</code></a> method to create a type
that represents <code>[T]</code> and supply <code>u8</code> as a type parameter.
To create a <code>ty::Ty</code> programmatically, we rely on <code>Ty::new_*</code> methods. These
methods create a <code>TyKind</code> and then wrap it in a <code>Ty</code> struct. This means we
have access to all the primitive types, such as <code>Ty::new_char</code>,
<code>Ty::new_bool</code>, <code>Ty::new_int</code>, etc. We can also create more complex types,
such as slices, tuples, and references out of these basic building blocks.</p>
<p>For trait checking, it is not enough to create the types, we need to convert
them into <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.GenericArg.html">GenericArg</a>. In rustc, a generic is an entity that the compiler
understands and has three kinds, type, const and lifetime. By calling
<code>.into()</code> on a constructed <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html">Ty</a>, we wrap the type into a generic which can
then be used by the query system to decide whether the specialized trait
is implemented.</p>
<p>The following code demonstrates how to do this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>
use rustc_middle::ty::Ty;
use clippy_utils::sym;
use clippy_utils::ty::implements_trait;

let ty = todo!("Get the `Foo` type to check for a trait implementation");
let borrow_id = cx.tcx.get_diagnostic_item(sym::Borrow).unwrap(); // avoid unwrap in real code
let slice_of_bytes_t = Ty::new_slice(cx.tcx, cx.tcx.types.u8);
let generic_param = slice_of_bytes_t.into();
if implements_trait(cx, ty, borrow_id, &amp;[generic_param]) {
    todo!("Rest of lint implementation")
}
<span class="boring">}</span></code></pre>
<p>In essence, the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html">Ty</a> struct allows us to create types programmatically in a
representation that can be used by the compiler and the query engine. We then
use the <code>rustc_middle::Ty</code> of the type we are interested in, and query the
compiler to see if it indeed implements the trait we are interested in.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="method-checking"><a class="header" href="#method-checking">Method Checking</a></h1>
<p>In some scenarios we might want to check for methods when developing
a lint. There are two kinds of questions that we might be curious about:</p>
<ul>
<li>Invocation: Does an expression call a specific method?</li>
<li>Definition: Does an <code>impl</code> define a method?</li>
</ul>
<h2 id="checking-if-an-expr-is-calling-a-specific-method"><a class="header" href="#checking-if-an-expr-is-calling-a-specific-method">Checking if an <code>expr</code> is calling a specific method</a></h2>
<p>Suppose we have an <code>expr</code>, we can check whether it calls a specific
method, e.g. <code>our_fancy_method</code>, by performing a pattern match on
the <a href="https://doc.rust-lang.org/beta/nightly-rustc/rustc_hir/hir/enum.ExprKind.html"><code>ExprKind</code></a> that we can access from <code>expr.kind</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustc_hir as hir;
use rustc_lint::{LateContext, LateLintPass};
use clippy_utils::res::{MaybeDef, MaybeTypeckRes};
use clippy_utils::sym;

impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for OurFancyMethodLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, expr: &amp;'tcx hir::Expr&lt;'_&gt;) {
        // Check our expr is calling a method with pattern matching
        if let hir::ExprKind::MethodCall(path, _, _, _) = &amp;expr.kind
            // Check if the name of this method is `our_fancy_method`
            &amp;&amp; path.ident.name == sym::our_fancy_method
            // Check if the method belongs to the `sym::OurFancyTrait` trait.
            // (for example, a `map` method could belong to user-defined trait instead of to `Iterator`)
            // See the next section for more information.
            &amp;&amp; cx.ty_based_def(expr).opt_parent(cx).is_diag_item(cx, sym::OurFancyTrait)
        {
            println!("`expr` is a method call for `our_fancy_method`");
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Take a closer look at the <code>ExprKind</code> enum variant <a href="https://doc.rust-lang.org/beta/nightly-rustc/rustc_hir/hir/enum.ExprKind.html#variant.MethodCall"><code>MethodCall</code></a> for more
information on the pattern matching. As mentioned in <a href="#lint-types">Define
Lints</a>, the <code>methods</code> lint type is full of pattern
matching with <code>MethodCall</code> in case the reader wishes to explore more.</p>
<p>New symbols such as <code>our_fancy_method</code> need to be added to the <code>clippy_utils::sym</code> module.
This module extends the list of symbols already provided by the compiler crates
in <code>rustc_span::sym</code>.</p>
<p>If a trait defines only one method (such as the <code>std::ops::Deref</code> trait, which only has the <code>deref()</code> method),
one might be tempted to omit the method name check. This would work, but is not always advisable because:</p>
<ul>
<li>If a new method (possibly with a default implementation) were to be added to the trait, there would be a risk of
matching the wrong method.</li>
<li>Comparing symbols is very cheap and might prevent a more expensive lookup.</li>
</ul>
<h2 id="checking-if-a-impl-block-implements-a-method"><a class="header" href="#checking-if-a-impl-block-implements-a-method">Checking if a <code>impl</code> block implements a method</a></h2>
<p>While sometimes we want to check whether a method is being called or not, other
times we want to know if our <code>Ty</code> defines a method.</p>
<p>To check if our <code>impl</code> block defines a method <code>our_fancy_method</code>, we will
utilize the <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_lint/trait.LateLintPass.html#method.check_impl_item"><code>check_impl_item</code></a> method that is available in our beloved
<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_lint/trait.LateLintPass.html"><code>LateLintPass</code></a> (for more information, refer to the <a href="#lint-passes-1">“Lint
Passes”</a> chapter in the Clippy book). This method provides us
with an <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_hir/hir/struct.ImplItem.html"><code>ImplItem</code></a> struct, which represents anything within an <code>impl</code> block.</p>
<p>Let us take a look at how we might check for the implementation of
<code>our_fancy_method</code> on a type:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::{return_ty, sym};
use clippy_utils::res::MaybeDef;
use rustc_hir::{ImplItem, ImplItemKind};
use rustc_lint::{LateContext, LateLintPass};

impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for MyTypeImpl {
    fn check_impl_item(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, impl_item: &amp;'tcx ImplItem&lt;'_&gt;) {
        // Check if item is a method/function
        if let ImplItemKind::Fn(ref signature, _) = impl_item.kind
            // Check the method is named `our_fancy_method`
            &amp;&amp; impl_item.ident.name.as_str() == "our_fancy_method"
            // We can also check it has a parameter `self`
            &amp;&amp; signature.decl.implicit_self.has_implicit_self()
            // We can go even further and even check if its return type is `String`
            &amp;&amp; return_ty(cx, impl_item.hir_id).is_diag_item(cx, sym::String)
        {
            println!("`our_fancy_method` is implemented!");
        }
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dealing-with-macros-and-expansions"><a class="header" href="#dealing-with-macros-and-expansions">Dealing with macros and expansions</a></h1>
<p>Sometimes we might encounter Rust macro expansions while working with Clippy.
While macro expansions are not as dramatic and profound as the expansion
of our universe, they can certainly bring chaos to the orderly world
of code and logic.</p>
<p>The general rule of thumb is that we should ignore code with macro
expansions when working with Clippy because the code can be dynamic
in ways that are difficult or impossible for us to foresee.</p>
<h2 id="false-positives"><a class="header" href="#false-positives">False Positives</a></h2>
<p>What exactly do we mean by <em>dynamic in ways that are difficult to foresee</em>?</p>
<p>Macros are <a href="https://rustc-dev-guide.rust-lang.org/macro-expansion.html#expansion-and-ast-integration">expanded</a> in the <code>EarlyLintPass</code> level,
so the Abstract Syntax Tree (AST) is generated in place of macros.
This means the code which we work with in Clippy is already expanded.</p>
<p>If we wrote a new lint, there is a possibility that the lint is
triggered in macro-generated code. Since this expanded macro code
is not written by the macro’s user but really by the macro’s author,
the user cannot and should not be responsible for fixing the issue
that triggers the lint.</p>
<p>Besides, a <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html">Span</a> in a macro can be changed by the macro author.
Therefore, any lint check related to lines or columns should be
avoided since they might be changed at any time and become unreliable
or incorrect information.</p>
<p>Because of these unforeseeable or unstable behaviors, macro expansion
should often not be regarded as a part of the stable API.
This is also why most lints check if they are inside a macro or not
before emitting suggestions to the end user to avoid false positives.</p>
<h2 id="how-to-work-with-macros"><a class="header" href="#how-to-work-with-macros">How to Work with Macros</a></h2>
<p>Several functions are available for working with macros.</p>
<h3 id="the-spanfrom_expansion-method"><a class="header" href="#the-spanfrom_expansion-method">The <code>Span::from_expansion</code> method</a></h3>
<p>We could utilize a <code>span</code>’s <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> method, which
detects if the <code>span</code> is from a macro expansion / desugaring.
This is a very common first step in a lint:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if expr.span.from_expansion() {
    // We most likely want to ignore it.
    return;
}
<span class="boring">}</span></code></pre>
<h3 id="spanctxt-method"><a class="header" href="#spanctxt-method"><code>Span::ctxt</code> method</a></h3>
<p>The <code>span</code>’s context, given by the method <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.ctxt"><code>ctxt</code></a> and returning <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html">SyntaxContext</a>,
represents if the span is from a macro expansion and, if it is, which
macro call expanded this span.</p>
<p>Sometimes, it is useful to check if the context of two spans are equal.
For instance, suppose we have the following line of code that would
expand into <code>1 + 0</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following code expands to `1 + 0` for both `EarlyLintPass` and `LateLintPass`
1 + mac!()
<span class="boring">}</span></code></pre>
<p>Assuming that we’d collect the <code>1</code> expression as a variable <code>left</code> and the
<code>0</code>/<code>mac!()</code> expression as a variable <code>right</code>, we can simply compare their
contexts. If the context is different, then we most likely are dealing with a
macro expansion and should just ignore it:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if left.span.ctxt() != right.span.ctxt() {
    // The code author most likely cannot modify this expression
    return;
}
<span class="boring">}</span></code></pre>
<blockquote>
<p><strong>Note</strong>: Code that is not from expansion is in the “root” context.
So any spans whose <code>from_expansion</code> returns <code>false</code> can be assumed
to have the same context. Because of this, using <code>span.from_expansion()</code>
is often sufficient.</p>
</blockquote>
<p>Going a bit deeper, in a simple expression such as <code>a == b</code>,
<code>a</code> and <code>b</code> have the same context.
However, in a <code>macro_rules!</code> with <code>a == $b</code>, <code>$b</code> is expanded to
an expression that contains a different context from <code>a</code>.</p>
<p>Take a look at the following macro <code>m</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($a:expr, $b:expr) =&gt; {
        if $a.is_some() {
            $b;
        }
    }
}

let x: Option&lt;u32&gt; = Some(42);
m!(x, x.unwrap());
<span class="boring">}</span></code></pre>
<p>If the <code>m!(x, x.unwrap());</code> line is expanded, we would get two expanded
expressions:</p>
<ul>
<li><code>x.is_some()</code> (from the <code>$a.is_some()</code> line in the <code>m</code> macro)</li>
<li><code>x.unwrap()</code> (corresponding to <code>$b</code> in the <code>m</code> macro)</li>
</ul>
<p>Suppose <code>x.is_some()</code> expression’s span is associated with the <code>x_is_some_span</code> variable
and <code>x.unwrap()</code> expression’s span is associated with <code>x_unwrap_span</code> variable,
we could assume that these two spans do not share the same context:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// x.is_some() is from inside the macro
// x.unwrap() is from outside the macro
assert_ne!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());
<span class="boring">}</span></code></pre>
<h3 id="the-in_external_macro-function"><a class="header" href="#the-in_external_macro-function">The <code>in_external_macro</code> function</a></h3>
<p><code>Span</code> provides a method (<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a>) that can
detect if the given span is from a macro defined in a foreign crate.</p>
<p>Therefore, if we really want a new lint to work with macro-generated code,
this is the next line of defense to avoid macros not defined inside
the current crate since it is unfair to the user if Clippy lints code
which the user cannot change.</p>
<p>For example, assume we have the following code that is being examined
by Clippy:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate a_foreign_crate_with_macros;

// `foo` macro is defined in `a_foreign_crate_with_macros`
foo!("bar");
<span class="boring">}</span></code></pre>
<p>Also assume that we get the corresponding variable <code>foo_span</code> for the
<code>foo</code> macro call, we could decide not to lint if <code>in_external_macro</code>
results in <code>true</code> (note that <code>cx</code> can be <code>EarlyContext</code> or <code>LateContext</code>):</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if foo_span.in_external_macro(cx.sess().source_map()) {
    // We should ignore macro from a foreign crate.
    return;
}
<span class="boring">}</span></code></pre>
<h3 id="the-is_from_proc_macro-function"><a class="header" href="#the-is_from_proc_macro-function">The <code>is_from_proc_macro</code> function</a></h3>
<p>A common point of confusion is the existence of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/fn.is_from_proc_macro.html"><code>is_from_proc_macro</code></a>
and how it differs from the other <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a>/<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> functions.</p>
<p>While <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a> and <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> both work perfectly fine for detecting expanded code
from <em>declarative</em> macros (i.e. <code>macro_rules!</code> and macros 2.0),
detecting <em>proc macro</em>-generated code is a bit more tricky, as proc macros can (and often do)
freely manipulate the span of returned tokens.</p>
<p>In practice, this often happens through the use of <a href="https://docs.rs/quote/latest/quote/macro.quote_spanned.html"><code>quote::quote_spanned!</code></a> with a span from the input tokens.</p>
<p>In those cases, there is no <em>reliable</em> way for the compiler (and tools like Clippy)
to distinguish code that comes from such a proc macro from code that the user wrote directly,
and <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a> will return <code>false</code>.</p>
<p>This is usually not an issue for the compiler and actually helps proc macro authors create better error messages,
as it allows associating parts of the expansion with parts of the macro input and lets the compiler
point the user to the relevant code in case of a compile error.</p>
<p>However, for Clippy this is inconvenient, because most of the time <em>we don’t</em> want
to lint proc macro-generated code and this makes it impossible to tell what is and isn’t proc macro code.</p>
<blockquote>
<p>NOTE: this is specifically only an issue when a proc macro explicitly sets the span to that of an <strong>input span</strong>.</p>
<p>For example, other common ways of creating <code>TokenStream</code>s, such as <code>"fn foo() {...}".parse::&lt;TokenStream&gt;()</code>,
sets each token’s span to <code>Span::call_site()</code>, which already marks the span as coming from a proc macro
and the usual span methods have no problem detecting that as a macro span.</p>
</blockquote>
<p>As such, Clippy has its own <code>is_from_proc_macro</code> function which tries to <em>approximate</em>
whether a span comes from a proc macro, by checking whether the source text at the given span
lines up with the given AST node.</p>
<p>This function is typically used in combination with the other mentioned macro span functions,
but is usually called much later into the condition chain as it’s a bit heavier than most other conditions,
so that the other cheaper conditions can fail faster. For example, the <code>borrow_deref_ref</code> lint:</p>
<pre><code class="language-rs">impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for BorrowDerefRef {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, e: &amp;rustc_hir::Expr&lt;'tcx&gt;) {
        if let ... = ...
            &amp;&amp; ...
            &amp;&amp; !e.span.from_expansion()
            &amp;&amp; ...
            &amp;&amp; ...
            &amp;&amp; !is_from_proc_macro(cx, e)
            &amp;&amp; ...
        {
            ...
        }
    }
}
</code></pre>
<h3 id="testing-lints-with-macro-expansions"><a class="header" href="#testing-lints-with-macro-expansions">Testing lints with macro expansions</a></h3>
<p>To test that all of these cases are handled correctly in your lint,
we have a helper auxiliary crate that exposes various macros, used by tests like so:</p>
<pre class="playground"><code class="language-rust edition2024">//@aux-build:proc_macros.rs

extern crate proc_macros;

fn main() {
    proc_macros::external!{ code_that_should_trigger_your_lint }
    proc_macros::with_span!{ span code_that_should_trigger_your_lint }
}</code></pre>
<p>This exercises two cases:</p>
<ul>
<li>
<p><code>proc_macros::external!</code> is a simple proc macro that echos the input tokens back but with a macro span:
this represents the usual, common case where an external macro expands to code that your lint would trigger,
and is correctly handled by <code>in_external_macro</code> and <code>Span::from_expansion</code>.</p>
</li>
<li>
<p><code>proc_macros::with_span!</code> echos back the input tokens starting from the second token
with the span of the first token: this is where the other functions will fail and <code>is_from_proc_macro</code> is needed</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="common-tools-for-writing-lints"><a class="header" href="#common-tools-for-writing-lints">Common tools for writing lints</a></h1>
<p>You may need following tooltips to catch up with common operations.</p>
<ul>
<li><a href="#common-tools-for-writing-lints">Common tools for writing lints</a>
<ul>
<li><a href="#retrieving-the-type-of-expression">Retrieving the type of expression</a></li>
<li><a href="#checking-if-an-expr-is-calling-a-specific-method-1">Checking if an expr is calling a specific method</a></li>
<li><a href="#checking-for-a-specific-type">Checking for a specific type</a></li>
<li><a href="#checking-if-a-type-implements-a-specific-trait">Checking if a type implements a specific trait</a></li>
<li><a href="#checking-if-a-type-defines-a-specific-method">Checking if a type defines a specific method</a></li>
<li><a href="#dealing-with-macros-and-expansions-1">Dealing with macros</a></li>
</ul>
</li>
</ul>
<p>Useful Rustc dev guide links:</p>
<ul>
<li><a href="https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation">Stages of compilation</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html">Diagnostic items</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/type-checking.html">Type checking</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/ty.html">Ty module</a></li>
</ul>
<h2 id="retrieving-the-type-of-expression"><a class="header" href="#retrieving-the-type-of-expression">Retrieving the type of expression</a></h2>
<p>Sometimes you may want to retrieve the type <code>Ty</code> of an expression <code>Expr</code>, for
example to answer following questions:</p>
<ul>
<li>which type does this expression correspond to (using its <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_type_ir/ty_kind/enum.TyKind.html"><code>TyKind</code></a>)?</li>
<li>is it a sized type?</li>
<li>is it a primitive type?</li>
<li>does it implement a trait?</li>
</ul>
<p>This operation is performed using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty"><code>expr_ty()</code></a> method from the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a> struct, that gives you access to the underlying
structure <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html"><code>Ty</code></a>.</p>
<p>Example of use:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        // Get type of `expr`
        let ty = cx.typeck_results().expr_ty(expr);
        // Match its kind to enter its type
        match ty.kind() {
            ty::Adt(adt_def, _) if adt_def.is_struct() =&gt; println!("Our `expr` is a struct!"),
            _ =&gt; ()
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Similarly, in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a> methods, you have the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.pat_ty"><code>pat_ty()</code></a> method to retrieve a type from a pattern.</p>
<p>Two noticeable items here:</p>
<ul>
<li><code>cx</code> is the lint context <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html"><code>LateContext</code></a>. The two most useful
data structures in this context are <code>tcx</code> and the <code>TypeckResults</code> returned by
<code>LateContext::typeck_results</code>, allowing us to jump to type definitions and
other compilation stages such as HIR.</li>
<li><code>typeck_results</code>’s return value is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html"><code>TypeckResults</code></a> and is
created by type checking step, it includes useful information such as types of
expressions, ways to resolve methods and so on.</li>
</ul>
<h2 id="checking-if-an-expr-is-calling-a-specific-method-1"><a class="header" href="#checking-if-an-expr-is-calling-a-specific-method-1">Checking if an expr is calling a specific method</a></h2>
<p>Starting with an <code>expr</code>, you can check whether it is calling a specific method
<code>some_method</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, expr: &amp;'tcx hir::Expr&lt;'_&gt;) {
        // Check our expr is calling a method
        if let hir::ExprKind::MethodCall(path, _, _self_arg, ..) = &amp;expr.kind
            // Check the name of this method is `some_method`
            &amp;&amp; path.ident.name == sym::some_method
            // Optionally, check the type of the self argument.
            // - See "Checking for a specific type"
        {
                // ...
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="checking-for-a-specific-type"><a class="header" href="#checking-for-a-specific-type">Checking for a specific type</a></h2>
<p>There are three ways to check if an expression type is a specific type we want
to check for. All of these methods only check for the base type, generic
arguments have to be checked separately.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::{paths, sym};
use clippy_utils::res::MaybeDef;
use rustc_hir::LangItem;

impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {
        // Getting the expression type
        let ty = cx.typeck_results().expr_ty(expr);

        // 1. Using diagnostic items
        // The last argument is the diagnostic item to check for
        if ty.is_diag_item(cx, sym::Option) {
            // The type is an `Option`
        }

        // 2. Using lang items
        if ty.is_lang_item(cx, LangItem::RangeFull) {
            // The type is a full range like `.drain(..)`
        }

        // 3. Using the type path
        // This method should be avoided if possible
        if paths::RESULT.matches_ty(cx, ty) {
            // The type is a `core::result::Result`
        }
    }
}
<span class="boring">}</span></code></pre>
<p>Prefer using diagnostic items and lang items where possible.</p>
<h2 id="checking-if-a-type-implements-a-specific-trait"><a class="header" href="#checking-if-a-type-implements-a-specific-trait">Checking if a type implements a specific trait</a></h2>
<p>There are three ways to do this, depending on if the target trait has a
diagnostic item, lang item or neither.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::sym;
use clippy_utils::ty::implements_trait;

impl LateLintPass&lt;'_&gt; for MyStructLint {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'_&gt;, expr: &amp;Expr&lt;'_&gt;) {

        // 1. Get the `DefId` of the trait.
        // via lang items
        let trait_id = cx.tcx.lang_items().drop_trait();
        // via diagnostic items
        let trait_id = cx.tcx.get_diagnostic_item(sym::Eq);

        // 2. Check for the trait implementation via the `implements_trait` util.
        let ty = cx.typeck_results().expr_ty(expr);
        if trait_id.is_some_and(|id| implements_trait(cx, ty, id, &amp;[])) {
            // `ty` implements the trait.
        }

        // 3. If the trait requires additional generic arguments
        let trait_id = cx.tcx.lang_items().eq_trait();
        if trait_id.is_some_and(|id| implements_trait(cx, ty, id, &amp;[ty])) {
            // `ty` implements `PartialEq&lt;Self&gt;`
        }
    }
}
<span class="boring">}</span></code></pre>
<blockquote>
<p>Prefer using diagnostic and lang items, if the target trait has one.</p>
</blockquote>
<p>We access lang items through the type context <code>tcx</code>. <code>tcx</code> is of type
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html"><code>TyCtxt</code></a> and is defined in the <code>rustc_middle</code> crate. A list of defined
paths for Clippy can be found in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/paths/index.html">paths.rs</a></p>
<h2 id="checking-if-a-type-defines-a-specific-method"><a class="header" href="#checking-if-a-type-defines-a-specific-method">Checking if a type defines a specific method</a></h2>
<p>To check if our type defines a method called <code>some_method</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clippy_utils::ty::is_type_lang_item;
use clippy_utils::{sym, return_ty};

impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for MyTypeImpl {
    fn check_impl_item(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, impl_item: &amp;'tcx ImplItem&lt;'_&gt;) {
        // Check if item is a method/function
        if let ImplItemKind::Fn(ref signature, _) = impl_item.kind
            // Check the method is named `some_method`
            //
            // Add `some_method` to `clippy_utils::sym` if it's not already there
            &amp;&amp; impl_item.ident.name == sym::some_method
            // We can also check it has a parameter `self`
            &amp;&amp; signature.decl.implicit_self.has_implicit_self()
            // We can go further and even check if its return type is `String`
            &amp;&amp; return_ty(cx, impl_item.hir_id).is_lang_item(cx, LangItem::String)
        {
            // ...
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="dealing-with-macros-and-expansions-1"><a class="header" href="#dealing-with-macros-and-expansions-1">Dealing with macros and expansions</a></h2>
<p>Keep in mind that macros are already expanded and desugaring is already applied
to the code representation that you are working with in Clippy. This
unfortunately causes a lot of false positives because macro expansions are
“invisible” unless you actively check for them. Generally speaking, code with
macro expansions should just be ignored by Clippy because that code can be
dynamic in ways that are difficult or impossible to see. Use the following
functions to deal with macros:</p>
<ul>
<li>
<p><code>span.from_expansion()</code>: detects if a span is from macro expansion or
desugaring. Checking this is a common first step in a lint.</p>
<pre><code class="language-rust ignore">if expr.span.from_expansion() {
    // just forget it
    return;
}</code></pre>
</li>
<li>
<p><code>span.ctxt()</code>: the span’s context represents whether it is from expansion, and
if so, which macro call expanded it. It is sometimes useful to check if the
context of two spans are equal.</p>
<pre><code class="language-rust ignore">// expands to `1 + 0`, but don't lint
1 + mac!()</code></pre>
<pre><code class="language-rust ignore">if left.span.ctxt() != right.span.ctxt() {
    // the coder most likely cannot modify this expression
    return;
}</code></pre>
<blockquote>
<p>Note: Code that is not from expansion is in the “root” context. So any spans
where <code>from_expansion</code> returns <code>true</code> can be assumed to have the same
context. And so just using <code>span.from_expansion()</code> is often good enough.</p>
</blockquote>
</li>
<li>
<p><code>span.in_external_macro(sm)</code>: detect if the given span is from a macro defined in
a foreign crate. If you want the lint to work with macro-generated code, this
is the next line of defense to avoid macros not defined in the current crate.
It doesn’t make sense to lint code that the coder can’t change.</p>
<p>You may want to use it for example to not start linting in macros from other
crates</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use a_crate_with_macros::foo;

// `foo` is defined in `a_crate_with_macros`
foo!("bar");

// if we lint the `match` of `foo` call and test its span
assert_eq!(match_span.in_external_macro(cx.sess().source_map()), true);
<span class="boring">}</span></code></pre>
</li>
<li>
<p><code>span.ctxt()</code>: the span’s context represents whether it is from expansion, and
if so, what expanded it</p>
<p>One thing <code>SpanContext</code> is useful for is to check if two spans are in the same
context. For example, in <code>a == b</code>, <code>a</code> and <code>b</code> have the same context. In a
<code>macro_rules!</code> with <code>a == $b</code>, <code>$b</code> is expanded to some expression with a
different context from <code>a</code>.</p>
<pre><code class="language-rust ignore">macro_rules! m {
    ($a:expr, $b:expr) =&gt; {
        if $a.is_some() {
            $b;
        }
    }
}

let x: Option&lt;u32&gt; = Some(42);
m!(x, x.unwrap());

// These spans are not from the same context
// x.is_some() is from inside the macro
// x.unwrap() is from outside the macro
assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h1>
<p>In order to deploy Clippy over <code>rustup</code>, some infrastructure is necessary. This
chapter describes the different parts of the Clippy infrastructure that need to
be maintained to make this possible.</p>
<p>The most important part is the sync between the <code>rust-lang/rust</code> repository and
the Clippy repository that takes place every two weeks. This process is
described in the <a href="#syncing-changes-between-clippy-and-rust-langrust">Syncing changes between Clippy and <code>rust-lang/rust</code></a>
section.</p>
<p>A new Clippy release is done together with every Rust release, so every six
weeks. The release process is described in the <a href="#release-a-new-clippy-version">Release a new Clippy
Version</a> section. During a release cycle a changelog entry for the
next release has to be written. The format of that and how to do that is
documented in the <a href="#changelog-update">Changelog Update</a> section.</p>
<blockquote>
<p><em>Note:</em> The Clippy CI should also be described in this chapter, but for now is
left as a TODO.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="syncing-changes-between-clippy-and-rust-langrust"><a class="header" href="#syncing-changes-between-clippy-and-rust-langrust">Syncing changes between Clippy and <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a></a></h1>
<p>Clippy currently gets built with a pinned nightly version.</p>
<p>In the <code>rust-lang/rust</code> repository, where rustc resides, there’s a copy of
Clippy that compiler hackers modify from time to time to adapt to changes in the
unstable API of the compiler.</p>
<p>We need to sync these changes back to this repository periodically, and the
changes made to this repository in the meantime also need to be synced to the
<code>rust-lang/rust</code> repository.</p>
<p>To avoid flooding the <code>rust-lang/rust</code> PR queue, this two-way sync process is
done in a bi-weekly basis if there’s no urgent changes. This is done starting on
the day of the Rust stable release and then every other week. That way we
guarantee that we keep this repo up to date with the latest compiler API, and
every feature in Clippy is available for 2 weeks in nightly, before it can get
to beta. For reference, the first sync following this cadence was performed the
2020-08-27.</p>
<p>This process is described in detail in the following sections. For general
information about <code>subtree</code>s in the Rust repository see <a href="https://rustc-dev-guide.rust-lang.org/external-repos.html#external-dependencies-subtree">the rustc-dev-guide</a>.</p>
<h2 id="patching-git-subtree-to-work-with-big-repos"><a class="header" href="#patching-git-subtree-to-work-with-big-repos">Patching git-subtree to work with big repos</a></h2>
<p>Currently, there’s a bug in <code>git-subtree</code> that prevents it from working properly
with the <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> repo. There’s an open PR to fix that, but it’s
stale. Before continuing with the following steps, we need to manually apply
that fix to our local copy of <code>git-subtree</code>.</p>
<p>You can get the patched version of <code>git-subtree</code> from <a href="https://github.com/gitgitgadget/git/pull/493">here</a>.
Put this file under <code>/usr/lib/git-core</code> (making a backup of the previous file)
and make sure it has the proper permissions:</p>
<pre><code class="language-bash">sudo cp --backup /path/to/patched/git-subtree.sh /usr/lib/git-core/git-subtree
sudo chmod --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree
sudo chown --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subtree
</code></pre>
<blockquote>
<p><em>Note:</em> The first time running <code>git subtree push</code> a cache has to be built.
This involves going through the complete Clippy history once. For this you
have to increase the stack limit though, which you can do with <code>ulimit -s 60000</code>. Make sure to run the <code>ulimit</code> command from the same session you call
git subtree.</p>
</blockquote>
<blockquote>
<p><em>Note:</em> If you are a Debian user, <code>dash</code> is the shell used by default for
scripts instead of <code>sh</code>. This shell has a hardcoded recursion limit set to
1,000. In order to make this process work, you need to force the script to run
<code>bash</code> instead. You can do this by editing the first line of the <code>git-subtree</code>
script and changing <code>sh</code> to <code>bash</code>.</p>
</blockquote>
<blockquote>
<p>Note: The following sections assume that you have set up remotes following the
instructions in <a href="#defining-remotes">defining remotes</a>.</p>
</blockquote>
<h2 id="performing-the-sync-from-rust-langrust-to-clippy"><a class="header" href="#performing-the-sync-from-rust-langrust-to-clippy">Performing the sync from <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> to Clippy</a></h2>
<p>Here is a TL;DR version of the sync process (all the following commands have
to be run inside the <code>rust</code> directory):</p>
<ol>
<li>
<p>Clone the <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> repository or make sure it is up-to-date.</p>
</li>
<li>
<p>Checkout the commit from the latest available nightly. You can get it using
<code>rustup check</code>.</p>
</li>
<li>
<p>Sync the changes to the rust-copy of Clippy to your Clippy fork:</p>
<pre><code class="language-bash"># Be sure to either use a net-new branch, e.g. `rustup`, or delete the branch beforehand
# because changes cannot be fast forwarded and you have to run this command again.
git subtree push -P src/tools/clippy clippy-local rustup
</code></pre>
<blockquote>
<p><em>Note:</em> Most of the time you have to create a merge commit in the
<code>rust-clippy</code> repo (this has to be done in the Clippy repo, not in the
rust-copy of Clippy):</p>
</blockquote>
<pre><code class="language-bash">git fetch upstream  # assuming upstream is the rust-lang/rust remote
git switch rustup
git merge upstream/master --no-ff
</code></pre>
<blockquote>
<p>Note: This is one of the few instances where a merge commit is allowed in
a PR.</p>
</blockquote>
</li>
<li>
<p>Bump the nightly version in the Clippy repository by running these commands:</p>
<pre><code class="language-bash">cargo dev sync update_nightly
git commit -m "Bump nightly version -&gt; YYYY-MM-DD" rust-toolchain.toml clippy_utils/README.md
</code></pre>
</li>
<li>
<p>Open a PR to <code>rust-lang/rust-clippy</code> and wait for it to get merged (to
accelerate the process ping the <code>@rust-lang/clippy</code> team in your PR and/or
ask them in the <a href="https://rust-lang.zulipchat.com/#narrow/stream/clippy">Zulip</a> stream.)</p>
</li>
</ol>
<h2 id="performing-the-sync-from-clippy-to-rust-langrust"><a class="header" href="#performing-the-sync-from-clippy-to-rust-langrust">Performing the sync from Clippy to <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a></a></h2>
<p>All the following commands have to be run inside the <code>rust</code> directory.</p>
<ol>
<li>Make sure you have checked out the latest <code>master</code> of <code>rust-lang/rust</code>.</li>
<li>Sync the <code>rust-lang/rust-clippy</code> master to the rust-copy of Clippy:
<pre><code class="language-bash">git switch -c clippy-subtree-update
git subtree pull -P src/tools/clippy clippy-upstream master
</code></pre>
</li>
<li>Open a PR to <a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="backport-changes"><a class="header" href="#backport-changes">Backport Changes</a></h1>
<p>Sometimes it is necessary to backport changes to the beta release of Clippy.
Backports in Clippy are rare and should be approved by the Clippy team. For
example, a backport is done, if a crucial ICE was fixed or a lint is broken to a
point, that it has to be disabled, before landing on stable.</p>
<blockquote>
<p>Note: If you think a PR should be backported you can label it with
<code>beta-nominated</code>. This has to be done before the Thursday the week before the
release.</p>
</blockquote>
<h2 id="filtering-prs-to-backport"><a class="header" href="#filtering-prs-to-backport">Filtering PRs to backport</a></h2>
<p>First, find all labeled PRs using <a href="https://github.com/rust-lang/rust-clippy/issues?q=label%3Abeta-nominated">this filter</a>.</p>
<p>Next, look at each PR individually. There are a few things to check. Those need
some explanation and are quite subjective. Good judgement is required.</p>
<ol>
<li>
<p><strong>Is the fix worth a backport?</strong></p>
<p>This is really subjective. An ICE fix usually is. Moving a lint to a <em>lower</em>
group (from warn- to allow-by-default) usually as well. An FP fix usually not
(on its own). If a backport is done anyway, FP fixes might also be included.
If the PR has a lot of changes, backports must be considered more carefully.</p>
</li>
<li>
<p><strong>Is the problem that was fixed by the PR already in <code>beta</code>?</strong></p>
<p>It could be that the problem that was fixed by the PR hasn’t made it to the
<code>beta</code> branch of the Rust repo yet. If that’s the case, and the fix is
already synced to the Rust repo, the fix doesn’t need to be backported, as it
will hit stable together with the commit that introduced the problem. If the
fix PR is not synced yet, the fix PR either needs to be “backported” to the
Rust <code>master</code> branch or to <code>beta</code> in the next backport cycle.</p>
</li>
<li>
<p><strong>Make sure that the fix is on <code>master</code> before porting to <code>beta</code></strong></p>
<p>The fix must already be synced to the Rust <code>master</code> branch. Otherwise, the
next <code>beta</code> will be missing this fix again. If it is not yet in <code>master</code> it
should probably not be backported. If the backport is really important, do an
out-of-cycle sync first. However, the out-of-cycle sync should be small,
because the changes in that sync will get right into <code>beta</code>, without being
tested in <code>nightly</code> first.</p>
</li>
</ol>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<blockquote>
<p>Note: All commands in this chapter will be run in the Rust clone.</p>
</blockquote>
<p>Follow the instructions in <a href="#defining-remotes">defining remotes</a> to define the <code>clippy-upstream</code>
remote in the Rust repository.</p>
<p>After that, fetch the remote with</p>
<pre><code class="language-bash">git fetch clippy-upstream master
</code></pre>
<p>Then, switch to the <code>beta</code> branch:</p>
<pre><code class="language-bash">git switch beta
git fetch upstream
git reset --hard upstream/beta
</code></pre>
<h2 id="backport-the-changes"><a class="header" href="#backport-the-changes">Backport the changes</a></h2>
<p>When a PR is merged with the GitHub merge queue, the PR is closed with the message</p>
<blockquote>
<p>&lt;PR title&gt; (#&lt;PR number&gt;)</p>
</blockquote>
<p>This commit needs to be backported. To do that, find the <code>&lt;sha1&gt;</code> of that commit
and run the following command in the clone of the <strong>Rust repository</strong>:</p>
<pre><code class="language-bash">git cherry-pick -m 1 `&lt;sha1&gt;`
</code></pre>
<p>Do this for all PRs that should be backported.</p>
<h2 id="open-pr-in-the-rust-repository"><a class="header" href="#open-pr-in-the-rust-repository">Open PR in the Rust repository</a></h2>
<p>Next, open the PR for the backport. Make sure, the PR is opened towards the
<code>beta</code> branch and not the <code>master</code> branch. The PR description should look like
this:</p>
<pre><code>[beta] Clippy backports

r? @Mark-Simulacrum

Backports:
- &lt;Link to the Clippy PR&gt;
- ...

&lt;Short summary of what is backported and why&gt;
</code></pre>
<p>Mark is from the release team and they ultimately have to merge the PR before
branching a new <code>beta</code> version. Tag them to take care of the backport. Next,
list all the backports and give a short summary what’s backported and why it is
worth backporting this.</p>
<h2 id="relabel-backported-prs"><a class="header" href="#relabel-backported-prs">Relabel backported PRs</a></h2>
<p>When a PR is backported to Rust <code>beta</code>, label the PR with <code>beta-accepted</code>. This
will then get picked up when <a href="#4-include-beta-accepted-prs">writing the changelog</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog-update"><a class="header" href="#changelog-update">Changelog Update</a></h1>
<p>If you want to help with updating the <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md">changelog</a>, you’re in the right place.</p>
<h2 id="when-to-update"><a class="header" href="#when-to-update">When to update</a></h2>
<p>Typos and other small fixes/additions are <em>always</em> welcome.</p>
<p>Special care needs to be taken when it comes to updating the changelog for a new
Rust release. For that purpose, the changelog is ideally updated during the week
before an upcoming stable release. You can find the release dates on the <a href="https://forge.rust-lang.org/">Rust
Forge</a>.</p>
<p>Most of the time we only need to update the changelog for minor Rust releases.
It’s been very rare that Clippy changes were included in a patch release.</p>
<h2 id="changelog-update-walkthrough"><a class="header" href="#changelog-update-walkthrough">Changelog update walkthrough</a></h2>
<h3 id="1-finding-the-relevant-clippy-commits"><a class="header" href="#1-finding-the-relevant-clippy-commits">1. Finding the relevant Clippy commits</a></h3>
<p>Each Rust release ships with its own version of Clippy. The Clippy subtree can
be found in the <code>tools</code> directory of the Rust repository.</p>
<p>Depending on the current time and what exactly you want to update, the following
bullet points might be helpful:</p>
<ul>
<li>When writing the release notes for the <strong>upcoming stable release</strong> you need to
check out the Clippy commit of the current Rust <code>beta</code> branch.
<a href="https://github.com/rust-lang/rust/tree/beta/src/tools/clippy">Link</a></li>
<li>When writing the release notes for the <strong>upcoming beta release</strong>, you need to
check out the Clippy commit of the current Rust <code>master</code>.
<a href="https://github.com/rust-lang/rust/tree/HEAD/src/tools/clippy">Link</a></li>
<li>When writing the (forgotten) release notes for a <strong>past stable release</strong>, you
need to check out the Rust release tag of the stable release.
<a href="https://github.com/rust-lang/rust/releases">Link</a></li>
</ul>
<p>Usually you want to write the changelog of the <strong>upcoming stable release</strong>. Make
sure though, that <code>beta</code> was already branched in the Rust repository.</p>
<p>To find the commit hash, issue the following command when in a <code>rust-lang/rust</code>
checkout (most of the time on the <code>upstream/beta</code> branch):</p>
<pre><code>git log --oneline -- src/tools/clippy/ | grep -o "Merge commit '[a-f0-9]*' into .*" | head -1 | sed -e "s/Merge commit '\([a-f0-9]*\)' into .*/\1/g"
</code></pre>
<h3 id="2-fetching-the-prs-between-those-commits"><a class="header" href="#2-fetching-the-prs-between-those-commits">2. Fetching the PRs between those commits</a></h3>
<p>Once you’ve got the correct commit range, run</p>
<pre><code>util/fetch_prs_between.sh start_commit end_commit &gt; changes.txt
</code></pre>
<p>where <code>end_commit</code> is the commit hash from the previous command and <code>start_commit</code>
is <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#unreleased--beta--in-rust-nightly">the commit hash</a> from the current CHANGELOG file.
Open <code>changes.txt</code> file in your editor of choice.</p>
<h3 id="3-authoring-the-final-changelog"><a class="header" href="#3-authoring-the-final-changelog">3. Authoring the final changelog</a></h3>
<p>The above script should have dumped all the relevant PRs to the file you
specified. It should have filtered out most of the irrelevant PRs already, but
it’s a good idea to do a manual cleanup pass and choose valuable PRs.
If you’re not sure about some PRs, just leave them in for the review and
ask for feedback.</p>
<p>With the PRs filtered, you can start to take each PR and move the <code>changelog: </code>
content to <code>CHANGELOG.md</code>. Adapt the wording as you see fit but try to keep it
somewhat coherent.</p>
<p>The sections order should roughly be:</p>
<pre><code>### New Lints
* Added [`LINT`] to `GROUP`

### Moves and Deprecations
* Moved [`LINT`] to `GROUP` (From `GROUP`, now LEVEL-by-default)
* Renamed `LINT` to [`LINT`]

### Enhancements
### False Positive Fixes
### ICE Fixes
### Documentation Improvements
### Others
</code></pre>
<p>Please also be sure to update <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#unreleased--beta--in-rust-nightly">the <code>Unreleased/Beta/In Rust Nightly</code> section</a> at the top with the
relevant commits ranges and to add the <code>Rust &lt;version&gt;</code> section with release date and PR ranges.</p>
<h3 id="4-include-beta-accepted-prs"><a class="header" href="#4-include-beta-accepted-prs">4. Include <code>beta-accepted</code> PRs</a></h3>
<p>Look for the <a href="https://github.com/rust-lang/rust-clippy/issues?q=label%3Abeta-accepted+"><code>beta-accepted</code></a> label and make sure to also include the PRs with
that label in the changelog. If you can, remove the <code>beta-accepted</code> labels
<strong>after</strong> the changelog PR was merged.</p>
<blockquote>
<p><em>Note:</em> Some of those PRs might even get backported to the previous <code>beta</code>.
Those have to be included in the changelog of the <em>previous</em> release.</p>
</blockquote>
<h3 id="5-update-clippyversion-attributes"><a class="header" href="#5-update-clippyversion-attributes">5. Update <code>clippy::version</code> attributes</a></h3>
<p>Next, make sure to check that the <code>#[clippy::version]</code> attributes for the added
lints contain the correct version.
In order to find lints that need a version update, go through the lints in the
“New Lints” section and run the following command for each lint name:</p>
<pre><code>grep -rB1 "pub $LINT_NAME" .
</code></pre>
<p>The version shown should match the version of the release the changelog is
written for. If not, update the version to the changelog version.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="release-a-new-clippy-version"><a class="header" href="#release-a-new-clippy-version">Release a new Clippy Version</a></h1>
<blockquote>
<p><em>NOTE:</em> This document is probably only relevant to you, if you’re a member of
the Clippy team.</p>
</blockquote>
<p>Clippy is released together with stable Rust releases. The dates for these
releases can be found at the <a href="https://forge.rust-lang.org/">Rust Forge</a>. This document explains the necessary
steps to create a Clippy release.</p>
<ol>
<li><a href="#defining-remotes">Defining Remotes</a></li>
<li><a href="#bump-version">Bump Version</a></li>
<li><a href="#find-the-clippy-commit">Find the Clippy commit</a></li>
<li><a href="#update-the-beta-branch">Update the <code>beta</code> branch</a></li>
<li><a href="#update-the-stable-branch">Update the <code>stable</code> branch</a></li>
<li><a href="#tag-the-stable-commit">Tag the stable commit</a></li>
<li><a href="#update-changelogmd">Update <code>CHANGELOG.md</code></a></li>
</ol>
<h2 id="defining-remotes"><a class="header" href="#defining-remotes">Defining Remotes</a></h2>
<p>You may want to define the <code>upstream</code> remote of the Clippy project to simplify
the following steps. However, this is optional and you can replace <code>upstream</code>
with the full URL instead.</p>
<pre><code class="language-bash">git remote add upstream git@github.com:rust-lang/rust-clippy
</code></pre>
<h2 id="bump-version"><a class="header" href="#bump-version">Bump Version</a></h2>
<p>When a release needs to be done, <code>cargo test</code> will fail, if the versions in the
<code>Cargo.toml</code> are not correct. During that sync, the versions need to be bumped.
This is done by running:</p>
<pre><code class="language-bash">cargo dev release bump_version
</code></pre>
<p>This will increase the version number of each relevant <code>Cargo.toml</code> file. After
that, just commit the updated files with:</p>
<pre><code class="language-bash">git commit -m "Bump Clippy version -&gt; 0.1.XY" **/*Cargo.toml
</code></pre>
<p><code>XY</code> should be exchanged with the corresponding version</p>
<h2 id="find-the-clippy-commit"><a class="header" href="#find-the-clippy-commit">Find the Clippy commit</a></h2>
<p>For both updating the <code>beta</code> and the <code>stable</code> branch, the first step is to find
the Clippy commit of the last Clippy sync done in the respective Rust branch.</p>
<p>Running the following commands <em>in the Rust repo</em> will get the commit for the
specified <code>&lt;branch&gt;</code>:</p>
<pre><code class="language-bash">git switch &lt;branch&gt;
SHA=$(git log --oneline -- src/tools/clippy/ | grep -o "Merge commit '[a-f0-9]*' into .*" | head -1 | sed -e "s/Merge commit '\([a-f0-9]*\)' into .*/\1/g")
</code></pre>
<p>Where <code>&lt;branch&gt;</code> is one of <code>stable</code>, <code>beta</code>, or <code>master</code>.</p>
<h2 id="update-the-beta-branch"><a class="header" href="#update-the-beta-branch">Update the <code>beta</code> branch</a></h2>
<p>After getting the commit of the <code>beta</code> branch, the <code>beta</code> branch in the Clippy
repository can be updated.</p>
<pre><code class="language-bash">git checkout beta
git reset --hard $SHA
git push upstream beta
</code></pre>
<h2 id="update-the-stable-branch"><a class="header" href="#update-the-stable-branch">Update the <code>stable</code> branch</a></h2>
<p>After getting the commit of the <code>stable</code> branch, the <code>stable</code> branch in the
Clippy repository can be updated.</p>
<pre><code class="language-bash">git checkout stable
git reset --hard $SHA
git push upstream stable
</code></pre>
<h2 id="tag-the-stable-commit"><a class="header" href="#tag-the-stable-commit">Tag the <code>stable</code> commit</a></h2>
<p>After updating the <code>stable</code> branch, tag the HEAD commit and push it to the
Clippy repo.</p>
<pre><code class="language-bash">git tag rust-1.XX.0               # XX should be exchanged with the corresponding version
git push upstream rust-1.XX.0     # `upstream` is the `rust-lang/rust-clippy` remote
</code></pre>
<p>After this, the release should be available on the Clippy <a href="https://github.com/rust-lang/rust-clippy/tags">tags page</a>.</p>
<h2 id="publish-clippy_utils"><a class="header" href="#publish-clippy_utils">Publish <code>clippy_utils</code></a></h2>
<p>The <code>clippy_utils</code> crate is published to <code>crates.io</code> without any stability
guarantees. To do this, after the <a href="#syncing-changes-between-clippy-and-rust-langrust">sync</a> and the release is done, switch back to
the <code>upstream/master</code> branch and publish <code>clippy_utils</code>:</p>
<blockquote>
<p>Note: The Rustup PR bumping the nightly and Clippy version <strong>must</strong> be merged
before doing this.</p>
</blockquote>
<pre><code class="language-bash">git switch master &amp;&amp; git pull upstream master
cargo publish --manifest-path clippy_utils/Cargo.toml
</code></pre>
<h2 id="update-changelogmd"><a class="header" href="#update-changelogmd">Update <code>CHANGELOG.md</code></a></h2>
<p>For this see the document on <a href="#changelog-update">how to update the changelog</a>.</p>
<p>If you don’t have time to do a complete changelog update right away, just update
the following parts:</p>
<ul>
<li>
<p>Remove the <code>(beta)</code> from the new stable version:</p>
<pre><code class="language-markdown">## Rust 1.XX (beta) -&gt; ## Rust 1.XX
</code></pre>
</li>
<li>
<p>Update the release date line of the new stable version:</p>
<pre><code class="language-markdown">Current beta, release 20YY-MM-DD -&gt; Current stable, released 20YY-MM-DD
</code></pre>
</li>
<li>
<p>Update the release date line of the previous stable version:</p>
<pre><code class="language-markdown">Current stable, released 20YY-MM-DD -&gt; Released 20YY-MM-DD
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-clippy-book"><a class="header" href="#the-clippy-book">The Clippy Book</a></h1>
<p>This document explains how to make additions and changes to the Clippy book, the
guide to Clippy that you’re reading right now. The Clippy book is formatted with
<a href="https://www.markdownguide.org">Markdown</a> and generated by
<a href="https://github.com/rust-lang/mdBook">mdBook</a>.</p>
<ul>
<li><a href="#get-mdbook">Get mdBook</a></li>
<li><a href="#make-changes">Make changes</a></li>
</ul>
<h2 id="get-mdbook"><a class="header" href="#get-mdbook">Get mdBook</a></h2>
<p>While not strictly necessary since the book source is simply Markdown text
files, having mdBook locally will allow you to build, test and serve the book
locally to view changes before you commit them to the repository. You likely
already have <code>cargo</code> installed, so the easiest option is to:</p>
<pre><code class="language-shell">cargo install mdbook
</code></pre>
<p>See the mdBook <a href="https://github.com/rust-lang/mdBook#installation">installation</a>
instructions for other options.</p>
<h2 id="make-changes"><a class="header" href="#make-changes">Make changes</a></h2>
<p>The book’s
<a href="https://github.com/rust-lang/rust-clippy/tree/master/book/src">src</a>
directory contains all the markdown files used to generate the book. If you
want to see your changes in real time, you can use the mdBook <code>serve</code> command to
run a web server locally that will automatically update changes as they are
made. From the top level of your <code>rust-clippy</code> directory:</p>
<pre><code class="language-shell">mdbook serve book --open
</code></pre>
<p>Then navigate to <code>http://localhost:3000</code> to see the generated book. While the
server is running, changes you make will automatically be updated.</p>
<p>For more information, see the mdBook
<a href="https://rust-lang.github.io/mdBook/">guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="benchmarking-clippy"><a class="header" href="#benchmarking-clippy">Benchmarking Clippy</a></h1>
<p>Benchmarking Clippy is similar to using our Lintcheck tool, in fact, it even
uses the same tool! Just by adding a <code>--perf</code> flag it will transform Lintcheck
into a very simple but powerful benchmarking tool!</p>
<p>It requires having the <a href="https://perfwiki.github.io/main/"><code>perf</code> tool</a> installed, as <code>perf</code> is what’s actually
profiling Clippy under the hood.</p>
<p>The lintcheck <code>--perf</code> tool generates a series of <code>perf.data</code> in the
<code>target/lintcheck/sources/&lt;package&gt;-&lt;version&gt;</code> directories. Each <code>perf.data</code>
corresponds to the package which is contained.</p>
<p>Lintcheck uses the <code>-g</code> flag, meaning that you can get stack traces for richer
analysis, including with tools such as <a href="https://github.com/brendangregg/FlameGraph">flamegraph</a>
(or <a href="https://github.com/flamegraph-rs/flamegraph"><code>flamegraph-rs</code></a>).</p>
<p>Currently, we only measure instruction count, as it’s the most reproducible metric
and <a href="https://github.com/rust-lang/rustc-perf">rustc-perf</a> also considers it the main number to focus on.</p>
<h2 id="benchmarking-a-pr"><a class="header" href="#benchmarking-a-pr">Benchmarking a PR</a></h2>
<p>Having a benchmarking tool directly implemented into lintcheck gives us the
ability to benchmark any given PR just by making a before and after</p>
<p>Here’s the way you can get into any PR, benchmark it, and then benchmark
<code>master</code>.</p>
<p>The first <code>perf.data</code> will not have any numbers appended, but any subsequent
benchmark will be written to <code>perf.data.number</code> with a number growing for 0.
All benchmarks are compressed so that you can</p>
<pre><code class="language-bash">git fetch upstream pull/&lt;PR_NUMBER&gt;/head:&lt;BRANCH_NAME&gt;
git switch BRANCHNAME

# Bench
cargo lintcheck --perf

# Get last common commit, checkout that
LAST_COMMIT=$(git log BRANCHNAME..master --oneline | tail -1 | cut -c 1-11)
git switch -c temporary $LAST_COMMIT

# We're now on master

# Bench
cargo lintcheck --perf
perf diff ./target/lintcheck/sources/CRATE/perf.data ./target/lintcheck/sources/CRATE/perf.data.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="proposals"><a class="header" href="#proposals">Proposals</a></h1>
<p>This chapter is about accepted proposals for changes that should be worked on in
or around Clippy in the long run.</p>
<p>Besides adding more and more lints and improve the lints that Clippy already
has, Clippy is also interested in making the experience of its users, developers
and maintainers better over time. Projects that address bigger picture things
like this usually take more time, and it is useful to have a proposal for those
first. This is the place where such proposals are collected, so that we can
refer to them when working on them.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="roadmap-2021"><a class="header" href="#roadmap-2021">Roadmap 2021</a></h1>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This Roadmap lays out the plans for Clippy in 2021:</p>
<ul>
<li>Improving usability and reliability</li>
<li>Improving experience of contributors and maintainers</li>
<li>Develop and specify processes</li>
</ul>
<p>Members of the Clippy team will be assigned tasks from one or more of these
topics. The team member is then responsible to complete the assigned tasks. This
can either be done by implementing them or by providing mentorship to interested
contributors.</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>With the ongoing growth of the Rust language and with that of the whole
ecosystem, also Clippy gets more and more users and contributors. This is good
for the project, but also brings challenges along. Some of these challenges are:</p>
<ul>
<li>More issues about reliability or usability are popping up</li>
<li>Traffic is hard to handle for a small team</li>
<li>Bigger projects don’t get completed due to the lack of processes and/or time
of the team members</li>
</ul>
<p>Additionally, according to the <a href="https://github.com/rust-lang/rfcs/pull/3037">Rust Roadmap 2021</a>, clear processes should be
defined by every team and unified across teams. This Roadmap is the first step
towards this.</p>
<h1 id="explanation"><a class="header" href="#explanation">Explanation</a></h1>
<p>This section will explain the things that should be done in 2021. It is
important to note, that this document focuses on the “What?”, not the “How?”.
The later will be addressed in follow-up tracking issue, with an assigned team
member.</p>
<p>The following is split up in two major sections. The first section covers the
user facing plans, the second section the internal plans.</p>
<h2 id="user-facing"><a class="header" href="#user-facing">User Facing</a></h2>
<p>Clippy should be as pleasant to use and configure as possible. This section
covers plans that should be implemented to improve the situation of Clippy in
this regard.</p>
<h3 id="usability"><a class="header" href="#usability">Usability</a></h3>
<p>In the following, plans to improve the usability are covered.</p>
<h4 id="no-output-after-cargo-check"><a class="header" href="#no-output-after-cargo-check">No Output After <code>cargo check</code></a></h4>
<p>Currently, when <code>cargo clippy</code> is run after <code>cargo check</code>, it does not produce
any output. This is especially problematic since <code>rust-analyzer</code> is on the rise,
and it uses <code>cargo check</code> for checking code. A fix is already implemented, but
it still has to be pushed over the finish line. This also includes the
stabilization of the <code>cargo clippy --fix</code> command or the support of multi-span
suggestions in <code>rustfix</code>.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/4612">#4612</a></li>
</ul>
<h4 id="lintstoml-configuration"><a class="header" href="#lintstoml-configuration"><code>lints.toml</code> Configuration</a></h4>
<p>This is something that comes up every now and then: a reusable configuration
file, where lint levels can be defined. Discussions about this often lead to
nothing specific or to “we need an RFC for this”. And this is exactly what needs
to be done. Get together with the cargo team and write an RFC and implement such
a configuration file somehow and somewhere.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/3164">#3164</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/5034">cargo#5034</a></li>
<li><a href="https://internals.rust-lang.org/t/proposal-cargo-lint-configuration/9135/8">IRLO</a></li>
</ul>
<h4 id="lint-groups"><a class="header" href="#lint-groups">Lint Groups</a></h4>
<p>There are more and more issues about managing lints in Clippy popping up. Lints
are hard to implement with a guarantee of no/few false positives (FPs). One way
to address this might be to introduce more lint groups to give users the ability
to better manage lints, or improve the process of classifying lints, so that
disabling lints due to FPs becomes rare. It is important to note, that Clippy
lints are less conservative than <code>rustc</code> lints, which won’t change in the
future.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/5537">#5537</a></li>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6366">#6366</a></li>
</ul>
<h3 id="reliability"><a class="header" href="#reliability">Reliability</a></h3>
<p>In the following, plans to improve the reliability are covered.</p>
<h4 id="false-positive-rate"><a class="header" href="#false-positive-rate">False Positive Rate</a></h4>
<p>In the worst case, new lints are only available in nightly for 2 weeks, before
hitting beta and ultimately stable. This and the fact that fewer people use
nightly Rust nowadays makes it more probable that a lint with many FPs hits
stable. This leads to annoyed users, that will disable these new lints in the
best case and to more annoyed users, that will stop using Clippy in the worst.
A process should be developed and implemented to prevent this from happening.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6429">#6429</a></li>
</ul>
<h2 id="internal"><a class="header" href="#internal">Internal</a></h2>
<p>(The end of) 2020 has shown, that Clippy has to think about the available
resources, especially regarding management and maintenance of the project. This
section address issues affecting team members and contributors.</p>
<h3 id="management"><a class="header" href="#management">Management</a></h3>
<p>In 2020 Clippy achieved over 1000 open issues with regularly between 25-35 open
PRs. This is simultaneously a win and a loss. More issues and PRs means more
people are interested in Clippy and in contributing to it. On the other hand, it
means for team members more work and for contributors longer wait times for
reviews. The following will describe plans how to improve the situation for both
team members and contributors.</p>
<h4 id="clear-expectations-for-team-members"><a class="header" href="#clear-expectations-for-team-members">Clear Expectations for Team Members</a></h4>
<p>According to the <a href="https://github.com/rust-lang/rfcs/pull/3037">Rust Roadmap 2021</a>, a document specifying what it means to be
a member of the team should be produced. This should not put more pressure on
the team members, but rather help them and interested folks to know what the
expectations are. With this it should also be easier to recruit new team members
and may encourage people to get in touch, if they’re interested to join.</p>
<h4 id="scaling-up-the-team"><a class="header" href="#scaling-up-the-team">Scaling up the Team</a></h4>
<p>More people means less work for each individual. Together with the document
about expectations for team members, a document defining the process of how to
join the team should be produced. This can also increase the stability of the
team, in case of current members dropping out (temporarily). There can also be
different roles in the team, like people triaging vs. people reviewing.</p>
<h4 id="regular-meetings"><a class="header" href="#regular-meetings">Regular Meetings</a></h4>
<p>Other teams have regular meetings. Clippy is big enough that it might be worth
to also do them. Especially if more people join the team, this can be important
for sync-ups. Besides the asynchronous communication, that works well for
working on separate lints, a meeting adds a synchronous alternative at a known
time. This is especially helpful if there are bigger things that need to be
discussed (like the projects in this roadmap). For starters bi-weekly meetings
before Rust syncs might make sense.</p>
<h4 id="triaging"><a class="header" href="#triaging">Triaging</a></h4>
<p>To get a handle on the influx of open issues, a process for triaging issues and
PRs should be developed. Officially, Clippy follows the Rust triage process, but
currently no one enforces it. This can be improved by sharing triage teams
across projects or by implementing dashboards / tools which simplify triaging.</p>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<p>Improving the developer and contributor experience is something the Clippy team
works on regularly. Though, some things might need special attention and
planing. These topics are listed in the following.</p>
<h4 id="process-for-new-and-existing-lints"><a class="header" href="#process-for-new-and-existing-lints">Process for New and Existing Lints</a></h4>
<p>As already mentioned above, classifying new lints gets quite hard, because the
probability of a buggy lint getting into stable is quite high. A process should
be implemented on how to classify lints. In addition, a test system should be
developed to find out which lints are currently problematic in real world code
to fix or disable them.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741056379">#6429 (comment)</a></li>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741153345">#6429 (comment)</a></li>
</ul>
<h4 id="processes"><a class="header" href="#processes">Processes</a></h4>
<p>Related to the point before, a process for suggesting and discussing major
changes should be implemented. It’s also not clearly defined when a lint should
be enabled or disabled by default. This can also be improved by the test system
mentioned above.</p>
<h4 id="dev-tools"><a class="header" href="#dev-tools">Dev-Tools</a></h4>
<p>There’s already <code>cargo dev</code> which makes Clippy development easier and more
pleasant. This can still be expanded, so that it covers more areas of the
development process.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/5394">#5394</a></li>
</ul>
<h4 id="contributor-guide"><a class="header" href="#contributor-guide">Contributor Guide</a></h4>
<p>Similar to a Clippy Book, which describes how to use Clippy, a book about how to
contribute to Clippy might be helpful for new and existing contributors. There’s
already the <code>doc</code> directory in the Clippy repo, this can be turned into a
<code>mdbook</code>.</p>
<h4 id="rustc-integration"><a class="header" href="#rustc-integration"><code>rustc</code> integration</a></h4>
<p>Recently Clippy was integrated with <code>git subtree</code> into the <code>rust-lang/rust</code>
repository. This made syncing between the two repositories easier. A
<code>#[non_exhaustive]</code> list of things that still can be improved is:</p>
<ol>
<li>Use the same <code>rustfmt</code> version and configuration as <code>rustc</code>.</li>
<li>Make <code>cargo dev</code> work in the Rust repo, just as it works in the Clippy repo.
E.g. <code>cargo dev bless</code> or <code>cargo dev update_lints</code>. And even add more things
to it that might be useful for the Rust repo, e.g. <code>cargo dev deprecate</code>.</li>
<li>Easier sync process. The <code>subtree</code> situation is not ideal.</li>
</ol>
<h2 id="prioritization"><a class="header" href="#prioritization">Prioritization</a></h2>
<p>The most pressing issues for users of Clippy are of course the user facing
issues. So there should be a priority on those issues, but without losing track
of the internal issues listed in this document.</p>
<p>Getting the FP rate of warn/deny-by-default lints under control should have the
highest priority. Other user facing issues should also get a high priority, but
shouldn’t be in the way of addressing internal issues.</p>
<p>To better manage the upcoming projects, the basic internal processes, like
meetings, tracking issues and documentation, should be established as soon as
possible. They might even be necessary to properly manage the projects,
regarding the user facing issues.</p>
<h1 id="prior-art"><a class="header" href="#prior-art">Prior Art</a></h1>
<h2 id="rust-roadmap"><a class="header" href="#rust-roadmap">Rust Roadmap</a></h2>
<p>Rust’s roadmap process was established by <a href="https://rust-lang.github.io/rfcs/1728-north-star.html">RFC 1728</a> in 2016. Since then every
year a roadmap was published, that defined the bigger plans for the coming
years. This year roadmap can be found <a href="https://github.com/rust-lang/rfcs/pull/3037">here</a>.</p>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<h2 id="big-roadmap"><a class="header" href="#big-roadmap">Big Roadmap</a></h2>
<p>This roadmap is pretty big and not all items listed in this document might be
addressed during 2021. Because this is the first roadmap for Clippy, having open
tasks at the end of 2021 is fine, but they should be revisited in the 2022
roadmap.</p>
<div style="break-before: page; page-break-before: always;"></div>
<ul>
<li>Feature Name: syntax-tree-patterns</li>
<li>Start Date: 2019-03-12</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rust-clippy/pull/3875">#3875</a></li>
</ul>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>Introduce a domain-specific language (similar to regular expressions) that
allows to describe lints using <em>syntax tree patterns</em>.</p>
<h1 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h1>
<p>Finding parts of a syntax tree (AST, HIR, …) that have certain properties
(e.g. “<em>an if that has a block as its condition</em>”) is a major task when writing
lints. For non-trivial lints, it often requires nested pattern matching of AST /
HIR nodes. For example, testing that an expression is a boolean literal requires
the following checks:</p>
<pre><code class="language-rust ignore">if let ast::ExprKind::Lit(lit) = &amp;expr.node {
    if let ast::LitKind::Bool(_) = &amp;lit.node {
        ...
    }
}</code></pre>
<p>Writing this kind of matching code quickly becomes a complex task and the
resulting code is often hard to comprehend. The code below shows a simplified
version of the pattern matching required by the <code>collapsible_if</code> lint:</p>
<pre><code class="language-rust ignore">// simplified version of the collapsible_if lint
if let ast::ExprKind::If(check, then, None) = &amp;expr.node {
    if then.stmts.len() == 1 {
        if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &amp;then.stmts[0].node {
            if let ast::ExprKind::If(check_inner, content, None) = &amp;inner.node {
                ...
            }
        }
    }
}</code></pre>
<p>The <code>if_chain</code> macro can improve readability by flattening the nested if
statements, but the resulting code is still quite hard to read:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// simplified version of the collapsible_if lint
if_chain! {
    if let ast::ExprKind::If(check, then, None) = &amp;expr.node;
    if then.stmts.len() == 1;
    if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &amp;then.stmts[0].node;
    if let ast::ExprKind::If(check_inner, content, None) = &amp;inner.node;
    then {
        ...
    }
}
<span class="boring">}</span></code></pre>
<p>The code above matches if expressions that contain only another if expression
(where both ifs don’t have an else branch). While it’s easy to explain what the
lint does, it’s hard to see that from looking at the code samples above.</p>
<p>Following the motivation above, the first goal this RFC is to <strong>simplify writing
and reading lints</strong>.</p>
<p>The second part of the motivation is clippy’s dependence on unstable
compiler-internal data structures. Clippy lints are currently written against
the compiler’s AST / HIR which means that even small changes in these data
structures might break a lot of lints. The second goal of this RFC is to <strong>make
lints independent of the compiler’s AST / HIR data structures</strong>.</p>
<h1 id="approach"><a class="header" href="#approach">Approach</a></h1>
<p>A lot of complexity in writing lints currently seems to come from having to
manually implement the matching logic (see code samples above). It’s an
imperative style that describes <em>how</em> to match a syntax tree node instead of
specifying <em>what</em> should be matched against declaratively. In other areas, it’s
common to use declarative patterns to describe desired information and let the
implementation do the actual matching. A well-known example of this approach are
<a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>. Instead
of writing code that detects certain character sequences, one can describe a
search pattern using a domain-specific language and search for matches using
that pattern. The advantage of using a declarative domain-specific language is
that its limited domain (e.g. matching character sequences in the case of
regular expressions) allows to express entities in that domain in a very natural
and expressive way.</p>
<p>While regular expressions are very useful when searching for patterns in flat
character sequences, they cannot easily be applied to hierarchical data
structures like syntax trees. This RFC therefore proposes a pattern matching
system that is inspired by regular expressions and designed for hierarchical
syntax trees.</p>
<h1 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h1>
<p>This proposal adds a <code>pattern!</code> macro that can be used to specify a syntax tree
pattern to search for. A simple pattern is shown below:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    my_pattern: Expr =
        Lit(Bool(false))
}
<span class="boring">}</span></code></pre>
<p>This macro call defines a pattern named <code>my_pattern</code> that can be matched against
an <code>Expr</code> syntax tree node. The actual pattern (<code>Lit(Bool(false))</code> in this case)
defines which syntax trees should match the pattern. This pattern matches
expressions that are boolean literals with value <code>false</code>.</p>
<p>The pattern can then be used to implement lints in the following way:</p>
<pre><code class="language-rust ignore">...

impl EarlyLintPass for MyAwesomeLint {
    fn check_expr(&amp;mut self, cx: &amp;EarlyContext, expr: &amp;syntax::ast::Expr) {

        if my_pattern(expr).is_some() {
            cx.span_lint(
                MY_AWESOME_LINT,
                expr.span,
                "This is a match for a simple pattern. Well done!",
            );
        }

    }
}</code></pre>
<p>The <code>pattern!</code> macro call expands to a function <code>my_pattern</code> that expects a
syntax tree expression as its argument and returns an <code>Option</code> that indicates
whether the pattern matched.</p>
<blockquote>
<p>Note: The result type is explained in more detail in <a href="#the-result-type">a later
section</a>. For now, it’s enough to know that the result is
<code>Some</code> if the pattern matched and <code>None</code> otherwise.</p>
</blockquote>
<h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern syntax</a></h2>
<p>The following examples demonstrate the pattern syntax:</p>
<h4 id="any-_"><a class="header" href="#any-_">Any (<code>_</code>)</a></h4>
<p>The simplest pattern is the any pattern. It matches anything and is therefore
similar to regex’s <code>*</code>.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches any expression
    my_pattern: Expr =
        _
}
<span class="boring">}</span></code></pre>
<h4 id="node-node-nameargs"><a class="header" href="#node-node-nameargs">Node (<code>&lt;node-name&gt;(&lt;args&gt;)</code>)</a></h4>
<p>Nodes are used to match a specific variant of an AST node. A node has a name and
a number of arguments that depends on the node type. For example, the <code>Lit</code> node
has a single argument that describes the type of the literal. As another
example, the <code>If</code> node has three arguments describing the if’s condition, then
block and else block.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches any expression that is a literal
    my_pattern: Expr =
        Lit(_)
}

pattern!{
    // matches any expression that is a boolean literal
    my_pattern: Expr =
        Lit(Bool(_))
}

pattern!{
    // matches if expressions that have a boolean literal in their condition
    // Note: The `_?` syntax here means that the else branch is optional and can be anything.
    //       This is discussed in more detail in the section `Repetition`.
    my_pattern: Expr =
        If( Lit(Bool(_)) , _, _?)
}
<span class="boring">}</span></code></pre>
<h4 id="literal-lit"><a class="header" href="#literal-lit">Literal (<code>&lt;lit&gt;</code>)</a></h4>
<p>A pattern can also contain Rust literals. These literals match themselves.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches the boolean literal false
    my_pattern: Expr =
        Lit(Bool(false))
}

pattern!{
    // matches the character literal 'x'
    my_pattern: Expr =
        Lit(Char('x'))
}
<span class="boring">}</span></code></pre>
<h4 id="alternations-a--b"><a class="header" href="#alternations-a--b">Alternations (<code>a | b</code>)</a></h4>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches if the literal is a boolean or integer literal
    my_pattern: Lit =
        Bool(_) | Int(_)
}

pattern!{
    // matches if the expression is a char literal with value 'x' or 'y'
    my_pattern: Expr =
        Lit( Char('x' | 'y') )
}
<span class="boring">}</span></code></pre>
<h4 id="empty-"><a class="header" href="#empty-">Empty (<code>()</code>)</a></h4>
<p>The empty pattern represents an empty sequence or the <code>None</code> variant of an
optional.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches if the expression is an empty array
    my_pattern: Expr =
        Array( () )
}

pattern!{
    // matches if expressions that don't have an else clause
    my_pattern: Expr =
        If(_, _, ())
}
<span class="boring">}</span></code></pre>
<h4 id="sequence-a-b"><a class="header" href="#sequence-a-b">Sequence (<code>&lt;a&gt; &lt;b&gt;</code>)</a></h4>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches the array [true, false]
    my_pattern: Expr =
        Array( Lit(Bool(true)) Lit(Bool(false)) )
}
<span class="boring">}</span></code></pre>
<h4 id="repetition-a-a-a-an-anm-an"><a class="header" href="#repetition-a-a-a-an-anm-an">Repetition (<code>&lt;a&gt;*</code>, <code>&lt;a&gt;+</code>, <code>&lt;a&gt;?</code>, <code>&lt;a&gt;{n}</code>, <code>&lt;a&gt;{n,m}</code>, <code>&lt;a&gt;{n,}</code>)</a></h4>
<p>Elements may be repeated. The syntax for specifying repetitions is identical to
<a href="https://docs.rs/regex/1.1.2/regex/#repetitions">regex’s syntax</a>.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches arrays that contain 2 'x's as their last or second-last elements
    // Examples:
    //     ['x', 'x']                         match
    //     ['x', 'x', 'y']                    match
    //     ['a', 'b', 'c', 'x', 'x', 'y']     match
    //     ['x', 'x', 'y', 'z']               no match
    my_pattern: Expr =
        Array( _* Lit(Char('x')){2} _? )
}

pattern!{
    // matches if expressions that **may or may not** have an else block
    // Attn: `If(_, _, _)` matches only ifs that **have** an else block
    //
    //              | if with else block | if without else block
    // If(_, _, _)  |       match        |       no match
    // If(_, _, _?) |       match        |        match
    // If(_, _, ()) |      no match      |        match
    my_pattern: Expr =
        If(_, _, _?)
}
<span class="boring">}</span></code></pre>
<h4 id="named-submatch-aname"><a class="header" href="#named-submatch-aname">Named submatch (<code>&lt;a&gt;#&lt;name&gt;</code>)</a></h4>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches character literals and gives the literal the name foo
    my_pattern: Expr =
        Lit(Char(_)#foo)
}

pattern!{
    // matches character literals and gives the char the name bar
    my_pattern: Expr =
        Lit(Char(_#bar))
}

pattern!{
    // matches character literals and gives the expression the name baz
    my_pattern: Expr =
        Lit(Char(_))#baz
}
<span class="boring">}</span></code></pre>
<p>The reason for using named submatches is described in the section <a href="#the-result-type">The result
type</a>.</p>
<h3 id="summary-1-1"><a class="header" href="#summary-1-1">Summary</a></h3>
<p>The following table gives an summary of the pattern syntax:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Syntax</th><th>Concept</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><code>_</code></td><td>Any</td><td><code>_</code></td></tr>
<tr><td><code>&lt;node-name&gt;(&lt;args&gt;)</code></td><td>Node</td><td><code>Lit(Bool(true))</code>, <code>If(_, _, _)</code></td></tr>
<tr><td><code>&lt;lit&gt;</code></td><td>Literal</td><td><code>'x'</code>, <code>false</code>, <code>101</code></td></tr>
<tr><td><code>&lt;a&gt; | &lt;b&gt;</code></td><td>Alternation</td><td><code>Char(_) | Bool(_)</code></td></tr>
<tr><td><code>()</code></td><td>Empty</td><td><code>Array( () )</code></td></tr>
<tr><td><code>&lt;a&gt; &lt;b&gt;</code></td><td>Sequence</td><td><code>Tuple( Lit(Bool(_)) Lit(Int(_)) Lit(_) )</code></td></tr>
<tr><td><code>&lt;a&gt;*</code> <br> <code>&lt;a&gt;+</code> <br> <code>&lt;a&gt;?</code> <br> <code>&lt;a&gt;{n}</code> <br> <code>&lt;a&gt;{n,m}</code> <br> <code>&lt;a&gt;{n,}</code></td><td>Repetition <br> <br> <br> <br> <br><br></td><td><code>Array( _* )</code>, <br> <code>Block( Semi(_)+ )</code>, <br> <code>If(_, _, Block(_)?)</code>, <br> <code>Array( Lit(_){10} )</code>, <br> <code>Lit(_){5,10}</code>, <br> <code>Lit(Bool(_)){10,}</code></td></tr>
<tr><td><code>&lt;a&gt;#&lt;name&gt;</code></td><td>Named submatch</td><td><code>Lit(Int(_))#foo</code> <code>Lit(Int(_#bar))</code></td></tr>
</tbody>
</table>
</div>
<h2 id="the-result-type"><a class="header" href="#the-result-type">The result type</a></h2>
<p>A lot of lints require checks that go beyond what the pattern syntax described
above can express. For example, a lint might want to check whether a node was
created as part of a macro expansion or whether there’s no comment above a node.
Another example would be a lint that wants to match two nodes that have the same
value (as needed by lints like <code>almost_swapped</code>). Instead of allowing users to
write these checks into the pattern directly (which might make patterns hard to
read), the proposed solution allows users to assign names to parts of a pattern
expression. When matching a pattern against a syntax tree node, the return value
will contain references to all nodes that were matched by these named
subpatterns. This is similar to capture groups in regular expressions.</p>
<p>For example, given the following pattern</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches character literals
    my_pattern: Expr =
        Lit(Char(_#val_inner)#val)#val_outer
}
<span class="boring">}</span></code></pre>
<p>one could get references to the nodes that matched the subpatterns in the
following way:</p>
<pre><code class="language-rust ignore">...
fn check_expr(expr: &amp;syntax::ast::Expr) {
    if let Some(result) = my_pattern(expr) {
        result.val_inner  // type: &amp;char
        result.val        // type: &amp;syntax::ast::Lit
        result.val_outer  // type: &amp;syntax::ast::Expr
    }
}</code></pre>
<p>The types in the <code>result</code> struct depend on the pattern. For example, the
following pattern</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches arrays of character literals
    my_pattern_seq: Expr =
        Array( Lit(_)*#foo )
}
<span class="boring">}</span></code></pre>
<p>matches arrays that consist of any number of literal expressions. Because those
expressions are named <code>foo</code>, the result struct contains a <code>foo</code> attribute which
is a vector of expressions:</p>
<pre><code class="language-rust ignore">...
if let Some(result) = my_pattern_seq(expr) {
    result.foo        // type: Vec&lt;&amp;syntax::ast::Expr&gt;
}</code></pre>
<p>Another result type occurs when a name is only defined in one branch of an
alternation:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    // matches if expression is a boolean or integer literal
    my_pattern_alt: Expr =
        Lit( Bool(_#bar) | Int(_) )
}
<span class="boring">}</span></code></pre>
<p>In the pattern above, the <code>bar</code> name is only defined if the pattern matches a
boolean literal. If it matches an integer literal, the name isn’t set. To
account for this, the result struct’s <code>bar</code> attribute is an option type:</p>
<pre><code class="language-rust ignore">...
if let Some(result) = my_pattern_alt(expr) {
    result.bar        // type: Option&lt;&amp;bool&gt;
}</code></pre>
<p>It’s also possible to use a name in multiple alternation branches if they have
compatible types:</p>
<pre><code class="language-rust ignore">pattern!{
    // matches if expression is a boolean or integer literal
    my_pattern_mult: Expr =
        Lit(_#baz) | Array( Lit(_#baz) )
}
...
if let Some(result) = my_pattern_mult(expr) {
    result.baz        // type: &amp;syntax::ast::Lit
}</code></pre>
<p>Named submatches are a <strong>flat</strong> namespace and this is intended. In the example
above, two different sub-structures are assigned to a flat name. I expect that
for most lints, a flat namespace is sufficient and easier to work with than a
hierarchical one.</p>
<h4 id="two-stages"><a class="header" href="#two-stages">Two stages</a></h4>
<p>Using named subpatterns, users can write lints in two stages. First, a coarse
selection of possible matches is produced by the pattern syntax. In the second
stage, the named subpattern references can be used to do additional tests like
asserting that a node hasn’t been created as part of a macro expansion.</p>
<h2 id="implementing-clippy-lints-using-patterns"><a class="header" href="#implementing-clippy-lints-using-patterns">Implementing Clippy lints using patterns</a></h2>
<p>As a “real-world” example, I re-implemented the <code>collapsible_if</code> lint using
patterns. The code can be found
<a href="https://github.com/fkohlgrueber/rust-clippy-pattern/blob/039b07ecccaf96d6aa7504f5126720d2c9cceddd/clippy_lints/src/collapsible_if.rs#L88-L163">here</a>.
The pattern-based version passes all test cases that were written for
<code>collapsible_if</code>.</p>
<h1 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The following diagram shows the dependencies between the main parts of the
proposed solution:</p>
<pre><code>                          Pattern syntax
                                |
                                |  parsing / lowering
                                v
                           PatternTree
                                ^
                                |
                                |
                          IsMatch trait
                                |
                                |
             +---------------+-----------+---------+
             |               |           |         |
             v               v           v         v
        syntax::ast     rustc::hir      syn       ...
</code></pre>
<p>The pattern syntax described in the previous section is parsed / lowered into
the so-called <em>PatternTree</em> data structure that represents a valid syntax tree
pattern. Matching a <em>PatternTree</em> against an actual syntax tree (e.g. rust ast /
hir or the syn ast, …) is done using the <em>IsMatch</em> trait.</p>
<p>The <em>PatternTree</em> and the <em>IsMatch</em> trait are introduced in more detail in the
following sections.</p>
<h2 id="patterntree"><a class="header" href="#patterntree">PatternTree</a></h2>
<p>The core data structure of this RFC is the <strong>PatternTree</strong>.</p>
<p>It’s a data structure similar to rust’s AST / HIR, but with the following
differences:</p>
<ul>
<li>The PatternTree doesn’t contain parsing information like <code>Span</code>s</li>
<li>The PatternTree can represent alternatives, sequences and optionals</li>
</ul>
<p>The code below shows a simplified version of the current PatternTree:</p>
<blockquote>
<p>Note: The current implementation can be found
<a href="https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/pattern_tree.rs#L50-L96">here</a>.</p>
</blockquote>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    Lit(Alt&lt;Lit&gt;),
    Array(Seq&lt;Expr&gt;),
    Block_(Alt&lt;BlockType&gt;),
    If(Alt&lt;Expr&gt;, Alt&lt;BlockType&gt;, Opt&lt;Expr&gt;),
    IfLet(
        Alt&lt;BlockType&gt;,
        Opt&lt;Expr&gt;,
    ),
}

pub enum Lit {
    Char(Alt&lt;char&gt;),
    Bool(Alt&lt;bool&gt;),
    Int(Alt&lt;u128&gt;),
}

pub enum Stmt {
    Expr(Alt&lt;Expr&gt;),
    Semi(Alt&lt;Expr&gt;),
}

pub enum BlockType {
    Block(Seq&lt;Stmt&gt;),
}
<span class="boring">}</span></code></pre>
<p>The <code>Alt</code>, <code>Seq</code> and <code>Opt</code> structs look like these:</p>
<blockquote>
<p>Note: The current implementation can be found
<a href="https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/matchers.rs#L35-L60">here</a>.</p>
</blockquote>
<pre><code class="language-rust ignore">pub enum Alt&lt;T&gt; {
    Any,
    Elmt(Box&lt;T&gt;),
    Alt(Box&lt;Self&gt;, Box&lt;Self&gt;),
    Named(Box&lt;Self&gt;, ...)
}

pub enum Opt&lt;T&gt; {
    Any,  // anything, but not None
    Elmt(Box&lt;T&gt;),
    None,
    Alt(Box&lt;Self&gt;, Box&lt;Self&gt;),
    Named(Box&lt;Self&gt;, ...)
}

pub enum Seq&lt;T&gt; {
    Any,
    Empty,
    Elmt(Box&lt;T&gt;),
    Repeat(Box&lt;Self&gt;, RepeatRange),
    Seq(Box&lt;Self&gt;, Box&lt;Self&gt;),
    Alt(Box&lt;Self&gt;, Box&lt;Self&gt;),
    Named(Box&lt;Self&gt;, ...)
}

pub struct RepeatRange {
    pub start: usize,
    pub end: Option&lt;usize&gt;  // exclusive
}</code></pre>
<h2 id="parsing--lowering"><a class="header" href="#parsing--lowering">Parsing / Lowering</a></h2>
<p>The input of a <code>pattern!</code> macro call is parsed into a <code>ParseTree</code> first and then
lowered to a <code>PatternTree</code>.</p>
<p>Valid patterns depend on the <em>PatternTree</em> definitions. For example, the pattern
<code>Lit(Bool(_)*)</code> isn’t valid because the parameter type of the <code>Lit</code> variant of
the <code>Expr</code> enum is <code>Any&lt;Lit&gt;</code> and therefore doesn’t support repetition (<code>*</code>). As
another example, <code>Array( Lit(_)* )</code> is a valid pattern because the parameter of
<code>Array</code> is of type <code>Seq&lt;Expr&gt;</code> which allows sequences and repetitions.</p>
<blockquote>
<p>Note: names in the pattern syntax correspond to <em>PatternTree</em> enum
<strong>variants</strong>. For example, the <code>Lit</code> in the pattern above refers to the <code>Lit</code>
variant of the <code>Expr</code> enum (<code>Expr::Lit</code>), not the <code>Lit</code> enum.</p>
</blockquote>
<h2 id="the-ismatch-trait"><a class="header" href="#the-ismatch-trait">The IsMatch Trait</a></h2>
<p>The pattern syntax and the <em>PatternTree</em> are independent of specific syntax tree
implementations (rust ast / hir, syn, …). When looking at the different
pattern examples in the previous sections, it can be seen that the patterns
don’t contain any information specific to a certain syntax tree implementation.
In contrast, Clippy lints currently match against ast / hir syntax tree nodes
and therefore directly depend on their implementation.</p>
<p>The connection between the <em>PatternTree</em> and specific syntax tree
implementations is the <code>IsMatch</code> trait. It defines how to match <em>PatternTree</em>
nodes against specific syntax tree nodes. A simplified implementation of the
<code>IsMatch</code> trait is shown below:</p>
<pre><code class="language-rust ignore">pub trait IsMatch&lt;O&gt; {
    fn is_match(&amp;self, other: &amp;'o O) -&gt; bool;
}</code></pre>
<p>This trait needs to be implemented on each enum of the <em>PatternTree</em> (for the
corresponding syntax tree types). For example, the <code>IsMatch</code> implementation for
matching <code>ast::LitKind</code> against the <em>PatternTree’s</em> <code>Lit</code> enum might look like
this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IsMatch&lt;ast::LitKind&gt; for Lit {
    fn is_match(&amp;self, other: &amp;ast::LitKind) -&gt; bool {
        match (self, other) {
            (Lit::Char(i), ast::LitKind::Char(j)) =&gt; i.is_match(j),
            (Lit::Bool(i), ast::LitKind::Bool(j)) =&gt; i.is_match(j),
            (Lit::Int(i), ast::LitKind::Int(j, _)) =&gt; i.is_match(j),
            _ =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre>
<p>All <code>IsMatch</code> implementations for matching the current <em>PatternTree</em> against
<code>syntax::ast</code> can be found
<a href="https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/ast_match.rs">here</a>.</p>
<h1 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h1>
<h4 id="performance"><a class="header" href="#performance">Performance</a></h4>
<p>The pattern matching code is currently not optimized for performance, so it
might be slower than hand-written matching code. Additionally, the two-stage
approach (matching against the coarse pattern first and checking for additional
properties later) might be slower than the current practice of checking for
structure and additional properties in one pass. For example, the following lint</p>
<pre><code class="language-rust ignore">pattern!{
    pat_if_without_else: Expr =
        If(
            _,
            Block(
                Expr( If(_, _, ())#inner )
                | Semi( If(_, _, ())#inner )
            )#then,
            ()
        )
}
...
fn check_expr(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, expr: &amp;ast::Expr) {
    if let Some(result) = pat_if_without_else(expr) {
        if !block_starts_with_comment(cx, result.then) {
            ...
        }
}</code></pre>
<p>first matches against the pattern and then checks that the <code>then</code> block doesn’t
start with a comment. Using clippy’s current approach, it’s possible to check
for these conditions earlier:</p>
<pre><code class="language-rust ignore">fn check_expr(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, expr: &amp;ast::Expr) {
    if_chain! {
        if let ast::ExprKind::If(ref check, ref then, None) = expr.node;
        if !block_starts_with_comment(cx, then);
        if let Some(inner) = expr_block(then);
        if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;
        then {
            ...
        }
    }
}</code></pre>
<p>Whether or not this causes performance regressions depends on actual patterns.
If it turns out to be a problem, the pattern matching algorithms could be
extended to allow “early filtering” (see the <a href="#early-filtering">Early Filtering</a>
section in Future Possibilities).</p>
<p>That being said, I don’t see any conceptual limitations regarding pattern
matching performance.</p>
<h4 id="applicability"><a class="header" href="#applicability">Applicability</a></h4>
<p>Even though I’d expect that a lot of lints can be written using the proposed
pattern syntax, it’s unlikely that all lints can be expressed using patterns. I
suspect that there will still be lints that need to be implemented by writing
custom pattern matching code. This would lead to mix within clippy’s codebase
where some lints are implemented using patterns and others aren’t. This
inconsistency might be considered a drawback.</p>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<p>Specifying lints using syntax tree patterns has a couple of advantages compared
to the current approach of manually writing matching code. First, syntax tree
patterns allow users to describe patterns in a simple and expressive way. This
makes it easier to write new lints for both novices and experts and also makes
reading / modifying existing lints simpler.</p>
<p>Another advantage is that lints are independent of specific syntax tree
implementations (e.g. AST / HIR, …). When these syntax tree implementations
change, only the <code>IsMatch</code> trait implementations need to be adapted and existing
lints can remain unchanged. This also means that if the <code>IsMatch</code> trait
implementations were integrated into the compiler, updating the <code>IsMatch</code>
implementations would be required for the compiler to compile successfully. This
could reduce the number of times Clippy breaks because of changes in the
compiler. Another advantage of the pattern’s independence is that converting an
<code>EarlyLintPass</code> lint into a <code>LatePassLint</code> wouldn’t require rewriting the whole
pattern matching code. In fact, the pattern might work just fine without any
adaptions.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="rust-like-pattern-syntax"><a class="header" href="#rust-like-pattern-syntax">Rust-like pattern syntax</a></h3>
<p>The proposed pattern syntax requires users to know the structure of the
<code>PatternTree</code> (which is very similar to the AST’s / HIR’s structure) and also
the pattern syntax. An alternative would be to introduce a pattern syntax that
is similar to actual Rust syntax (probably like the <code>quote!</code> macro). For
example, a pattern that matches <code>if</code> expressions that have <code>false</code> in their
condition could look like this:</p>
<pre><code class="language-rust ignore">if false {
    #[*]
}</code></pre>
<h4 id="problems"><a class="header" href="#problems">Problems</a></h4>
<p>Extending Rust syntax (which is quite complex by itself) with additional syntax
needed for specifying patterns (alternations, sequences, repetitions, named
submatches, …) might become difficult to read and really hard to parse
properly.</p>
<p>For example, a pattern that matches a binary operation that has <code>0</code> on both
sides might look like this:</p>
<pre><code>0 #[*:BinOpKind] 0
</code></pre>
<p>Now consider this slightly more complex example:</p>
<pre><code>1 + 0 #[*:BinOpKind] 0
</code></pre>
<p>The parser would need to know the precedence of <code>#[*:BinOpKind]</code> because it
affects the structure of the resulting AST. <code>1 + 0 + 0</code> is parsed as <code>(1 + 0) + 0</code> while <code>1 + 0 * 0</code> is parsed as <code>1 + (0 * 0)</code>. Since the pattern could be any
<code>BinOpKind</code>, the precedence cannot be known in advance.</p>
<p>Another example of a problem would be named submatches. Take a look at this
pattern:</p>
<pre><code class="language-rust ignore">fn test() {
    1 #foo
}</code></pre>
<p>Which node is <code>#foo</code> referring to? <code>int</code>, <code>ast::Lit</code>, <code>ast::Expr</code>, <code>ast::Stmt</code>?
Naming subpatterns in a rust-like syntax is difficult because a lot of AST nodes
don’t have a syntactic element that can be used to put the name tag on. In these
situations, the only sensible option would be to assign the name tag to the
outermost node (<code>ast::Stmt</code> in the example above), because the information of
all child nodes can be retrieved through the outermost node. The problem with
this then would be that accessing inner nodes (like <code>ast::Lit</code>) would again
require manual pattern matching.</p>
<p>In general, Rust syntax contains a lot of code structure implicitly. This
structure is reconstructed during parsing (e.g. binary operations are
reconstructed using operator precedence and left-to-right) and is one of the
reasons why parsing is a complex task. The advantage of this approach is that
writing code is simpler for users.</p>
<p>When writing <em>syntax tree patterns</em>, each element of the hierarchy might have
alternatives, repetitions, etc.. Respecting that while still allowing
human-friendly syntax that contains structure implicitly seems to be really
complex, if not impossible.</p>
<p>Developing such a syntax would also require to maintain a custom parser that is
at least as complex as the Rust parser itself. Additionally, future changes in
the Rust syntax might be incompatible with such a syntax.</p>
<p>In summary, I think that developing such a syntax would introduce a lot of
complexity to solve a relatively minor problem.</p>
<p>The issue of users not knowing about the <em>PatternTree</em> structure could be solved
by a tool that, given a rust program, generates a pattern that matches only this
program (similar to the Clippy author lint).</p>
<p>For some simple cases (like the first example above), it might be possible to
successfully mix Rust and pattern syntax. This space could be further explored
in a future extension.</p>
<h1 id="prior-art-1"><a class="header" href="#prior-art-1">Prior art</a></h1>
<p>The pattern syntax is heavily inspired by regular expressions (repetitions,
alternatives, sequences, …).</p>
<p>From what I’ve seen until now, other linters also implement lints that directly
work on syntax tree data structures, just like Clippy does currently. I would
therefore consider the pattern syntax to be <em>new</em>, but please correct me if I’m
wrong.</p>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<h4 id="how-to-handle-multiple-matches"><a class="header" href="#how-to-handle-multiple-matches">How to handle multiple matches?</a></h4>
<p>When matching a syntax tree node against a pattern, there are possibly multiple
ways in which the pattern can be matched. A simple example of this would be the
following pattern:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    my_pattern: Expr =
        Array( _* Lit(_)+#literals)
}
<span class="boring">}</span></code></pre>
<p>This pattern matches arrays that end with at least one literal. Now given the
array <code>[x, 1, 2]</code>, should <code>1</code> be matched as part of the <code>_*</code> or the <code>Lit(_)+</code>
part of the pattern? The difference is important because the named submatch
<code>#literals</code> would contain 1 or 2 elements depending how the pattern is matched.
In regular expressions, this problem is solved by matching “greedy” by default
and “non-greedy” optionally.</p>
<p>I haven’t looked much into this yet because I don’t know how relevant it is for
most lints. The current implementation simply returns the first match it finds.</p>
<h1 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h1>
<h4 id="implement-rest-of-rust-syntax"><a class="header" href="#implement-rest-of-rust-syntax">Implement rest of Rust Syntax</a></h4>
<p>The current project only implements a small part of the Rust syntax. In the
future, this should incrementally be extended to more syntax to allow
implementing more lints. Implementing more of the Rust syntax requires extending
the <code>PatternTree</code> and <code>IsMatch</code> implementations, but should be relatively
straight-forward.</p>
<h4 id="early-filtering"><a class="header" href="#early-filtering">Early filtering</a></h4>
<p>As described in the <em>Drawbacks/Performance</em> section, allowing additional checks
during the pattern matching might be beneficial.</p>
<p>The pattern below shows how this could look like:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    pat_if_without_else: Expr =
        If(
            _,
            Block(
                Expr( If(_, _, ())#inner )
                | Semi( If(_, _, ())#inner )
            )#then,
            ()
        )
    where
        !in_macro(#then.span);
}
<span class="boring">}</span></code></pre>
<p>The difference compared to the currently proposed two-stage filtering is that
using early filtering, the condition (<code>!in_macro(#then.span)</code> in this case)
would be evaluated as soon as the <code>Block(_)#then</code> was matched.</p>
<p>Another idea in this area would be to introduce a syntax for backreferences.
They could be used to require that multiple parts of a pattern should match the
same value. For example, the <code>assign_op_pattern</code> lint that searches for <code>a = a op b</code> and recommends changing it to <code>a op= b</code> requires that both occurrences of
<code>a</code> are the same. Using <code>=#...</code> as syntax for backreferences, the lint could be
implemented like this:</p>
<pre><code class="language-rust ignore">pattern!{
    assign_op_pattern: Expr =
        Assign(_#target, Binary(_, =#target, _)
}</code></pre>
<h4 id="match-descendant"><a class="header" href="#match-descendant">Match descendant</a></h4>
<p>A lot of lints currently implement custom visitors that check whether any
subtree (which might not be a direct descendant) of the current node matches
some properties. This cannot be expressed with the proposed pattern syntax.
Extending the pattern syntax to allow patterns like “a function that contains at
least two return statements” could be a practical addition.</p>
<h4 id="negation-operator-for-alternatives"><a class="header" href="#negation-operator-for-alternatives">Negation operator for alternatives</a></h4>
<p>For patterns like “a literal that is not a boolean literal” one currently needs
to list all alternatives except the boolean case. Introducing a negation
operator that allows to write <code>Lit(!Bool(_))</code> might be a good idea. This pattern
would be equivalent to <code>Lit( Char(_) | Int(_) )</code> (given that currently only three
literal types are implemented).</p>
<h4 id="functional-composition"><a class="header" href="#functional-composition">Functional composition</a></h4>
<p>Patterns currently don’t have any concept of composition. This leads to
repetitions within patterns. For example, one of the collapsible-if patterns
currently has to be written like this:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    pat_if_else: Expr =
        If(
            _,
            _,
            Block_(
                Block(
                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) |
                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)
                )#block_inner
            )#block
        ) |
        IfLet(
            _,
            Block_(
                Block(
                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) |
                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)
                )#block_inner
            )#block
        )
}
<span class="boring">}</span></code></pre>
<p>If patterns supported defining functions of subpatterns, the code could be
simplified as follows:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    fn expr_or_semi(expr: Expr) -&gt; Stmt {
        Expr(expr) | Semi(expr)
    }
    fn if_or_if_let(then: Block, else: Opt&lt;Expr&gt;) -&gt; Expr {
        If(_, then, else) | IfLet(then, else)
    }
    pat_if_else: Expr =
        if_or_if_let(
            _,
            Block_(
                Block(
                    expr_or_semi( if_or_if_let(_, _?)#else_ )
                )#block_inner
            )#block
        )
}
<span class="boring">}</span></code></pre>
<p>Additionally, common patterns like <code>expr_or_semi</code> could be shared between
different lints.</p>
<h4 id="clippy-pattern-author"><a class="header" href="#clippy-pattern-author">Clippy Pattern Author</a></h4>
<p>Another improvement could be to create a tool that, given some valid Rust
syntax, generates a pattern that matches this syntax exactly. This would make
starting to write a pattern easier. A user could take a look at the patterns
generated for a couple of Rust code examples and use that information to write a
pattern that matches all of them.</p>
<p>This is similar to clippy’s author lint.</p>
<h4 id="supporting-other-syntaxes"><a class="header" href="#supporting-other-syntaxes">Supporting other syntaxes</a></h4>
<p>Most of the proposed system is language-agnostic. For example, the pattern
syntax could also be used to describe patterns for other programming languages.</p>
<p>In order to support other languages’ syntaxes, one would need to implement
another <code>PatternTree</code> that sufficiently describes the languages’ AST and
implement <code>IsMatch</code> for this <code>PatternTree</code> and the languages’ AST.</p>
<p>One aspect of this is that it would even be possible to write lints that work on
the pattern syntax itself. For example, when writing the following pattern</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    my_pattern: Expr =
        Array( Lit(Bool(false)) Lit(Bool(false)) )
}
<span class="boring">}</span></code></pre>
<p>a lint that works on the pattern syntax’s AST could suggest using this pattern
instead:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pattern!{
    my_pattern: Expr =
        Array( Lit(Bool(false)){2} )
}
<span class="boring">}</span></code></pre>
<p>In the future, Clippy could use this system to also provide lints for custom
syntaxes like those found in macros.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-team"><a class="header" href="#the-team">The team</a></h1>
<p>Everyone who contributes to Clippy makes the project what it is. Collaboration
and discussions are the lifeblood of every open-source project. Clippy has a
very flat hierarchy. The teams mainly have additional access rights to the repo.</p>
<p>This document outlines the onboarding process, as well as duties, and access
rights for members of a group.</p>
<p>All regular events mentioned in this chapter are tracked in the <a href="https://github.com/rust-lang/calendar/blob/main/clippy.toml">calendar repository</a>.
The calendar file is also available for download: <a href="https://rust-lang.github.io/calendar/clippy.ics">clippy.ics</a></p>
<h2 id="everyone"><a class="header" href="#everyone">Everyone</a></h2>
<p>Everyone, including you, is welcome to join discussions and contribute in other
ways, like PRs.</p>
<p>You also have some triage rights, using <code>@rustbot</code> to add labels and claim
issues. See <a href="https://forge.rust-lang.org/triagebot/labeling.html">labeling with @rustbot</a>.</p>
<p>A rule for everyone should be to keep a healthy work-life balance. Take a break
when you need one.</p>
<h2 id="clippy-contributors"><a class="header" href="#clippy-contributors">Clippy-Contributors</a></h2>
<p>This is a group of regular contributors to Clippy to help with triaging.</p>
<h3 id="duties"><a class="header" href="#duties">Duties</a></h3>
<p>This team exists to make contributing easier for regular members. It doesn’t
carry any duties that need to be done. However, we want to encourage members of
this group to help with triaging, which can include:</p>
<ol>
<li>
<p><strong>Labeling issues</strong></p>
<p>For the <code>good first issue</code> label, it can still be good to use <code>@rustbot</code> to
subscribe to the issue and help interested parties, if they post questions
in the comments.</p>
</li>
<li>
<p><strong>Closing duplicate or resolved issues</strong></p>
<p>When you manually close an issue, it’s often a good idea, to add a short
comment explaining the reason.</p>
</li>
<li>
<p><strong>Ping people after two weeks of inactivity</strong></p>
<p>We try to keep issue assignments and PRs fairly up-to-date. After two weeks,
it can be good to send a friendly ping to the delaying party.</p>
<p>You might close a PR with the <code>I-inactive-closed</code> label if the author is
busy or wants to abandon it. If the reviewer is busy, the PR can be
reassigned to someone else.</p>
<p>Checkout: https://triage.rust-lang.org/triage/rust-lang/rust-clippy to
monitor PRs.</p>
</li>
</ol>
<p>While not part of their duties, contributors are encouraged to review PRs
and help on Zulip. The team always appreciates help!</p>
<h3 id="membership"><a class="header" href="#membership">Membership</a></h3>
<p>If you have been contributing to Clippy for some time, we’ll probably ask you if
you want to join this team. Members of this team are also welcome to suggest
people who they think would make a great addition to this group.</p>
<p>For this group, there is no direct onboarding process. You’re welcome to just
continue what you’ve been doing. If you like, you can ask for someone to mentor
you, either in the Clippy stream on Zulip or privately via a PM.</p>
<p>If you have been inactive in Clippy for over three months, we’ll probably move
you to the alumni group. You’re always welcome to come back.</p>
<h2 id="the-clippy-team"><a class="header" href="#the-clippy-team">The Clippy Team</a></h2>
<p><a href="https://www.rust-lang.org/governance/teams/dev-tools#team-clippy">The Clippy team</a>
is responsible for maintaining Clippy.</p>
<h3 id="duties-1"><a class="header" href="#duties-1">Duties</a></h3>
<ol>
<li>
<p><strong>Respond to PRs in a timely manner</strong></p>
<p>It’s totally fine, if you don’t have the time for reviews right now.
You can reassign the PR to a random member by commenting <code>r? clippy</code>.</p>
</li>
<li>
<p><strong>Take a break when you need one</strong></p>
<p>You are valuable! Clippy wouldn’t be what it is without you. So take a break
early and recharge some energy when you need to.</p>
</li>
<li>
<p><strong>Be responsive on Zulip</strong></p>
<p>This means in a reasonable time frame, so responding within one or two days
is totally fine.</p>
<p>It’s also good, if you answer threads on Zulip and take part in our Clippy
meetings, every two weeks. The meeting dates are tracked in the <a href="https://github.com/rust-lang/calendar/blob/main/clippy.toml">calendar repository</a>.</p>
</li>
<li>
<p><strong>Sync Clippy with the rust-lang/rust repo</strong></p>
<p>This is done every two weeks, usually by @flip1995.</p>
</li>
<li>
<p><strong>Update the changelog</strong></p>
<p>This needs to be done for every release, every six weeks.</p>
</li>
</ol>
<h3 id="membership-1"><a class="header" href="#membership-1">Membership</a></h3>
<p>If you have been active for some time, we’ll probably reach out and ask
if you want to help with reviews and eventually join the Clippy team.</p>
<p>During the onboarding process, you’ll be assigned pull requests to review.
You’ll also have an active team member as a mentor who’ll stay in contact via
Zulip DMs to provide advice and feedback. If you have questions, you’re always
welcome to ask, that is the best way to learn. Once you’re done with the review,
you can ping your mentor for a full review and to r+ the PR in both of your names.</p>
<p>When your mentor is confident that you can handle reviews on your own, they’ll
start an informal vote among the active team members to officially add you to
the team. This vote is usually accepted unanimously. Then you’ll be added to
the team once you’ve confirmed that you’re still interested in joining. The
onboarding phase typically takes a couple of weeks to a few months.</p>
<p>If you have been inactive in Clippy for over three months, we’ll probably move
you to the alumni group. You’re always welcome to come back.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
