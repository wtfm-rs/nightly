<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Unstable Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-fe73a51c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-f39945cd.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Unstable Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/unstable-book" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="the-unstable-book"><a class="header" href="#the-unstable-book">The Unstable Book</a></h1>
<p>Welcome to the Unstable Book! This book consists of a number of chapters,
each one organized by a “feature flag.” That is, when using an unstable
feature of Rust, you must use a flag, like this:</p>
<pre class="playground"><code class="language-rust">#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::{Coroutine, CoroutineState};
use std::pin::Pin;

fn main() {
    let mut coroutine = #[coroutine] || {
        yield 1;
        return "foo"
    };

    match Pin::new(&amp;mut coroutine).resume(()) {
        CoroutineState::Yielded(1) =&gt; {}
        _ =&gt; panic!("unexpected value from resume"),
    }
    match Pin::new(&amp;mut coroutine).resume(()) {
        CoroutineState::Complete("foo") =&gt; {}
        _ =&gt; panic!("unexpected value from resume"),
    }
}</code></pre>
<p>The <code>coroutines</code> feature <a href="#coroutines">has a chapter</a> describing how to use it.</p>
<p>Because this documentation relates to unstable features, we make no guarantees
that what is contained here is accurate or up to date. It’s developed on a
best-effort basis. Each page will have a link to its tracking issue with the
latest developments; you might want to check those as well.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="compiler-environment-variables"><a class="header" href="#compiler-environment-variables">Compiler environment variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="colorterm"><a class="header" href="#colorterm"><code>COLORTERM</code></a></h1>
<p>This environment variable is used by <a href="#-z-terminal-urls"><code>-Zterminal-urls</code></a> to detect if URLs are supported by the terminal emulator.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="qnx_target"><a class="header" href="#qnx_target"><code>QNX_TARGET</code></a></h1>
<hr>
<p>This environment variable is mandatory when linking on <code>nto-qnx*_iosock</code> platforms. It is used to determine an <code>-L</code> path to pass to the QNX linker.</p>
<p>You should <a href="https://www.qnx.com/developers/docs/qsc/com.qnx.doc.qsc.inst_larg_org/topic/build_server_developer_steps.html">set this variable</a> by running <code>source qnxsdp-env.sh</code>.
See <a href="https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.io_sock/topic/migrate_app.html.">the QNX docs</a> for more background information.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_bless"><a class="header" href="#rustc_bless"><code>RUSTC_BLESS</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_BLESS%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_bootstrap"><a class="header" href="#rustc_bootstrap"><code>RUSTC_BOOTSTRAP</code></a></h1>
<p>This feature is perma-unstable and has no tracking issue.</p>
<hr>
<p>The <code>RUSTC_BOOTSTRAP</code> environment variable tells rustc to act as if it is a nightly compiler;
in particular, it allows <code>#![feature(...)]</code> attributes and <code>-Z</code> flags even on the stable release channel.</p>
<p>Setting <code>RUSTC_BOOTSTRAP=1</code> instructs rustc to enable this for all crates.
Setting <code>RUSTC_BOOTSTRAP=crate_name</code> instructs rustc to only apply this to crates named <code>crate_name</code>.
Setting <code>RUSTC_BOOTSTRAP=-1</code> instructs rustc to act as if it is a stable compiler, even on the nightly release channel.
Cargo disallows setting <code>cargo::rustc-env=RUSTC_BOOTSTRAP</code> in build scripts.
Build systems can limit the features they enable with <a href="#allow-features"><code>-Z allow-features=feature1,feature2</code></a>.
Crates can fully opt out of unstable features by using <a href="../rustc/lints/listing/allowed-by-default.html#unstable-features"><code>#![forbid(unstable_features)]</code></a> at the crate root (or any other way of enabling lints, such as <code>-F unstable-features</code>).</p>
<h2 id="why-does-this-environment-variable-exist"><a class="header" href="#why-does-this-environment-variable-exist">Why does this environment variable exist?</a></h2>
<p><code>RUSTC_BOOTSTRAP</code>, as the name suggests, is used for bootstrapping the compiler from an earlier version.
In particular, nightly is built with beta, and beta is built with stable.
Since the standard library and compiler both use unstable features, <code>RUSTC_BOOTSTRAP</code> is required so that we can use the previous version to build them.</p>
<h2 id="why-is-this-environment-variable-so-easy-to-use-for-people-not-in-the-rust-project"><a class="header" href="#why-is-this-environment-variable-so-easy-to-use-for-people-not-in-the-rust-project">Why is this environment variable so easy to use for people not in the Rust project?</a></h2>
<p>Originally, <code>RUSTC_BOOTSTRAP</code> required passing in a hash of the previous compiler version, to discourage using it for any purpose other than bootstrapping.
That constraint was later relaxed; see <a href="https://github.com/rust-lang/rust/issues/36548">https://github.com/rust-lang/rust/issues/36548</a> for the discussion that happened at that time.</p>
<p>People have at various times proposed re-adding the technical constraints.
However, doing so is extremely disruptive for several major projects that we very much want to keep using the latest stable toolchain version, such as Firefox, Rust for Linux, and Chromium.
We continue to allow <code>RUSTC_BOOTSTRAP</code> until we can come up with an alternative that does not disrupt our largest constituents.</p>
<h2 id="stability-policy"><a class="header" href="#stability-policy">Stability policy</a></h2>
<p>Despite being usable on stable, this is an unstable feature.
Like any other unstable feature, we reserve the right to change or remove this feature in the future, as well as any other unstable feature that it enables.
Using this feature opts you out of the normal stability/backwards compatibility guarantee of stable.</p>
<p>Although we do not take technical measures to prevent it from being used, we strongly discourage using this feature.
If at all possible, please contribute to stabilizing the features you care about instead of bypassing the Rust project’s stability policy.</p>
<p>For library crates, we especially discourage the use of this feature.
The crates depending on you do not know that you use this feature, have little recourse if it breaks, and can be used in contexts that are hard to predict.</p>
<p>For libraries that do use this feature, please document the versions you support (including a <em>maximum</em> as well as minimum version), and a mechanism to disable it.
If you do not have a mechanism to disable the use of <code>RUSTC_BOOTSTRAP</code>, consider removing its use altogether, such that people can only use your library if they are already using a nightly toolchain.
This leaves the choice of whether to opt-out of Rust’s stability guarantees up to the end user building their code.</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/37265">Allowed without a hash</a> (<a href="https://github.com/rust-lang/rust/issues/36548">discussion</a>)</li>
<li><a href="https://github.com/rust-lang/rust/pull/77802">Extended to crate names</a> (<a href="https://github.com/rust-lang/cargo/issues/7088">discussion</a>)</li>
<li><a href="https://github.com/rust-lang/cargo/pull/9181">Disallowed for build scripts</a> (<a href="https://github.com/rust-lang/compiler-team/issues/350">discussion</a>)</li>
<li><a href="https://github.com/rust-lang/rust/pull/132993">Extended to emulate stable</a> (<a href="https://github.com/rust-lang/rust/issues/123404">discussion</a>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_break_on_ice"><a class="header" href="#rustc_break_on_ice"><code>RUSTC_BREAK_ON_ICE</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_BREAK_ON_ICE%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_ctfe_backtrace"><a class="header" href="#rustc_ctfe_backtrace"><code>RUSTC_CTFE_BACKTRACE</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_CTFE_BACKTRACE%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_force_rustc_version"><a class="header" href="#rustc_force_rustc_version"><code>RUSTC_FORCE_RUSTC_VERSION</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_FORCE_RUSTC_VERSION%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_graphviz_font"><a class="header" href="#rustc_graphviz_font"><code>RUSTC_GRAPHVIZ_FONT</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_GRAPHVIZ_FONT%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_ice"><a class="header" href="#rustc_ice"><code>RUSTC_ICE</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_ICE%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_log"><a class="header" href="#rustc_log"><code>RUSTC_LOG</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_LOG%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_override_version_string"><a class="header" href="#rustc_override_version_string"><code>RUSTC_OVERRIDE_VERSION_STRING</code></a></h1>
<p>This feature is perma-unstable and has no tracking issue.</p>
<hr>
<p>The <code>RUSTC_OVERRIDE_VERSION_STRING</code> environment variable overrides the version reported by <code>rustc --version</code>. For example:</p>
<pre><code class="language-console">$ rustc --version
rustc 1.87.0-nightly (43f0014ef 2025-03-25)
$ env RUSTC_OVERRIDE_VERSION_STRING=1.81.0-nightly rustc --version
rustc 1.81.0-nightly
</code></pre>
<p>Note that the version string is completely overwritten; i.e. rustc discards commit hash and commit date information unless it is explicitly included in the environment variable. The string only applies to the “release” part of the version; for example:</p>
<pre><code class="language-console">$ RUSTC_OVERRIDE_VERSION_STRING="1.81.0-nightly (aaaaaaaaa 2025-03-22)" rustc -vV
rustc 1.81.0-nightly (aaaaaaaaa 2025-03-22)
binary: rustc
commit-hash: 43f0014ef0f242418674f49052ed39b70f73bc1c
commit-date: 2025-03-25
host: x86_64-unknown-linux-gnu
release: 1.81.0-nightly (aaaaaaaaa 2025-03-22)
LLVM version: 20.1.1
</code></pre>
<p>Note here that <code>commit-hash</code> and <code>commit-date</code> do not match the values in the string, and <code>release</code> includes the fake hash and date.</p>
<p>This variable has no effect on whether or not unstable features are allowed to be used. It only affects the output of <code>--version</code>.</p>
<h2 id="why-does-this-environment-variable-exist-1"><a class="header" href="#why-does-this-environment-variable-exist-1">Why does this environment variable exist?</a></h2>
<p>Various library crates have incomplete or incorrect feature detection.
This environment variable allows bisecting crates that do incorrect detection with <code>version_check::supports_feature</code>.</p>
<p>This is not intended to be used for any other case (and, except for bisection, is not particularly useful).</p>
<p>See <a href="https://github.com/rust-lang/rust/pull/124339">https://github.com/rust-lang/rust/pull/124339</a> for further discussion.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_translation_no_debug_assert"><a class="header" href="#rustc_translation_no_debug_assert"><code>RUSTC_TRANSLATION_NO_DEBUG_ASSERT</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_TRANSLATION_NO_DEBUG_ASSERT%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_windows_rc"><a class="header" href="#rustc_windows_rc"><code>RUSTC_WINDOWS_RC</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUSTC_WINDOWS_RC%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust_backtrace"><a class="header" href="#rust_backtrace"><code>RUST_BACKTRACE</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUST_BACKTRACE%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust_dep_graph"><a class="header" href="#rust_dep_graph"><code>RUST_DEP_GRAPH</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUST_DEP_GRAPH%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust_dep_graph_filter"><a class="header" href="#rust_dep_graph_filter"><code>RUST_DEP_GRAPH_FILTER</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUST_DEP_GRAPH_FILTER%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust_forbid_dep_graph_edge"><a class="header" href="#rust_forbid_dep_graph_edge"><code>RUST_FORBID_DEP_GRAPH_EDGE</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUST_FORBID_DEP_GRAPH_EDGE%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust_min_stack"><a class="header" href="#rust_min_stack"><code>RUST_MIN_STACK</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUST_MIN_STACK%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust_target_path"><a class="header" href="#rust_target_path"><code>RUST_TARGET_PATH</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22RUST_TARGET_PATH%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sdkroot"><a class="header" href="#sdkroot"><code>SDKROOT</code></a></h1>
<p>This environment variable is used on Apple targets.
It is passed through to the linker (currently either directly or via the <code>-syslibroot</code> flag).</p>
<p>Note that this variable is not always respected. When the SDKROOT is clearly wrong (e.g. when the platform of the SDK does not match the <code>--target</code> used by rustc), this is ignored and rustc does its own detection.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="term"><a class="header" href="#term"><code>TERM</code></a></h1>
<p>This environment variable is used by <a href="#-z-terminal-urls"><code>-Zterminal-urls</code></a> to detect if URLs are supported by the terminal emulator.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unstable_rustdoc_test_line"><a class="header" href="#unstable_rustdoc_test_line"><code>UNSTABLE_RUSTDOC_TEST_LINE</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22UNSTABLE_RUSTDOC_TEST_LINE%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unstable_rustdoc_test_path"><a class="header" href="#unstable_rustdoc_test_path"><code>UNSTABLE_RUSTDOC_TEST_PATH</code></a></h1>
<p>Environment variables have no tracking issue. This environment variable has no documentation, and therefore is likely internal to the compiler and not meant for general use.</p>
<p>See <a href="https://github.com/search?q=repo%3Arust-lang%2Frust+%22UNSTABLE_RUSTDOC_TEST_PATH%22+path%3Acompiler&amp;type=code">the code</a> for more information.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="compiler-flags"><a class="header" href="#compiler-flags">Compiler flags</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="allow-features"><a class="header" href="#allow-features"><code>allow-features</code></a></h1>
<p>This feature is perma-unstable and has no tracking issue.</p>
<hr>
<p>This flag allows limiting the features which can be enabled with <code>#![feature(...)]</code> attributes.
By default, all features are allowed on nightly and no features are allowed on stable or beta (but see <a href="#rustc_bootstrap"><code>RUSTC_BOOTSTRAP</code></a>).</p>
<p>Features are comma-separated, for example <code>-Z allow-features=ffi_pure,f16</code>.
If the flag is present, any feature listed will be allowed and any feature not listed will be disallowed.
Any unrecognized feature is ignored.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="annotate-moves"><a class="header" href="#annotate-moves"><code>annotate-moves</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148197">#148197</a>.</p>
<hr>
<p>The <code>-Z annotate-moves</code> flag enables annotation of compiler-generated
move and copy operations, making them visible in profilers and stack traces
for performance debugging.</p>
<p>When enabled, the compiler manipulates debug info to make large move and copy
operations appear as if they were inlined calls to <code>core::profiling::compiler_move</code>
and <code>core::profiling::compiler_copy</code>. No actual function calls are generated -
this is purely a debug info transformation that makes expensive memory operations
visible in profilers and stack traces.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-bash">rustc -Z annotate-moves[=&lt;value&gt;]
</code></pre>
<p>Where <code>&lt;value&gt;</code> can be:</p>
<ul>
<li>A boolean: <code>true</code>, <code>false</code>, <code>yes</code>, <code>no</code>, <code>on</code>, <code>off</code></li>
<li>A number: size threshold in bytes (e.g., <code>128</code>)</li>
<li>Omitted: enables with default threshold (65 bytes)</li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<ul>
<li><code>-Z annotate-moves</code> or <code>-Z annotate-moves=true</code>: Enable with default size limit</li>
<li><code>-Z annotate-moves=false</code>: Disable annotation</li>
<li><code>-Z annotate-moves=N</code>: Enable with custom size limit of N bytes</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><code class="language-bash"># Enable annotation with default threshold (65 bytes)
rustc -Z annotate-moves main.rs

# Enable with custom 128-byte threshold
rustc -Z annotate-moves=128 main.rs

# Only annotate very large moves (1KB+)
rustc -Z annotate-moves=1024 main.rs

# Explicitly disable
rustc -Z annotate-moves=false main.rs
</code></pre>
<h2 id="behavior"><a class="header" href="#behavior">Behavior</a></h2>
<p>The annotation only applies to:</p>
<ul>
<li>Types equal or larger than the specified size threshold</li>
<li>Non-immediate types (those that would generate <code>memcpy</code>)</li>
<li>Operations that actually move/copy data (not ZST types)</li>
</ul>
<p>Stack traces will show the operations:</p>
<pre><code class="language-text">0: memcpy
1: core::profiling::compiler_move::&lt;MyLargeStruct, 148&gt;
2: my_function
</code></pre>
<p>The <code>compiler_move</code> and <code>compiler_copy</code> functions have two generic parameters:
the type being moved/copied and its size in bytes. The size is identical to
<code>size_of::&lt;T&gt;()</code>, and is present just so that it’s easy to immediately tell how
large the copy is.</p>
<p>Note that this requires v0 mangling to be properly encoded; legacy mangling does
not substitute these with a specific type and size.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct LargeData {
    buffer: [u8; 1000],
}

fn example() {
    let data = LargeData { buffer: [0; 1000] };
    let copy = data.clone(); // Shows as compiler_copy in profiler
    let moved = data;        // Shows as compiler_move in profiler
}
<span class="boring">}</span></code></pre>
<h2 id="overhead"><a class="header" href="#overhead">Overhead</a></h2>
<p>This has no effect on generated code; it only adds debuginfo. The overhead is
typically very small; on rustc itself, the default limit of 65 bytes adds about
0.055% to the binary size.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="autodiff"><a class="header" href="#autodiff"><code>autodiff</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/124509">#124509</a>.</p>
<hr>
<p>This feature allows you to differentiate functions using automatic differentiation.
Set the <code>-Zautodiff=&lt;options&gt;</code> compiler flag to adjust the behaviour of the autodiff feature.
Multiple options can be separated with a comma.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-bash">rustc -Z autodiff=Enable[,options]
</code></pre>
<p>Where <code>options</code> can be:</p>
<ul>
<li><code>Enable</code> - Required flag to enable autodiff</li>
<li><code>PrintTA</code> - print Type Analysis Information</li>
<li><code>PrintTAFn=&lt;fn_name&gt;</code> - print Type Analysis Information for a specific function (consider combining it with <code>no_mangle</code>)</li>
<li><code>PrintAA</code> - print Activity Analysis Information</li>
<li><code>PrintPerf</code> - print Performance Warnings from Enzyme</li>
<li><code>PrintSteps</code> - prints all intermediate transformations</li>
<li><code>PrintModBefore</code> - print the whole module, before running opts</li>
<li><code>PrintModAfter</code> - print the module after Enzyme differentiated everything</li>
<li><code>LooseTypes</code> - Enzyme’s loose type debug helper (can cause incorrect gradients)</li>
<li><code>Inline</code> - runs Enzyme specific Inlining</li>
<li><code>RuntimeActivity</code> - allow specifying activity at runtime</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><code class="language-bash"># Enable autodiff via cargo, assuming `enzyme` being a toolchain that supports autodiff
"RUSTFLAGS=-Zautodiff=Enable" cargo +enzyme build

# Enable autodiff directly via rustc
rustc -Z autodiff=Enable

# Print TypeAnalysis updates for the function `foo`, as well as Activity Analysis for all differentiated code.
rustc -Z autodiff=Enable,PrintTAFn=foo,PrintAA
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="branch-protection"><a class="header" href="#branch-protection"><code>branch-protection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/113369">#113369</a>.</p>
<hr>
<p>This option lets you enable branch authentication instructions on AArch64.
This option is only accepted when targeting AArch64 architectures.
It takes some combination of the following values, separated by a <code>,</code>.</p>
<ul>
<li><code>pac-ret</code> - Enable pointer authentication for non-leaf functions.</li>
<li><code>pc</code> - Use PC as a diversifier using PAuthLR instructions</li>
<li><code>leaf</code> - Enable pointer authentication for all functions, including leaf functions.</li>
<li><code>b-key</code> - Sign return addresses with key B, instead of the default key A.</li>
<li><code>bti</code> - Enable branch target identification.</li>
<li><code>gcs</code> - Enable guarded control stack support.</li>
</ul>
<p><code>leaf</code>, <code>b-key</code> and <code>pc</code> are only valid if <code>pac-ret</code> was previously specified.
For example, <code>-Z branch-protection=bti,pac-ret,leaf</code> is valid, but
<code>-Z branch-protection=bti,leaf,pac-ret</code> is not.</p>
<p>Rust’s standard library does not ship with BTI or pointer authentication enabled by default.
In Cargo projects the standard library can be recompiled with pointer authentication using the nightly
<a href="../cargo/reference/unstable.html#build-std">build-std</a> feature.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cf-protection"><a class="header" href="#cf-protection"><code>cf-protection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93754">#93754</a>.</p>
<hr>
<p>This option enables control-flow enforcement technology (CET) on x86; a more detailed description of
CET is available <a href="https://www.intel.com/content/www/us/en/develop/articles/technical-look-control-flow-enforcement-technology.html">here</a>. Similar to <code>clang</code>, this flag takes one of the following values:</p>
<ul>
<li><code>none</code> - Disable CET completely (this is the default).</li>
<li><code>branch</code> - Enable indirect branch tracking (<code>IBT</code>).</li>
<li><code>return</code> - Enable shadow stack (<code>SHSTK</code>).</li>
<li><code>full</code> - Enable both <code>branch</code> and <code>return</code>.</li>
</ul>
<p>This flag only applies to the LLVM backend: it sets the <code>cf-protection-branch</code> and
<code>cf-protection-return</code> flags on LLVM modules. Note, however, that all compiled modules linked
together must have the flags set for the compiled output to be CET-enabled. Currently, Rust’s
standard library does not ship with CET enabled by default, so you may need to rebuild all standard
modules with a <code>cargo</code> command like:</p>
<pre><code class="language-sh">$ RUSTFLAGS="-Z cf-protection=full" cargo +nightly build -Z build-std --target x86_64-unknown-linux-gnu
</code></pre>
<h3 id="detection"><a class="header" href="#detection">Detection</a></h3>
<p>An ELF binary is CET-enabled if it has the <code>IBT</code> and <code>SHSTK</code> tags, e.g.:</p>
<pre><code class="language-sh">$ readelf -a target/x86_64-unknown-linux-gnu/debug/example | grep feature:
      Properties: x86 feature: IBT, SHSTK
</code></pre>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<p>To display modules that are not CET enabled, examine the linker errors available when <code>cet-report</code> is enabled:</p>
<pre><code class="language-sh">$ RUSTC_LOG=rustc_codegen_ssa::back::link=info rustc-custom -v -Z cf-protection=full -C link-arg="-Wl,-z,cet-report=warning" -o example example.rs
...
/usr/bin/ld: /.../build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd-d73f7266be14cb8b.rlib(std-d73f7266be14cb8b.std.f7443020-cgu.12.rcgu.o): warning: missing IBT and SHSTK properties
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="codegen-backend"><a class="header" href="#codegen-backend"><code>codegen-backend</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/77933">#77933</a>.</p>
<hr>
<p>This feature allows you to specify a path to a dynamic library to use as rustc’s
code generation backend at runtime.</p>
<p>Set the <code>-Zcodegen-backend=&lt;path&gt;</code> compiler flag to specify the location of the
backend. The library must be of crate type <code>dylib</code> and must contain a function
named <code>__rustc_codegen_backend</code> with a signature of <code>fn() -&gt; Box&lt;dyn rustc_codegen_ssa::traits::CodegenBackend&gt;</code>.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>See also the <a href="https://github.com/rust-lang/rust/tree/HEAD/tests/ui-fulldeps/codegen-backend/hotplug.rs"><code>codegen-backend/hotplug</code></a> test for a working example.</p>
<pre><code class="language-rust ignore (partial-example)">use rustc_codegen_ssa::traits::CodegenBackend;

struct MyBackend;

impl CodegenBackend for MyBackend {
   // Implement codegen methods
}

#[no_mangle]
pub fn __rustc_codegen_backend() -&gt; Box&lt;dyn CodegenBackend&gt; {
    Box::new(MyBackend)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unstable-codegen-options"><a class="header" href="#unstable-codegen-options">Unstable codegen options</a></h1>
<p>All of these options are passed to <code>rustc</code> via the <code>-C</code> flag, short for “codegen”. The flags are
stable but some of their values are individually unstable, and also require using <code>-Z unstable-options</code> to be accepted.</p>
<h2 id="linker-flavor"><a class="header" href="#linker-flavor">linker-flavor</a></h2>
<p>In addition to the stable set of linker flavors, the following unstable values also exist:</p>
<ul>
<li><code>ptx</code>: use <a href="https://github.com/denzp/rust-ptx-linker"><code>rust-ptx-linker</code></a>
for Nvidia NVPTX GPGPU support.</li>
<li><code>bpf</code>: use <a href="https://github.com/alessandrod/bpf-linker"><code>bpf-linker</code></a> for eBPF support.</li>
<li><code>llbc</code>: for linking in llvm bitcode. Install the preview rustup components<code>llvm-bitcode-linker</code>
and <code>llvm-tools</code> to use as a self-contained linker by passing
<code>-Zunstable-options -Clink-self-contained=+linker</code> together with <code>-Clinker-flavor=llbc</code>.
Can currently only be used for Nvidia NVPTX targets (<code>nvptx64-nvidia-cuda</code>).</li>
</ul>
<p>Additionally, a set of more precise linker flavors also exists, for example allowing targets to
declare that they use the LLD linker by default. The following values are currently unstable, and
the goal is for them to become stable, and preferred in practice over the existing stable values:</p>
<ul>
<li><code>gnu</code>: unix-like linker with GNU extensions</li>
<li><code>gnu-lld</code>: <code>gnu</code> using LLD</li>
<li><code>gnu-cc</code>: <code>gnu</code> using a C/C++ compiler as the linker driver</li>
<li><code>gnu-lld-cc</code>: <code>gnu</code> using LLD and a C/C++ compiler as the linker driver</li>
<li><code>darwin</code>: unix-like linker for Apple targets</li>
<li><code>darwin-lld</code>: <code>darwin</code> using LLD</li>
<li><code>darwin-cc</code>: <code>darwin</code> using a C/C++ compiler as the linker driver</li>
<li><code>darwin-lld-cc</code>: <code>darwin</code> using LLD and a C/C++ compiler as the linker driver</li>
<li><code>wasm-lld</code>: unix-like linker for Wasm targets, with LLD</li>
<li><code>wasm-lld-cc</code>: unix-like linker for Wasm targets, with LLD and a C/C++ compiler as the linker
driver</li>
<li><code>unix</code>: basic unix-like linker for “any other Unix” targets (Solaris/illumos, L4Re, MSP430, etc),
not supported with LLD.</li>
<li><code>unix-cc</code>: <code>unix</code> using a C/C++ compiler as the linker driver</li>
<li><code>msvc-lld</code>: MSVC-style linker for Windows and UEFI, with LLD</li>
<li><code>em-cc</code>: emscripten compiler frontend, similar to <code>wasm-lld-cc</code> with a different interface</li>
</ul>
<h2 id="link-self-contained"><a class="header" href="#link-self-contained">link-self-contained</a></h2>
<p>This flag generally controls whether the linker will use libraries and objects shipped with Rust
instead of those in the system. The stable boolean values for this flag are coarse-grained
(everything or nothing), but there exists a set of unstable values with finer-grained control,
<code>-Clink-self-contained</code> can accept a comma-separated list of components, individually enabled
(<code>+component</code>) or disabled (<code>-component</code>):</p>
<ul>
<li><code>crto</code>: CRT objects (e.g. on <code>windows-gnu</code>, <code>musl</code>, <code>wasi</code> targets)</li>
<li><code>libc</code>: libc static library (e.g. on <code>musl</code>, <code>wasi</code> targets)</li>
<li><code>unwind</code>: libgcc/libunwind (e.g. on <code>windows-gnu</code>, <code>fuchsia</code>, <code>fortanix</code>, <code>gnullvm</code> targets)</li>
<li><code>linker</code>: linker, dlltool, and their necessary libraries (e.g. on <code>windows-gnu</code> and for
<code>rust-lld</code>)</li>
<li><code>sanitizers</code>: sanitizer runtime libraries</li>
<li><code>mingw</code>: other MinGW libs and Windows import libs</li>
</ul>
<p>Out of the above self-contained linking components, <code>linker</code> is the only one currently implemented
(beyond parsing the CLI options) and stabilized.</p>
<p>It refers to the LLD linker, built from the same LLVM revision used by rustc (named <code>rust-lld</code> to
avoid naming conflicts), that is distributed via <code>rustup</code> with the compiler (and is used by default
for the wasm targets). One can also opt into using it by combining this flag with the appropriate
linker feature: for example, <code>-Clinker-features=+lld -Clink-self-contained=+linker</code> will use the
toolchain’s <code>rust-lld</code> as the linker instead of the system’s lld with <code>-Clinker-features=+lld</code> only.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="codegen-source-order"><a class="header" href="#codegen-source-order"><code>codegen-source-order</code></a></h1>
<hr>
<p>This feature allows you to have a predictive and
deterministic order for items after codegen, which
is the same as in source code.</p>
<p>For every <code>CodegenUnit</code>, local <code>MonoItem</code>s would
be sorted by <code>(Span, SymbolName)</code>, which
makes codegen tests rely on the order of items in
source files work.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="control-flow-guard"><a class="header" href="#control-flow-guard"><code>control-flow-guard</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/68793">#68793</a>.</p>
<hr>
<p>The rustc flag <code>-Z control-flow-guard</code> enables the Windows <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">Control Flow Guard</a> (CFG) platform security feature.</p>
<p>CFG is an exploit mitigation designed to enforce control-flow integrity for software running on supported <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">Windows platforms (Windows 8.1 onwards)</a>. Specifically, CFG uses runtime checks to validate the target address of every indirect call/jump before allowing the call to complete.</p>
<p>During compilation, the compiler identifies all indirect calls/jumps and adds CFG checks. It also emits metadata containing the relative addresses of all address-taken functions. At runtime, if the binary is run on a CFG-aware operating system, the loader uses the CFG metadata to generate a bitmap of the address space and marks those addresses that contain valid targets. On each indirect call, the inserted check determines whether the target address is marked in this bitmap. If the target is not valid, the process is terminated.</p>
<p>In terms of interoperability:</p>
<ul>
<li>Code compiled with CFG enabled can be linked with libraries and object files that are not compiled with CFG. In this case, a CFG-aware linker can identify address-taken functions in the non-CFG libraries.</li>
<li>Libraries compiled with CFG can linked into non-CFG programs. In this case, the CFG runtime checks in the libraries are not used (i.e. the mitigation is completely disabled).</li>
</ul>
<p>CFG functionality is completely implemented in the LLVM backend and is supported for X86 (32-bit and 64-bit), ARM, and Aarch64 targets. The rustc flag adds the relevant LLVM module flags to enable the feature. This flag will be ignored for all non-Windows targets.</p>
<h2 id="when-to-use-control-flow-guard"><a class="header" href="#when-to-use-control-flow-guard">When to use Control Flow Guard</a></h2>
<p>The primary motivation for enabling CFG in Rust is to enhance security when linking against non-Rust code, especially C/C++ code. To achieve full CFG protection, all indirect calls (including any from Rust code) must have the appropriate CFG checks, as added by this flag. CFG can also improve security for Rust code that uses the <code>unsafe</code> keyword.</p>
<p>Another motivation behind CFG is to harden programs against <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">return-oriented programming (ROP)</a> attacks. CFG disallows an attacker from taking advantage of the program’s own instructions while redirecting control flow in unexpected ways.</p>
<h2 id="overhead-of-control-flow-guard"><a class="header" href="#overhead-of-control-flow-guard">Overhead of Control Flow Guard</a></h2>
<p>The CFG checks and metadata can potentially increase binary size and runtime overhead. The magnitude of any increase depends on the number and frequency of indirect calls. For example, enabling CFG for the Rust standard library increases binary size by approximately 0.14%. Enabling CFG in the SPEC CPU 2017 Integer Speed benchmark suite (compiled with Clang/LLVM) incurs approximate runtime overheads of between 0% and 8%, with a geometric mean of 2.9%.</p>
<h2 id="testing-control-flow-guard"><a class="header" href="#testing-control-flow-guard">Testing Control Flow Guard</a></h2>
<p>The rustc flag <code>-Z control-flow-guard=nochecks</code> instructs LLVM to emit the list of valid call targets without inserting runtime checks. This flag should only be used for testing purposes as it does not provide security enforcement.</p>
<h2 id="control-flow-guard-in-libraries"><a class="header" href="#control-flow-guard-in-libraries">Control Flow Guard in libraries</a></h2>
<p>It is strongly recommended to also enable CFG checks for all linked libraries, including the standard library.</p>
<p>To enable CFG in the standard library, use the <a href="../cargo/reference/unstable.html#build-std">cargo <code>-Z build-std</code> functionality</a> to recompile the standard library with the same configuration options as the main program.</p>
<p>For example:</p>
<pre><code class="language-cmd">rustup toolchain install --force nightly
rustup component add rust-src
SET RUSTFLAGS=-Z control-flow-guard
cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc
</code></pre>
<pre><code class="language-PowerShell">rustup toolchain install --force nightly
rustup component add rust-src
$Env:RUSTFLAGS = "-Z control-flow-guard"
cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc
</code></pre>
<p>Alternatively, if you are building the standard library from source, you can set <code>control-flow-guard = true</code> in the bootstrap.toml file.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="coverage-options"><a class="header" href="#coverage-options"><code>coverage-options</code></a></h1>
<p>This option controls details of the coverage instrumentation performed by
<code>-C instrument-coverage</code>.</p>
<p>Multiple options can be passed, separated by commas. Valid options are:</p>
<ul>
<li><code>block</code>, <code>branch</code>, <code>condition</code>:
Sets the level of coverage instrumentation.
Setting the level will override any previously-specified level.
<ul>
<li><code>block</code> (default):
Blocks in the control-flow graph will be instrumented for coverage.</li>
<li><code>branch</code>:
In addition to block coverage, also enables branch coverage instrumentation.</li>
<li><code>condition</code>:
In addition to branch coverage, also instruments some boolean expressions
as branches, even if they are not directly used as branch conditions.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crate-attr"><a class="header" href="#crate-attr"><code>crate-attr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138287">#138287</a>.</p>
<hr>
<p>The <code>-Z crate-attr</code> flag allows you to inject attributes into the crate root.
For example, <code>-Z crate-attr=crate_name="test"</code> acts as if <code>#![crate_name="test"]</code> were present before the first source line of the crate root.</p>
<p>To inject multiple attributes, pass <code>-Z crate-attr</code> multiple times.</p>
<p>Formally, the expansion behaves as follows:</p>
<ol>
<li>The crate is parsed as if <code>-Z crate-attr</code> were not present.</li>
<li>The attributes in <code>-Z crate-attr</code> are parsed.</li>
<li>The attributes are injected at the top of the crate root.</li>
<li>Macro expansion is performed.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debug-info-for-profiling"><a class="header" href="#debug-info-for-profiling"><code>debug-info-for-profiling</code></a></h1>
<hr>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Automatic Feedback Directed Optimization (AFDO) is a method for using sampling
based profiles to guide optimizations. This is contrasted with other methods of
FDO or profile-guided optimization (PGO) which use instrumented profiling.</p>
<p>Unlike PGO (controlled by the <code>rustc</code> flags <code>-Cprofile-generate</code> and
<code>-Cprofile-use</code>), a binary being profiled does not perform significantly worse,
and thus it’s possible to profile binaries used in real workflows and not
necessary to construct artificial workflows.</p>
<h2 id="use"><a class="header" href="#use">Use</a></h2>
<p>In order to use AFDO, the target platform must be Linux running on an <code>x86_64</code>
architecture with the performance profiler <code>perf</code> available. In addition, the
external tool <code>create_llvm_prof</code> from <a href="https://github.com/google/autofdo">this repository</a> must be used.</p>
<p>Given a Rust file <code>main.rs</code>, we can produce an optimized binary as follows:</p>
<pre><code class="language-shell">rustc -O -Zdebug-info-for-profiling main.rs -o main
perf record -b ./main
create_llvm_prof --binary=main --out=code.prof
rustc -O -Zprofile-sample-use=code.prof main.rs -o main2
</code></pre>
<p>The <code>perf</code> command produces a profile <code>perf.data</code>, which is then used by the
<code>create_llvm_prof</code> command to create <code>code.prof</code>. This final profile is then
used by <code>rustc</code> to guide optimizations in producing the binary <code>main2</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debug-info-type-line-numbers"><a class="header" href="#debug-info-type-line-numbers"><code>debug-info-type-line-numbers</code></a></h1>
<hr>
<p>This option causes additional type and line information to be emitted in debug
info to provide richer information to debuggers. This is currently off by
default as it causes some compilation scenarios to be noticeably slower.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="default-visibility"><a class="header" href="#default-visibility"><code>default-visibility</code></a></h1>
<p>The tracking issue for this feature is: https://github.com/rust-lang/rust/issues/131090</p>
<hr>
<p>This flag can be used to override the target’s
<a href="https://doc.rust-lang.org/beta/nightly-rustc/rustc_target/spec/struct.TargetOptions.html#structfield.default_visibility"><code>default_visibility</code></a>
setting.</p>
<p>This option only affects building of shared objects and should have no effect on executables.</p>
<p>Visibility an be set to one of three options:</p>
<ul>
<li>protected</li>
<li>hidden</li>
<li>interposable</li>
</ul>
<h2 id="hidden-visibility"><a class="header" href="#hidden-visibility">Hidden visibility</a></h2>
<p>Using <code>-Zdefault-visibility=hidden</code> is roughly equivalent to Clang’s
<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fvisibility"><code>-fvisibility=hidden</code></a>
cmdline flag. Hidden symbols will not be exported from the created shared object, so cannot be
referenced from other shared objects or from executables.</p>
<h2 id="protected-visibility"><a class="header" href="#protected-visibility">Protected visibility</a></h2>
<p>Using <code>-Zdefault-visibility=protected</code> will cause rust-mangled symbols to be emitted with
“protected” visibility. This signals the compiler, the linker and the runtime linker that these
symbols cannot be overridden by the executable or by other shared objects earlier in the load order.</p>
<p>This will allow the compiler to emit direct references to symbols, which may improve performance. It
also removes the need for these symbols to be resolved when a shared object built with this option
is loaded.</p>
<p>Using protected visibility when linking with GNU ld prior to 2.40 will result in linker errors when
building for Linux. Other linkers such as LLD are not affected.</p>
<h2 id="interposable"><a class="header" href="#interposable">Interposable</a></h2>
<p>Using <code>-Zdefault-visibility=interposable</code> will cause symbols to be emitted with “default”
visibility. On platforms that support it, this makes it so that symbols can be interposed, which
means that they can be overridden by symbols with the same name from the executable or by other
shared objects earier in the load order.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="direct_access_external_data"><a class="header" href="#direct_access_external_data"><code>direct_access_external_data</code></a></h1>
<p>The tracking issue for this feature is: https://github.com/rust-lang/compiler-team/issues/707</p>
<hr>
<p>Option <code>-Z direct-access-external-data</code> controls how to access symbols of
external data.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>yes</code> - Don’t use GOT indirection to reference external data symbols.</li>
<li><code>no</code> - Use GOT indirection to reference external data symbols.</li>
</ul>
<p>If the option is not explicitly specified, different targets have different
default values.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dump-mono-stats"><a class="header" href="#dump-mono-stats"><code>dump-mono-stats</code></a></h1>
<hr>
<p>The <code>-Z dump-mono-stats</code> compiler flag generates a file with a list of the monomorphized items in the current crate.
It is useful for investigating compile times.</p>
<p>It accepts an optional directory where the file will be located. If no directory is specified, the file will be placed in the current directory.</p>
<p>See also <code>-Z dump-mono-stats-format</code> and <code>-Z print-mono-items</code>. Unlike <code>print-mono-items</code>,
<code>dump-mono-stats</code> aggregates monomorphized items by definition and includes a size estimate of how
large the item is when codegened.</p>
<p>See <a href="https://rustc-dev-guide.rust-lang.org/backend/monomorph.html">https://rustc-dev-guide.rust-lang.org/backend/monomorph.html</a> for an overview of monomorphized items.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dump-mono-stats-format"><a class="header" href="#dump-mono-stats-format"><code>dump-mono-stats-format</code></a></h1>
<hr>
<p>The <code>-Z dump-mono-stats-format</code> compiler flag controls what file format to use for <code>-Z dump-mono-stats</code>.
The default is markdown; currently JSON is also supported. JSON can be useful for programmatically manipulating the results (e.g. to find the item that took the longest to compile).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dylib_lto"><a href="#dylib_lto" class="header">dylib_lto</a></h1>
<h2 id="dylib-lto"><a class="header" href="#dylib-lto"><code>dylib-lto</code></a></h2>
<p>This option enables using LTO for the <code>dylib</code> crate type. This is currently only used for compiling
<code>rustc</code> itself (more specifically, the <code>librustc_driver</code> dylib).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="eagerly-emit-delayed-bugs"><a class="header" href="#eagerly-emit-delayed-bugs"><code>eagerly-emit-delayed-bugs</code></a></h1>
<p>This feature is perma-unstable and has no tracking issue.</p>
<hr>
<p>This flag converts all <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagCtxtHandle.html#method.span_delayed_bug"><code>span_delayed_bug()</code></a> calls to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/macro.bug.html"><code>bug!</code></a> calls, exiting the compiler immediately and allowing you to generate a backtrace of where the delayed bug occurred.
For full documentation, see <a href="https://rustc-dev-guide.rust-lang.org/compiler-debugging.html#debugging-delayed-bugs">the rustc-dev-guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="embed_metadata"><a href="#embed_metadata" class="header">embed_metadata</a></h1>
<h2 id="embed-metadata"><a class="header" href="#embed-metadata"><code>embed-metadata</code></a></h2>
<p>This option instructs <code>rustc</code> to include the full metadata in <code>rlib</code> and <code>dylib</code> crate types. The default value is <code>yes</code> (enabled). If disabled (<code>no</code>), only stub metadata will be stored in these files, to reduce their size on disk. When using <code>-Zembed-metadata=no</code>, you will probably want to use <code>--emit=metadata</code> to produce the full metadata into a separate <code>.rmeta</code> file.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="embed-source"><a class="header" href="#embed-source"><code>embed-source</code></a></h1>
<p>This flag controls whether the compiler embeds the program source code text into
the object debug information section. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code> or <code>true</code>: put source code in debug info.</li>
<li><code>n</code>, <code>no</code>, <code>off</code>, <code>false</code> or no value: omit source code from debug info (the default).</li>
</ul>
<p>This flag is ignored in configurations that don’t emit DWARF debug information
and is ignored on non-LLVM backends. <code>-Z embed-source</code> requires DWARFv5. Use
<code>-Z dwarf-version=5</code> to control the compiler’s DWARF target version and <code>-g</code> to
enable debug info generation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="emit-stack-sizes"><a class="header" href="#emit-stack-sizes"><code>emit-stack-sizes</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54192">#54192</a></p>
<hr>
<p>The rustc flag <code>-Z emit-stack-sizes</code> makes LLVM emit stack size metadata.</p>
<blockquote>
<p><strong>NOTE</strong>: This LLVM feature only supports the ELF object format as of LLVM
8.0. Using this flag with targets that use other object formats (e.g. macOS
and Windows) will result in it being ignored.</p>
</blockquote>
<p>Consider this crate:</p>
<pre><code>#![crate_type = "lib"]

use std::ptr;

pub fn foo() {
    // this function doesn't use the stack
}

pub fn bar() {
    let xs = [0u32; 2];

    // force LLVM to allocate `xs` on the stack
    unsafe { ptr::read_volatile(&amp;xs.as_ptr()); }
}
</code></pre>
<p>Using the <code>-Z emit-stack-sizes</code> flag produces extra linker sections in the
output <em>object file</em>.</p>
<pre><code class="language-console">$ rustc -C opt-level=3 --emit=obj foo.rs

$ size -A foo.o
foo.o  :
section                                 size   addr
.text                                      0      0
.text._ZN3foo3foo17he211d7b4a3a0c16eE      1      0
.text._ZN3foo3bar17h1acb594305f70c2eE     22      0
.note.GNU-stack                            0      0
.eh_frame                                 72      0
Total                                     95

$ rustc -C opt-level=3 --emit=obj -Z emit-stack-sizes foo.rs

$ size -A foo.o
foo.o  :
section                                 size   addr
.text                                      0      0
.text._ZN3foo3foo17he211d7b4a3a0c16eE      1      0
.stack_sizes                               9      0
.text._ZN3foo3bar17h1acb594305f70c2eE     22      0
.stack_sizes                               9      0
.note.GNU-stack                            0      0
.eh_frame                                 72      0
Total                                    113
</code></pre>
<p>As of LLVM 7.0 the data will be written into a section named <code>.stack_sizes</code> and
the format is “an array of pairs of function symbol values (pointer size) and
stack sizes (unsigned LEB128)”.</p>
<pre><code class="language-console">$ objdump -d foo.o

foo.o:     file format elf64-x86-64

Disassembly of section .text._ZN3foo3foo17he211d7b4a3a0c16eE:

0000000000000000 &lt;_ZN3foo3foo17he211d7b4a3a0c16eE&gt;:
   0:   c3                      retq

Disassembly of section .text._ZN3foo3bar17h1acb594305f70c2eE:

0000000000000000 &lt;_ZN3foo3bar17h1acb594305f70c2eE&gt;:
   0:   48 83 ec 10             sub    $0x10,%rsp
   4:   48 8d 44 24 08          lea    0x8(%rsp),%rax
   9:   48 89 04 24             mov    %rax,(%rsp)
   d:   48 8b 04 24             mov    (%rsp),%rax
  11:   48 83 c4 10             add    $0x10,%rsp
  15:   c3                      retq

$ objdump -s -j .stack_sizes foo.o

foo.o:     file format elf64-x86-64

Contents of section .stack_sizes:
 0000 00000000 00000000 00                 .........
Contents of section .stack_sizes:
 0000 00000000 00000000 10                 .........
</code></pre>
<p>It’s important to note that linkers will discard this linker section by default.
To preserve the section you can use a linker script like the one shown below.</p>
<pre><code class="language-text">/* file: keep-stack-sizes.x */
SECTIONS
{
  /* `INFO` makes the section not allocatable so it won't be loaded into memory */
  .stack_sizes (INFO) :
  {
    KEEP(*(.stack_sizes));
  }
}
</code></pre>
<p>The linker script must be passed to the linker using a rustc flag like <code>-C link-arg</code>.</p>
<pre><code>// file: src/main.rs
use std::ptr;

#[inline(never)]
fn main() {
    let xs = [0u32; 2];

    // force LLVM to allocate `xs` on the stack
    unsafe { ptr::read_volatile(&amp;xs.as_ptr()); }
}
</code></pre>
<pre><code class="language-console">$ RUSTFLAGS="-Z emit-stack-sizes" cargo build --release

$ size -A target/release/hello | grep stack_sizes || echo section was not found
section was not found

$ RUSTFLAGS="-Z emit-stack-sizes" cargo rustc --release -- \
    -C link-arg=-Wl,-Tkeep-stack-sizes.x \
    -C link-arg=-N

$ size -A target/release/hello | grep stack_sizes
.stack_sizes                               90   176272

$ # non-allocatable section (flags don't contain the "A" (alloc) flag)
$ readelf -S target/release/hello
Section Headers:
  [Nr]   Name              Type             Address           Offset
       Size              EntSize            Flags  Link  Info  Align
(..)
  [1031] .stack_sizes      PROGBITS         000000000002b090  0002b0f0
       000000000000005a  0000000000000000   L       5     0     1

$ objdump -s -j .stack_sizes target/release/hello

target/release/hello:     file format elf64-x86-64

Contents of section .stack_sizes:
 2b090 c0040000 00000000 08f00400 00000000  ................
 2b0a0 00080005 00000000 00000810 05000000  ................
 2b0b0 00000000 20050000 00000000 10400500  .... ........@..
 2b0c0 00000000 00087005 00000000 00000080  ......p.........
 2b0d0 05000000 00000000 90050000 00000000  ................
 2b0e0 00a00500 00000000 0000               ..........
</code></pre>
<blockquote>
<p>Author note: I’m not entirely sure why, in <em>this</em> case, <code>-N</code> is required in
addition to <code>-Tkeep-stack-sizes.x</code>. For example, it’s not required when
producing statically linked files for the ARM Cortex-M architecture.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="emscripten-wasm-eh"><a class="header" href="#emscripten-wasm-eh"><code>emscripten-wasm-eh</code></a></h1>
<p>Use the WebAssembly exception handling ABI to unwind for the
<code>wasm32-unknown-emscripten</code>. If compiling with this setting, the <code>emcc</code> linker
should be invoked with <code>-fwasm-exceptions</code>. If linking with C/C++ files, the
C/C++ files should also be compiled with <code>-fwasm-exceptions</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="env-set"><a class="header" href="#env-set"><code>env-set</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118372">#118372</a>.</p>
<hr>
<p>This option flag allows to specify environment variables value at compile time to be
used by <code>env!</code> and <code>option_env!</code> macros. It also impacts <code>tracked_env::var</code> function
from the <code>proc_macro</code> crate.</p>
<p>This information will be stored in the dep-info files. For more information about
dep-info files, take a look <a href="https://doc.rust-lang.org/cargo/guide/build-cache.html#dep-info-files">here</a>.</p>
<p>When retrieving an environment variable value, the one specified by <code>--env-set</code> will take
precedence. For example, if you want have <code>PATH=a</code> in your environment and pass:</p>
<pre><code class="language-bash">rustc --env-set PATH=env
</code></pre>
<p>Then you will have:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(env!("PATH"), "env");
<span class="boring">}</span></code></pre>
<p>It will trigger a new compilation if any of the <code>--env-set</code> argument value is different.
So if you first passed:</p>
<pre><code class="language-bash">--env-set A=B --env X=12
</code></pre>
<p>and then on next compilation:</p>
<pre><code class="language-bash">--env-set A=B
</code></pre>
<p><code>X</code> value is different (not set) so the code will be re-compiled.</p>
<p>Please note that on Windows, environment variables are case insensitive but case
preserving whereas <code>rustc</code>’s environment variables are case sensitive. For example,
having <code>Path</code> in your environment (case insensitive) is different than using
<code>rustc --env-set Path=...</code> (case sensitive).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="export-executable-symbols"><a class="header" href="#export-executable-symbols"><code>export-executable-symbols</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/84161">#84161</a>.</p>
<hr>
<p>The <code>-Zexport-executable-symbols</code> compiler flag makes <code>rustc</code> export symbols from executables. The resulting binary is runnable, but can also be used as a dynamic library. This is useful for interoperating with programs written in other languages, in particular languages with a runtime like Java or Lua.</p>
<p>For example on windows:</p>
<pre class="playground"><code class="language-rust">#[no_mangle]
fn my_function() -&gt; usize {
    return 42;
}

fn main() {
    println!("Hello, world!");
}</code></pre>
<p>A standard <code>cargo build</code> will produce a <code>.exe</code> without an export directory. When the <code>export-executable-symbols</code> flag is added</p>
<pre><code class="language-Bash">export RUSTFLAGS="-Zexport-executable-symbols"
cargo build
</code></pre>
<p>the binary has an export directory with the functions:</p>
<pre><code class="language-plain">The Export Tables (interpreted .edata section contents)

...

[Ordinal/Name Pointer] Table
    [   0] my_function
    [   1] main
</code></pre>
<p>(the output of <code>objdump -x</code> on the binary)</p>
<p>Please note that the <code>#[no_mangle]</code> attribute is required. Without it, the symbol is not exported.</p>
<p>The equivalent of this flag in C and C++ compilers is the <code>__declspec(dllexport)</code> annotation or the <code>-rdynamic</code> linker flag.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="--extern-options"><a class="header" href="#--extern-options"><code>--extern</code> Options</a></h1>
<ul>
<li>Tracking issue for <code>--extern</code> crate modifiers: <a href="https://github.com/rust-lang/rust/issues/98405">#98405</a></li>
<li>Tracking issue for <code>noprelude</code>: <a href="https://github.com/rust-lang/rust/issues/98398">#98398</a></li>
<li>Tracking issue for <code>priv</code>: <a href="https://github.com/rust-lang/rust/issues/98399">#98399</a></li>
<li>Tracking issue for <code>nounused</code>: <a href="https://github.com/rust-lang/rust/issues/98400">#98400</a></li>
<li>Tracking issue for <code>force</code>: <a href="https://github.com/rust-lang/rust/issues/111302">#111302</a></li>
</ul>
<p>The behavior of the <code>--extern</code> flag can be modified with <code>noprelude</code>, <code>priv</code> or <code>nounused</code> options.</p>
<p>This is unstable feature, so you have to provide <code>-Zunstable-options</code> to enable it.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>Use your own build of the <code>core</code> crate.</p>
<p><code>rustc main.rs -Z unstable-options --extern noprelude:core=libcore.rlib</code></p>
<p>To use multiple options, separate them with a comma:</p>
<p><code>rustc main.rs -Z unstable-options --extern noprelude,priv,nounused:mydep=mydep.rlib</code></p>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<ul>
<li><code>noprelude</code>: Do not add the crate to the external prelude. If used, it will need to be imported using <code>extern crate</code>.
This is used by the <a href="https://github.com/rust-lang/wg-cargo-std-aware/">build-std project</a> to simulate compatibility with sysroot-only crates.</li>
<li><code>priv</code>: Mark the crate as a private dependency for the <a href="../rustc/lints/listing/warn-by-default.html#exported-private-dependencies"><code>exported_private_dependencies</code></a> lint.</li>
<li><code>nounused</code>: Suppress <a href="../rustc/lints/listing/allowed-by-default.html#unused-crate-dependencies"><code>unused-crate-dependencies</code></a> warnings for the crate.</li>
<li><code>force</code>: Resolve the crate as if it is used, even if it is not used. This can be used to satisfy compilation session requirements like the presence of an allocator or panic handler.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="external-clangrt"><a class="header" href="#external-clangrt"><code>external-clangrt</code></a></h1>
<p>This option controls whether the compiler links in its own runtime library for
<a href="#sanitizer">sanitizers</a>. Passing this flag makes the compiler <em>not</em> link
its own library. For more information, see the section in the sanitizers doc on
<a href="#working-with-other-languages">working with other languages.</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fixed-x18"><a class="header" href="#fixed-x18"><code>fixed-x18</code></a></h1>
<p>This option prevents the compiler from using the x18 register. It is only
supported on <code>aarch64</code>.</p>
<p>From the <a href="https://developer.arm.com/documentation/den0024/a/The-ABI-for-ARM-64-bit-Architecture/Register-use-in-the-AArch64-Procedure-Call-Standard/Parameters-in-general-purpose-registers">ABI spec</a>:</p>
<blockquote>
<p>X18 is the platform register and is reserved for the use of platform ABIs.
This is an additional temporary register on platforms that don’t assign a
special meaning to it.</p>
</blockquote>
<p>This flag only has an effect when the x18 register would otherwise be considered
a temporary register. When the flag is applied, x18 is always a reserved
register.</p>
<p>This flag is intended for use with the shadow call stack sanitizer. Generally,
when that sanitizer is enabled, the x18 register is used to store a pointer to
the shadow stack. Enabling this flag prevents the compiler from overwriting the
shadow stack pointer with temporary data, which is necessary for the sanitizer
to work correctly.</p>
<p>Currently, the <code>-Zsanitizer=shadow-call-stack</code> flag is only supported on
platforms that always treat x18 as a reserved register, and the <code>-Zfixed-x18</code>
flag is not required to use the sanitizer on such platforms. However, the
sanitizer may be supported on targets where this is not the case in the future.
One way to do so now on Nightly compilers is to explicitly supply this <code>-Zfixed-x18</code>
flag with <code>aarch64</code> targets, so that the sanitizer is available for instrumentation
on targets like <code>aarch64-unknown-none</code>, for instance. However, discretion is still
required to make sure that the runtime support is in place for this sanitizer
to be effective.</p>
<p>It is undefined behavior for <code>-Zsanitizer=shadow-call-stack</code> code to call into
code where x18 is a temporary register. On the other hand, when you are <em>not</em>
using the shadow call stack sanitizer, compilation units compiled with and
without the <code>-Zfixed-x18</code> flag are compatible with each other.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fmt-debug"><a class="header" href="#fmt-debug"><code>fmt-debug</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/129709">#129709</a>.</p>
<hr>
<p>Option <code>-Z fmt-debug=val</code> controls verbosity of derived <code>Debug</code> implementations
and debug formatting in format strings (<code>{:?}</code>).</p>
<ul>
<li>
<p><code>full</code> — <code>#[derive(Debug)]</code> prints types recursively. This is the default behavior.</p>
</li>
<li>
<p><code>shallow</code> — <code>#[derive(Debug)]</code> prints only the type name, or name of a variant of a fieldless enums. Details of the <code>Debug</code> implementation are not stable and may change in the future. Behavior of custom <code>fmt::Debug</code> implementations is not affected.</p>
</li>
<li>
<p><code>none</code> — <code>#[derive(Debug)]</code> does not print anything at all. <code>{:?}</code> in formatting strings has no effect.
This option may reduce size of binaries, and remove occurrences of type names in the binary that are not removed by striping symbols. However, it may also cause <code>panic!</code> and <code>assert!</code> messages to be incomplete.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="function-return"><a class="header" href="#function-return"><code>function-return</code></a></h1>
<p>The tracking issue for this feature is: https://github.com/rust-lang/rust/issues/116853.</p>
<hr>
<p>Option <code>-Zfunction-return</code> controls how function returns are converted.</p>
<p>It is equivalent to <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-mfunction-return">Clang</a>’s and <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html#index-mfunction-return">GCC</a>’s <code>-mfunction-return</code>. The Linux kernel
uses it for RETHUNK builds. For details, see <a href="https://github.com/llvm/llvm-project/commit/2240d72f15f3b7b9d9fb65450f9bf635fd310f6f">LLVM commit 2240d72f15f3</a> (“[X86]
initial -mfunction-return=thunk-extern support”) which introduces the feature.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>keep</code>: do not convert function returns.</li>
<li><code>thunk-extern</code>: convert function returns (<code>ret</code>) to jumps (<code>jmp</code>)
to an external symbol called <code>__x86_return_thunk</code>.</li>
</ul>
<p>Like in Clang, GCC’s values <code>thunk</code> and <code>thunk-inline</code> are not supported.</p>
<p>Only x86 and non-large code models are supported.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hint-mostly-unused"><a class="header" href="#hint-mostly-unused"><code>hint-mostly-unused</code></a></h1>
<p>This flag hints to the compiler that most of the crate will probably go unused.
The compiler can optimize its operation based on this assumption, in order to
compile faster. This is a hint, and does not guarantee any particular behavior.</p>
<p>This option can substantially speed up compilation if applied to a large
dependency where the majority of the dependency does not get used. This flag
may slow down compilation in other cases.</p>
<p>Currently, this option makes the compiler defer as much code generation as
possible from functions in the crate, until later crates invoke those
functions. Functions that never get invoked will never have code generated for
them. For instance, if a crate provides thousands of functions, but only a few
of them will get called, this flag will result in the compiler only doing code
generation for the called functions. (This uses the same mechanisms as
cross-crate inlining of functions.) This does not affect <code>extern</code> functions, or
functions marked as <code>#[inline(never)]</code>.</p>
<p>To try applying this flag to one dependency out of a dependency tree, use the
<a href="https://doc.rust-lang.org/cargo/reference/unstable.html#profile-rustflags-option"><code>profile-rustflags</code></a>
feature of nightly cargo:</p>
<pre><code class="language-toml">cargo-features = ["profile-rustflags"]

# ...
[dependencies]
mostly-unused-dependency = "1.2.3"

[profile.release.package.mostly-unused-dependency]
rustflags = ["-Zhint-mostly-unused"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="indirect-branch-cs-prefix"><a class="header" href="#indirect-branch-cs-prefix"><code>indirect-branch-cs-prefix</code></a></h1>
<p>The tracking issue for this feature is: https://github.com/rust-lang/rust/issues/116852.</p>
<hr>
<p>Option <code>-Zindirect-branch-cs-prefix</code> controls whether a <code>cs</code> prefix is added to
<code>call</code> and <code>jmp</code> to indirect thunks.</p>
<p>It is equivalent to <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-mindirect-branch-cs-prefix">Clang</a>’s and <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html#index-mindirect-branch-cs-prefix">GCC</a>’s <code>-mindirect-branch-cs-prefix</code>. The
Linux kernel uses it for RETPOLINE builds. For details, see
<a href="https://github.com/llvm/llvm-project/commit/6f867f9102838ebe314c1f3661fdf95700386e5a">LLVM commit 6f867f910283</a> (“[X86] Support <code>-mindirect-branch-cs-prefix</code> for
call and jmp to indirect thunk”) which introduces the feature.</p>
<p>Only x86 and x86_64 are supported.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="instrument-xray"><a class="header" href="#instrument-xray"><code>instrument-xray</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/102921">#102921</a>.</p>
<hr>
<p>Enable generation of NOP sleds for XRay function tracing instrumentation.
For more information on XRay,
read <a href="https://llvm.org/docs/XRay.html">LLVM documentation</a>,
and/or the <a href="http://research.google.com/pubs/pub45287.html">XRay whitepaper</a>.</p>
<p>Set the <code>-Z instrument-xray</code> compiler flag in order to enable XRay instrumentation.</p>
<ul>
<li><code>-Z instrument-xray</code> – use the default settings</li>
<li><code>-Z instrument-xray=skip-exit</code> – configure a custom setting</li>
<li><code>-Z instrument-xray=ignore-loops,instruction-threshold=300</code> –
multiple settings separated by commas</li>
</ul>
<p>Supported options:</p>
<ul>
<li><code>always</code> – force instrumentation of all functions</li>
<li><code>never</code> – do no instrument any functions</li>
<li><code>ignore-loops</code> – ignore presence of loops,
instrument functions based only on instruction count</li>
<li><code>instruction-threshold=10</code> – set a different instruction threshold for instrumentation</li>
<li><code>skip-entry</code> – do no instrument function entry</li>
<li><code>skip-exit</code> – do no instrument function exit</li>
</ul>
<p>The default settings are:</p>
<ul>
<li>instrument both entry &amp; exit from functions</li>
<li>instrument functions with at least 200 instructions,
or containing a non-trivial loop</li>
</ul>
<p>Note that <code>-Z instrument-xray</code> only enables generation of NOP sleds
which on their own don’t do anything useful.
In order to actually trace the functions,
you will need to link a separate runtime library of your choice,
such as Clang’s <a href="https://www.llvm.org/docs/XRay.html#xray-runtime-library">XRay Runtime Library</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="large-data-threshold"><a class="header" href="#large-data-threshold"><code>large-data-threshold</code></a></h1>
<hr>
<p>This flag controls the threshold for static data to be placed in large data
sections when using the <code>medium</code> code model on x86-64.</p>
<p>When using <code>-Ccode-model=medium</code>, static data smaller than this threshold will
use RIP-relative addressing (32-bit offsets), while larger data will use
absolute 64-bit addressing. This allows the compiler to generate more efficient
code for smaller data while still supporting data larger than 2GB.</p>
<p>The default threshold is 65536 bytes (64KB) if not specified.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-sh">rustc -Ccode-model=medium -Zlarge-data-threshold=1024 main.rs
</code></pre>
<p>This sets the threshold to 1KB, meaning only data smaller than 1024 bytes will
use RIP-relative addressing.</p>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h2>
<p>This flag is only effective on x86-64 targets when using <code>-Ccode-model=medium</code>.
On other architectures or with other code models, this flag has no effect.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="link-native-libraries"><a class="header" href="#link-native-libraries"><code>link-native-libraries</code></a></h1>
<p>This option allows ignoring libraries specified in <code>#[link]</code> attributes instead of passing them to the linker.
This can be useful in build systems that manage native libraries themselves and pass them manually,
e.g. with <code>-Clink-arg</code>.</p>
<ul>
<li><code>yes</code> - Pass native libraries to the linker. Default.</li>
<li><code>no</code> - Don’t pass native libraries to the linker.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lint-llvm-ir"><a class="header" href="#lint-llvm-ir"><code>lint-llvm-ir</code></a></h1>
<hr>
<p>This flag will add <code>LintPass</code> to the start of the pipeline.
You can use it to check for common errors in the LLVM IR generated by <code>rustc</code>.
You can add <code>-Cllvm-args=-lint-abort-on-error</code> to abort the process if errors were found.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="llvm-module-flag"><a class="header" href="#llvm-module-flag"><code>llvm-module-flag</code></a></h1>
<hr>
<p>This flag allows adding a key/value to the <code>!llvm.module.flags</code> metadata in the
LLVM-IR for a compiled Rust module.  The syntax is</p>
<p><code>-Z llvm_module_flag=&lt;name&gt;:&lt;type&gt;:&lt;value&gt;:&lt;behavior&gt;</code></p>
<p>Currently only u32 values are supported but the type is required to be specified
for forward compatibility.  The <code>behavior</code> element must match one of the named
LLVM <a href="https://llvm.org/docs/LangRef.html#module-flags-metadata">metadata behaviors</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="location-detail"><a class="header" href="#location-detail"><code>location-detail</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/70580">#70580</a>.</p>
<hr>
<p>Option <code>-Z location-detail=val</code> controls what location details are tracked when
using <code>caller_location</code>. This allows users to control what location details
are printed as part of panic messages, by allowing them to exclude any combination
of filenames, line numbers, and column numbers. This option is intended to provide
users with a way to mitigate the size impact of <code>#[track_caller]</code>.</p>
<p>This option supports a comma separated list of location details to be included. Valid options
within this list are:</p>
<ul>
<li><code>file</code> - the filename of the panic will be included in the panic output</li>
<li><code>line</code> - the source line of the panic will be included in the panic output</li>
<li><code>column</code> - the source column of the panic will be included in the panic output</li>
</ul>
<p>Any combination of these three options are supported. Alternatively, you can pass
<code>none</code> to this option, which results in no location details being tracked.
If this option is not specified, all three are included by default.</p>
<p>An example of a panic output when using <code>-Z location-detail=line</code>:</p>
<pre><code class="language-text">panicked at 'Process blink had a fault', &lt;redacted&gt;:323:0
</code></pre>
<p>The code size savings from this option are two-fold. First, the <code>&amp;'static str</code> values
for each path to a file containing a panic are removed from the binary. For projects
with deep directory structures and many files with panics, this can add up. This category
of savings can only be realized by excluding filenames from the panic output. Second,
savings can be realized by allowing multiple panics to be fused into a single panicking
branch. It is often the case that within a single file, multiple panics with the same
panic message exist – e.g. two calls to <code>Option::unwrap()</code> in a single line, or
two calls to <code>Result::expect()</code> on adjacent lines. If column and line information
are included in the <code>Location</code> struct passed to the panic handler, these branches cannot
be fused, as the output is different depending on which panic occurs. However if line
and column information is identical for all panics, these branches can be fused, which
can lead to substantial code size savings, especially for small embedded binaries with
many panics.</p>
<p>The savings from this option are amplified when combined with the use of <code>-Zbuild-std</code>, as
otherwise paths for panics within the standard library are still included in your binary.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="macro-stats"><a class="header" href="#macro-stats"><code>macro-stats</code></a></h1>
<p>This feature is perma-unstable and has no tracking issue.</p>
<hr>
<p>Some macros, especially procedural macros, can generate a surprising amount of
code, which can slow down compile times. This is hard to detect because the
generated code is normally invisible to the programmer.</p>
<p>This flag helps identify such cases. When enabled, the compiler measures the
effect on code size of all used macros and prints a table summarizing that
effect. For each distinct macro, it counts how many times it is used, and how
much code it produces when expanded (in lines of code, and bytes of code). The
code size evaluation uses the compiler’s internal pretty-printing, and so will
be independent of the formatting in the original code.</p>
<p>Note that the output size of a macro may be zero. E.g. the <code>cfg!</code> and
<code>#[test]</code> macros often strip out code.</p>
<p>If a macro is identified as causing a large increase in code size, it is worth
using <code>cargo expand</code> to inspect the post-expansion code, which includes the
code produced by all macros. It may be possible to optimize the macro to
produce smaller code, or it may be possible to avoid using it altogether.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="min-function-alignment"><a class="header" href="#min-function-alignment"><code>min-function-alignment</code></a></h1>
<p>The tracking issue for this feature is: https://github.com/rust-lang/rust/issues/82232.</p>
<hr>
<p>The <code>-Zmin-function-alignment=&lt;align&gt;</code> flag specifies the minimum alignment of functions for which code is generated.
The <code>align</code> value must be a power of 2, other values are rejected.</p>
<p>Note that <code>-Zbuild-std</code> (or similar) is required to apply this minimum alignment to standard library functions.
By default, these functions come precompiled and their alignments won’t respect the <code>min-function-alignment</code> flag.</p>
<p>This flag is equivalent to:</p>
<ul>
<li><code>-fmin-function-alignment</code> for <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-fmin-function-alignment_003dn">GCC</a></li>
<li><code>-falign-functions</code> for <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang1-falign-functions">Clang</a></li>
</ul>
<p>The specified alignment is a minimum. A higher alignment can be specified for specific functions by using the <a href="https://github.com/rust-lang/rust/issues/82232"><code>align(...)</code></a> feature and annotating the function with a <code>#[align(&lt;align&gt;)]</code> attribute. The attribute’s value is ignored when it is lower than the value passed to <code>min-function-alignment</code>.</p>
<p>There are two additional edge cases for this flag:</p>
<ul>
<li>targets have a minimum alignment for functions (e.g. on x86_64 the lowest that LLVM generates is 16 bytes).
A <code>min-function-alignment</code> value lower than the target’s minimum has no effect.</li>
<li>the maximum alignment supported by rust (and LLVM) is <code>2^29</code>. Trying to set a higher value results in an error.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="move_size_limit"><a class="header" href="#move_size_limit"><code>move_size_limit</code></a></h1>
<hr>
<p>The <code>-Zmove-size-limit=N</code> compiler flag enables <code>large_assignments</code> lints which
will warn when moving objects whose size exceeds <code>N</code> bytes.</p>
<p>Lint warns only about moves in functions that participate in code generation.
Consequently it will be ineffective for compiler invocation that emit
metadata only, i.e., <code>cargo check</code> like workflows.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="no-parallel-llvm"><a class="header" href="#no-parallel-llvm"><code>no-parallel-llvm</code></a></h1>
<hr>
<p>This flag disables parallelization of codegen and linking, while otherwise preserving
behavior with regard to codegen units and LTO.</p>
<p>This flag is not useful for regular users, but it can be useful for debugging the backend. Codegen issues commonly only manifest under specific circumstances, e.g. if multiple codegen units are used and ThinLTO is enabled. Serialization of these threaded configurations makes the use of LLVM debugging facilities easier, by avoiding the interleaving of output.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="no-steal-thir"><a class="header" href="#no-steal-thir"><code>no-steal-thir</code></a></h1>
<p>By default, to save on memory, the THIR body (obtained from the <code>tcx.thir_body</code> query) is stolen
once no longer used. This is inconvenient for authors of rustc drivers who want to access the THIR.</p>
<p>This option disables the stealing. This has no observable effect on compiler behavior, only on
memory usage.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="no-unique-section-names"><a class="header" href="#no-unique-section-names"><code>no-unique-section-names</code></a></h1>
<hr>
<p>This flag currently applies only to ELF-based targets using the LLVM codegen backend. It prevents the generation of unique ELF section names for each separate code and data item when <code>-Z function-sections</code> is also in use, which is the default for most targets. This option can reduce the size of object files, and depending on the linker, the final ELF binary as well.</p>
<p>For example, a function <code>func</code> will by default generate a code section called <code>.text.func</code>. Normally this is fine because the linker will merge all those <code>.text.*</code> sections into a single one in the binary. However, starting with <a href="https://github.com/llvm/llvm-project/commit/ee5d1a04">LLVM 12</a>, the backend will also generate unique section names for exception handling, so you would see a section name of <code>.gcc_except_table.func</code> in the object file and potentially in the final ELF binary, which could add significant bloat to programs that contain many functions.</p>
<p>This flag instructs LLVM to use the same <code>.text</code> and <code>.gcc_except_table</code> section name for each function, and it is analogous to Clang’s <code>-fno-unique-section-names</code> option.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="offload"><a class="header" href="#offload"><code>offload</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/131513">#131513</a>.</p>
<hr>
<p>This feature will later allow you to run functions on GPUs. It is work in progress.
Set the <code>-Zoffload=Enable</code> compiler flag to experiment with it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="on-broken-pipe"><a class="header" href="#on-broken-pipe"><code>on-broken-pipe</code></a></h1>
<hr>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/97889">#97889</a></p>
<p>Note: The ui for this feature was previously an attribute named <code>#[unix_sigpipe = "..."]</code>.</p>
<hr>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The <code>-Zon-broken-pipe=...</code> compiler flag can be used to specify how libstd shall setup <code>SIGPIPE</code> on Unix platforms before invoking <code>fn main()</code>. This flag is ignored on non-Unix targets. The flag can be used with three different values or be omitted entirely. It affects <code>SIGPIPE</code> before <code>fn main()</code> and before children get <code>exec()</code>’ed:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Compiler flag</th><th><code>SIGPIPE</code> before <code>fn main()</code></th><th><code>SIGPIPE</code> before child <code>exec()</code></th></tr>
</thead>
<tbody>
<tr><td>not used</td><td><code>SIG_IGN</code></td><td><code>SIG_DFL</code></td></tr>
<tr><td><code>-Zon-broken-pipe=kill</code></td><td><code>SIG_DFL</code></td><td>not touched</td></tr>
<tr><td><code>-Zon-broken-pipe=error</code></td><td><code>SIG_IGN</code></td><td>not touched</td></tr>
<tr><td><code>-Zon-broken-pipe=inherit</code></td><td>not touched</td><td>not touched</td></tr>
</tbody>
</table>
</div>
<h2 id="-zon-broken-pipe-not-used"><a class="header" href="#-zon-broken-pipe-not-used"><code>-Zon-broken-pipe</code> not used</a></h2>
<p>If <code>-Zon-broken-pipe</code> is not used, libstd will behave in the manner it has since 2014, before Rust 1.0. <code>SIGPIPE</code> will be set to <code>SIG_IGN</code> before <code>fn main()</code> and result in <code>EPIPE</code> errors which are converted to <code>std::io::ErrorKind::BrokenPipe</code>.</p>
<p>When spawning child processes, <code>SIGPIPE</code> will be set to <code>SIG_DFL</code> before doing the underlying <code>exec()</code> syscall.</p>
<h2 id="-zon-broken-pipekill"><a class="header" href="#-zon-broken-pipekill"><code>-Zon-broken-pipe=kill</code></a></h2>
<p>Set the <code>SIGPIPE</code> handler to <code>SIG_DFL</code> before invoking <code>fn main()</code>. This will result in your program getting killed if it tries to write to a closed pipe. This is normally what you want if your program produces textual output.</p>
<p>When spawning child processes, <code>SIGPIPE</code> will not be touched. This normally means child processes inherit <code>SIG_DFL</code> for <code>SIGPIPE</code>.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre class="playground"><code class="language-rust no_run">fn main() {
    loop {
        println!("hello world");
    }
}</code></pre>
<pre><code class="language-console">$ rustc -Zon-broken-pipe=kill main.rs
$ ./main | head -n1
hello world
</code></pre>
<h2 id="-zon-broken-pipeerror"><a class="header" href="#-zon-broken-pipeerror"><code>-Zon-broken-pipe=error</code></a></h2>
<p>Set the <code>SIGPIPE</code> handler to <code>SIG_IGN</code> before invoking <code>fn main()</code>. This will result in <code>ErrorKind::BrokenPipe</code> errors if you program tries to write to a closed pipe. This is normally what you want if you for example write socket servers, socket clients, or pipe peers.</p>
<p>When spawning child processes, <code>SIGPIPE</code> will not be touched. This normally means child processes inherit <code>SIG_IGN</code> for <code>SIGPIPE</code>.</p>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example</a></h3>
<pre class="playground"><code class="language-rust no_run">fn main() {
    loop {
        println!("hello world");
    }
}</code></pre>
<pre><code class="language-console">$ rustc -Zon-broken-pipe=error main.rs
$ ./main | head -n1
hello world
thread 'main' panicked at library/std/src/io/stdio.rs:1118:9:
failed printing to stdout: Broken pipe (os error 32)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<h2 id="-zon-broken-pipeinherit"><a class="header" href="#-zon-broken-pipeinherit"><code>-Zon-broken-pipe=inherit</code></a></h2>
<p>Leave <code>SIGPIPE</code> untouched before entering <code>fn main()</code>. Unless the parent process has changed the default <code>SIGPIPE</code> handler from <code>SIG_DFL</code> to something else, this will behave the same as <code>-Zon-broken-pipe=kill</code>.</p>
<p>When spawning child processes, <code>SIGPIPE</code> will not be touched. This normally means child processes inherit <code>SIG_DFL</code> for <code>SIGPIPE</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="patchable-function-entry"><a class="header" href="#patchable-function-entry"><code>patchable-function-entry</code></a></h1>
<hr>
<p>The <code>-Z patchable-function-entry=total_nops,prefix_nops</code> or <code>-Z patchable-function-entry=total_nops</code>
compiler flag enables nop padding of function entries with ‘total_nops’ nops, with
an offset for the entry of the function at ‘prefix_nops’ nops. In the second form,
‘prefix_nops’ defaults to 0.</p>
<p>As an illustrative example, <code>-Z patchable-function-entry=3,2</code> would produce:</p>
<pre><code class="language-text">nop
nop
function_label:
nop
//Actual function code begins here
</code></pre>
<p>This flag is used for hotpatching, especially in the Linux kernel. The flag
arguments are modeled after the <code>-fpatchable-function-entry</code> flag as defined
for both <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fpatchable-function-entry">Clang</a>
and <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html#index-fpatchable-function-entry">gcc</a>
and is intended to provide the same effect.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="printcheck-cfg"><a class="header" href="#printcheck-cfg"><code>print=check-cfg</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/125704">#125704</a>.</p>
<hr>
<p>This option of the <code>--print</code> flag print the list of all the expected cfgs.</p>
<p>This is related to the <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg.html"><code>--check-cfg</code> flag</a> which allows specifying arbitrary expected
names and values.</p>
<p>This print option outputs compatible <code>--check-cfg</code> arguments with a reduced syntax where all the
expected values are on the same line and <code>values(...)</code> is always explicit.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>--check-cfg</code></th><th><code>--print=check-cfg</code></th></tr>
</thead>
<tbody>
<tr><td><code>cfg(foo)</code></td><td>`cfg(foo, values(none()))</td></tr>
<tr><td><code>cfg(foo, values("bar"))</code></td><td><code>cfg(foo, values("bar"))</code></td></tr>
<tr><td><code>cfg(foo, values(none(), "bar"))</code></td><td><code>cfg(foo, values(none(), "bar"))</code></td></tr>
<tr><td><code>cfg(foo, values(any())</code></td><td><code>cfg(foo, values(any())</code></td></tr>
<tr><td><code>cfg(foo, values())</code></td><td><code>cfg(foo, values())</code></td></tr>
<tr><td><code>cfg(any())</code></td><td><code>cfg(any())</code></td></tr>
<tr><td><em>nothing</em></td><td><em>nothing</em></td></tr>
</tbody>
</table>
</div>
<p>The print option includes well known cfgs.</p>
<p>To be used like this:</p>
<pre><code class="language-bash">rustc --print=check-cfg -Zunstable-options lib.rs
</code></pre>
<blockquote>
<p><strong>Note:</strong> Users should be resilient when parsing, in particular against new predicates that
may be added in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="printcrate-root-lint-levels"><a class="header" href="#printcrate-root-lint-levels"><code>print=crate-root-lint-levels</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139180">#139180</a>.</p>
<hr>
<p>This option of the <code>--print</code> flag print the list of lints with print out all the lints and their associated levels (<code>allow</code>, <code>warn</code>, <code>deny</code>, <code>forbid</code>) based on the regular Rust rules at crate root, that is <em>(roughly)</em>:</p>
<ul>
<li>command line args (<code>-W</code>, <code>-A</code>, <code>--force-warn</code>, <code>--cap-lints</code>, …)</li>
<li>crate root attributes (<code>#![allow]</code>, <code>#![warn]</code>, <code>#[expect]</code>, …)</li>
<li><em>the special <code>warnings</code> lint group</em></li>
<li>the default lint level</li>
</ul>
<p>The output format is <code>LINT_NAME=LINT_LEVEL</code>, e.g.:</p>
<pre><code class="language-text">unknown_lint=warn
arithmetic_overflow=deny
</code></pre>
<p>To be used like this:</p>
<pre><code class="language-bash">rustc --print=crate-root-lint-levels -Zunstable-options lib.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="printsupported-crate-types"><a class="header" href="#printsupported-crate-types"><code>print=supported-crate-types</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138640">#138640</a>.</p>
<hr>
<p>This option of the <code>--print</code> flag produces a list of crate types (delimited by newlines) supported for the given target.</p>
<p>The crate type strings correspond to the values accepted by the <code>--crate-type</code> flag.</p>
<p>Intended to be used like this:</p>
<pre><code class="language-bash">rustc --print=supported-crate-types -Zunstable-options --target=x86_64-unknown-linux-gnu
</code></pre>
<p>Example output for <code>x86_64-unknown-linux-gnu</code>:</p>
<pre><code class="language-text">bin
cdylib
dylib
lib
proc-macro
rlib
staticlib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="profile-sample-use"><a class="header" href="#profile-sample-use"><code>profile-sample-use</code></a></h1>
<hr>
<p><code>-Zprofile-sample-use=code.prof</code> directs <code>rustc</code> to use the profile
<code>code.prof</code> as a source for Automatic Feedback Directed Optimization (AFDO).
See the documentation of <a href="#debug-info-for-profiling"><code>-Zdebug-info-for-profiling</code></a> for more information
on using AFDO.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="randomize-layout"><a class="header" href="#randomize-layout"><code>randomize-layout</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/106764">#106764</a>.</p>
<hr>
<p>The <code>-Zrandomize-layout</code> flag changes the layout algorithm for <code>repr(Rust)</code> types defined in the current crate from its normal
optimization goals to pseudorandomly rearranging fields within the degrees of freedom provided by the largely unspecified
default representation. This also affects type sizes and padding.
Downstream instantiations of generic types defined in a crate with randomization enabled will also be randomized.</p>
<p>It can be used to find unsafe code that accidentally relies on unspecified behavior.</p>
<p>Randomization is not guaranteed to use a different permutation for each compilation session.
<code>-Zlayout-seed=&lt;u64&gt;</code> can be used to supply additional entropy.</p>
<p>Randomization only approximates the intended freedom of repr(Rust). Sometimes two distinct types may still consistently
result in the same layout due to limitations of the current implementation. Randomization may become
more aggressive over time as our coverage of the available degrees of freedoms improves.
Corollary: Randomization is not a safety oracle. Two struct layouts being observably the same under different layout seeds
on the current compiler version does not guarantee that future compiler versions won’t give them distinct layouts.</p>
<p>Randomization may also become less aggressive in the future if additional guarantees get added to the default layout.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reg-struct-return"><a class="header" href="#reg-struct-return"><code>reg-struct-return</code></a></h1>
<p>The tracking issue for this feature is: https://github.com/rust-lang/rust/issues/116973.</p>
<hr>
<p>Option -Zreg-struct-return causes the compiler to return small structs in registers
instead of on the stack for extern “C”-like functions.
It is UNSOUND to link together crates that use different values for this flag.
It is only supported on <code>x86</code>.</p>
<p>It is equivalent to <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-freg-struct-return">Clang</a>’s and <a href="https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-freg-struct-return">GCC</a>’s <code>-freg-struct-return</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="regparm"><a class="header" href="#regparm"><code>regparm</code></a></h1>
<p>The tracking issue for this feature is: https://github.com/rust-lang/rust/issues/131749.</p>
<hr>
<p>Option -Zregparm=N causes the compiler to pass N arguments
in registers EAX, EDX, and ECX instead of on the stack for “C”, “cdecl”, and “stdcall” fn.
It is UNSOUND to link together crates that use different values for this flag.
It is only supported on <code>x86</code>.</p>
<p>It is equivalent to <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-mregparm">Clang</a>’s and <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html#index-regparm-function-attribute_002c-x86">GCC</a>’s <code>-mregparm</code>.</p>
<p>Supported values for this option are 0-3.</p>
<p>Implementation details:
For eligible arguments, llvm <code>inreg</code> attribute is set.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="remap-cwd-prefix"><a class="header" href="#remap-cwd-prefix"><code>remap-cwd-prefix</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87325">#87325</a>.</p>
<hr>
<p>This flag will rewrite absolute paths under the current working directory,
replacing the current working directory prefix with a specified value.</p>
<p>The given value may be absolute or relative, or empty. This switch takes
precedence over <code>--remap-path-prefix</code> in case they would both match a given
path.</p>
<p>This flag helps to produce deterministic output, by removing the current working
directory from build output, while allowing the command line to be universally
reproducible, such that the same execution will work on all machines, regardless
of build environment.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><code class="language-sh"># This would produce an absolute path to main.rs in build outputs of
# "./main.rs".
rustc -Z remap-cwd-prefix=. main.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="report-time"><a class="header" href="#report-time"><code>report-time</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/64888">#64888</a></p>
<hr>
<p>The <code>report-time</code> feature adds a possibility to report execution time of the
tests generated via <code>libtest</code>.</p>
<p>This is unstable feature, so you have to provide <code>-Zunstable-options</code> to get
this feature working.</p>
<p>Sample usage command:</p>
<pre><code class="language-sh">./test_executable -Zunstable-options --report-time
</code></pre>
<p>Available options:</p>
<pre><code class="language-sh">--report-time
                Show execution time of each test.
                Threshold values for colorized output can be
                configured via
                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`
                and
                `RUST_TEST_TIME_DOCTEST` environment variables.
                Expected format of environment variable is
                `VARIABLE=WARN_TIME,CRITICAL_TIME`.
                Not available for --format=terse
--ensure-time
                Treat excess of the test execution time limit as
                error.
                Threshold values for this option can be configured via
                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`
                and
                `RUST_TEST_TIME_DOCTEST` environment variables.
                Expected format of environment variable is
                `VARIABLE=WARN_TIME,CRITICAL_TIME`.
                `CRITICAL_TIME` here means the limit that should not be
                exceeded by test.
</code></pre>
<p>Example of the environment variable format:</p>
<pre><code class="language-sh">RUST_TEST_TIME_UNIT=100,200
</code></pre>
<p>where 100 stands for warn time, and 200 stands for critical time.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<pre><code class="language-sh">cargo test --tests -- -Zunstable-options --report-time
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running target/debug/deps/example-27fb188025bec02c

running 3 tests
test tests::unit_test_quick ... ok &lt;0.000s&gt;
test tests::unit_test_warn ... ok &lt;0.055s&gt;
test tests::unit_test_critical ... ok &lt;0.110s&gt;

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/tests-cedb06f6526d15d9

running 3 tests
test unit_test_quick ... ok &lt;0.000s&gt;
test unit_test_warn ... ok &lt;0.550s&gt;
test unit_test_critical ... ok &lt;1.100s&gt;

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sanitizer"><a class="header" href="#sanitizer"><code>sanitizer</code></a></h1>
<p>Sanitizers are tools that help detect and prevent various types of bugs and
vulnerabilities in software. They are available in compilers and work by
instrumenting the code to add additional runtime checks. While they provide
powerful tools for identifying bugs or security issues, it’s important to note
that using sanitizers can introduce runtime overhead and might not catch all
possible issues. Therefore, they are typically used alongside other best
practices in software development, such as testing and fuzzing, to ensure the
highest level of software quality and security.</p>
<p>The tracking issues for this feature are:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/39699">#39699</a>.</li>
<li><a href="https://github.com/rust-lang/rust/issues/89653">#89653</a>.</li>
</ul>
<hr>
<p>This feature allows for use of one of following sanitizers:</p>
<ul>
<li>
<p>Those intended for testing or fuzzing (but not production use):</p>
<ul>
<li><a href="#addresssanitizer">AddressSanitizer</a> a fast memory error detector.</li>
<li><a href="#hwaddresssanitizer">HWAddressSanitizer</a> a memory error detector similar to
AddressSanitizer, but based on partial hardware assistance.</li>
<li><a href="#leaksanitizer">LeakSanitizer</a> a run-time memory leak detector.</li>
<li><a href="#memorysanitizer">MemorySanitizer</a> a detector of uninitialized reads.</li>
<li><a href="#realtimesanitizer">RealtimeSanitizer</a> a detector of calls to function with
non-deterministic execution time in realtime contexts.</li>
<li><a href="#threadsanitizer">ThreadSanitizer</a> a fast data race detector.</li>
</ul>
</li>
<li>
<p>Those that apart from testing, may be used in production:</p>
<ul>
<li><a href="#controlflowintegrity">ControlFlowIntegrity</a> LLVM Control Flow Integrity
(CFI) provides forward-edge control flow protection.</li>
<li><a href="#dataflowsanitizer">DataFlowSanitizer</a> a generic dynamic data flow analysis
framework.</li>
<li><a href="#kernelcontrolflowintegrity">KernelControlFlowIntegrity</a> LLVM Kernel
Control Flow Integrity (KCFI) provides forward-edge control flow protection
for operating systems kernels.</li>
<li><a href="#memtagsanitizer">MemTagSanitizer</a> fast memory error detector based on
Armv8.5-A Memory Tagging Extension.</li>
<li><a href="#safestack">SafeStack</a> provides backward-edge control flow protection by
separating the stack into safe and unsafe regions.</li>
<li><a href="#shadowcallstack">ShadowCallStack</a> provides backward-edge control flow
protection (aarch64 only).</li>
</ul>
</li>
</ul>
<p>To enable a sanitizer compile with <code>-Zsanitizer=address</code>, <code>-Zsanitizer=cfi</code>,
<code>-Zsanitizer=dataflow</code>,<code>-Zsanitizer=hwaddress</code>, <code>-Zsanitizer=leak</code>,
<code>-Zsanitizer=memory</code>, <code>-Zsanitizer=memtag</code>, <code>-Zsanitizer=realtime</code>,
<code>-Zsanitizer=shadow-call-stack</code> or <code>-Zsanitizer=thread</code>. You might also need the
<code>--target</code> and <code>build-std</code> flags. If you’re working with other languages that are also
instrumented with sanitizers, you might need the <code>external-clangrt</code> flag. See
the section on <a href="#working-with-other-languages">working with other languages</a>.</p>
<p>Example:</p>
<pre><code class="language-shell">$ RUSTFLAGS=-Zsanitizer=address cargo build -Zbuild-std --target x86_64-unknown-linux-gnu
</code></pre>
<p>Additional options for sanitizers can be passed to LLVM command line argument
processor via LLVM arguments using <code>llvm-args</code> codegen option (e.g.,
<code>-Cllvm-args=-dfsan-combine-pointer-labels-on-load=false</code>). See the sanitizer
documentation for more information about additional options.</p>
<h1 id="addresssanitizer"><a class="header" href="#addresssanitizer">AddressSanitizer</a></h1>
<p>AddressSanitizer is a memory error detector. It can detect the following types
of bugs:</p>
<ul>
<li>Out of bound accesses to heap, stack and globals</li>
<li>Use after free</li>
<li>Use after return (runtime flag <code>ASAN_OPTIONS=detect_stack_use_after_return=1</code>)</li>
<li>Use after scope</li>
<li>Double-free, invalid free</li>
<li>Memory leaks</li>
</ul>
<p>The memory leak detection is enabled by default on Linux, and can be enabled
with runtime flag <code>ASAN_OPTIONS=detect_leaks=1</code> on macOS.</p>
<p>AddressSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-apple-darwin</code></li>
<li><code>aarch64-unknown-fuchsia</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-apple-darwin</code></li>
<li><code>x86_64-unknown-fuchsia</code></li>
<li><code>x86_64-unknown-freebsd</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>AddressSanitizer works with non-instrumented code although it will impede its
ability to detect some bugs.  It is not expected to produce false positive
reports.</p>
<p>See the <a href="https://clang.llvm.org/docs/AddressSanitizer.html">Clang AddressSanitizer documentation</a> for more details.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>Stack buffer overflow:</p>
<pre class="playground"><code class="language-rust">fn main() {
    let xs = [0, 1, 2, 3];
    let _y = unsafe { *xs.as_ptr().offset(4) };
}</code></pre>
<pre><code class="language-shell">$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208
READ of size 4 at 0x7ffe400e6250 thread T0
    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23
    ...

Address 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame
    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1

  This frame has 1 object(s):
    [32, 48) 'xs' (line 2) &lt;== Memory access at offset 48 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2
Shadow bytes around the buggy address:
  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00
  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00
  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==37882==ABORTING
</code></pre>
<p>Use of a stack object after its scope has already ended:</p>
<pre class="playground"><code class="language-rust">static mut P: *mut usize = std::ptr::null_mut();

fn main() {
    unsafe {
        {
            let mut x = 0;
            P = &amp;mut x;
        }
        std::ptr::write_volatile(P, 123);
    }
}</code></pre>
<pre><code class="language-shell">$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
=================================================================
==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048
WRITE of size 8 at 0x7ffc7ed3e1a0 thread T0
    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5
    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9
    ...

Address 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame
    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3

  This frame has 1 object(s):
    [32, 40) 'x' (line 6) &lt;== Memory access at offset 32 is inside this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a
Shadow bytes around the buggy address:
  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00
  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1
  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3
  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==39249==ABORTING
</code></pre>
<h1 id="controlflowintegrity"><a class="header" href="#controlflowintegrity">ControlFlowIntegrity</a></h1>
<p>The LLVM CFI support in the Rust compiler provides forward-edge control flow
protection for both Rust-compiled code only and for C or C++ and Rust -compiled
code mixed-language binaries, also known as “mixed binaries” (i.e., for when C
or C++ and Rust -compiled code share the same virtual address space), by
aggregating function pointers in groups identified by their return and parameter
types.</p>
<p>LLVM CFI can be enabled with <code>-Zsanitizer=cfi</code> and requires LTO (i.e.,
<code>-Clinker-plugin-lto</code> or <code>-Clto</code>). Cross-language LLVM CFI can be enabled with
<code>-Zsanitizer=cfi</code>, and requires the <code>-Zsanitizer-cfi-normalize-integers</code> option
to be used with Clang <code>-fsanitize-cfi-icall-experimental-normalize-integers</code>
option for cross-language LLVM CFI support, and proper (i.e., non-rustc) LTO
(i.e., <code>-Clinker-plugin-lto</code>).</p>
<p>It is recommended to rebuild the standard library with CFI enabled by using the
Cargo build-std feature (i.e., <code>-Zbuild-std</code>) when enabling CFI.</p>
<p>See the <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">Clang ControlFlowIntegrity documentation</a> for more details.</p>
<h2 id="example-1-redirecting-control-flow-using-an-indirect-branchcall-to-an-invalid-destination"><a class="header" href="#example-1-redirecting-control-flow-using-an-indirect-branchcall-to-an-invalid-destination">Example 1: Redirecting control flow using an indirect branch/call to an invalid destination</a></h2>
<pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[unsafe(naked)]
<span class="boring">#[cfg(all(target_os = "linux", target_arch = "x86_64"))]
</span>pub extern "sysv64" fn add_two(x: i32) {
    // x + 2 preceded by a landing pad/nop block
    std::arch::naked_asm!(
        "
         nop
         nop
         nop
         nop
         nop
         nop
         nop
         nop
         nop
         lea eax, [rdi+2]
         ret
        "
    );
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);

<span class="boring">  #[cfg(all(target_os = "linux", target_arch = "x86_64"))] {
</span>        println!("With CFI enabled, you should not see the next answer");
        let f: fn(i32) -&gt; i32 = unsafe {
            // Offset 0 is a valid branch/call destination (i.e., the function entry
            // point), but offsets 1-8 within the landing pad/nop block are invalid
            // branch/call destinations (i.e., within the body of the function).
            std::mem::transmute::&lt;*const u8, fn(i32) -&gt; i32&gt;((add_two as *const u8).offset(5))
        };
        let next_answer = do_twice(f, 5);

        println!("The next answer is: {}", next_answer);
<span class="boring">  }
</span>}</code></pre>
<p>Fig. 1. Redirecting control flow using an indirect branch/call to an invalid
destination (i.e., within the body of the function).</p>
<pre><code class="language-shell">$ cargo run --release
   Compiling rust-cfi-1 v0.1.0 (/home/rcvalle/rust-cfi-1)
    Finished release [optimized] target(s) in 0.42s
     Running `target/release/rust-cfi-1`
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 2. Build and execution of Fig. 1 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ RUSTFLAGS="-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-1 v0.1.0 (/home/rcvalle/rust-cfi-1)
    Finished release [optimized] target(s) in 1m 08s
     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-1`
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 3. Build and execution of Fig. 1 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to change/hijack control
flow using an indirect branch/call to an invalid destination, the execution is
terminated (see Fig. 3).</p>
<h2 id="example-2-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-a-different-number-of-parameters"><a class="header" href="#example-2-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-a-different-number-of-parameters">Example 2: Redirecting control flow using an indirect branch/call to a function with a different number of parameters</a></h2>
<pre class="playground"><code class="language-rust">use std::mem;

fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn add_two(x: i32, _y: i32) -&gt; i32 {
    x + 2
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);

    println!("With CFI enabled, you should not see the next answer");
    let f: fn(i32) -&gt; i32 =
        unsafe { mem::transmute::&lt;*const u8, fn(i32) -&gt; i32&gt;(add_two as *const u8) };
    let next_answer = do_twice(f, 5);

    println!("The next answer is: {}", next_answer);
}</code></pre>
<p>Fig. 4. Redirecting control flow using an indirect branch/call to a function
with a different number of parameters than arguments intended/passed in the
call/branch site.</p>
<pre><code class="language-shell">$ cargo run --release
   Compiling rust-cfi-2 v0.1.0 (/home/rcvalle/rust-cfi-2)
    Finished release [optimized] target(s) in 0.43s
     Running `target/release/rust-cfi-2`
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 5. Build and execution of Fig. 4 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ RUSTFLAGS="-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-2 v0.1.0 (/home/rcvalle/rust-cfi-2)
    Finished release [optimized] target(s) in 1m 08s
     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-2`
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 6. Build and execution of Fig. 4 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to change/hijack control
flow using an indirect branch/call to a function with different number of
parameters than arguments intended/passed in the call/branch site, the
execution is also terminated (see Fig. 6).</p>
<h2 id="example-3-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types"><a class="header" href="#example-3-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types">Example 3: Redirecting control flow using an indirect branch/call to a function with different return and parameter types</a></h2>
<pre class="playground"><code class="language-rust">use std::mem;

fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn add_two(x: i64) -&gt; i64 {
    x + 2
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);

    println!("With CFI enabled, you should not see the next answer");
    let f: fn(i32) -&gt; i32 =
        unsafe { mem::transmute::&lt;*const u8, fn(i32) -&gt; i32&gt;(add_two as *const u8) };
    let next_answer = do_twice(f, 5);

    println!("The next answer is: {}", next_answer);
}</code></pre>
<p>Fig. 7. Redirecting control flow using an indirect branch/call to a function
with different return and parameter types than the return type expected and
arguments intended/passed at the call/branch site.</p>
<pre><code class="language-shell">$ cargo run --release
   Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)
    Finished release [optimized] target(s) in 0.44s
     Running `target/release/rust-cfi-3`
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 8. Build and execution of Fig. 7 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ RUSTFLAGS="-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi" cargo run -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)
    Finished release [optimized] target(s) in 1m 07s
     Running `target/x86_64-unknown-linux-gnu/release/rust-cfi-3`
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 9. Build and execution of Fig. 7 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to change/hijack control
flow using an indirect branch/call to a function with different return and
parameter types than the return type expected and arguments intended/passed in
the call/branch site, the execution is also terminated (see Fig. 9).</p>
<h2 id="example-4-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types-across-the-ffi-boundary"><a class="header" href="#example-4-redirecting-control-flow-using-an-indirect-branchcall-to-a-function-with-different-return-and-parameter-types-across-the-ffi-boundary">Example 4: Redirecting control flow using an indirect branch/call to a function with different return and parameter types across the FFI boundary</a></h2>
<pre><code class="language-ignore (cannot-test-this-because-uses-custom-build)">int
do_twice(int (*fn)(int), int arg)
{
    return fn(arg) + fn(arg);
}
</code></pre>
<p>Fig. 10. Example C library.</p>
<pre><code class="language-ignore (cannot-test-this-because-uses-custom-build)">use std::mem;

#[link(name = "foo")]
extern "C" {
    fn do_twice(f: unsafe extern "C" fn(i32) -&gt; i32, arg: i32) -&gt; i32;
}

unsafe extern "C" fn add_one(x: i32) -&gt; i32 {
    x + 1
}

unsafe extern "C" fn add_two(x: i64) -&gt; i64 {
    x + 2
}

fn main() {
    let answer = unsafe { do_twice(add_one, 5) };

    println!("The answer is: {}", answer);

    println!("With CFI enabled, you should not see the next answer");
    let f: unsafe extern "C" fn(i32) -&gt; i32 = unsafe {
        mem::transmute::&lt;*const u8, unsafe extern "C" fn(i32) -&gt; i32&gt;(add_two as *const u8)
    };
    let next_answer = unsafe { do_twice(f, 5) };

    println!("The next answer is: {}", next_answer);
}
</code></pre>
<p>Fig. 11. Redirecting control flow using an indirect branch/call to a function
with different return and parameter types than the return type expected and
arguments intended/passed in the call/branch site, across the FFI boundary.</p>
<pre><code class="language-shell">$ make
mkdir -p target/release
clang -I. -Isrc -Wall -c src/foo.c -o target/release/libfoo.o
llvm-ar rcs target/release/libfoo.a target/release/libfoo.o
RUSTFLAGS="-L./target/release -Clinker=clang -Clink-arg=-fuse-ld=lld" cargo build --release
   Compiling rust-cfi-4 v0.1.0 (/home/rcvalle/rust-cfi-4)
    Finished release [optimized] target(s) in 0.49s
$ ./target/release/rust-cfi-4
The answer is: 12
With CFI enabled, you should not see the next answer
The next answer is: 14
$
</code></pre>
<p>Fig. 12. Build and execution of Figs. 10–11 with LLVM CFI disabled.</p>
<pre><code class="language-shell">$ make
mkdir -p target/release
clang -I. -Isrc -Wall -flto -fsanitize=cfi -fsanitize-cfi-icall-experimental-normalize-integers -fvisibility=hidden -c -emit-llvm src/foo.c -o target/release/libfoo.bc
llvm-ar rcs target/release/libfoo.a target/release/libfoo.bc
RUSTFLAGS="-L./target/release -Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers" cargo build -Zbuild-std -Zbuild-std-features --release --target x86_64-unknown-linux-gnu
   ...
   Compiling rust-cfi-4 v0.1.0 (/home/rcvalle/rust-cfi-4)
    Finished release [optimized] target(s) in 1m 06s
$ ./target/x86_64-unknown-linux-gnu/release/rust-cfi-4
The answer is: 12
With CFI enabled, you should not see the next answer
Illegal instruction
$
</code></pre>
<p>Fig. 13. Build and execution of FIgs. 10–11 with LLVM CFI enabled.</p>
<p>When LLVM CFI is enabled, if there are any attempts to redirect control flow
using an indirect branch/call to a function with different return and parameter
types than the return type expected and arguments intended/passed in the
call/branch site, even across the FFI boundary and for extern “C” function types
indirectly called (i.e., callbacks/function pointers) across the FFI boundary,
the execution is also terminated (see Fig. 13).</p>
<h1 id="hwaddresssanitizer"><a class="header" href="#hwaddresssanitizer">HWAddressSanitizer</a></h1>
<p>HWAddressSanitizer is a newer variant of AddressSanitizer that consumes much
less memory.</p>
<p>HWAddressSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-linux-android</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
</ul>
<p>HWAddressSanitizer requires <code>tagged-globals</code> target feature to instrument
globals. To enable this target feature compile with <code>-C target-feature=+tagged-globals</code></p>
<p>See the <a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">Clang HWAddressSanitizer documentation</a> for more details.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>Heap buffer overflow:</p>
<pre class="playground"><code class="language-rust">fn main() {
    let xs = vec![0, 1, 2, 3];
    let _y = unsafe { *xs.as_ptr().offset(4) };
}</code></pre>
<pre><code class="language-shell">$ rustc main.rs -Zsanitizer=hwaddress -C target-feature=+tagged-globals -C
linker=aarch64-linux-gnu-gcc -C link-arg=-fuse-ld=lld --target
aarch64-unknown-linux-gnu
</code></pre>
<pre><code class="language-shell">$ ./main
==241==ERROR: HWAddressSanitizer: tag-mismatch on address 0xefdeffff0050 at pc 0xaaaae0ae4a98
READ of size 4 at 0xefdeffff0050 tags: 2c/00 (ptr/mem) in thread T0
    #0 0xaaaae0ae4a94  (/.../main+0x54a94)
    ...

[0xefdeffff0040,0xefdeffff0060) is a small allocated heap chunk; size: 32 offset: 16
0xefdeffff0050 is located 0 bytes to the right of 16-byte region [0xefdeffff0040,0xefdeffff0050)
allocated here:
    #0 0xaaaae0acb80c  (/.../main+0x3b80c)
    ...

Thread: T0 0xeffe00002000 stack: [0xffffc28ad000,0xffffc30ad000) sz: 8388608 tls: [0xffffaa10a020,0xffffaa10a7d0)
Memory tags around the buggy address (one tag corresponds to 16 bytes):
  0xfefcefffef80: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffef90: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefa0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefb0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefc0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefd0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffefe0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefcefffeff0: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
=&gt;0xfefceffff000: d7  d7  05  00  2c [00] 00  00  00  00  00  00  00  00  00  00
  0xfefceffff010: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff020: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff030: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff040: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff050: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff060: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff070: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xfefceffff080: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
Tags for short granules around the buggy address (one tag corresponds to 16 bytes):
  0xfefcefffeff0: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
=&gt;0xfefceffff000: ..  ..  8c  ..  .. [..] ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
  0xfefceffff010: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
See https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html#short-granules for a description of short granule tags
Registers where the failure occurred (pc 0xaaaae0ae4a98):
    x0  2c00efdeffff0050  x1  0000000000000004  x2  0000000000000004  x3  0000000000000000
    x4  0000fffefc30ac37  x5  000000000000005d  x6  00000ffffc30ac37  x7  0000efff00000000
    x8  2c00efdeffff0050  x9  0200efff00000000  x10 0000000000000000  x11 0200efff00000000
    x12 0200effe00000310  x13 0200effe00000310  x14 0000000000000008  x15 5d00ffffc30ac360
    x16 0000aaaae0ad062c  x17 0000000000000003  x18 0000000000000001  x19 0000ffffc30ac658
    x20 4e00ffffc30ac6e0  x21 0000aaaae0ac5e10  x22 0000000000000000  x23 0000000000000000
    x24 0000000000000000  x25 0000000000000000  x26 0000000000000000  x27 0000000000000000
    x28 0000000000000000  x29 0000ffffc30ac5a0  x30 0000aaaae0ae4a98
SUMMARY: HWAddressSanitizer: tag-mismatch (/.../main+0x54a94)
</code></pre>
<h1 id="kernelcontrolflowintegrity"><a class="header" href="#kernelcontrolflowintegrity">KernelControlFlowIntegrity</a></h1>
<p>The LLVM Kernel Control Flow Integrity (CFI) support to the Rust compiler
initially provides forward-edge control flow protection for operating systems
kernels for Rust-compiled code only by aggregating function pointers in groups
identified by their return and parameter types. (See <a href="https://github.com/llvm/llvm-project/commit/cff5bef948c91e4919de8a5fb9765e0edc13f3de">LLVM commit cff5bef “KCFI
sanitizer”</a>.)</p>
<p>Forward-edge control flow protection for C or C++ and Rust -compiled code “mixed
binaries” (i.e., for when C or C++ and Rust -compiled code share the same
virtual address space) will be provided in later work by defining and using
compatible type identifiers (see Type metadata in the design document in the
tracking issue <a href="https://github.com/rust-lang/rust/issues/89653">#89653</a>).</p>
<p>LLVM KCFI can be enabled with <code>-Zsanitizer=kcfi</code>.</p>
<p>LLVM KCFI is supported on the following targets:</p>
<ul>
<li><code>aarch64-linux-android</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-linux-android</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html#fsanitize-kcfi">Clang KernelControlFlowIntegrity documentation</a> for more
details.</p>
<h1 id="dataflowsanitizer"><a class="header" href="#dataflowsanitizer">DataFlowSanitizer</a></h1>
<p>DataFlowSanitizer is a generalised dynamic data flow analysis.</p>
<p>Unlike other Sanitizer tools, this tool is not designed to detect a specific
class of bugs on its own. Instead, it provides a generic dynamic data flow
analysis framework to be used by clients to help detect application-specific
issues within their own code.</p>
<p>DataFlowSanitizer is supported on the following targets:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/DataFlowSanitizer.html">Clang DataFlowSanitizer documentation</a> for more details.</p>
<h1 id="kerneladdresssanitizer"><a class="header" href="#kerneladdresssanitizer">KernelAddressSanitizer</a></h1>
<p>KernelAddressSanitizer (KASAN) is a freestanding version of AddressSanitizer
which is suitable for detecting memory errors in programs which do not have a
runtime environment, such as operating system kernels. KernelAddressSanitizer
requires manual implementation of the underlying functions used for tracking
KernelAddressSanitizer state.</p>
<p>KernelAddressSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-unknown-none</code></li>
<li><code>riscv64gc-unknown-none-elf</code></li>
<li><code>riscv64imac-unknown-none-elf</code></li>
<li><code>x86_64-unknown-none</code></li>
</ul>
<p>See the <a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">Linux Kernel’s KernelAddressSanitizer documentation</a> for
more details.</p>
<h1 id="leaksanitizer"><a class="header" href="#leaksanitizer">LeakSanitizer</a></h1>
<p>LeakSanitizer is run-time memory leak detector.</p>
<p>LeakSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-apple-darwin</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/LeakSanitizer.html">Clang LeakSanitizer documentation</a> for more details.</p>
<h1 id="memorysanitizer"><a class="header" href="#memorysanitizer">MemorySanitizer</a></h1>
<p>MemorySanitizer is detector of uninitialized reads.</p>
<p>MemorySanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-unknown-freebsd</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>MemorySanitizer requires all program code to be instrumented. C/C++ dependencies
need to be recompiled using Clang with <code>-fsanitize=memory</code> option. Failing to
achieve that will result in false positive reports.</p>
<p>See the <a href="https://clang.llvm.org/docs/MemorySanitizer.html">Clang MemorySanitizer documentation</a> for more details.</p>
<h2 id="example-1-2"><a class="header" href="#example-1-2">Example</a></h2>
<p>Detecting the use of uninitialized memory. The <code>-Zbuild-std</code> flag rebuilds and
instruments the standard library, and is strictly necessary for the correct
operation of the tool. The <code>-Zsanitizer-memory-track-origins</code> enables tracking
of the origins of uninitialized memory:</p>
<pre class="playground"><code class="language-rust">use std::mem::MaybeUninit;

fn main() {
    unsafe {
        let a = MaybeUninit::&lt;[usize; 4]&gt;::uninit();
        let a = a.assume_init();
        println!("{}", a[2]);
    }
}</code></pre>
<pre><code class="language-shell">$ export \
  RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \
  RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'
$ cargo clean
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
==9416==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16
...
  Uninitialized value was stored to memory at
    #0 0x560c04ae898a in __msan_memcpy.part.0 $RUST/src/llvm-project/compiler-rt/lib/msan/msan_interceptors.cc:1558:3
    #1 0x560c04b2bf88 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:6:16

  Uninitialized value was created by an allocation of 'a' in the stack frame of function '_ZN6memory4main17hd2333c1899d997f5E'
    #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3
</code></pre>
<h1 id="memtagsanitizer"><a class="header" href="#memtagsanitizer">MemTagSanitizer</a></h1>
<p>MemTagSanitizer detects a similar class of errors as AddressSanitizer and HardwareAddressSanitizer, but with lower overhead suitable for use as hardening for production binaries.</p>
<p>MemTagSanitizer is supported on the following targets:</p>
<ul>
<li><code>aarch64-linux-android</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
</ul>
<p>MemTagSanitizer requires hardware support and the <code>mte</code> target feature.
To enable this target feature compile with <code>-C target-feature="+mte"</code>.</p>
<p>See the <a href="https://llvm.org/docs/MemTagSanitizer.html">LLVM MemTagSanitizer documentation</a> for more details.</p>
<h1 id="safestack"><a class="header" href="#safestack">SafeStack</a></h1>
<p>SafeStack provides backward edge control flow protection by separating the stack into data which is only accessed safely (the safe stack) and all other data (the unsafe stack).</p>
<p>SafeStack can be enabled with the <code>-Zsanitizer=safestack</code> option and is supported on the following targets:</p>
<ul>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>See the <a href="https://clang.llvm.org/docs/SafeStack.html">Clang SafeStack documentation</a> for more details.</p>
<h1 id="shadowcallstack"><a class="header" href="#shadowcallstack">ShadowCallStack</a></h1>
<p>ShadowCallStack provides backward edge control flow protection by storing a function’s return address in a separately allocated ‘shadow call stack’
and loading the return address from that shadow call stack.
AArch64 and RISC-V both have a platform register defined in their ABIs, which is <code>x18</code> and <code>x3</code>/<code>gp</code> respectively, that can optionally be reserved for this purpose.
Software support from the operating system and runtime may be required depending on the target platform which is detailed in the remaining section.
See the <a href="https://clang.llvm.org/docs/ShadowCallStack.html">Clang ShadowCallStack documentation</a> for more details.</p>
<p>ShadowCallStack can be enabled with <code>-Zsanitizer=shadow-call-stack</code> option and is supported on the following targets:</p>
<h2 id="aarch64-family"><a class="header" href="#aarch64-family">AArch64 family</a></h2>
<p>ShadowCallStack requires the use of the ABI defined platform register, <code>x18</code>, which is required for code generation purposes.
When <code>x18</code> is not reserved, and is instead used as a scratch register subsequently, enabling ShadowCallStack would lead to undefined behaviour
due to corruption of return address or invalid memory access when the instrumentation restores return register to the link register <code>lr</code> from the
already clobbered <code>x18</code> register.
In other words, code that is calling into or called by functions instrumented with ShadowCallStack must reserve the <code>x18</code> register or preserve its value.</p>
<h3 id="aarch64-linux-android-and-aarch64-unknown-fuchsiaaarch64-fuchsia"><a class="header" href="#aarch64-linux-android-and-aarch64-unknown-fuchsiaaarch64-fuchsia"><code>aarch64-linux-android</code> and <code>aarch64-unknown-fuchsia</code>/<code>aarch64-fuchsia</code></a></h3>
<p>This target already reserves the <code>x18</code> register.
A runtime must be provided by the application or operating system.
If <code>bionic</code> is used on this target, the software support is provided.
Otherwise, a runtime needs to prepare a memory region and points <code>x18</code> to the region which serves as the shadow call stack.</p>
<h3 id="aarch64-unknown-none"><a class="header" href="#aarch64-unknown-none"><code>aarch64-unknown-none</code></a></h3>
<p>In addition to support from a runtime by the application or operating system, the <code>-Zfixed-x18</code> flag is also mandatory.</p>
<h2 id="risc-v-64-family"><a class="header" href="#risc-v-64-family">RISC-V 64 family</a></h2>
<p>ShadowCallStack uses either the <code>gp</code> register for software shadow stack, also known as <code>x3</code>, or the <code>ssp</code> register if <a href="https://github.com/riscv/riscv-cfi/blob/3f8e450c481ac303bd5643444f7a89672f24476e/src/cfi_backward.adoc"><code>Zicfiss</code></a> extension is available.
<code>gp</code>/<code>x3</code> is currently always reserved and available for ShadowCallStack instrumentation, and <code>ssp</code> in case of <code>Zicfiss</code> is only accessible through its dedicated shadow stack instructions.</p>
<p>Support from the runtime and operating system is required when <code>gp</code>/<code>x3</code> is used for software shadow stack.
A runtime must prepare a memory region and point <code>gp</code>/<code>x3</code> to the region before executing the code.</p>
<p>The following targets support ShadowCallStack.</p>
<ul>
<li><code>riscv64imac-unknown-none-elf</code></li>
<li><code>riscv64gc-unknown-none-elf</code></li>
<li><code>riscv64gc-unknown-fuchsia</code></li>
</ul>
<h1 id="threadsanitizer"><a class="header" href="#threadsanitizer">ThreadSanitizer</a></h1>
<p>ThreadSanitizer is a data race detection tool. It is supported on the following
targets:</p>
<ul>
<li><code>aarch64-apple-darwin</code></li>
<li><code>aarch64-unknown-linux-gnu</code></li>
<li><code>x86_64-apple-darwin</code></li>
<li><code>x86_64-unknown-freebsd</code></li>
<li><code>x86_64-unknown-linux-gnu</code></li>
</ul>
<p>To work correctly ThreadSanitizer needs to be “aware” of all synchronization
operations in a program. It generally achieves that through combination of
library interception (for example synchronization performed through
<code>pthread_mutex_lock</code> / <code>pthread_mutex_unlock</code>) and compile time instrumentation
(e.g. atomic operations). Using it without instrumenting all the program code
can lead to false positive reports.</p>
<p>ThreadSanitizer does not support atomic fences <code>std::sync::atomic::fence</code>,
nor synchronization performed using inline assembly code.</p>
<p>See the <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">Clang ThreadSanitizer documentation</a> for more details.</p>
<h2 id="example-2-1"><a class="header" href="#example-2-1">Example</a></h2>
<pre class="playground"><code class="language-rust">static mut A: usize = 0;

fn main() {
    let t = std::thread::spawn(|| {
        unsafe { A += 1 };
    });
    unsafe { A += 1 };

    t.join().unwrap();
}</code></pre>
<pre><code class="language-shell">$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread
$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu
==================
WARNING: ThreadSanitizer: data race (pid=10574)
  Read of size 8 at 0x5632dfe3d030 by thread T1:
    #0 example::main::_$u7b$$u7b$closure$u7d$$u7d$::h23f64b0b2f8c9484 ../src/main.rs:5:18 (example+0x86cec)
    ...

  Previous write of size 8 at 0x5632dfe3d030 by main thread:
    #0 example::main::h628ffc6626ed85b2 /.../src/main.rs:7:14 (example+0x868c8)
    ...
    #11 main &lt;null&gt; (example+0x86a1a)

  Location is global 'example::A::h43ac149ddf992709' of size 8 at 0x5632dfe3d030 (example+0x000000bd9030)
</code></pre>
<h1 id="realtimesanitizer"><a class="header" href="#realtimesanitizer">RealtimeSanitizer</a></h1>
<p>RealtimeSanitizer detects non-deterministic execution time calls in real-time contexts.
Functions marked with the <code>#[sanitize(realtime = "nonblocking")]</code> attribute are considered real-time functions.
When RTSan detects a call to a function with a non-deterministic execution time, like <code>malloc</code> or <code>free</code>
while in a real-time context, it reports an error.</p>
<p>Besides “nonblocking” the attribute can also be used with “blocking” and “caller”.</p>
<ul>
<li>“blocking” allows the programmer to mark their own functions as having a non-deterministic execution time.
When reaching such a function while in a real-time context a violation will be reported. A typical use
case is a userland spinlock.</li>
<li>functions marked with “caller” will be sanitized if they were called from a real-time context.
If no attribute is set, this is the default. Between entering a “nonblocking” function and exiting that
function again the program will get sanitized.</li>
</ul>
<p>The santizer checks can be disabled using the external functions <code>__rtsan_disable()</code> and <code>__rtsan_enable()</code>.
Each call to <code>__rtsan_disable()</code> must be paired with one following call to <code>__rtsan_enable()</code>, otherwise the behaviour is undefined.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
  fn __rtsan_disable();
  fn __rtsan_enable();
}
<span class="boring">}</span></code></pre>
<pre><code class="language-rust ignore (log is just a example and doesn&#39;t exist)">// in a real-time context
#[cfg(debug_assertions)]
{
    unsafe { __rtsan_disable() };
    log!("logging xyz");
    unsafe { __rtsan_enable() };
}</code></pre>
<p>See the <a href="https://clang.llvm.org/docs/RealtimeSanitizer.html">Clang RealtimeSanitizer documentation</a> for more details.</p>
<h2 id="example-3-1"><a class="header" href="#example-3-1">Example</a></h2>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![feature(sanitize)]
<span class="boring">fn main() {
</span>#[sanitize(realtime = "nonblocking")]
fn real_time() {
  let vec = vec![0, 1, 2]; // call to malloc is detected and reported as an error
}
<span class="boring">}</span></code></pre>
<pre><code class="language-shell">==8670==ERROR: RealtimeSanitizer: unsafe-library-call
Intercepted call to real-time unsafe function `malloc` in real-time context!
    #0 0x00010107b0d8 in malloc rtsan_interceptors_posix.cpp:792
    #1 0x000100d94e70 in alloc::alloc::Global::alloc_impl::h9e1fc3206c868eea+0xa0 (realtime_vec:arm64+0x100000e70)
    #2 0x000100d94d90 in alloc::alloc::exchange_malloc::hd45b5788339eb5c8+0x48 (realtime_vec:arm64+0x100000d90)
    #3 0x000100d95020 in realtime_vec::main::hea6bd69b03eb9ca1+0x24 (realtime_vec:arm64+0x100001020)
    #4 0x000100d94a28 in core::ops::function::FnOnce::call_once::h493b6cb9dd87d87c+0xc (realtime_vec:arm64+0x100000a28)
    #5 0x000100d949b8 in std::sys::backtrace::__rust_begin_short_backtrace::hfcddb06c73c19eea+0x8 (realtime_vec:arm64+0x1000009b8)
    #6 0x000100d9499c in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::h202288c05a2064f0+0xc (realtime_vec:arm64+0x10000099c)
    #7 0x000100d9fa34 in std::rt::lang_start_internal::h6c763158a05ac05f+0x6c (realtime_vec:arm64+0x10000ba34)
    #8 0x000100d94980 in std::rt::lang_start::h1c29cc56df0598b4+0x38 (realtime_vec:arm64+0x100000980)
    #9 0x000100d95118 in main+0x20 (realtime_vec:arm64+0x100001118)
    #10 0x000183a46b94 in start+0x17b8 (dyld:arm64+0xfffffffffff3ab94)

SUMMARY: RealtimeSanitizer: unsafe-library-call rtsan_interceptors_posix.cpp:792 in malloc
</code></pre>
<h1 id="instrumentation-of-external-dependencies-and-std"><a class="header" href="#instrumentation-of-external-dependencies-and-std">Instrumentation of external dependencies and std</a></h1>
<p>The sanitizers to varying degrees work correctly with partially instrumented
code. On the one extreme is LeakSanitizer that doesn’t use any compile time
instrumentation, on the other is MemorySanitizer that requires that all program
code to be instrumented (failing to achieve that will inevitably result in
false positives).</p>
<p>It is strongly recommended to combine sanitizers with recompiled and
instrumented standard library, for example using <a href="../cargo/reference/unstable.html#build-std">cargo <code>-Zbuild-std</code>
functionality</a>.</p>
<h1 id="working-with-other-languages"><a class="header" href="#working-with-other-languages">Working with other languages</a></h1>
<p>Sanitizers rely on compiler runtime libraries to function properly. Rust links
in its own compiler runtime which might conflict with runtimes required by
languages such as C++. Since Rust’s runtime doesn’t always contain the symbols
required by C++ instrumented code, you might need to skip linking it so another
runtime can be linked instead.</p>
<p>A separate unstable option <code>-Zexternal-clangrt</code> can be used to make rustc skip
linking the compiler runtime for the sanitizer. This will require you to link
in an external runtime, such as from clang instead.</p>
<h1 id="build-scripts-and-procedural-macros"><a class="header" href="#build-scripts-and-procedural-macros">Build scripts and procedural macros</a></h1>
<p>Use of sanitizers together with build scripts and procedural macros is
technically possible, but in almost all cases it would be best avoided.  This
is especially true for procedural macros which would require an instrumented
version of rustc.</p>
<p>In more practical terms when using cargo always remember to pass <code>--target</code>
flag, so that rustflags will not be applied to build scripts and procedural
macros.</p>
<h1 id="symbolizing-the-reports"><a class="header" href="#symbolizing-the-reports">Symbolizing the Reports</a></h1>
<p>Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in <code>PATH</code>.</p>
<h1 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h1>
<ul>
<li><a href="https://github.com/google/sanitizers/wiki/">Sanitizers project page</a></li>
<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">ControlFlowIntegrity in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/DataFlowSanitizer.html">DataFlowSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">HWAddressSanitizer in Clang</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html">Linux Kernel’s KernelAddressSanitizer documentation</a></li>
<li><a href="https://clang.llvm.org/docs/LeakSanitizer.html">LeakSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer in Clang</a></li>
<li><a href="https://llvm.org/docs/MemTagSanitizer.html">MemTagSanitizer in LLVM</a></li>
<li><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer in Clang</a></li>
<li><a href="https://clang.llvm.org/docs/RealtimeSanitizer.html">RealtimeSanitizer in Clang</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="self-profile"><a class="header" href="#self-profile"><code>self-profile</code></a></h1>
<hr>
<p>The <code>-Zself-profile</code> compiler flag enables rustc’s internal profiler.
When enabled, the compiler will output three binary files in the specified directory (or the current working directory if no directory is specified).
These files can be analyzed by using the tools in the <a href="https://github.com/rust-lang/measureme.git"><code>measureme</code></a> repository.</p>
<p>To control the data recorded in the trace files, use the <code>-Zself-profile-events</code> flag.</p>
<p>For example:</p>
<p>First, run a compilation session and provide the <code>-Zself-profile</code> flag:</p>
<pre><code class="language-console">$ rustc --crate-name foo -Zself-profile
</code></pre>
<p>This will generate three files in the working directory such as:</p>
<ul>
<li><code>foo-1234.events</code></li>
<li><code>foo-1234.string_data</code></li>
<li><code>foo-1234.string_index</code></li>
</ul>
<p>Where <code>foo</code> is the name of the crate and <code>1234</code> is the process id of the rustc process.</p>
<p>To get a summary of where the compiler is spending its time:</p>
<pre><code class="language-console">$ ../measureme/target/release/summarize summarize foo-1234
</code></pre>
<p>To generate a flamegraph of the same data:</p>
<pre><code class="language-console">$ ../measureme/target/release/inferno foo-1234
</code></pre>
<p>To dump the event data in a Chromium-profiler compatible format:</p>
<pre><code class="language-console">$ ../measureme/target/release/crox foo-1234
</code></pre>
<p>For more information, consult the <a href="https://github.com/rust-lang/measureme.git"><code>measureme</code></a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="self-profile-events"><a class="header" href="#self-profile-events"><code>self-profile-events</code></a></h1>
<hr>
<p>The <code>-Zself-profile-events</code> compiler flag controls what events are recorded by the self-profiler when it is enabled via the <code>-Zself-profile</code> flag.</p>
<p>This flag takes a comma delimited list of event types to record.</p>
<p>For example:</p>
<pre><code class="language-console">$ rustc -Zself-profile -Zself-profile-events=default,args
</code></pre>
<h2 id="event-types"><a class="header" href="#event-types">Event types</a></h2>
<ul>
<li>
<p><code>query-provider</code></p>
<ul>
<li>Traces each query used internally by the compiler.</li>
</ul>
</li>
<li>
<p><code>generic-activity</code></p>
<ul>
<li>Traces other parts of the compiler not covered by the query system.</li>
</ul>
</li>
<li>
<p><code>query-cache-hit</code></p>
<ul>
<li>Adds tracing information that records when the in-memory query cache is “hit” and does not need to re-execute a query which has been cached.</li>
<li>Disabled by default because this significantly increases the trace file size.</li>
</ul>
</li>
<li>
<p><code>query-blocked</code></p>
<ul>
<li>Tracks time that a query tries to run but is blocked waiting on another thread executing the same query to finish executing.</li>
<li>Query blocking only occurs when the compiler is built with parallel mode support.</li>
</ul>
</li>
<li>
<p><code>incr-cache-load</code></p>
<ul>
<li>Tracks time that is spent loading and deserializing query results from the incremental compilation on-disk cache.</li>
</ul>
</li>
<li>
<p><code>query-keys</code></p>
<ul>
<li>Adds a serialized representation of each query’s query key to the tracing data.</li>
<li>Disabled by default because this significantly increases the trace file size.</li>
</ul>
</li>
<li>
<p><code>function-args</code></p>
<ul>
<li>Adds additional tracing data to some <code>generic-activity</code> events.</li>
<li>Disabled by default for parity with <code>query-keys</code>.</li>
</ul>
</li>
<li>
<p><code>llvm</code></p>
<ul>
<li>Adds tracing information about LLVM passes and codegeneration.</li>
<li>Disabled by default because this significantly increases the trace file size.</li>
</ul>
</li>
</ul>
<h2 id="event-synonyms"><a class="header" href="#event-synonyms">Event synonyms</a></h2>
<ul>
<li>
<p><code>none</code></p>
<ul>
<li>Disables all events.
Equivalent to the self-profiler being disabled.</li>
</ul>
</li>
<li>
<p><code>default</code></p>
<ul>
<li>The default set of events which stikes a balance between providing detailed tracing data and adding additional overhead to the compilation.</li>
</ul>
</li>
<li>
<p><code>args</code></p>
<ul>
<li>Equivalent to <code>query-keys</code> and <code>function-args</code>.</li>
</ul>
</li>
<li>
<p><code>all</code></p>
<ul>
<li>Enables all events.</li>
</ul>
</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<p>Enable the profiler and capture the default set of events (both invocations are equivalent):</p>
<pre><code class="language-console">$ rustc -Zself-profile
$ rustc -Zself-profile -Zself-profile-events=default
</code></pre>
<p>Enable the profiler and capture the default events and their arguments:</p>
<pre><code class="language-console">$ rustc -Zself-profile -Zself-profile-events=default,args
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="shell-argfiles"><a class="header" href="#shell-argfiles"><code>shell-argfiles</code></a></h1>
<hr>
<p>The <code>-Zshell-argfiles</code> compiler flag allows argfiles to be parsed using POSIX
“shell-style” quoting. When enabled, the compiler will use <code>shlex</code> to parse the
arguments from argfiles specified with <code>@shell:&lt;path&gt;</code>.</p>
<p>Because this feature controls the parsing of input arguments, the
<code>-Zshell-argfiles</code> flag must be present before the argument specifying the
shell-style argument file.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="small-data-threshold"><a class="header" href="#small-data-threshold"><code>small-data-threshold</code></a></h1>
<hr>
<p>This flag controls the maximum static variable size that may be included in the
“small data sections” (.sdata, .sbss) supported by some architectures (RISCV,
MIPS, M68K, Hexagon).  Can be set to <code>0</code> to disable the use of small data
sections.</p>
<p>Target support is indicated by the <code>small_data_threshold_support</code> target
option which can be:</p>
<ul>
<li><code>none</code> (<code>SmallDataThresholdSupport::None</code>) for no support</li>
<li><code>default-for-arch</code> (<code>SmallDataThresholdSupport::DefaultForArch</code>) which
is automatically translated into an appropriate value for the target.</li>
<li><code>llvm-module-flag=&lt;flag_name&gt;</code>
(<code>SmallDataThresholdSupport::LlvmModuleFlag</code>) for specifying the
threshold via an LLVM module flag</li>
<li><code>llvm-arg=&lt;arg_name&gt;</code> (<code>SmallDataThresholdSupport::LlvmArg</code>) for
specifying the threshold via an LLVM argument.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="split-dwarf-out-dir"><a class="header" href="#split-dwarf-out-dir"><code>split-dwarf-out-dir</code></a></h1>
<p>On systems which use DWARF debug info this flag causes <code>.dwo</code> files produced
by <code>-C split-debuginfo</code> to be written to the specified directory rather than
placed next to the object files. This is mostly useful if you have a build
system which needs to control where to find compile outputs without running the
compiler and have to put your <code>.dwo</code> files in a separate directory.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="src-hash-algorithm"><a class="header" href="#src-hash-algorithm"><code>src-hash-algorithm</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/70401">#70401</a>.</p>
<hr>
<p>The <code>-Z src-hash-algorithm</code> compiler flag controls which algorithm is used when hashing each source file. The hash is stored in the debug info and can be used by a debugger to verify the source code matches the executable.</p>
<p>Supported hash algorithms are: <code>md5</code>, <code>sha1</code>, and <code>sha256</code>. Note that not all hash algorithms are supported by all debug info formats.</p>
<p>By default, the compiler chooses the hash algorithm based on the target specification.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="temps-dir"><a class="header" href="#temps-dir"><code>temps-dir</code></a></h1>
<hr>
<p>The <code>-Ztemps-dir</code> compiler flag specifies the directory to write the
intermediate files in. If not set, the output directory is used. This option is
useful if you are running more than one instance of <code>rustc</code> (e.g. with different
<code>--crate-type</code> settings), and you need to make sure they are not overwriting
each other’s intermediate files. No files are kept unless <code>-C save-temps=yes</code> is
also set.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="-z-terminal-urls"><a class="header" href="#-z-terminal-urls"><code>-Z terminal-urls</code></a></h1>
<p>The tracking feature for this issue is <a href="https://github.com/rust-lang/rust/issues/125586">#125586</a></p>
<hr>
<p>This flag takes either a boolean or the string “auto”.</p>
<p>When enabled, use the OSC 8 hyperlink terminal specification to print hyperlinks in the compiler output.
Use “auto” to try and autodetect whether the terminal emulator supports hyperlinks.
Currently, “auto” only enables hyperlinks if <code>COLORTERM=truecolor</code> and <code>TERM=xterm-256color</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tiny-const-eval-limit"><a class="header" href="#tiny-const-eval-limit"><code>tiny-const-eval-limit</code></a></h1>
<hr>
<p>The <code>-Ztiny-const-eval-limit</code> compiler flag sets a tiny, non-configurable limit for const eval.
This flag should only be used by const eval tests in the rustc test suite.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tls_model"><a class="header" href="#tls_model"><code>tls_model</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<p>Option <code>-Z tls-model</code> controls <a href="https://www.akkadia.org/drepper/tls.pdf">TLS model</a> used to
generate code for accessing <code>#[thread_local]</code> <code>static</code> items.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>global-dynamic</code> - General Dynamic TLS Model (alternatively called Global Dynamic) is the most
general option usable in all circumstances, even if the TLS data is defined in a shared library
loaded at runtime and is accessed from code outside of that library.
This is the default for most targets.</li>
<li><code>local-dynamic</code> - model usable if the TLS data is only accessed from the shared library or
executable it is defined in. The TLS data may be in a library loaded after startup (via <code>dlopen</code>).</li>
<li><code>initial-exec</code> - model usable if the TLS data is defined in the executable or in a shared library
loaded at program startup.
The TLS data must not be in a library loaded after startup (via <code>dlopen</code>).</li>
<li><code>local-exec</code> - model usable only if the TLS data is defined directly in the executable,
but not in a shared library, and is accessed only from that executable.</li>
<li><code>emulated</code> - Uses thread-specific data keys to implement emulated TLS.
It is like using a general-dynamic TLS model for all modes.</li>
</ul>
<p><code>rustc</code> and LLVM may use a more optimized model than specified if they know that we are producing
an executable rather than a library, or that the <code>static</code> item is private enough.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="track-diagnostics"><a class="header" href="#track-diagnostics"><code>track-diagnostics</code></a></h1>
<p>This feature is perma-unstable and has no tracking issue.</p>
<hr>
<p>This flag prints the source code span in the compiler where a diagnostic was generated, respecting <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-track_caller-attribute"><code>#[track_caller]</code></a>. Note that this may be different from the place it was emitted.
For full documentation, see <a href="https://rustc-dev-guide.rust-lang.org/compiler-debugging.html#getting-the-error-creation-location">the rustc-dev-guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="treat-err-as-bug"><a class="header" href="#treat-err-as-bug"><code>treat-err-as-bug</code></a></h1>
<p>This feature is perma-unstable and has no tracking issue.</p>
<hr>
<p>This flag converts the selected error to a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/macro.bug.html"><code>bug!</code></a> call, exiting the compiler immediately and allowing you to generate a backtrace of where the error occurred.
For full documentation, see <a href="https://rustc-dev-guide.rust-lang.org/compiler-debugging.html#getting-a-backtrace-for-errors">the rustc-dev-guide</a>.</p>
<p>Note that the compiler automatically sets <code>RUST_BACKTRACE=1</code> for itself, and so you do not need to set it yourself when using this flag.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ub-checks"><a class="header" href="#ub-checks"><code>ub-checks</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123499">#123499</a>.</p>
<hr>
<p>The <code>-Zub-checks</code> compiler flag enables additional runtime checks that detect some causes of Undefined Behavior at runtime.
By default, <code>-Zub-checks</code> flag inherits the value of <code>-Cdebug-assertions</code>.</p>
<p>All checks are generated on a best-effort basis; even if we have a check implemented for some cause of Undefined Behavior, it may be possible for the check to not fire.
If a dependency is compiled with <code>-Zub-checks=no</code> but the final binary or library is compiled with <code>-Zub-checks=yes</code>, UB checks reached by the dependency are likely to be optimized out.</p>
<p>When <code>-Zub-checks</code> detects UB, a non-unwinding panic is produced.
That means that we will not unwind the stack and will not call any <code>Drop</code> impls, but we will execute the configured panic hook.
We expect that unsafe code has been written which relies on code not unwinding which may have UB checks inserted.
Ergo, an unwinding panic could easily turn works-as-intended UB into a much bigger problem.
Calling the panic hook theoretically has the same implications, but we expect that the standard library panic hook will be stateless enough to be always called, and that if a user has configured a panic hook that the hook may be very helpful to debugging the detected UB.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsound-mir-opts"><a class="header" href="#unsound-mir-opts"><code>unsound-mir-opts</code></a></h1>
<hr>
<p>The <code>-Zunsound-mir-opts</code> compiler flag enables <a href="https://rustc-dev-guide.rust-lang.org/mir/optimizations.html">MIR optimization passes</a> which can cause unsound behavior.
This flag should only be used by MIR optimization tests in the rustc test suite.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="verbose-asm"><a class="header" href="#verbose-asm"><code>verbose-asm</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/126802">#126802</a>.</p>
<hr>
<p>This enables passing <code>-Zverbose-asm</code> to get contextual comments added by LLVM.</p>
<p>Sample code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub fn foo(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre>
<p>Default output:</p>
<pre><code class="language-asm">foo:
        push    rax
        add     edi, esi
        mov     dword ptr [rsp + 4], edi
        seto    al
        jo      .LBB0_2
        mov     eax, dword ptr [rsp + 4]
        pop     rcx
        ret
.LBB0_2:
        lea     rdi, [rip + .L__unnamed_1]
        mov     rax, qword ptr [rip + core::panicking::panic_const::panic_const_add_overflow::h9c85248fe0d735b2@GOTPCREL]
        call    rax

.L__unnamed_2:
        .ascii  "/app/example.rs"

.L__unnamed_1:
        .quad   .L__unnamed_2
        .asciz  "\017\000\000\000\000\000\000\000\004\000\000\000\005\000\000"
</code></pre>
<p>With <code>-Zverbose-asm</code>:</p>
<pre><code class="language-asm">foo:                                    # @foo
# %bb.0:
        push    rax
        add     edi, esi
        mov     dword ptr [rsp + 4], edi        # 4-byte Spill
        seto    al
        jo      .LBB0_2
# %bb.1:
        mov     eax, dword ptr [rsp + 4]        # 4-byte Reload
        pop     rcx
        ret
.LBB0_2:
        lea     rdi, [rip + .L__unnamed_1]
        mov     rax, qword ptr [rip + core::panicking::panic_const::panic_const_add_overflow::h9c85248fe0d735b2@GOTPCREL]
        call    rax
                                        # -- End function
.L__unnamed_2:
        .ascii  "/app/example.rs"

.L__unnamed_1:
        .quad   .L__unnamed_2
        .asciz  "\017\000\000\000\000\000\000\000\004\000\000\000\005\000\000"

                                        # DW_AT_external
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="virtual-function-elimination"><a class="header" href="#virtual-function-elimination"><code>virtual-function-elimination</code></a></h1>
<p>This option controls whether LLVM runs the Virtual Function Elimination (VFE)
optimization. This optimization in only available with LTO, so this flag can
only be passed if <a href="../rustc/codegen-options/index.html#lto"><code>-Clto</code></a> is also passed.</p>
<p>VFE makes it possible to remove functions from vtables that are never
dynamically called by the rest of the code. Without this flag, LLVM makes the
really conservative assumption, that if any function in a vtable is called, no
function that is referenced by this vtable can be removed. With this flag
additional information are given to LLVM, so that it can determine which
functions are actually called and remove the unused functions.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>At the time of writing this flag may remove vtable functions too eagerly. One
such example is in this code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo { fn foo(&amp;self) { println!("foo") } }

impl Foo for usize {}

pub struct FooBox(Box&lt;dyn Foo&gt;);

pub fn make_foo() -&gt; FooBox { FooBox(Box::new(0)) }

#[inline]
pub fn f(a: FooBox) { a.0.foo() }
<span class="boring">}</span></code></pre>
<p>In the above code the <code>Foo</code> trait is private, so an assumption is made that its
functions can only be seen/called from the current crate and can therefore get
optimized out, if unused. However, with <code>make_foo</code> you can produce a wrapped
<code>dyn Foo</code> type outside of the current crate, which can then be used in <code>f</code>. Due
to inlining of <code>f</code>, <code>Foo::foo</code> can then be called from a foreign crate. This can
lead to miscompilations.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm-c-abi"><a class="header" href="#wasm-c-abi"><code>wasm-c-abi</code></a></h1>
<p>This option controls whether Rust uses the spec-compliant C ABI when compiling
for the <code>wasm32-unknown-unknown</code> target.</p>
<p>This makes it possible to be ABI-compatible with all other spec-compliant Wasm targets
like <code>wasm32-wasip1</code>.</p>
<p>This compiler flag is perma-unstable, as it will be enabled by default in the
future with no option to fall back to the old non-spec-compliant ABI.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="language-features"><a class="header" href="#language-features">Language features</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64_unstable_target_feature"><a class="header" href="#aarch64_unstable_target_feature"><code>aarch64_unstable_target_feature</code></a></h1>
<p>The remaining unstable target features on aarch64.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150244">#150244</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="aarch64_ver_target_feature"><a class="header" href="#aarch64_ver_target_feature"><code>aarch64_ver_target_feature</code></a></h1>
<p>Instruction set “version” target features on aarch64.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150245">#150245</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_avr_interrupt"><a class="header" href="#abi_avr_interrupt"><code>abi_avr_interrupt</code></a></h1>
<p>Allows <code>extern "avr-interrupt" fn()</code> and <code>extern "avr-non-blocking-interrupt" fn()</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/69664">#69664</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_cmse_nonsecure_call"><a class="header" href="#abi_cmse_nonsecure_call"><code>abi_cmse_nonsecure_call</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/81391">#81391</a></p>
<hr>
<p>The <a href="https://developer.arm.com/documentation/100690/latest/">TrustZone-M
feature</a> is available
for targets with the Armv8-M architecture profile (<code>thumbv8m</code> in their target
name).
LLVM, the Rust compiler and the linker are providing
<a href="https://developer.arm.com/documentation/ecm0359818/latest/">support</a> for the
TrustZone-M feature.</p>
<p>One of the things provided with this unstable feature is the “cmse-nonsecure-call” function ABI.
This ABI is used on function pointers to non-secure code to mark a non-secure function call
(see <a href="https://developer.arm.com/documentation/ecm0359818/latest/">section 5.5</a> for details).</p>
<p>With this ABI, the compiler will do the following to perform the call:</p>
<ul>
<li>save registers needed after the call to Secure memory</li>
<li>clear all registers that might contain confidential information</li>
<li>clear the Least Significant Bit of the function address</li>
<li>branches using the BLXNS instruction</li>
</ul>
<p>To avoid using the non-secure stack, the compiler will constrain the number and
type of parameters/return value.</p>
<!-- NOTE(ignore) this example is specific to thumbv8m targets -->
<pre><code class="language-rust ignore">#![no_std]
#![feature(abi_cmse_nonsecure_call)]

#[no_mangle]
pub fn call_nonsecure_function(addr: usize) -&gt; u32 {
    let non_secure_function =
        unsafe { core::mem::transmute::&lt;usize, extern "cmse-nonsecure-call" fn() -&gt; u32&gt;(addr) };
    non_secure_function()
}</code></pre>
<pre><code class="language-text">$ rustc --emit asm --crate-type lib --target thumbv8m.main-none-eabi function.rs

call_nonsecure_function:
        .fnstart
        .save   {r7, lr}
        push    {r7, lr}
        .setfp  r7, sp
        mov     r7, sp
        .pad    #16
        sub     sp, #16
        str     r0, [sp, #12]
        ldr     r0, [sp, #12]
        str     r0, [sp, #8]
        b       .LBB0_1
.LBB0_1:
        ldr     r0, [sp, #8]
        push.w  {r4, r5, r6, r7, r8, r9, r10, r11}
        bic     r0, r0, #1
        mov     r1, r0
        mov     r2, r0
        mov     r3, r0
        mov     r4, r0
        mov     r5, r0
        mov     r6, r0
        mov     r7, r0
        mov     r8, r0
        mov     r9, r0
        mov     r10, r0
        mov     r11, r0
        mov     r12, r0
        msr     apsr_nzcvq, r0
        blxns   r0
        pop.w   {r4, r5, r6, r7, r8, r9, r10, r11}
        str     r0, [sp, #4]
        b       .LBB0_2
.LBB0_2:
        ldr     r0, [sp, #4]
        add     sp, #16
        pop     {r7, pc}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_custom"><a class="header" href="#abi_custom"><code>abi_custom</code></a></h1>
<p>Allows <code>extern "custom" fn()</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/140829">#140829</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_gpu_kernel"><a class="header" href="#abi_gpu_kernel"><code>abi_gpu_kernel</code></a></h1>
<p>Allows <code>extern "gpu-kernel" fn()</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/135467">#135467</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_msp430_interrupt"><a class="header" href="#abi_msp430_interrupt"><code>abi_msp430_interrupt</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/38487">#38487</a></p>
<hr>
<p>In the MSP430 architecture, interrupt handlers have a special calling
convention. You can use the <code>"msp430-interrupt"</code> ABI to make the compiler apply
the right calling convention to the interrupt handlers you define.</p>
<!-- NOTE(ignore) this example is specific to the msp430 target -->
<pre><code class="language-rust ignore">#![feature(abi_msp430_interrupt)]
#![no_std]

// Place the interrupt handler at the appropriate memory address
// (Alternatively, you can use `#[used]` and remove `pub` and `#[no_mangle]`)
#[link_section = "__interrupt_vector_10"]
#[no_mangle]
pub static TIM0_VECTOR: extern "msp430-interrupt" fn() = tim0;

// The interrupt handler
extern "msp430-interrupt" fn tim0() {
    // ..
}</code></pre>
<pre><code class="language-text">$ msp430-elf-objdump -CD ./target/msp430/release/app
Disassembly of section __interrupt_vector_10:

0000fff2 &lt;TIM0_VECTOR&gt;:
    fff2:       00 c0           interrupt service routine at 0xc000

Disassembly of section .text:

0000c000 &lt;int::tim0&gt;:
    c000:       00 13           reti
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_ptx"><a class="header" href="#abi_ptx"><code>abi_ptx</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/38788">#38788</a></p>
<hr>
<p>When emitting PTX code, all vanilla Rust functions (<code>fn</code>) get translated to
“device” functions. These functions are <em>not</em> callable from the host via the
CUDA API so a crate with only device functions is not too useful!</p>
<p>OTOH, “global” functions <em>can</em> be called by the host; you can think of them
as the real public API of your crate. To produce a global function use the
<code>"ptx-kernel"</code> ABI.</p>
<!-- NOTE(ignore) this example is specific to the nvptx targets -->
<pre><code class="language-rust ignore">#![feature(abi_ptx)]
#![no_std]

pub unsafe extern "ptx-kernel" fn global_function() {
    device_function();
}

pub fn device_function() {
    // ..
}</code></pre>
<pre><code class="language-text">$ xargo rustc --target nvptx64-nvidia-cuda --release -- --emit=asm

$ cat $(find -name '*.s')
//
// Generated by LLVM NVPTX Back-End
//

.version 3.2
.target sm_20
.address_size 64

        // .globl       _ZN6kernel15global_function17h46111ebe6516b382E

.visible .entry _ZN6kernel15global_function17h46111ebe6516b382E()
{


        ret;
}

        // .globl       _ZN6kernel15device_function17hd6a0e4993bbf3f78E
.visible .func _ZN6kernel15device_function17hd6a0e4993bbf3f78E()
{


        ret;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_riscv_interrupt"><a class="header" href="#abi_riscv_interrupt"><code>abi_riscv_interrupt</code></a></h1>
<p>Allows <code>extern "riscv-interrupt-m" fn()</code> and <code>extern "riscv-interrupt-s" fn()</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111889">#111889</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_unadjusted"><a class="header" href="#abi_unadjusted"><code>abi_unadjusted</code></a></h1>
<p>Allows using the <code>unadjusted</code> ABI; perma-unstable.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_vectorcall"><a class="header" href="#abi_vectorcall"><code>abi_vectorcall</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/124485">#124485</a></p>
<hr>
<p>Adds support for the Windows <code>"vectorcall"</code> ABI, the equivalent of <code>__vectorcall</code> in MSVC.</p>
<pre><code class="language-rust ignore (only-windows-or-x86-or-x86-64)">extern "vectorcall" {
    fn add_f64s(x: f64, y: f64) -&gt; f64;
}

fn main() {
    println!("{}", add_f64s(2.0, 4.0));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="abi_x86_interrupt"><a class="header" href="#abi_x86_interrupt"><code>abi_x86_interrupt</code></a></h1>
<p>Allows <code>extern "x86-interrupt" fn()</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/40180">#40180</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="adt_const_params"><a class="header" href="#adt_const_params"><code>adt_const_params</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/95174">#95174</a></p>
<hr>
<p>Allows for using more complex types for const parameters, such as structs or enums.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(adt_const_params)]
#![allow(incomplete_features)]

<span class="boring">fn main() {
</span>use std::marker::ConstParamTy;

#[derive(ConstParamTy, PartialEq, Eq)]
enum Foo {
    A,
    B,
    C,
}

#[derive(ConstParamTy, PartialEq, Eq)]
struct Bar {
    flag: bool,
}

fn is_foo_a_and_bar_true&lt;const F: Foo, const B: Bar&gt;() -&gt; bool {
    match (F, B.flag) {
        (Foo::A, true) =&gt; true,
        _ =&gt; false,
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="alloc_error_handler"><a class="header" href="#alloc_error_handler"><code>alloc_error_handler</code></a></h1>
<p>Allows defining an <code>#[alloc_error_handler]</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/51540">#51540</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="allocator_internals"><a class="header" href="#allocator_internals"><code>allocator_internals</code></a></h1>
<p>This feature does not have a tracking issue, it is an unstable implementation
detail of the <code>global_allocator</code> feature not intended for use outside the
compiler.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="allow_internal_unsafe"><a class="header" href="#allow_internal_unsafe"><code>allow_internal_unsafe</code></a></h1>
<p>Allows using <code>#[allow_internal_unsafe]</code>. This is an attribute on <code>macro_rules!</code> and can’t use the attribute handling below (it has to be checked before expansion possibly makes macros disappear).</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="allow_internal_unstable"><a class="header" href="#allow_internal_unstable"><code>allow_internal_unstable</code></a></h1>
<p>Allows using <code>#[allow_internal_unstable]</code>. This is an attribute on <code>macro_rules!</code> and can’t use the attribute handling below (it has to be checked before expansion possibly makes macros disappear).</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="anonymous_lifetime_in_impl_trait"><a class="header" href="#anonymous_lifetime_in_impl_trait"><code>anonymous_lifetime_in_impl_trait</code></a></h1>
<p>Allows using anonymous lifetimes in argument-position impl-trait.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="apx_target_feature"><a class="header" href="#apx_target_feature"><code>apx_target_feature</code></a></h1>
<p>The <code>apxf</code> target feature on x86</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139284">#139284</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="arbitrary_self_types"><a class="header" href="#arbitrary_self_types"><code>arbitrary_self_types</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/44874">#44874</a></p>
<hr>
<p>Allows any type implementing <code>core::ops::Receiver&lt;Target=T&gt;</code> to be used as the type
of <code>self</code> in a method belonging to <code>T</code>.</p>
<p>For example,</p>
<pre class="playground"><code class="language-rust">#![feature(arbitrary_self_types)]

struct A;

impl A {
    fn f(self: SmartPtr&lt;Self&gt;) -&gt; i32 { 1 }  // note self type
}

struct SmartPtr&lt;T&gt;(T);

impl&lt;T&gt; core::ops::Receiver for SmartPtr&lt;T&gt; {
    type Target = T;
}

fn main() {
    let smart_ptr = SmartPtr(A);
    assert_eq!(smart_ptr.f(), 1);
}</code></pre>
<p>The <code>Receiver</code> trait has a blanket implementation for all <code>T: Deref</code>, so in fact
things like this work too:</p>
<pre class="playground"><code class="language-rust">#![feature(arbitrary_self_types)]

use std::rc::Rc;

struct A;

impl A {
    fn f(self: Rc&lt;Self&gt;) -&gt; i32 { 1 } // Rc implements Deref
}

fn main() {
    let smart_ptr = Rc::new(A);
    assert_eq!(smart_ptr.f(), 1);
}</code></pre>
<p>Interestingly, that works even without the <code>arbitrary_self_types</code> feature</p>
<ul>
<li>but that’s because certain types are <em>effectively</em> hard coded, including
<code>Rc</code>. (“Hard coding” isn’t quite true; they use a lang-item called
<code>LegacyReceiver</code> to denote their special-ness in this way). With the
<code>arbitrary_self_types</code> feature, their special-ness goes away, and custom
smart pointers can achieve the same.</li>
</ul>
<h2 id="changes-to-method-lookup"><a class="header" href="#changes-to-method-lookup">Changes to method lookup</a></h2>
<p>Method lookup previously used to work by stepping through the <code>Deref</code>
chain then using the resulting list of steps in two different ways:</p>
<ul>
<li>To identify types that might contribute methods via their <code>impl</code>
blocks (inherent methods) or via traits</li>
<li>To identify the types that the method receiver (<code>a</code> in the above
examples) can be converted to.</li>
</ul>
<p>With this feature, these lists are created by instead stepping through
the <code>Receiver</code> chain. However, a note is kept about whether the type
can be reached also via the <code>Deref</code> chain.</p>
<p>The full chain (via <code>Receiver</code> hops) is used for the first purpose
(identifying relevant <code>impl</code> blocks and traits); whereas the shorter
list (reachable via <code>Deref</code>) is used for the second purpose. That’s
because, to convert the method target (<code>a</code> in <code>a.b()</code>) to the self
type, Rust may need to be able to use <code>Deref::deref</code>. Type conversions,
then, can only proceed as far as the end of the <code>Deref</code> chain whereas
the longer <code>Receiver</code> chain can be used to explore more places where
useful methods might reside.</p>
<h2 id="types-suitable-for-use-as-smart-pointers"><a class="header" href="#types-suitable-for-use-as-smart-pointers">Types suitable for use as smart pointers</a></h2>
<p>This feature allows the creation of customised smart pointers - for example
your own equivalent to <code>Rc</code> or <code>Box</code> with whatever capabilities you like.
Those smart pointers can either implement <code>Deref</code> (if it’s safe to
create a reference to the referent) or <code>Receiver</code> (if it isn’t).</p>
<p>Either way, smart pointer types should mostly <em>avoid having methods</em>.
Calling methods on a smart pointer leads to ambiguity about whether you’re
aiming for a method on the pointer, or on the referent.</p>
<p>Best practice is therefore to put smart pointer functionality into
associated functions instead - that’s what’s done in all the smart pointer
types within Rust’s standard library which implement <code>Receiver</code>.</p>
<p>If you choose to add any methods to your smart pointer type, your users
may run into errors from deshadowing, as described in the next section.</p>
<h2 id="avoiding-shadowing"><a class="header" href="#avoiding-shadowing">Avoiding shadowing</a></h2>
<p>With or without this feature, Rust emits an error if it finds two method
candidates, like this:</p>
<pre class="playground"><code class="language-rust compile_fail">use std::pin::Pin;
use std::pin::pin;

struct A;

impl A {
    fn get_ref(self: Pin&lt;&amp;A&gt;) {}
}

fn main() {
    let pinned_a: Pin&lt;&amp;A&gt; = pin!(A).as_ref();
    let pinned_a: Pin&lt;&amp;A&gt; = pinned_a.as_ref();
    pinned_a.get_ref(); // error[E0034]: multiple applicable items in scope
}</code></pre>
<p>(this is why Rust’s smart pointers are mostly carefully designed to avoid
having methods at all, and shouldn’t add new methods in future.)</p>
<p>With <code>arbitrary_self_types</code>, we take care to spot some other kinds of
conflict:</p>
<pre class="playground"><code class="language-rust compile_fail">#![feature(arbitrary_self_types)]

use std::pin::Pin;
use std::pin::pin;

struct A;

impl A {
    fn get_ref(self: &amp;Pin&lt;&amp;A&gt;) {}  // note &amp;Pin
}

fn main() {
    let pinned_a: Pin&lt;&amp;mut A&gt; = pin!(A);
    let pinned_a: Pin&lt;&amp;A&gt; = pinned_a.as_ref();
    pinned_a.get_ref();
}</code></pre>
<p>This is to guard against the case where an inner (referent) type has a
method of a given name, taking the smart pointer by reference, and then
the smart pointer implementer adds a similar method taking self by value.
As noted in the previous section, the safe option is simply
not to add methods to smart pointers, and then these errors can’t occur.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arbitrary_self_types_pointers"><a class="header" href="#arbitrary_self_types_pointers"><code>arbitrary_self_types_pointers</code></a></h1>
<p>The tracking issue for this feature is: [#44874]</p>
<hr>
<p>This extends the <a href="#arbitrary_self_types">arbitrary self types</a> feature to allow methods to
receive <code>self</code> by pointer. For example:</p>
<pre class="playground"><code class="language-rust">#![feature(arbitrary_self_types_pointers)]

struct A;

impl A {
    fn m(self: *const Self) {}
}

fn main() {
    let a = A;
    let a_ptr: *const A = &amp;a as *const A;
    a_ptr.m();
}</code></pre>
<p>In general this is not advised: it’s thought to be better practice to wrap
raw pointers in a newtype wrapper which implements the <code>core::ops::Receiver</code>
trait, then you need “only” the <code>arbitrary_self_types</code> feature. For example:</p>
<pre class="playground"><code class="language-rust">#![feature(arbitrary_self_types)]
#![allow(dead_code)]

struct A;

impl A {
    fn m(self: Wrapper&lt;Self&gt;) {} // can extract the pointer and do
        // what it needs
}

struct Wrapper&lt;T&gt;(*const T);

impl&lt;T&gt; core::ops::Receiver for Wrapper&lt;T&gt; {
    type Target = T;
}

fn main() {
    let a = A;
    let a_ptr: *const A = &amp;a as *const A;
    let a_wrapper = Wrapper(a_ptr);
    a_wrapper.m();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm_target_feature"><a class="header" href="#arm_target_feature"><code>arm_target_feature</code></a></h1>
<p>Target features on arm.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150246">#150246</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="asm_experimental_arch"><a class="header" href="#asm_experimental_arch"><code>asm_experimental_arch</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93335">#93335</a></p>
<hr>
<p>This feature tracks <code>asm!</code> and <code>global_asm!</code> support for the following architectures:</p>
<ul>
<li>NVPTX</li>
<li>PowerPC</li>
<li>Hexagon</li>
<li>MIPS32r2 and MIPS64r2</li>
<li>wasm32</li>
<li>BPF</li>
<li>SPIR-V</li>
<li>AVR</li>
<li>MSP430</li>
<li>M68k</li>
<li>CSKY</li>
<li>SPARC</li>
</ul>
<h2 id="register-classes"><a class="header" href="#register-classes">Register classes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Register class</th><th>Registers</th><th>LLVM constraint code</th></tr>
</thead>
<tbody>
<tr><td>MIPS</td><td><code>reg</code></td><td><code>$[2-25]</code></td><td><code>r</code></td></tr>
<tr><td>MIPS</td><td><code>freg</code></td><td><code>$f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>NVPTX</td><td><code>reg16</code></td><td>None*</td><td><code>h</code></td></tr>
<tr><td>NVPTX</td><td><code>reg32</code></td><td>None*</td><td><code>r</code></td></tr>
<tr><td>NVPTX</td><td><code>reg64</code></td><td>None*</td><td><code>l</code></td></tr>
<tr><td>Hexagon</td><td><code>reg</code></td><td><code>r[0-28]</code></td><td><code>r</code></td></tr>
<tr><td>Hexagon</td><td><code>preg</code></td><td><code>p[0-3]</code></td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>reg</code></td><td><code>r0</code>, <code>r[3-12]</code>, <code>r[14-29]</code>*</td><td><code>r</code></td></tr>
<tr><td>PowerPC</td><td><code>reg_nonzero</code></td><td><code>r[3-12]</code>, <code>r[14-29]</code>*</td><td><code>b</code></td></tr>
<tr><td>PowerPC</td><td><code>freg</code></td><td><code>f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>PowerPC</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td><code>v</code></td></tr>
<tr><td>PowerPC</td><td>`vsreg</td><td><code>vs[0-63]</code></td><td><code>wa</code></td></tr>
<tr><td>PowerPC</td><td><code>cr</code></td><td><code>cr[0-7]</code>, <code>cr</code></td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>ctr</code></td><td><code>ctr</code></td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>lr</code></td><td><code>lr</code></td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>xer</code></td><td><code>xer</code></td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>spe_acc</code></td><td><code>spe_acc</code></td><td>Only clobbers</td></tr>
<tr><td>wasm32</td><td><code>local</code></td><td>None*</td><td><code>r</code></td></tr>
<tr><td>BPF</td><td><code>reg</code></td><td><code>r[0-10]</code></td><td><code>r</code></td></tr>
<tr><td>BPF</td><td><code>wreg</code></td><td><code>w[0-10]</code></td><td><code>w</code></td></tr>
<tr><td>AVR</td><td><code>reg</code></td><td><code>r[2-25]</code>, <code>XH</code>, <code>XL</code>, <code>ZH</code>, <code>ZL</code></td><td><code>r</code></td></tr>
<tr><td>AVR</td><td><code>reg_upper</code></td><td><code>r[16-25]</code>, <code>XH</code>, <code>XL</code>, <code>ZH</code>, <code>ZL</code></td><td><code>d</code></td></tr>
<tr><td>AVR</td><td><code>reg_pair</code></td><td><code>r3r2</code> .. <code>r25r24</code>, <code>X</code>, <code>Z</code></td><td><code>r</code></td></tr>
<tr><td>AVR</td><td><code>reg_iw</code></td><td><code>r25r24</code>, <code>X</code>, <code>Z</code></td><td><code>w</code></td></tr>
<tr><td>AVR</td><td><code>reg_ptr</code></td><td><code>X</code>, <code>Z</code></td><td><code>e</code></td></tr>
<tr><td>MSP430</td><td><code>reg</code></td><td><code>r[0-15]</code></td><td><code>r</code></td></tr>
<tr><td>M68k</td><td><code>reg</code></td><td><code>d[0-7]</code>, <code>a[0-7]</code></td><td><code>r</code></td></tr>
<tr><td>M68k</td><td><code>reg_data</code></td><td><code>d[0-7]</code></td><td><code>d</code></td></tr>
<tr><td>M68k</td><td><code>reg_addr</code></td><td><code>a[0-3]</code></td><td><code>a</code></td></tr>
<tr><td>CSKY</td><td><code>reg</code></td><td><code>r[0-31]</code></td><td><code>r</code></td></tr>
<tr><td>CSKY</td><td><code>freg</code></td><td><code>f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>SPARC</td><td><code>reg</code></td><td><code>r[2-29]</code></td><td><code>r</code></td></tr>
<tr><td>SPARC</td><td><code>yreg</code></td><td><code>y</code></td><td>Only clobbers</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li>
<p>NVPTX doesn’t have a fixed register set, so named registers are not supported.</p>
</li>
<li>
<p>WebAssembly doesn’t have registers, so named registers are not supported.</p>
</li>
<li>
<p>r29 is reserved only on 32 bit PowerPC targets.</p>
</li>
<li>
<p>spe_acc is only available on PowerPC SPE targets.</p>
</li>
</ul>
</blockquote>
<h1 id="register-class-supported-types"><a class="header" href="#register-class-supported-types">Register class supported types</a></h1>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Register class</th><th>Target feature</th><th>Allowed types</th></tr>
</thead>
<tbody>
<tr><td>MIPS32</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>MIPS32</td><td><code>freg</code></td><td>None</td><td><code>f32</code>, <code>f64</code></td></tr>
<tr><td>MIPS64</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code></td></tr>
<tr><td>MIPS64</td><td><code>freg</code></td><td>None</td><td><code>f32</code>, <code>f64</code></td></tr>
<tr><td>NVPTX</td><td><code>reg16</code></td><td>None</td><td><code>i8</code>, <code>i16</code></td></tr>
<tr><td>NVPTX</td><td><code>reg32</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>NVPTX</td><td><code>reg64</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>Hexagon</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>Hexagon</td><td><code>preg</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> (powerpc64 only)</td></tr>
<tr><td>PowerPC</td><td><code>reg_nonzero</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> (powerpc64 only)</td></tr>
<tr><td>PowerPC</td><td><code>freg</code></td><td>None</td><td><code>f32</code>, <code>f64</code></td></tr>
<tr><td>PowerPC</td><td><code>vreg</code></td><td><code>altivec</code></td><td><code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>f32x4</code></td></tr>
<tr><td>PowerPC</td><td><code>vreg</code></td><td><code>vsx</code></td><td><code>f32</code>, <code>f64</code>, <code>i64x2</code>, <code>f64x2</code></td></tr>
<tr><td>PowerPC</td><td><code>vsreg</code></td><td><code>vsx</code></td><td>The union of vsx and altivec vreg types</td></tr>
<tr><td>PowerPC</td><td><code>cr</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>ctr</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>lr</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>xer</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>PowerPC</td><td><code>spe_acc</code></td><td>N/A</td><td>Only clobbers</td></tr>
<tr><td>wasm32</td><td><code>local</code></td><td>None</td><td><code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code> <code>f32</code> <code>f64</code></td></tr>
<tr><td>BPF</td><td><code>reg</code></td><td>None</td><td><code>i8</code> <code>i16</code> <code>i32</code> <code>i64</code></td></tr>
<tr><td>BPF</td><td><code>wreg</code></td><td><code>alu32</code></td><td><code>i8</code> <code>i16</code> <code>i32</code></td></tr>
<tr><td>AVR</td><td><code>reg</code>, <code>reg_upper</code></td><td>None</td><td><code>i8</code></td></tr>
<tr><td>AVR</td><td><code>reg_pair</code>, <code>reg_iw</code>, <code>reg_ptr</code></td><td>None</td><td><code>i16</code></td></tr>
<tr><td>MSP430</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code></td></tr>
<tr><td>M68k</td><td><code>reg</code>, <code>reg_addr</code></td><td>None</td><td><code>i16</code>, <code>i32</code></td></tr>
<tr><td>M68k</td><td><code>reg_data</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code></td></tr>
<tr><td>CSKY</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code></td></tr>
<tr><td>CSKY</td><td><code>freg</code></td><td>None</td><td><code>f32</code>,</td></tr>
<tr><td>SPARC</td><td><code>reg</code></td><td>None</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> (SPARC64 only)</td></tr>
<tr><td>SPARC</td><td><code>yreg</code></td><td>N/A</td><td>Only clobbers</td></tr>
</tbody>
</table>
</div>
<h2 id="register-aliases"><a class="header" href="#register-aliases">Register aliases</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Base register</th><th>Aliases</th></tr>
</thead>
<tbody>
<tr><td>Hexagon</td><td><code>r29</code></td><td><code>sp</code></td></tr>
<tr><td>Hexagon</td><td><code>r30</code></td><td><code>fr</code></td></tr>
<tr><td>Hexagon</td><td><code>r31</code></td><td><code>lr</code></td></tr>
<tr><td>PowerPC</td><td><code>r1</code></td><td><code>sp</code></td></tr>
<tr><td>PowerPC</td><td><code>r31</code></td><td><code>fp</code></td></tr>
<tr><td>PowerPC</td><td><code>r[0-31]</code></td><td><code>[0-31]</code></td></tr>
<tr><td>PowerPC</td><td><code>f[0-31]</code></td><td><code>fr[0-31]</code></td></tr>
<tr><td>BPF</td><td><code>r[0-10]</code></td><td><code>w[0-10]</code></td></tr>
<tr><td>AVR</td><td><code>XH</code></td><td><code>r27</code></td></tr>
<tr><td>AVR</td><td><code>XL</code></td><td><code>r26</code></td></tr>
<tr><td>AVR</td><td><code>ZH</code></td><td><code>r31</code></td></tr>
<tr><td>AVR</td><td><code>ZL</code></td><td><code>r30</code></td></tr>
<tr><td>MSP430</td><td><code>r0</code></td><td><code>pc</code></td></tr>
<tr><td>MSP430</td><td><code>r1</code></td><td><code>sp</code></td></tr>
<tr><td>MSP430</td><td><code>r2</code></td><td><code>sr</code></td></tr>
<tr><td>MSP430</td><td><code>r3</code></td><td><code>cg</code></td></tr>
<tr><td>MSP430</td><td><code>r4</code></td><td><code>fp</code></td></tr>
<tr><td>M68k</td><td><code>a5</code></td><td><code>bp</code></td></tr>
<tr><td>M68k</td><td><code>a6</code></td><td><code>fp</code></td></tr>
<tr><td>M68k</td><td><code>a7</code></td><td><code>sp</code>, <code>usp</code>, <code>ssp</code>, <code>isp</code></td></tr>
<tr><td>CSKY</td><td><code>r[0-3]</code></td><td><code>a[0-3]</code></td></tr>
<tr><td>CSKY</td><td><code>r[4-11]</code></td><td><code>l[0-7]</code></td></tr>
<tr><td>CSKY</td><td><code>r[12-13]</code></td><td><code>t[0-1]</code></td></tr>
<tr><td>CSKY</td><td><code>r14</code></td><td><code>sp</code></td></tr>
<tr><td>CSKY</td><td><code>r15</code></td><td><code>lr</code></td></tr>
<tr><td>CSKY</td><td><code>r[16-17]</code></td><td><code>l[8-9]</code></td></tr>
<tr><td>CSKY</td><td><code>r[18-25]</code></td><td><code>t[2-9]</code></td></tr>
<tr><td>CSKY</td><td><code>r28</code></td><td><code>rgb</code></td></tr>
<tr><td>CSKY</td><td><code>r29</code></td><td><code>rtb</code></td></tr>
<tr><td>CSKY</td><td><code>r30</code></td><td><code>svbr</code></td></tr>
<tr><td>CSKY</td><td><code>r31</code></td><td><code>tls</code></td></tr>
<tr><td>SPARC</td><td><code>r[0-7]</code></td><td><code>g[0-7]</code></td></tr>
<tr><td>SPARC</td><td><code>r[8-15]</code></td><td><code>o[0-7]</code></td></tr>
<tr><td>SPARC</td><td><code>r[16-23]</code></td><td><code>l[0-7]</code></td></tr>
<tr><td>SPARC</td><td><code>r[24-31]</code></td><td><code>i[0-7]</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li>TI does not mandate a frame pointer for MSP430, but toolchains are allowed
to use one; LLVM uses <code>r4</code>.</li>
</ul>
</blockquote>
<h2 id="unsupported-registers"><a class="header" href="#unsupported-registers">Unsupported registers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Unsupported register</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>All</td><td><code>sp</code>, <code>r14</code>/<code>o6</code> (SPARC)</td><td>The stack pointer must be restored to its original value at the end of an asm code block.</td></tr>
<tr><td>All</td><td><code>fr</code> (Hexagon), <code>fp</code> (PowerPC), <code>$fp</code> (MIPS), <code>Y</code> (AVR), <code>r4</code> (MSP430), <code>a6</code> (M68k), <code>r30</code>/<code>i6</code> (SPARC)</td><td>The frame pointer cannot be used as an input or output.</td></tr>
<tr><td>All</td><td><code>r19</code> (Hexagon), <code>r29</code> (PowerPC 32 bit only), <code>r30</code> (PowerPC)</td><td>These are used internally by LLVM as “base pointer” for functions with complex stack frames.</td></tr>
<tr><td>MIPS</td><td><code>$0</code> or <code>$zero</code></td><td>This is a constant zero register which can’t be modified.</td></tr>
<tr><td>MIPS</td><td><code>$1</code> or <code>$at</code></td><td>Reserved for assembler.</td></tr>
<tr><td>MIPS</td><td><code>$26</code>/<code>$k0</code>, <code>$27</code>/<code>$k1</code></td><td>OS-reserved registers.</td></tr>
<tr><td>MIPS</td><td><code>$28</code>/<code>$gp</code></td><td>Global pointer cannot be used as inputs or outputs.</td></tr>
<tr><td>MIPS</td><td><code>$ra</code></td><td>Return address cannot be used as inputs or outputs.</td></tr>
<tr><td>Hexagon</td><td><code>lr</code></td><td>This is the link register which cannot be used as an input or output.</td></tr>
<tr><td>PowerPC</td><td><code>r2</code>, <code>r13</code></td><td>These are system reserved registers.</td></tr>
<tr><td>PowerPC</td><td><code>vrsave</code></td><td>The vrsave register cannot be used as an input or output.</td></tr>
<tr><td>AVR</td><td><code>r0</code>, <code>r1</code>, <code>r1r0</code></td><td>Due to an issue in LLVM, the <code>r0</code> and <code>r1</code> registers cannot be used as inputs or outputs.  If modified, they must be restored to their original values before the end of the block.</td></tr>
<tr><td>MSP430</td><td><code>r0</code>, <code>r2</code>, <code>r3</code></td><td>These are the program counter, status register, and constant generator respectively. Neither the status register nor constant generator can be written to.</td></tr>
<tr><td>M68k</td><td><code>a4</code>, <code>a5</code></td><td>Used internally by LLVM for the base pointer and global base pointer.</td></tr>
<tr><td>CSKY</td><td><code>r7</code>, <code>r28</code></td><td>Used internally by LLVM for the base pointer and global base pointer.</td></tr>
<tr><td>CSKY</td><td><code>r8</code></td><td>Used internally by LLVM for the frame pointer.</td></tr>
<tr><td>CSKY</td><td><code>r14</code></td><td>Used internally by LLVM for the stack pointer.</td></tr>
<tr><td>CSKY</td><td><code>r15</code></td><td>This is the link register.</td></tr>
<tr><td>CSKY</td><td><code>r[26-30]</code></td><td>Reserved by its ABI.</td></tr>
<tr><td>CSKY</td><td><code>r31</code></td><td>This is the TLS register.</td></tr>
<tr><td>SPARC</td><td><code>r0</code>/<code>g0</code></td><td>This is always zero and cannot be used as inputs or outputs.</td></tr>
<tr><td>SPARC</td><td><code>r1</code>/<code>g1</code></td><td>Used internally by LLVM.</td></tr>
<tr><td>SPARC</td><td><code>r5</code>/<code>g5</code></td><td>Reserved for system. (SPARC32 only)</td></tr>
<tr><td>SPARC</td><td><code>r6</code>/<code>g6</code>, <code>r7</code>/<code>g7</code></td><td>Reserved for system.</td></tr>
<tr><td>SPARC</td><td><code>r31</code>/<code>i7</code></td><td>Return address cannot be used as inputs or outputs.</td></tr>
</tbody>
</table>
</div>
<h2 id="template-modifiers"><a class="header" href="#template-modifiers">Template modifiers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Register class</th><th>Modifier</th><th>Example output</th><th>LLVM modifier</th></tr>
</thead>
<tbody>
<tr><td>MIPS</td><td><code>reg</code></td><td>None</td><td><code>$2</code></td><td>None</td></tr>
<tr><td>MIPS</td><td><code>freg</code></td><td>None</td><td><code>$f0</code></td><td>None</td></tr>
<tr><td>NVPTX</td><td><code>reg16</code></td><td>None</td><td><code>rs0</code></td><td>None</td></tr>
<tr><td>NVPTX</td><td><code>reg32</code></td><td>None</td><td><code>r0</code></td><td>None</td></tr>
<tr><td>NVPTX</td><td><code>reg64</code></td><td>None</td><td><code>rd0</code></td><td>None</td></tr>
<tr><td>Hexagon</td><td><code>reg</code></td><td>None</td><td><code>r0</code></td><td>None</td></tr>
<tr><td>PowerPC</td><td><code>reg</code></td><td>None</td><td><code>0</code></td><td>None</td></tr>
<tr><td>PowerPC</td><td><code>reg_nonzero</code></td><td>None</td><td><code>3</code></td><td>None</td></tr>
<tr><td>PowerPC</td><td><code>freg</code></td><td>None</td><td><code>0</code></td><td>None</td></tr>
<tr><td>PowerPC</td><td><code>vreg</code></td><td>None</td><td><code>0</code></td><td>None</td></tr>
<tr><td>PowerPC</td><td><code>vsreg</code></td><td>None</td><td><code>0</code></td><td>None</td></tr>
<tr><td>SPARC</td><td><code>reg</code></td><td>None</td><td><code>%o0</code></td><td>None</td></tr>
<tr><td>CSKY</td><td><code>reg</code></td><td>None</td><td><code>r0</code></td><td>None</td></tr>
<tr><td>CSKY</td><td><code>freg</code></td><td>None</td><td><code>f0</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<h1 id="flags-covered-by-preserves_flags"><a class="header" href="#flags-covered-by-preserves_flags">Flags covered by <code>preserves_flags</code></a></h1>
<p>These flags registers must be restored upon exiting the asm block if the <code>preserves_flags</code> option is set:</p>
<ul>
<li>AVR
<ul>
<li>The status register <code>SREG</code>.</li>
</ul>
</li>
<li>MSP430
<ul>
<li>The status register <code>r2</code>.</li>
</ul>
</li>
<li>M68k
<ul>
<li>The condition code register <code>ccr</code>.</li>
</ul>
</li>
<li>SPARC
<ul>
<li>Integer condition codes (<code>icc</code> and <code>xcc</code>)</li>
<li>Floating-point condition codes (<code>fcc[0-3]</code>)</li>
</ul>
</li>
<li>CSKY
<ul>
<li>Condition/carry bit (C) in <code>PSR</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="asm_experimental_arch-1"><a class="header" href="#asm_experimental_arch-1"><code>asm_experimental_arch</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133416">#133416</a></p>
<hr>
<p>This tracks support for additional registers in architectures where inline assembly is already stable.</p>
<h2 id="register-classes-1"><a class="header" href="#register-classes-1">Register classes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Register class</th><th>Registers</th><th>LLVM constraint code</th></tr>
</thead>
<tbody>
<tr><td>s390x</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td><code>v</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li>s390x <code>vreg</code> is clobber-only in stable.</li>
</ul>
</blockquote>
<h2 id="register-class-supported-types-1"><a class="header" href="#register-class-supported-types-1">Register class supported types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Register class</th><th>Target feature</th><th>Allowed types</th></tr>
</thead>
<tbody>
<tr><td>s390x</td><td><code>vreg</code></td><td><code>vector</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <code>i128</code>, <code>f128</code>, <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
</tbody>
</table>
</div>
<h2 id="register-aliases-1"><a class="header" href="#register-aliases-1">Register aliases</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Base register</th><th>Aliases</th></tr>
</thead>
<tbody></tbody>
</table>
</div>
<h2 id="unsupported-registers-1"><a class="header" href="#unsupported-registers-1">Unsupported registers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Unsupported register</th><th>Reason</th></tr>
</thead>
<tbody></tbody>
</table>
</div>
<h2 id="template-modifiers-1"><a class="header" href="#template-modifiers-1">Template modifiers</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Architecture</th><th>Register class</th><th>Modifier</th><th>Example output</th><th>LLVM modifier</th></tr>
</thead>
<tbody>
<tr><td>s390x</td><td><code>vreg</code></td><td>None</td><td><code>%v0</code></td><td>None</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="asm_goto_with_outputs"><a class="header" href="#asm_goto_with_outputs"><code>asm_goto_with_outputs</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/119364">#119364</a></p>
<hr>
<p>This feature allows label operands to be used together with output operands.</p>
<p>Example:</p>
<pre><code class="language-rust ignore (partial-example x86-only)">
unsafe {
    let a: usize;
    asm!(
        "mov {}, 1"
        "jmp {}",
        out(reg) a,
        label {
            println!("Jumped from asm {}!", a);
        }
    );
}</code></pre>
<p>The output operands are assigned before the label blocks are executed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="asm_unwind"><a class="header" href="#asm_unwind"><code>asm_unwind</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93334">#93334</a></p>
<hr>
<p>This feature adds a <code>may_unwind</code> option to <code>asm!</code> which allows an <code>asm</code> block to unwind stack and be part of the stack unwinding process. This option is only supported by the LLVM backend right now.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="associated_type_defaults"><a class="header" href="#associated_type_defaults"><code>associated_type_defaults</code></a></h1>
<p>Allows associated type defaults.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29661">#29661</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_drop"><a class="header" href="#async_drop"><code>async_drop</code></a></h1>
<p>Allows implementing <code>AsyncDrop</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/126482">#126482</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_fn_in_dyn_trait"><a class="header" href="#async_fn_in_dyn_trait"><code>async_fn_in_dyn_trait</code></a></h1>
<p>Allows async functions to be called from <code>dyn Trait</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133119">#133119</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_fn_track_caller"><a class="header" href="#async_fn_track_caller"><code>async_fn_track_caller</code></a></h1>
<p>Allows <code>#[track_caller]</code> on async functions.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/110011">#110011</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_for_loop"><a class="header" href="#async_for_loop"><code>async_for_loop</code></a></h1>
<p>Allows <code>for await</code> loops.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118898">#118898</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_trait_bounds"><a class="header" href="#async_trait_bounds"><code>async_trait_bounds</code></a></h1>
<p>Allows <code>async</code> trait bound modifier.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/62290">#62290</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="auto_traits"><a class="header" href="#auto_traits"><code>auto_traits</code></a></h1>
<p>The tracking issue for this feature is <a href="https://github.com/rust-lang/rust/issues/13231">#13231</a></p>
<hr>
<p>The <code>auto_traits</code> feature gate allows you to define auto traits.</p>
<p>Auto traits, like <a href="../std/marker/trait.Send.html"><code>Send</code></a> or <a href="../std/marker/trait.Sync.html"><code>Sync</code></a> in the standard library, are marker traits
that are automatically implemented for every type, unless the type, or a type it contains,
has explicitly opted out via a negative impl. (Negative impls are separately controlled
by the <code>negative_impls</code> feature.)</p>
<pre><code class="language-rust ignore (partial-example)">impl !Trait for Type {}</code></pre>
<p>Example:</p>
<pre class="playground"><code class="language-rust">#![feature(negative_impls)]
#![feature(auto_traits)]

auto trait Valid {}

struct True;
struct False;

impl !Valid for False {}

struct MaybeValid&lt;T&gt;(T);

fn must_be_valid&lt;T: Valid&gt;(_t: T) { }

fn main() {
    // works
    must_be_valid( MaybeValid(True) );

    // compiler error - trait bound not satisfied
    // must_be_valid( MaybeValid(False) );
}</code></pre>
<h2 id="automatic-trait-implementations"><a class="header" href="#automatic-trait-implementations">Automatic trait implementations</a></h2>
<p>When a type is declared as an <code>auto trait</code>, we will automatically
create impls for every struct/enum/union, unless an explicit impl is
provided. These automatic impls contain a where clause for each field
of the form <code>T: AutoTrait</code>, where <code>T</code> is the type of the field and
<code>AutoTrait</code> is the auto trait in question. As an example, consider the
struct <code>List</code> and the auto trait <code>Send</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct List&lt;T&gt; {
  data: T,
  next: Option&lt;Box&lt;List&lt;T&gt;&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<p>Presuming that there is no explicit impl of <code>Send</code> for <code>List</code>, the
compiler will supply an automatic impl of the form:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct List&lt;T&gt; {
  data: T,
  next: Option&lt;Box&lt;List&lt;T&gt;&gt;&gt;,
}

unsafe impl&lt;T&gt; Send for List&lt;T&gt;
where
  T: Send, // from the field `data`
  Option&lt;Box&lt;List&lt;T&gt;&gt;&gt;: Send, // from the field `next`
{ }
<span class="boring">}</span></code></pre>
<p>Explicit impls may be either positive or negative. They take the form:</p>
<pre><code class="language-rust ignore (partial-example)">impl&lt;...&gt; AutoTrait for StructName&lt;..&gt; { }
impl&lt;...&gt; !AutoTrait for StructName&lt;..&gt; { }</code></pre>
<h2 id="coinduction-auto-traits-permit-cyclic-matching"><a class="header" href="#coinduction-auto-traits-permit-cyclic-matching">Coinduction: Auto traits permit cyclic matching</a></h2>
<p>Unlike ordinary trait matching, auto traits are <strong>coinductive</strong>. This
means, in short, that cycles which occur in trait matching are
considered ok. As an example, consider the recursive struct <code>List</code>
introduced in the previous section. In attempting to determine whether
<code>List: Send</code>, we would wind up in a cycle: to apply the impl, we must
show that <code>Option&lt;Box&lt;List&gt;&gt;: Send</code>, which will in turn require
<code>Box&lt;List&gt;: Send</code> and then finally <code>List: Send</code> again. Under ordinary
trait matching, this cycle would be an error, but for an auto trait it
is considered a successful match.</p>
<h2 id="items"><a class="header" href="#items">Items</a></h2>
<p>Auto traits cannot have any trait items, such as methods or associated types. This ensures that we can generate default implementations.</p>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>Auto traits cannot have supertraits. This is for soundness reasons, as the interaction of coinduction with implied bounds is difficult to reconcile.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="avx10_target_feature"><a class="header" href="#avx10_target_feature"><code>avx10_target_feature</code></a></h1>
<p>Allows using Intel AVX10 target features and intrinsics</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138843">#138843</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="box_patterns"><a class="header" href="#box_patterns"><code>box_patterns</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29641">#29641</a></p>
<hr>
<blockquote>
<p><strong>Note</strong>: This feature will be superseded by <a href="#deref_patterns"><code>deref_patterns</code></a> in the future.</p>
</blockquote>
<p>Box patterns let you match on <code>Box&lt;T&gt;</code>s:</p>
<pre class="playground"><code class="language-rust">#![feature(box_patterns)]

fn main() {
    let b = Some(Box::new(5));
    match b {
        Some(box n) if n &lt; 0 =&gt; {
            println!("Box contains negative number {n}");
        },
        Some(box n) if n &gt;= 0 =&gt; {
            println!("Box contains non-negative number {n}");
        },
        None =&gt; {
            println!("No box");
        },
        _ =&gt; unreachable!()
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bpf_target_feature"><a class="header" href="#bpf_target_feature"><code>bpf_target_feature</code></a></h1>
<p>Target features on bpf.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150247">#150247</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="builtin_syntax"><a class="header" href="#builtin_syntax"><code>builtin_syntax</code></a></h1>
<p>Allows builtin # foo() syntax</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/110680">#110680</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="c_variadic"><a class="header" href="#c_variadic"><code>c_variadic</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/44930">#44930</a></p>
<hr>
<p>The <code>c_variadic</code> language feature enables C-variadic functions to be
defined in Rust. They may be called both from within Rust and via FFI.</p>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(c_variadic)]

<span class="boring">fn main() {
</span>pub unsafe extern "C" fn add(n: usize, mut args: ...) -&gt; usize {
    let mut sum = 0;
    for _ in 0..n {
        sum += args.arg::&lt;usize&gt;();
    }
    sum
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="c_variadic_naked_functions"><a class="header" href="#c_variadic_naked_functions"><code>c_variadic_naked_functions</code></a></h1>
<p>Allows defining c-variadic naked functions with any extern ABI that is allowed on c-variadic foreign functions.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148767">#148767</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_contract_checks"><a class="header" href="#cfg_contract_checks"><code>cfg_contract_checks</code></a></h1>
<p>Allows the use of <code>#[cfg(contract_checks)</code> to check if contract checks are enabled.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/128044">#128044</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_emscripten_wasm_eh"><a class="header" href="#cfg_emscripten_wasm_eh"><code>cfg_emscripten_wasm_eh</code></a></h1>
<p>Allows access to the emscripten_wasm_eh config, used by panic_unwind and unwind</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_overflow_checks"><a class="header" href="#cfg_overflow_checks"><code>cfg_overflow_checks</code></a></h1>
<p>Allows the use of <code>#[cfg(overflow_checks)</code> to check if integer overflow behaviour.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111466">#111466</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_relocation_model"><a class="header" href="#cfg_relocation_model"><code>cfg_relocation_model</code></a></h1>
<p>Provides the relocation model information as cfg entry</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/114929">#114929</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_sanitize"><a class="header" href="#cfg_sanitize"><code>cfg_sanitize</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/39699">#39699</a></p>
<hr>
<p>The <code>cfg_sanitize</code> feature makes it possible to execute different code
depending on whether a particular sanitizer is enabled or not.</p>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(cfg_sanitize)]

<span class="boring">fn main() {
</span>#[cfg(sanitize = "thread")]
fn a() {
    // ...
}

#[cfg(not(sanitize = "thread"))]
fn a() {
    // ...
}

fn b() {
    if cfg!(sanitize = "leak") {
        // ...
    } else {
        // ...
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_sanitizer_cfi"><a class="header" href="#cfg_sanitizer_cfi"><code>cfg_sanitizer_cfi</code></a></h1>
<p>Allows <code>cfg(sanitizer_cfi_generalize_pointers)</code> and <code>cfg(sanitizer_cfi_normalize_integers)</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89653">#89653</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_target_compact"><a class="header" href="#cfg_target_compact"><code>cfg_target_compact</code></a></h1>
<p>Allows <code>cfg(target(abi = "..."))</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96901">#96901</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_target_has_atomic"><a class="header" href="#cfg_target_has_atomic"><code>cfg_target_has_atomic</code></a></h1>
<p>Allows <code>cfg(target_has_atomic_load_store = "...")</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/94039">#94039</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_target_has_atomic_equal_alignment"><a class="header" href="#cfg_target_has_atomic_equal_alignment"><code>cfg_target_has_atomic_equal_alignment</code></a></h1>
<p>Allows <code>cfg(target_has_atomic_equal_alignment = "...")</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93822">#93822</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_target_has_reliable_f16_f128"><a class="header" href="#cfg_target_has_reliable_f16_f128"><code>cfg_target_has_reliable_f16_f128</code></a></h1>
<p>Allows checking whether or not the backend correctly supports unstable float types.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_target_thread_local"><a class="header" href="#cfg_target_thread_local"><code>cfg_target_thread_local</code></a></h1>
<p>Allows <code>cfg(target_thread_local)</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29594">#29594</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_ub_checks"><a class="header" href="#cfg_ub_checks"><code>cfg_ub_checks</code></a></h1>
<p>Allows the use of <code>#[cfg(ub_checks)</code> to check if UB checks are enabled.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123499">#123499</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_version"><a class="header" href="#cfg_version"><code>cfg_version</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/64796">#64796</a></p>
<hr>
<p>The <code>cfg_version</code> feature makes it possible to execute different code
depending on the compiler version. It will return true if the compiler
version is greater than or equal to the specified version.</p>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(cfg_version)]

<span class="boring">fn main() {
</span>#[cfg(version("1.42"))] // 1.42 and above
fn a() {
    // ...
}

#[cfg(not(version("1.42")))] // 1.41 and below
fn a() {
    // ...
}

fn b() {
    if cfg!(version("1.42")) {
        // ...
    } else {
        // ...
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfi_encoding"><a class="header" href="#cfi_encoding"><code>cfi_encoding</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89653">#89653</a></p>
<hr>
<p>The <code>cfi_encoding</code> feature allows the user to define a CFI encoding for a type.
It allows the user to use a different names for types that otherwise would be
required to have the same name as used in externally defined C functions.</p>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(cfi_encoding, extern_types)]

<span class="boring">fn main() {
</span>#[cfi_encoding = "3Foo"]
pub struct Type1(i32);

extern {
    #[cfi_encoding = "3Bar"]
    type Type2;
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="closure_lifetime_binder"><a class="header" href="#closure_lifetime_binder"><code>closure_lifetime_binder</code></a></h1>
<p>Allows <code>for&lt;...&gt;</code> on closures and coroutines.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/97362">#97362</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="closure_track_caller"><a class="header" href="#closure_track_caller"><code>closure_track_caller</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87417">#87417</a></p>
<hr>
<p>Allows using the <code>#[track_caller]</code> attribute on closures and coroutines.
Calls made to the closure or coroutine will have caller information
available through <code>std::panic::Location::caller()</code>, just like using
<code>#[track_caller]</code> on a function.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cmse_nonsecure_entry"><a class="header" href="#cmse_nonsecure_entry"><code>cmse_nonsecure_entry</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/75835">#75835</a></p>
<hr>
<p>The <a href="https://developer.arm.com/documentation/100690/latest/">TrustZone-M
feature</a> is available
for targets with the Armv8-M architecture profile (<code>thumbv8m</code> in their target
name).
LLVM, the Rust compiler and the linker are providing
<a href="https://developer.arm.com/documentation/ecm0359818/latest/">support</a> for the
TrustZone-M feature.</p>
<p>One of the things provided with this unstable feature is the “cmse-nonsecure-entry” ABI.
This ABI marks a Secure function as an entry function (see
<a href="https://developer.arm.com/documentation/ecm0359818/latest/">section 5.4</a> for details).
With this ABI, the compiler will do the following:</p>
<ul>
<li>add a special symbol on the function which is the <code>__acle_se_</code> prefix and the
standard function name</li>
<li>constrain the number of parameters to avoid using the Non-Secure stack</li>
<li>before returning from the function, clear registers that might contain Secure
information</li>
<li>use the <code>BXNS</code> instruction to return</li>
</ul>
<p>Because the stack can not be used to pass parameters, there will be compilation
errors if:</p>
<ul>
<li>the total size of all parameters is too big (for example, more than four 32-bit integers)</li>
</ul>
<p>The special symbol <code>__acle_se_</code> will be used by the linker to generate a secure
gateway veneer.</p>
<!-- NOTE(ignore) this example is specific to thumbv8m targets -->
<pre><code class="language-rust ignore">#![no_std]
#![feature(cmse_nonsecure_entry)]

#[no_mangle]
pub extern "cmse-nonsecure-entry" fn entry_function(input: u32) -&gt; u32 {
    input + 6
}</code></pre>
<pre><code class="language-text">$ rustc --emit obj --crate-type lib --target thumbv8m.main-none-eabi function.rs
$ arm-none-eabi-objdump -D function.o

00000000 &lt;entry_function&gt;:
   0:   b580            push    {r7, lr}
   2:   466f            mov     r7, sp
   4:   b082            sub     sp, #8
   6:   9001            str     r0, [sp, #4]
   8:   1d81            adds    r1, r0, #6
   a:   460a            mov     r2, r1
   c:   4281            cmp     r1, r0
   e:   9200            str     r2, [sp, #0]
  10:   d30b            bcc.n   2a &lt;entry_function+0x2a&gt;
  12:   e7ff            b.n     14 &lt;entry_function+0x14&gt;
  14:   9800            ldr     r0, [sp, #0]
  16:   b002            add     sp, #8
  18:   e8bd 4080       ldmia.w sp!, {r7, lr}
  1c:   4671            mov     r1, lr
  1e:   4672            mov     r2, lr
  20:   4673            mov     r3, lr
  22:   46f4            mov     ip, lr
  24:   f38e 8800       msr     CPSR_f, lr
  28:   4774            bxns    lr
  2a:   f240 0000       movw    r0, #0
  2e:   f2c0 0000       movt    r0, #0
  32:   f240 0200       movw    r2, #0
  36:   f2c0 0200       movt    r2, #0
  3a:   211c            movs    r1, #28
  3c:   f7ff fffe       bl      0 &lt;_ZN4core9panicking5panic17h5c028258ca2fb3f5E&gt;
  40:   defe            udf     #254    ; 0xfe
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="compiler_builtins"><a class="header" href="#compiler_builtins"><code>compiler_builtins</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_async_blocks"><a class="header" href="#const_async_blocks"><code>const_async_blocks</code></a></h1>
<p>Allows <code>async {}</code> expressions in const contexts.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/85368">#85368</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_closures"><a class="header" href="#const_closures"><code>const_closures</code></a></h1>
<p>Allows <code>const || {}</code> closures in const contexts.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/106003">#106003</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_destruct"><a class="header" href="#const_destruct"><code>const_destruct</code></a></h1>
<p>Allows using <code>[const] Destruct</code> bounds and calling drop impls in const contexts.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133214">#133214</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_for"><a class="header" href="#const_for"><code>const_for</code></a></h1>
<p>Allows <code>for _ in _</code> loops in const contexts.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87575">#87575</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_precise_live_drops"><a class="header" href="#const_precise_live_drops"><code>const_precise_live_drops</code></a></h1>
<p>Be more precise when looking for live drops in a const context.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/73255">#73255</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_trait_impl"><a class="header" href="#const_trait_impl"><code>const_trait_impl</code></a></h1>
<p>Allows <code>impl const Trait for T</code> syntax.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143874">#143874</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_try"><a class="header" href="#const_try"><code>const_try</code></a></h1>
<p>Allows the <code>?</code> operator in const contexts.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/74935">#74935</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="contracts"><a class="header" href="#contracts"><code>contracts</code></a></h1>
<p>Allows use of contracts attributes.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/128044">#128044</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="contracts_internals"><a class="header" href="#contracts_internals"><code>contracts_internals</code></a></h1>
<p>Allows access to internal machinery used to implement contracts.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/128044">#128044</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="coroutine_clone"><a class="header" href="#coroutine_clone"><code>coroutine_clone</code></a></h1>
<p>Allows coroutines to be cloned.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/95360">#95360</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="coroutines"><a class="header" href="#coroutines"><code>coroutines</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/43122">#43122</a></p>
<hr>
<p>The <code>coroutines</code> feature gate in Rust allows you to define coroutine or
coroutine literals. A coroutine is a “resumable function” that syntactically
resembles a closure but compiles to much different semantics in the compiler
itself. The primary feature of a coroutine is that it can be suspended during
execution to be resumed at a later date. Coroutines use the <code>yield</code> keyword to
“return”, and then the caller can <code>resume</code> a coroutine to resume execution just
after the <code>yield</code> keyword.</p>
<p>Coroutines are an extra-unstable feature in the compiler right now. Added in
<a href="https://github.com/rust-lang/rfcs/pull/2033">RFC 2033</a> they’re mostly intended right now as a information/constraint
gathering phase. The intent is that experimentation can happen on the nightly
compiler before actual stabilization. A further RFC will be required to
stabilize coroutines and will likely contain at least a few small
tweaks to the overall design.</p>
<p>A syntactical example of a coroutine is:</p>
<pre class="playground"><code class="language-rust">#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::{Coroutine, CoroutineState};
use std::pin::Pin;

fn main() {
    let mut coroutine = #[coroutine] || {
        yield 1;
        return "foo"
    };

    match Pin::new(&amp;mut coroutine).resume(()) {
        CoroutineState::Yielded(1) =&gt; {}
        _ =&gt; panic!("unexpected value from resume"),
    }
    match Pin::new(&amp;mut coroutine).resume(()) {
        CoroutineState::Complete("foo") =&gt; {}
        _ =&gt; panic!("unexpected value from resume"),
    }
}</code></pre>
<p>Coroutines are closure-like literals which are annotated with <code>#[coroutine]</code>
and can contain a <code>yield</code> statement. The
<code>yield</code> statement takes an optional expression of a value to yield out of the
coroutine. All coroutine literals implement the <code>Coroutine</code> trait in the
<code>std::ops</code> module. The <code>Coroutine</code> trait has one main method, <code>resume</code>, which
resumes execution of the coroutine at the previous suspension point.</p>
<p>An example of the control flow of coroutines is that the following example
prints all numbers in order:</p>
<pre class="playground"><code class="language-rust">#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::Coroutine;
use std::pin::Pin;

fn main() {
    let mut coroutine = #[coroutine] || {
        println!("2");
        yield;
        println!("4");
    };

    println!("1");
    Pin::new(&amp;mut coroutine).resume(());
    println!("3");
    Pin::new(&amp;mut coroutine).resume(());
    println!("5");
}</code></pre>
<p>At this time the main use case of coroutines is an implementation
primitive for <code>async</code>/<code>await</code> and <code>gen</code> syntax, but coroutines
will likely be extended to other primitives in the future.
Feedback on the design and usage is always appreciated!</p>
<h3 id="the-coroutine-trait"><a class="header" href="#the-coroutine-trait">The <code>Coroutine</code> trait</a></h3>
<p>The <code>Coroutine</code> trait in <code>std::ops</code> currently looks like:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(arbitrary_self_types, coroutine_trait)]
</span><span class="boring">use std::ops::CoroutineState;
</span><span class="boring">use std::pin::Pin;
</span>
pub trait Coroutine&lt;R = ()&gt; {
    type Yield;
    type Return;
    fn resume(self: Pin&lt;&amp;mut Self&gt;, resume: R) -&gt; CoroutineState&lt;Self::Yield, Self::Return&gt;;
}
<span class="boring">}</span></code></pre>
<p>The <code>Coroutine::Yield</code> type is the type of values that can be yielded with the
<code>yield</code> statement. The <code>Coroutine::Return</code> type is the returned type of the
coroutine. This is typically the last expression in a coroutine’s definition or
any value passed to <code>return</code> in a coroutine. The <code>resume</code> function is the entry
point for executing the <code>Coroutine</code> itself.</p>
<p>The return value of <code>resume</code>, <code>CoroutineState</code>, looks like:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CoroutineState&lt;Y, R&gt; {
    Yielded(Y),
    Complete(R),
}
<span class="boring">}</span></code></pre>
<p>The <code>Yielded</code> variant indicates that the coroutine can later be resumed. This
corresponds to a <code>yield</code> point in a coroutine. The <code>Complete</code> variant indicates
that the coroutine is complete and cannot be resumed again. Calling <code>resume</code>
after a coroutine has returned <code>Complete</code> will likely result in a panic of the
program.</p>
<h3 id="closure-like-semantics"><a class="header" href="#closure-like-semantics">Closure-like semantics</a></h3>
<p>The closure-like syntax for coroutines alludes to the fact that they also have
closure-like semantics. Namely:</p>
<ul>
<li>
<p>When created, a coroutine executes no code. A closure literal does not
actually execute any of the closure’s code on construction, and similarly a
coroutine literal does not execute any code inside the coroutine when
constructed.</p>
</li>
<li>
<p>Coroutines can capture outer variables by reference or by move, and this can
be tweaked with the <code>move</code> keyword at the beginning of the closure. Like
closures all coroutines will have an implicit environment which is inferred by
the compiler. Outer variables can be moved into a coroutine for use as the
coroutine progresses.</p>
</li>
<li>
<p>Coroutine literals produce a value with a unique type which implements the
<code>std::ops::Coroutine</code> trait. This allows actual execution of the coroutine
through the <code>Coroutine::resume</code> method as well as also naming it in return
types and such.</p>
</li>
<li>
<p>Traits like <code>Send</code> and <code>Sync</code> are automatically implemented for a <code>Coroutine</code>
depending on the captured variables of the environment. Unlike closures,
coroutines also depend on variables live across suspension points. This means
that although the ambient environment may be <code>Send</code> or <code>Sync</code>, the coroutine
itself may not be due to internal variables live across <code>yield</code> points being
not-<code>Send</code> or not-<code>Sync</code>. Note that coroutines do
not implement traits like <code>Copy</code> or <code>Clone</code> automatically.</p>
</li>
<li>
<p>Whenever a coroutine is dropped it will drop all captured environment
variables.</p>
</li>
</ul>
<h3 id="coroutines-as-state-machines"><a class="header" href="#coroutines-as-state-machines">Coroutines as state machines</a></h3>
<p>In the compiler, coroutines are currently compiled as state machines. Each
<code>yield</code> expression will correspond to a different state that stores all live
variables over that suspension point. Resumption of a coroutine will dispatch on
the current state and then execute internally until a <code>yield</code> is reached, at
which point all state is saved off in the coroutine and a value is returned.</p>
<p>Let’s take a look at an example to see what’s going on here:</p>
<pre class="playground"><code class="language-rust">#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::Coroutine;
use std::pin::Pin;

fn main() {
    let ret = "foo";
    let mut coroutine = #[coroutine] move || {
        yield 1;
        return ret
    };

    Pin::new(&amp;mut coroutine).resume(());
    Pin::new(&amp;mut coroutine).resume(());
}</code></pre>
<p>This coroutine literal will compile down to something similar to:</p>
<pre class="playground"><code class="language-rust">#![feature(arbitrary_self_types, coroutine_trait)]

use std::ops::{Coroutine, CoroutineState};
use std::pin::Pin;

fn main() {
    let ret = "foo";
    let mut coroutine = {
        enum __Coroutine {
            Start(&amp;'static str),
            Yield1(&amp;'static str),
            Done,
        }

        impl Coroutine for __Coroutine {
            type Yield = i32;
            type Return = &amp;'static str;

            fn resume(mut self: Pin&lt;&amp;mut Self&gt;, resume: ()) -&gt; CoroutineState&lt;i32, &amp;'static str&gt; {
                use std::mem;
                match mem::replace(&amp;mut *self, __Coroutine::Done) {
                    __Coroutine::Start(s) =&gt; {
                        *self = __Coroutine::Yield1(s);
                        CoroutineState::Yielded(1)
                    }

                    __Coroutine::Yield1(s) =&gt; {
                        *self = __Coroutine::Done;
                        CoroutineState::Complete(s)
                    }

                    __Coroutine::Done =&gt; {
                        panic!("coroutine resumed after completion")
                    }
                }
            }
        }

        __Coroutine::Start(ret)
    };

    Pin::new(&amp;mut coroutine).resume(());
    Pin::new(&amp;mut coroutine).resume(());
}</code></pre>
<p>Notably here we can see that the compiler is generating a fresh type,
<code>__Coroutine</code> in this case. This type has a number of states (represented here
as an <code>enum</code>) corresponding to each of the conceptual states of the coroutine.
At the beginning we’re closing over our outer variable <code>foo</code> and then that
variable is also live over the <code>yield</code> point, so it’s stored in both states.</p>
<p>When the coroutine starts it’ll immediately yield 1, but it saves off its state
just before it does so indicating that it has reached the yield point. Upon
resuming again we’ll execute the <code>return ret</code> which returns the <code>Complete</code>
state.</p>
<p>Here we can also note that the <code>Done</code> state, if resumed, panics immediately as
it’s invalid to resume a completed coroutine. It’s also worth noting that this
is just a rough desugaring, not a normative specification for what the compiler
does.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="coverage_attribute"><a class="header" href="#coverage_attribute"><code>coverage_attribute</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/84605">#84605</a></p>
<hr>
<p>The <code>coverage</code> attribute can be used to selectively disable coverage
instrumentation in an annotated function. This might be useful to:</p>
<ul>
<li>Avoid instrumentation overhead in a performance critical function</li>
<li>Avoid generating coverage for a function that is not meant to be executed,
but still target 100% coverage for the rest of the program.</li>
</ul>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(coverage_attribute)]

<span class="boring">fn main() {
</span>// `foo()` will get coverage instrumentation (by default)
fn foo() {
  // ...
}

#[coverage(off)]
fn bar() {
  // ...
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="csky_target_feature"><a class="header" href="#csky_target_feature"><code>csky_target_feature</code></a></h1>
<p>Target features on csky.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150248">#150248</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom_inner_attributes"><a class="header" href="#custom_inner_attributes"><code>custom_inner_attributes</code></a></h1>
<p>Allows non-builtin attributes in inner attribute position.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54726">#54726</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom_mir"><a class="header" href="#custom_mir"><code>custom_mir</code></a></h1>
<p>Allows writing custom MIR</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom_test_frameworks"><a class="header" href="#custom_test_frameworks"><code>custom_test_frameworks</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/50297">#50297</a></p>
<hr>
<p>The <code>custom_test_frameworks</code> feature allows the use of <code>#[test_case]</code> and <code>#![test_runner]</code>.
Any function, const, or static can be annotated with <code>#[test_case]</code> causing it to be aggregated (like <code>#[test]</code>)
and be passed to the test runner determined by the <code>#![test_runner]</code> crate attribute.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(custom_test_frameworks)]
#![test_runner(my_runner)]

<span class="boring">fn main() {
</span>fn my_runner(tests: &amp;[&amp;i32]) {
    for t in tests {
        if **t == 0 {
            println!("PASSED");
        } else {
            println!("FAILED");
        }
    }
}

#[test_case]
const WILL_PASS: i32 = 0;

#[test_case]
const WILL_FAIL: i32 = 4;
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="decl_macro"><a class="header" href="#decl_macro"><code>decl_macro</code></a></h1>
<p>Allows declarative macros 2.0 (<code>macro</code>).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/39412">#39412</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="default_field_values"><a class="header" href="#default_field_values"><code>default_field_values</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132162">#132162</a></p>
<p>The RFC for this feature is: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3681-default-field-values.md">#3681</a></p>
<hr>
<p>The <code>default_field_values</code> feature allows users to specify a const value for
individual fields in struct definitions, allowing those to be omitted from
initializers.</p>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<pre class="playground"><code class="language-rust">#![feature(default_field_values)]

#[derive(Default)]
struct Pet {
    name: Option&lt;String&gt;, // impl Default for Pet will use Default::default() for name
    age: i128 = 42, // impl Default for Pet will use the literal 42 for age
}

fn main() {
    let a = Pet { name: Some(String::new()), .. }; // Pet { name: Some(""), age: 42 }
    let b = Pet::default(); // Pet { name: None, age: 42 }
    assert_eq!(a.age, b.age);
    // The following would be a compilation error: `name` needs to be specified
    // let _ = Pet { .. };
}</code></pre>
<h2 id="derivedefault"><a class="header" href="#derivedefault"><code>#[derive(Default)]</code></a></h2>
<p>When deriving Default, the provided values are then used. On enum variants,
the variant must still be marked with <code>#[default]</code> and have all its fields
with default values.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(default_field_values)]

<span class="boring">fn main() {
</span>#[derive(Default)]
enum A {
    #[default]
    B {
        x: i32 = 0,
        y: i32 = 0,
    },
    C,
}
<span class="boring">}</span></code></pre>
<h2 id="enum-variants"><a class="header" href="#enum-variants">Enum variants</a></h2>
<p>This feature also supports enum variants for both specifying default values
and <code>#[derive(Default)]</code>.</p>
<h2 id="interaction-with-non_exhaustive"><a class="header" href="#interaction-with-non_exhaustive">Interaction with <code>#[non_exhaustive]</code></a></h2>
<p>A struct or enum variant marked with <code>#[non_exhaustive]</code> is not allowed to
have default field values.</p>
<h2 id="lints"><a class="header" href="#lints">Lints</a></h2>
<p>When manually implementing the <code>Default</code> trait for a type that has default
field values, if any of these are overridden in the impl the
<code>default_overrides_default_fields</code> lint will trigger. This lint is in place
to avoid surprising diverging behavior between <code>S { .. }</code> and
<code>S::default()</code>, where using the same type in both ways could result in
different values. The appropriate way to write a manual <code>Default</code>
implementation is to use the functional update syntax:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(default_field_values)]

<span class="boring">fn main() {
</span>struct Pet {
    name: String,
    age: i128 = 42, // impl Default for Pet will use the literal 42 for age
}

impl Default for Pet {
    fn default() -&gt; Pet {
        Pet {
            name: "no-name".to_string(),
            ..
        }
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="deprecated_safe"><a class="header" href="#deprecated_safe"><code>deprecated_safe</code></a></h1>
<p>Allows using <code>#[deprecated_safe]</code> to deprecate the safeness of a function or trait</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/94978">#94978</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="deprecated_suggestion"><a class="header" href="#deprecated_suggestion"><code>deprecated_suggestion</code></a></h1>
<p>Allows having using <code>suggestion</code> in the <code>#[deprecated]</code> attribute.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/94785">#94785</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="deref_patterns"><a class="header" href="#deref_patterns"><code>deref_patterns</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87121">#87121</a></p>
<hr>
<blockquote>
<p><strong>Note</strong>: This feature is incomplete. In the future, it is meant to supersede
<a href="#box_patterns"><code>box_patterns</code></a>.</p>
</blockquote>
<p>This feature permits pattern matching on <a href="https://doc.rust-lang.org/std/ops/trait.DerefPure.html#implementors">smart pointers in the standard library</a> through their
<code>Deref</code> target types, either implicitly or with explicit <code>deref!(_)</code> patterns (the syntax of which
is currently a placeholder).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(deref_patterns)]
#![allow(incomplete_features)]

<span class="boring">fn main() {
</span>let mut v = vec![Box::new(Some(0))];

// Implicit dereferences are inserted when a pattern can match against the
// result of repeatedly dereferencing but can't match against a smart
// pointer itself. This works alongside match ergonomics for references.
if let [Some(x)] = &amp;mut v {
    *x += 1;
}

// Explicit `deref!(_)` patterns may instead be used when finer control is
// needed, e.g. to dereference only a single smart pointer, or to bind the
// the result of dereferencing to a variable.
if let deref!([deref!(opt_x @ Some(1))]) = &amp;mut v {
    opt_x.as_mut().map(|x| *x += 1);
}

assert_eq!(v, [Box::new(Some(2))]);
<span class="boring">}</span></code></pre>
<p>Without this feature, it may be necessary to introduce temporaries to represent dereferenced places
when matching on nested structures:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![Box::new(Some(0))];
if let [b] = &amp;mut *v {
    if let Some(x) = &amp;mut **b {
        *x += 1;
    }
}
if let [b] = &amp;mut *v {
    if let opt_x @ Some(1) = &amp;mut **b {
        opt_x.as_mut().map(|x| *x += 1);
    }
}
assert_eq!(v, [Box::new(Some(2))]);
<span class="boring">}</span></code></pre>
<p>Like <a href="#box_patterns"><code>box_patterns</code></a>, deref patterns may move out of boxes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(deref_patterns)]
</span><span class="boring">#![allow(incomplete_features)]
</span>struct NoCopy;
let deref!(x) = Box::new(NoCopy);
drop::&lt;NoCopy&gt;(x);
<span class="boring">}</span></code></pre>
<p>Additionally, <code>deref_patterns</code> implements changes to string and byte string literal patterns,
allowing then to be used in deref patterns:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(deref_patterns)]
</span><span class="boring">#![allow(incomplete_features)]
</span>match ("test".to_string(), Box::from("test"), b"test".to_vec()) {
    ("test", "test", b"test") =&gt; {}
    _ =&gt; panic!(),
}

// This works through multiple layers of reference and smart pointer:
match (&amp;Box::new(&amp;"test".to_string()), &amp;&amp;&amp;"test") {
    ("test", "test") =&gt; {}
    _ =&gt; panic!(),
}

// `deref!("...")` syntax may also be used:
match "test".to_string() {
    deref!("test") =&gt; {}
    _ =&gt; panic!(),
}

// Matching on slices and arrays using literals is possible elsewhere as well:
match *"test" {
    "test" =&gt; {}
    _ =&gt; panic!(),
}
match *b"test" {
    b"test" =&gt; {}
    _ =&gt; panic!(),
}
match *(b"test" as &amp;[u8]) {
    b"test" =&gt; {}
    _ =&gt; panic!(),
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="derive_from"><a class="header" href="#derive_from"><code>derive_from</code></a></h1>
<p>Allows deriving the From trait on single-field structs.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144889">#144889</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="diagnostic_on_const"><a class="header" href="#diagnostic_on_const"><code>diagnostic_on_const</code></a></h1>
<p>Allows giving non-const impls custom diagnostic messages if attempted to be used as const</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143874">#143874</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="doc_cfg"><a class="header" href="#doc_cfg"><code>doc_cfg</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/43781">#43781</a></p>
<hr>
<p>The <code>doc_cfg</code> feature allows an API be documented as only available in some specific platforms.
This attribute has two effects:</p>
<ol>
<li>
<p>In the annotated item’s documentation, there will be a message saying “Available on
(platform) only”.</p>
</li>
<li>
<p>The item’s doc-tests will only run on the specific platform.</p>
</li>
</ol>
<p>In addition to allowing the use of the <code>#[doc(cfg)]</code> attribute, this feature enables the use of a
special conditional compilation flag, <code>#[cfg(doc)]</code>, set whenever building documentation on your
crate.</p>
<p>This feature was introduced as part of PR <a href="https://github.com/rust-lang/rust/issues/43348">#43348</a> to allow the platform-specific parts of the
standard library be documented.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(doc_cfg)]

<span class="boring">fn main() {
</span>#[cfg(any(windows, doc))]
#[doc(cfg(windows))]
/// The application's icon in the notification area (a.k.a. system tray).
///
/// # Examples
///
/// ```no_run
/// extern crate my_awesome_ui_library;
/// use my_awesome_ui_library::current_app;
/// use my_awesome_ui_library::windows::notification;
///
/// let icon = current_app().get::&lt;notification::Icon&gt;();
/// icon.show();
/// icon.show_message("Hello");
/// ```
pub struct Icon {
    // ...
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="doc_masked"><a class="header" href="#doc_masked"><code>doc_masked</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/pull/44027">#44027</a></p>
<hr>
<p>The <code>doc_masked</code> feature allows a crate to exclude types from a given crate from appearing in lists
of trait implementations. The specifics of the feature are as follows:</p>
<ol>
<li>
<p>When rustdoc encounters an <code>extern crate</code> statement annotated with a <code>#[doc(masked)]</code> attribute,
it marks the crate as being masked.</p>
</li>
<li>
<p>When listing traits a given type implements, rustdoc ensures that traits from masked crates are
not emitted into the documentation.</p>
</li>
<li>
<p>When listing types that implement a given trait, rustdoc ensures that types from masked crates
are not emitted into the documentation.</p>
</li>
</ol>
<p>This feature was introduced in PR <a href="https://github.com/rust-lang/rust/pull/44026">#44026</a> to ensure that compiler-internal and
implementation-specific types and traits were not included in the standard library’s documentation.
Such types would introduce broken links into the documentation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="doc_notable_trait"><a class="header" href="#doc_notable_trait"><code>doc_notable_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/45040">#45040</a></p>
<p>The <code>doc_notable_trait</code> feature allows the use of the <code>#[doc(notable_trait)]</code>
attribute, which will display the trait in a “Notable traits” dialog for
functions returning types that implement the trait. For example, this attribute
is applied to the <code>Iterator</code>, <code>Future</code>, <code>io::Read</code>, and <code>io::Write</code> traits in
the standard library.</p>
<p>You can do this on your own traits like so:</p>
<pre><code>#![feature(doc_notable_trait)]

#[doc(notable_trait)]
pub trait MyTrait {}

pub struct MyStruct;
impl MyTrait for MyStruct {}

/// The docs for this function will have a button that displays a dialog about
/// `MyStruct` implementing `MyTrait`.
pub fn my_fn() -&gt; MyStruct { MyStruct }
</code></pre>
<p>This feature was originally implemented in PR <a href="https://github.com/rust-lang/rust/pull/45039">#45039</a>.</p>
<p>See also its documentation in <a href="../rustdoc/unstable-features.html#adding-your-trait-to-the-notable-traits-dialog">the rustdoc book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dropck_eyepatch"><a class="header" href="#dropck_eyepatch"><code>dropck_eyepatch</code></a></h1>
<p>Allows using the <code>may_dangle</code> attribute (RFC 1327).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/34761">#34761</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="effective_target_features"><a class="header" href="#effective_target_features"><code>effective_target_features</code></a></h1>
<p>Allows features to allow target_feature to better interact with traits.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143352">#143352</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="eii_internals"><a class="header" href="#eii_internals"><code>eii_internals</code></a></h1>
<p>Implementation details of externally implementable items</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ergonomic_clones"><a class="header" href="#ergonomic_clones"><code>ergonomic_clones</code></a></h1>
<p>Allows the .use postfix syntax <code>x.use</code> and use closures <code>use |x| { ... }</code></p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132290">#132290</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ermsb_target_feature"><a class="header" href="#ermsb_target_feature"><code>ermsb_target_feature</code></a></h1>
<p>ermsb target feature on x86.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150249">#150249</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="exhaustive_patterns"><a class="header" href="#exhaustive_patterns"><code>exhaustive_patterns</code></a></h1>
<p>Allows exhaustive pattern matching on types that contain uninhabited types.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/51085">#51085</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="explicit_extern_abis"><a class="header" href="#explicit_extern_abis"><code>explicit_extern_abis</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134986">#134986</a></p>
<hr>
<p>Disallow <code>extern</code> without an explicit ABI. We should write <code>extern "C"</code>
(or another ABI) instead of just <code>extern</code>.</p>
<p>By making the ABI explicit, it becomes much clearer that “C” is just one of the
possible choices, rather than the “standard” way for external functions.
Removing the default makes it easier to add a new ABI on equal footing as “C”.</p>
<pre class="playground"><code class="language-rust editionfuture compile_fail"><span class="boring">#![allow(unused)]
</span>#![feature(explicit_extern_abis)]

<span class="boring">fn main() {
</span>extern fn function1() {}  // ERROR `extern` declarations without an explicit ABI
                          // are disallowed

extern "C" fn function2() {} // compiles

extern "aapcs" fn function3() {} // compiles
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="explicit_tail_calls"><a class="header" href="#explicit_tail_calls"><code>explicit_tail_calls</code></a></h1>
<p>Allows explicit tail calls via <code>become</code> expression.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/112788">#112788</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="export_stable"><a class="header" href="#export_stable"><code>export_stable</code></a></h1>
<p>Allows using <code>#[export_stable]</code> which indicates that an item is exportable.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139939">#139939</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="extern_item_impls"><a class="header" href="#extern_item_impls"><code>extern_item_impls</code></a></h1>
<p>Externally implementable items</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/125418">#125418</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="extern_types"><a class="header" href="#extern_types"><code>extern_types</code></a></h1>
<p>Allows defining <code>extern type</code>s.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/43467">#43467</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="f128"><a class="header" href="#f128"><code>f128</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/116909">#116909</a></p>
<hr>
<p>Enable the <code>f128</code> type for IEEE 128-bit floating numbers (quad precision).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="f16"><a class="header" href="#f16"><code>f16</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/116909">#116909</a></p>
<hr>
<p>Enable the <code>f16</code> type for IEEE 16-bit floating numbers (half precision).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ffi_const"><a class="header" href="#ffi_const"><code>ffi_const</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/58328">#58328</a></p>
<hr>
<p>The <code>#[ffi_const]</code> attribute applies clang’s <code>const</code> attribute to foreign
functions declarations.</p>
<p>That is, <code>#[ffi_const]</code> functions shall have no effects except for its return
value, which can only depend on the values of the function parameters, and is
not affected by changes to the observable state of the program.</p>
<p>Applying the <code>#[ffi_const]</code> attribute to a function that violates these
requirements is undefined behaviour.</p>
<p>This attribute enables Rust to perform common optimizations, like sub-expression
elimination, and it can avoid emitting some calls in repeated invocations of the
function with the same argument values regardless of other operations being
performed in between these functions calls (as opposed to <code>#[ffi_pure]</code>
functions).</p>
<h2 id="pitfalls"><a class="header" href="#pitfalls">Pitfalls</a></h2>
<p>A <code>#[ffi_const]</code> function can only read global memory that would not affect
its return value for the whole execution of the program (e.g. immutable global
memory). <code>#[ffi_const]</code> functions are referentially-transparent and therefore
more strict than <code>#[ffi_pure]</code> functions.</p>
<p>A common pitfall involves applying the <code>#[ffi_const]</code> attribute to a
function that reads memory through pointer arguments which do not necessarily
point to immutable global memory.</p>
<p>A <code>#[ffi_const]</code> function that returns unit has no effect on the abstract
machine’s state, and a <code>#[ffi_const]</code> function cannot be <code>#[ffi_pure]</code>.</p>
<p>A <code>#[ffi_const]</code> function must not diverge, neither via a side effect (e.g. a
call to <code>abort</code>) nor by infinite loops.</p>
<p>When translating C headers to Rust FFI, it is worth verifying for which targets
the <code>const</code> attribute is enabled in those headers, and using the appropriate
<code>cfg</code> macros in the Rust side to match those definitions. While the semantics of
<code>const</code> are implemented identically by many C and C++ compilers, e.g., clang,
<a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-const-function-attribute">GCC</a>, <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacgigch.html">ARM C/C++ compiler</a>, <a href="https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_const.htm">IBM ILE C/C++</a>, etc. they are not necessarily
implemented in this way on all of them. It is therefore also worth verifying
that the semantics of the C toolchain used to compile the binary being linked
against are compatible with those of the <code>#[ffi_const]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ffi_pure"><a class="header" href="#ffi_pure"><code>ffi_pure</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/58329">#58329</a></p>
<hr>
<p>The <code>#[ffi_pure]</code> attribute applies clang’s <code>pure</code> attribute to foreign
functions declarations.</p>
<p>That is, <code>#[ffi_pure]</code> functions shall have no effects except for its return
value, which shall not change across two consecutive function calls with
the same parameters.</p>
<p>Applying the <code>#[ffi_pure]</code> attribute to a function that violates these
requirements is undefined behavior.</p>
<p>This attribute enables Rust to perform common optimizations, like sub-expression
elimination and loop optimizations. Some common examples of pure functions are
<code>strlen</code> or <code>memcmp</code>.</p>
<p>These optimizations are only applicable when the compiler can prove that no
program state observable by the <code>#[ffi_pure]</code> function has changed between calls
of the function, which could alter the result. See also the <code>#[ffi_const]</code>
attribute, which provides stronger guarantees regarding the allowable behavior
of a function, enabling further optimization.</p>
<h2 id="pitfalls-1"><a class="header" href="#pitfalls-1">Pitfalls</a></h2>
<p>A <code>#[ffi_pure]</code> function can read global memory through the function
parameters (e.g. pointers), globals, etc. <code>#[ffi_pure]</code> functions are not
referentially-transparent, and are therefore more relaxed than <code>#[ffi_const]</code>
functions.</p>
<p>However, accessing global memory through volatile or atomic reads can violate the
requirement that two consecutive function calls shall return the same value.</p>
<p>A <code>pure</code> function that returns unit has no effect on the abstract machine’s
state.</p>
<p>A <code>#[ffi_pure]</code> function must not diverge, neither via a side effect (e.g. a
call to <code>abort</code>) nor by infinite loops.</p>
<p>When translating C headers to Rust FFI, it is worth verifying for which targets
the <code>pure</code> attribute is enabled in those headers, and using the appropriate
<code>cfg</code> macros in the Rust side to match those definitions. While the semantics of
<code>pure</code> are implemented identically by many C and C++ compilers, e.g., clang,
<a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-pure-function-attribute">GCC</a>, <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacigdac.html">ARM C/C++ compiler</a>, <a href="https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_pure.htm">IBM ILE C/C++</a>, etc. they are not necessarily
implemented in this way on all of them. It is therefore also worth verifying
that the semantics of the C toolchain used to compile the binary being linked
against are compatible with those of the <code>#[ffi_pure]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fmt_debug"><a class="header" href="#fmt_debug"><code>fmt_debug</code></a></h1>
<p>Controlling the behavior of fmt::Debug</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/129709">#129709</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fn_align"><a class="header" href="#fn_align"><code>fn_align</code></a></h1>
<p>Allows using <code>#[align(...)]</code> on function items</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/82232">#82232</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fn_delegation"><a class="header" href="#fn_delegation"><code>fn_delegation</code></a></h1>
<p>Support delegating implementation of functions to other already implemented functions.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118212">#118212</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="freeze_impls"><a class="header" href="#freeze_impls"><code>freeze_impls</code></a></h1>
<p>Allows impls for the Freeze trait.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121675">#121675</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="frontmatter"><a class="header" href="#frontmatter"><code>frontmatter</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136889">#136889</a></p>
<hr>
<p>The <code>frontmatter</code> feature allows an extra metadata block at the top of files for consumption by
external tools. For example, it can be used by <a href="https://rust-lang.github.io/rfcs/3502-cargo-script.html"><code>cargo-script</code></a> files to specify dependencies.</p>
<pre class="playground"><code class="language-rust">#!/usr/bin/env -S cargo -Zscript
---
[dependencies]
libc = "0.2.172"
---
#![feature(frontmatter)]
<span class="boring">mod libc { pub type c_int = i32; }
</span>
fn main() {
    let x: libc::c_int = 1i32;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fundamental"><a class="header" href="#fundamental"><code>fundamental</code></a></h1>
<p>Allows using the <code>#[fundamental]</code> attribute.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29635">#29635</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="gen_blocks"><a class="header" href="#gen_blocks"><code>gen_blocks</code></a></h1>
<p>Allows defining gen blocks and <code>gen fn</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/117078">#117078</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generic_assert"><a class="header" href="#generic_assert"><code>generic_assert</code></a></h1>
<p>Outputs useful <code>assert!</code> messages</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generic_const_exprs"><a class="header" href="#generic_const_exprs"><code>generic_const_exprs</code></a></h1>
<p>Allows non-trivial generic constants which have to have wfness manually propagated to callers</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/76560">#76560</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generic_const_items"><a class="header" href="#generic_const_items"><code>generic_const_items</code></a></h1>
<p>Allows generic parameters and where-clauses on free &amp; associated const items.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/113521">#113521</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generic_const_parameter_types"><a class="header" href="#generic_const_parameter_types"><code>generic_const_parameter_types</code></a></h1>
<p>Allows the type of const generics to depend on generic parameters</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137626">#137626</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generic_pattern_types"><a class="header" href="#generic_pattern_types"><code>generic_pattern_types</code></a></h1>
<p>Allows any generic constants being used as pattern type range ends</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136574">#136574</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="global_registration"><a class="header" href="#global_registration"><code>global_registration</code></a></h1>
<p>Allows registering static items globally, possibly across crates, to iterate over at runtime.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/125119">#125119</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="guard_patterns"><a class="header" href="#guard_patterns"><code>guard_patterns</code></a></h1>
<p>Allows using guards in patterns.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/129967">#129967</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="half_open_range_patterns_in_slices"><a class="header" href="#half_open_range_patterns_in_slices"><code>half_open_range_patterns_in_slices</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/67264">#67264</a>
It is a future part of the <code>exclusive_range_pattern</code> feature,
tracked at <a href="https://github.com/rust-lang/rust/issues/37854">#37854</a>.</p>
<hr>
<p>This feature allow using top-level half-open range patterns in slices.</p>
<pre class="playground"><code class="language-rust">#![feature(half_open_range_patterns_in_slices)]

fn main() {
    let xs = [13, 1, 5, 2, 3, 1, 21, 8];
    let [a @ 3.., b @ ..3, c @ 4..6, ..] = xs else { return; };
}</code></pre>
<p>Note that this feature is not required if the patterns are wrapped between parenthesis.</p>
<pre class="playground"><code class="language-rust">fn main() {
    let xs = [13, 1];
    let [(a @ 3..), c] = xs else { return; };
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hexagon_target_feature"><a class="header" href="#hexagon_target_feature"><code>hexagon_target_feature</code></a></h1>
<p>Target features on hexagon.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150250">#150250</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="if_let_guard"><a class="header" href="#if_let_guard"><code>if_let_guard</code></a></h1>
<p>Allows <code>if let</code> guard in match arms.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/51114">#51114</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="impl_trait_in_assoc_type"><a class="header" href="#impl_trait_in_assoc_type"><code>impl_trait_in_assoc_type</code></a></h1>
<p>Allows <code>impl Trait</code> to be used inside associated types (RFC 2515).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/63063">#63063</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="impl_trait_in_bindings"><a class="header" href="#impl_trait_in_bindings"><code>impl_trait_in_bindings</code></a></h1>
<p>Allows <code>impl Trait</code> in bindings (<code>let</code>).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/63065">#63065</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="impl_trait_in_fn_trait_return"><a class="header" href="#impl_trait_in_fn_trait_return"><code>impl_trait_in_fn_trait_return</code></a></h1>
<p>Allows <code>impl Trait</code> as output type in <code>Fn</code> traits in return position of functions.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99697">#99697</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="import_trait_associated_functions"><a class="header" href="#import_trait_associated_functions">import_trait_associated_functions</a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134691">#134691</a></p>
<hr>
<p>This feature allows importing associated functions and constants from traits and then using them like regular items.</p>
<pre class="playground"><code class="language-rust">#![feature(import_trait_associated_functions)]

use std::ops::Add::add;

fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    let sum = numbers.into_iter().reduce(add); // instead of `.reduce(Add:add)`

    assert_eq!(sum, Some(21));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inherent_associated_types"><a class="header" href="#inherent_associated_types"><code>inherent_associated_types</code></a></h1>
<p>Allows associated types in inherent impls.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/8995">#8995</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="intra-doc-pointers"><a class="header" href="#intra-doc-pointers"><code>intra-doc-pointers</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/80896">#80896</a></p>
<hr>
<p>Rustdoc does not currently allow disambiguating between <code>*const</code> and <code>*mut</code>, and
raw pointers in intra-doc links are unstable until it does.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intra_doc_pointers)]
<span class="boring">fn main() {
</span>//! [pointer::add]
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="intrinsics"><a class="header" href="#intrinsics"><code>intrinsics</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<p>Intrinsics are rarely intended to be stable directly, but are usually
exported in some sort of stable manner. Prefer using the stable interfaces to
the intrinsic directly when you can.</p>
<hr>
<h2 id="intrinsics-with-fallback-logic"><a class="header" href="#intrinsics-with-fallback-logic">Intrinsics with fallback logic</a></h2>
<p>Many intrinsics can be written in pure rust, albeit inefficiently or without supporting
some features that only exist on some backends. Backends can simply not implement those
intrinsics without causing any code miscompilations or failures to compile.
All intrinsic fallback bodies are automatically made cross-crate inlineable (like <code>#[inline]</code>)
by the codegen backend, but not the MIR inliner.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_intrinsic]
const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {}
<span class="boring">}</span></code></pre>
<p>Since these are just regular functions, it is perfectly ok to create the intrinsic twice:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_intrinsic]
const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {}

mod foo {
    #[rustc_intrinsic]
    const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {
        panic!("noisy const dealloc")
    }
}

<span class="boring">}</span></code></pre>
<p>The behaviour on backends that override the intrinsic is exactly the same. On other
backends, the intrinsic behaviour depends on which implementation is called, just like
with any regular function.</p>
<h2 id="intrinsics-lowered-to-mir-instructions"><a class="header" href="#intrinsics-lowered-to-mir-instructions">Intrinsics lowered to MIR instructions</a></h2>
<p>Various intrinsics have native MIR operations that they correspond to. Instead of requiring
backends to implement both the intrinsic and the MIR operation, the <code>lower_intrinsics</code> pass
will convert the calls to the MIR operation. Backends do not need to know about these intrinsics
at all. These intrinsics only make sense without a body, and can be declared as a <code>#[rustc_intrinsic]</code>.
The body is never used as the lowering pass implements support for all backends, so we never have to
use the fallback logic.</p>
<h2 id="intrinsics-without-fallback-logic"><a class="header" href="#intrinsics-without-fallback-logic">Intrinsics without fallback logic</a></h2>
<p>These must be implemented by all backends.</p>
<h3 id="rustc_intrinsic-declarations"><a class="header" href="#rustc_intrinsic-declarations"><code>#[rustc_intrinsic]</code> declarations</a></h3>
<p>These are written without a body:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>#[rustc_intrinsic]
pub fn abort() -&gt; !;
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lahfsahf_target_feature"><a class="header" href="#lahfsahf_target_feature"><code>lahfsahf_target_feature</code></a></h1>
<p>lahfsahf target feature on x86.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150251">#150251</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="lang_items"><a class="header" href="#lang_items"><code>lang_items</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<p>The <code>rustc</code> compiler has certain pluggable operations, that is,
functionality that isn’t hard-coded into the language, but is
implemented in libraries, with a special marker to tell the compiler
it exists. The marker is the attribute <code>#[lang = "..."]</code> and there are
various different values of <code>...</code>, i.e. various different ‘lang
items’. Most of them can only be defined once.</p>
<p>Lang items are loaded lazily by the compiler; e.g. if one never uses <code>Box</code>
then there is no need to define a function for <code>exchange_malloc</code>.
<code>rustc</code> will emit an error when an item is needed but not found in the current
crate or any that it depends on.</p>
<p>Some features provided by lang items:</p>
<ul>
<li>overloadable operators via traits: the traits corresponding to the
<code>==</code>, <code>&lt;</code>, dereferencing (<code>*</code>) and <code>+</code> (etc.) operators are all
marked with lang items; those specific four are <code>eq</code>, <code>partial_ord</code>,
<code>deref</code>/<code>deref_mut</code>, and <code>add</code> respectively.</li>
<li>panicking: the <code>panic</code> and <code>panic_impl</code> lang items, among others.</li>
<li>stack unwinding: the lang item <code>eh_personality</code> is a function used by the
failure mechanisms of the compiler. This is often mapped to GCC’s personality
function (see the <a href="https://github.com/rust-lang/rust/blob/HEAD/library/std/src/sys/personality/gcc.rs"><code>std</code> implementation</a> for more information),
but programs which don’t trigger a panic can be assured that this function is
never called. Additionally, a <code>eh_catch_typeinfo</code> static is needed for certain
targets which implement Rust panics on top of C++ exceptions.</li>
<li>the traits in <code>core::marker</code> used to indicate types of
various kinds; e.g. lang items <code>sized</code>, <code>sync</code> and <code>copy</code>.</li>
<li>memory allocation, see below.</li>
</ul>
<p>Most lang items are defined by <code>core</code>, but if you’re trying to build
an executable without the <code>std</code> crate, you might run into the need
for lang item definitions.</p>
<h2 id="example-implementing-a-box"><a class="header" href="#example-implementing-a-box">Example: Implementing a <code>Box</code></a></h2>
<p><code>Box</code> pointers require two lang items: one for the type itself and one for
allocation. A freestanding program that uses the <code>Box</code> sugar for dynamic
allocations via <code>malloc</code> and <code>free</code>:</p>
<pre><code class="language-rust ignore (libc-is-finicky)">#![feature(lang_items, core_intrinsics, rustc_private, panic_unwind, rustc_attrs)]
#![allow(internal_features)]
#![no_std]
#![no_main]

extern crate libc;
extern crate unwind;

use core::ffi::{c_int, c_void};
use core::intrinsics;
use core::panic::PanicInfo;
use core::ptr::NonNull;

pub struct Global; // the global allocator
struct Unique&lt;T&gt;(NonNull&lt;T&gt;);

#[lang = "owned_box"]
pub struct Box&lt;T, A = Global&gt;(Unique&lt;T&gt;, A);

impl&lt;T&gt; Box&lt;T&gt; {
    pub fn new(x: T) -&gt; Self {
        #[rustc_box]
        Box::new(x)
    }
}

impl&lt;T, A&gt; Drop for Box&lt;T, A&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            libc::free(self.0.0.as_ptr() as *mut c_void);
        }
    }
}

#[lang = "exchange_malloc"]
unsafe fn allocate(size: usize, _align: usize) -&gt; *mut u8 {
    let p = libc::malloc(size) as *mut u8;

    // Check if `malloc` failed:
    if p.is_null() {
        intrinsics::abort();
    }

    p
}

#[no_mangle]
extern "C" fn main(_argc: c_int, _argv: *const *const u8) -&gt; c_int {
    let _x = Box::new(1);

    0
}

#[lang = "eh_personality"]
fn rust_eh_personality() {}

#[panic_handler]
fn panic_handler(_info: &amp;PanicInfo) -&gt; ! { intrinsics::abort() }</code></pre>
<p>Note the use of <code>abort</code>: the <code>exchange_malloc</code> lang item is assumed to
return a valid pointer, and so needs to do the check internally.</p>
<h2 id="list-of-all-language-items"><a class="header" href="#list-of-all-language-items">List of all language items</a></h2>
<p>An up-to-date list of all language items can be found <a href="https://github.com/rust-lang/rust/blob/HEAD/compiler/rustc_hir/src/lang_items.rs">here</a> in the compiler code.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="large_assignments"><a class="header" href="#large_assignments"><code>large_assignments</code></a></h1>
<p>Allows setting the threshold for the <code>large_assignments</code> lint.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/83518">#83518</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="lazy_type_alias"><a class="header" href="#lazy_type_alias"><code>lazy_type_alias</code></a></h1>
<p>Allow to have type alias types for inter-crate use.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/112792">#112792</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="link_arg_attribute"><a class="header" href="#link_arg_attribute"><code>link_arg_attribute</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99427">#99427</a></p>
<hr>
<p>The <code>link_arg_attribute</code> feature allows passing arguments into the linker
from inside of the source code. Order is preserved for link attributes as
they were defined on a single extern block:</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![feature(link_arg_attribute)]

<span class="boring">fn main() {
</span>#[link(kind = "link-arg", name = "--start-group")]
#[link(kind = "static", name = "c")]
#[link(kind = "static", name = "gcc")]
#[link(kind = "link-arg", name = "--end-group")]
extern "C" {}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="link_cfg"><a class="header" href="#link_cfg"><code>link_cfg</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="link_llvm_intrinsics"><a class="header" href="#link_llvm_intrinsics"><code>link_llvm_intrinsics</code></a></h1>
<p>Allows using <code>#[link_name="llvm.*"]</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29602">#29602</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="linkage"><a class="header" href="#linkage"><code>linkage</code></a></h1>
<p>Allows using the <code>#[linkage = ".."]</code> attribute.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29603">#29603</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="loongarch_target_feature"><a class="header" href="#loongarch_target_feature"><code>loongarch_target_feature</code></a></h1>
<p>Target features on loongarch.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150252">#150252</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="loop_match"><a class="header" href="#loop_match"><code>loop_match</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132306">#132306</a></p>
<hr>
<p>The <code>#[loop_match]</code> and <code>#[const_continue]</code> attributes can be used to improve the code
generation of logic that fits this shape:</p>
<pre><code class="language-ignore (pseudo-rust)">loop {
    state = 'blk: {
        match state {
            State::A =&gt; {
                break 'blk State::B
            }
            State::B =&gt; { /* ... */ }
            /* ... */
        }
    }
}
</code></pre>
<p>Here the loop itself can be annotated with <code>#[loop_match]</code>, and any <code>break 'blk</code> with
<code>#[const_continue]</code> if the value is know at compile time:</p>
<pre><code class="language-ignore (pseudo-rust)">#[loop_match]
loop {
    state = 'blk: {
        match state {
            State::A =&gt; {
                #[const_continue]
                break 'blk State::B
            }
            State::B =&gt; { /* ... */ }
            /* ... */
        }
    }
}
</code></pre>
<p>The observable behavior of this loop is exactly the same as without the extra attributes.
The difference is in the generated output: normally, when the state is <code>A</code>, control flow
moves from the <code>A</code> branch, back to the top of the loop, then to the <code>B</code> branch. With the
attributes, The <code>A</code> branch will immediately jump to the <code>B</code> branch.</p>
<p>Removing the indirection can be beneficial for stack usage and branch prediction, and
enables other optimizations by clearly splitting out the control flow paths that your
program will actually use.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="m68k_target_feature"><a class="header" href="#m68k_target_feature"><code>m68k_target_feature</code></a></h1>
<p>Target features on m68k.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134328">#134328</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="macro_attr"><a class="header" href="#macro_attr"><code>macro_attr</code></a></h1>
<p>Allow <code>macro_rules!</code> attribute rules</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143547">#143547</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="macro_derive"><a class="header" href="#macro_derive"><code>macro_derive</code></a></h1>
<p>Allow <code>macro_rules!</code> derive rules</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143549">#143549</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="macro_metavar_expr"><a class="header" href="#macro_metavar_expr"><code>macro_metavar_expr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/83527">#83527</a></p>
<hr>
<blockquote>
<p>This feature is not to be confused with <a href="#macro_metavar_expr_concat"><code>macro_metavar_expr_concat</code></a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="macro_metavar_expr_concat"><a class="header" href="#macro_metavar_expr_concat"><code>macro_metavar_expr_concat</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/124225">#124225</a></p>
<hr>
<p>In stable Rust, there is no way to create new identifiers by joining identifiers to literals or other identifiers without using procedural macros such as <a href="https://crates.io/crates/paste"><code>paste</code></a>.
<code>#![feature(macro_metavar_expr_concat)]</code> introduces a way to do this, using the concat metavariable expression.</p>
<blockquote>
<p>This feature uses the syntax from <a href="#macro_metavar_expr"><code>macro_metavar_expr</code></a> but is otherwise
independent. It replaces the since-removed unstable feature
<a href="https://github.com/rust-lang/rust/issues/29599"><code>concat_idents</code></a>.</p>
</blockquote>
<blockquote>
<p>This is an experimental feature; it and its syntax will require a RFC before stabilization.</p>
</blockquote>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<p><code>#![feature(macro_metavar_expr_concat)]</code> provides the <code>concat</code> metavariable expression for creating new identifiers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(macro_metavar_expr_concat)]

<span class="boring">fn main() {
</span>macro_rules! create_some_structs {
    ($name:ident) =&gt; {
        pub struct ${ concat(First, $name) };
        pub struct ${ concat(Second, $name) };
        pub struct ${ concat(Third, $name) };
    }
}

create_some_structs!(Thing);
<span class="boring">}</span></code></pre>
<p>This macro invocation expands to:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FirstThing;
pub struct SecondThing;
pub struct ThirdThing;
<span class="boring">}</span></code></pre>
<h3 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h3>
<p>This feature builds upon the metavariable expression syntax <code>${ .. }</code> as specified in <a href="https://rust-lang.github.io/rfcs/3086-macro-metavar-expr.html">RFC 3086</a> (<a href="#macro_metavar_expr"><code>macro_metavar_expr</code></a>).
<code>concat</code> is available like <code>${ concat(items) }</code>, where <code>items</code> is a comma separated sequence of idents and/or literals.</p>
<h3 id="examples-11"><a class="header" href="#examples-11">Examples</a></h3>
<h4 id="create-a-function-or-method-with-a-concatenated-name"><a class="header" href="#create-a-function-or-method-with-a-concatenated-name">Create a function or method with a concatenated name</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(macro_metavar_expr_concat)]

<span class="boring">fn main() {
</span>macro_rules! make_getter {
    ($name:ident, $field: ident, $ret:ty) =&gt; {
        impl $name {
            pub fn ${ concat(get_, $field) }(&amp;self) -&gt; &amp;$ret {
                &amp;self.$field
            }
        }
    }
}

pub struct Thing {
    description: String,
}

make_getter!(Thing, description, String);
<span class="boring">}</span></code></pre>
<p>This expands to:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Thing {
    description: String,
}

impl Thing {
    pub fn get_description(&amp;self) -&gt; &amp;String {
        &amp;self.description
    }
}
<span class="boring">}</span></code></pre>
<h4 id="create-names-for-macro-generated-tests"><a class="header" href="#create-names-for-macro-generated-tests">Create names for macro generated tests</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(macro_metavar_expr_concat)]

<span class="boring">fn main() {
</span>macro_rules! test_math {
    ($integer:ident) =&gt; {
        #[test]
        fn ${ concat(test_, $integer, _, addition) } () {
            let a: $integer = 73;
            let b: $integer = 42;
            assert_eq!(a + b, 115)
        }

        #[test]
        fn ${ concat(test_, $integer, _, subtraction) } () {
            let a: $integer = 73;
            let b: $integer = 42;
            assert_eq!(a - b, 31)
        }
    }
}

test_math!(i32);
test_math!(u64);
test_math!(u128);
<span class="boring">}</span></code></pre>
<p>Running this returns the following output:</p>
<pre><code class="language-text">running 6 tests
test test_i32_subtraction ... ok
test test_i32_addition ... ok
test test_u128_addition ... ok
test test_u128_subtraction ... ok
test test_u64_addition ... ok
test test_u64_subtraction ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="marker_trait_attr"><a class="header" href="#marker_trait_attr"><code>marker_trait_attr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29864">#29864</a></p>
<hr>
<p>Normally, Rust keeps you from adding trait implementations that could
overlap with each other, as it would be ambiguous which to use.  This
feature, however, carves out an exception to that rule: a trait can
opt-in to having overlapping implementations, at the cost that those
implementations are not allowed to override anything (and thus the
trait itself cannot have any associated items, as they’re pointless
when they’d need to do the same thing for every type anyway).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(marker_trait_attr)]

<span class="boring">fn main() {
</span>#[marker] trait CheapToClone: Clone {}

impl&lt;T: Copy&gt; CheapToClone for T {}

// These could potentially overlap with the blanket implementation above,
// so are only allowed because CheapToClone is a marker trait.
impl&lt;T: CheapToClone, U: CheapToClone&gt; CheapToClone for (T, U) {}
impl&lt;T: CheapToClone&gt; CheapToClone for std::ops::Range&lt;T&gt; {}

fn cheap_clone&lt;T: CheapToClone&gt;(t: T) -&gt; T {
    t.clone()
}
<span class="boring">}</span></code></pre>
<p>This is expected to replace the unstable <code>overlapping_marker_traits</code>
feature, which applied to all empty traits (without needing an opt-in).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="min_generic_const_args"><a class="header" href="#min_generic_const_args"><code>min_generic_const_args</code></a></h1>
<p>Enables the generic const args MVP (only bare paths, not arbitrary computation).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132980">#132980</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="min_specialization"><a class="header" href="#min_specialization"><code>min_specialization</code></a></h1>
<p>A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/31844">#31844</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="mips_target_feature"><a class="header" href="#mips_target_feature"><code>mips_target_feature</code></a></h1>
<p>Target features on mips.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150253">#150253</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="more_maybe_bounds"><a class="header" href="#more_maybe_bounds"><code>more_maybe_bounds</code></a></h1>
<p>Allows using <code>?Trait</code> trait bounds in more contexts.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="more_qualified_paths"><a class="header" href="#more_qualified_paths"><code>more_qualified_paths</code></a></h1>
<p>The <code>more_qualified_paths</code> feature can be used in order to enable the
use of qualified paths in patterns.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/86935">#86935</a>.</p>
<hr>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre class="playground"><code class="language-rust">#![feature(more_qualified_paths)]

fn main() {
    // destructure through a qualified path
    let &lt;Foo as A&gt;::Assoc { br } = StructStruct { br: 2 };
}

struct StructStruct {
    br: i8,
}

struct Foo;

trait A {
    type Assoc;
}

impl A for Foo {
    type Assoc = StructStruct;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="movrs_target_feature"><a class="header" href="#movrs_target_feature"><code>movrs_target_feature</code></a></h1>
<p>The <code>movrs</code> target feature on x86.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137976">#137976</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="multiple_supertrait_upcastable"><a class="header" href="#multiple_supertrait_upcastable"><code>multiple_supertrait_upcastable</code></a></h1>
<p>Allows the <code>multiple_supertrait_upcastable</code> lint.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150833">#150833</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="must_not_suspend"><a class="header" href="#must_not_suspend"><code>must_not_suspend</code></a></h1>
<p>Allows the <code>#[must_not_suspend]</code> attribute.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/83310">#83310</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="mut_ref"><a class="header" href="#mut_ref"><code>mut_ref</code></a></h1>
<p>Allows <code>mut ref</code> and <code>mut ref mut</code> identifier patterns.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123076">#123076</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="naked_functions_rustic_abi"><a class="header" href="#naked_functions_rustic_abi"><code>naked_functions_rustic_abi</code></a></h1>
<p>Allows using <code>#[naked]</code> on <code>extern "Rust"</code> functions.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138997">#138997</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="naked_functions_target_feature"><a class="header" href="#naked_functions_target_feature"><code>naked_functions_target_feature</code></a></h1>
<p>Allows using <code>#[target_feature(enable = "...")]</code> on <code>#[naked]</code> on functions.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138568">#138568</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="native_link_modifiers_as_needed"><a class="header" href="#native_link_modifiers_as_needed"><code>native_link_modifiers_as_needed</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/81490">#81490</a></p>
<hr>
<p>The <code>native_link_modifiers_as_needed</code> feature allows you to use the <code>as-needed</code> modifier.</p>
<p><code>as-needed</code> is only compatible with the <code>dynamic</code> and <code>framework</code> linking kinds. Using any other kind will result in a compiler error.</p>
<p><code>+as-needed</code> means that the library will be actually linked only if it satisfies some undefined symbols at the point at which it is specified on the command line, making it similar to static libraries in this regard.</p>
<p>This modifier translates to <code>--as-needed</code> for ld-like linkers, and to <code>-dead_strip_dylibs</code> / <code>-needed_library</code> / <code>-needed_framework</code> for ld64.
The modifier does nothing for linkers that don’t support it (e.g. <code>link.exe</code>).</p>
<p>The default for this modifier is unclear, some targets currently specify it as <code>+as-needed</code>, some do not. We may want to try making <code>+as-needed</code> a default for all targets.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="needs_panic_runtime"><a class="header" href="#needs_panic_runtime"><code>needs_panic_runtime</code></a></h1>
<p>Allows declaring with <code>#![needs_panic_runtime]</code> that a panic runtime is needed.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/32837">#32837</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="negative_bounds"><a class="header" href="#negative_bounds"><code>negative_bounds</code></a></h1>
<p>Allow negative trait bounds. This is an internal-only feature for testing the trait solver!</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="negative_impls"><a class="header" href="#negative_impls"><code>negative_impls</code></a></h1>
<p>The tracking issue for this feature is <a href="https://github.com/rust-lang/rust/issues/68318">#68318</a>.</p>
<hr>
<p>With the feature gate <code>negative_impls</code>, you can write negative impls as well as positive ones:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]
<span class="boring">fn main() {
</span>trait DerefMut { }
impl&lt;T: ?Sized&gt; !DerefMut for &amp;T { }
<span class="boring">}</span></code></pre>
<p>Negative impls indicate a semver guarantee that the given trait will not be implemented for the given types. Negative impls play an additional purpose for auto traits, described below.</p>
<p>Negative impls have the following characteristics:</p>
<ul>
<li>They do not have any items.</li>
<li>They must obey the orphan rules as if they were a positive impl.</li>
<li>They cannot “overlap” with any positive impls.</li>
</ul>
<h2 id="semver-interaction"><a class="header" href="#semver-interaction">Semver interaction</a></h2>
<p>It is a breaking change to remove a negative impl. Negative impls are a commitment not to implement the given trait for the named types.</p>
<h2 id="orphan-and-overlap-rules"><a class="header" href="#orphan-and-overlap-rules">Orphan and overlap rules</a></h2>
<p>Negative impls must obey the same orphan rules as a positive impl. This implies you cannot add a negative impl for types defined in upstream crates and so forth.</p>
<p>Similarly, negative impls cannot overlap with positive impls, again using the same “overlap” check that we ordinarily use to determine if two impls overlap. (Note that positive impls typically cannot overlap with one another either, except as permitted by specialization.)</p>
<h2 id="interaction-with-auto-traits"><a class="header" href="#interaction-with-auto-traits">Interaction with auto traits</a></h2>
<p>Declaring a negative impl <code>impl !SomeAutoTrait for SomeType</code> for an
auto-trait serves two purposes:</p>
<ul>
<li>as with any trait, it declares that <code>SomeType</code> will never implement <code>SomeAutoTrait</code>;</li>
<li>it disables the automatic <code>SomeType: SomeAutoTrait</code> impl that would otherwise have been generated.</li>
</ul>
<p>Note that, at present, there is no way to indicate that a given type
does not implement an auto trait <em>but that it may do so in the
future</em>. For ordinary types, this is done by simply not declaring any
impl at all, but that is not an option for auto traits. A workaround
is that one could embed a marker type as one of the fields, where the
marker type is <code>!AutoTrait</code>.</p>
<h2 id="immediate-uses"><a class="header" href="#immediate-uses">Immediate uses</a></h2>
<p>Negative impls are used to declare that <code>&amp;T: !DerefMut</code>  and <code>&amp;mut T: !Clone</code>, as required to fix the soundness of <code>Pin</code> described in <a href="https://github.com/rust-lang/rust/issues/66544">#66544</a>.</p>
<p>This serves two purposes:</p>
<ul>
<li>For proving the correctness of unsafe code, we can use that impl as evidence that no <code>DerefMut</code> or <code>Clone</code> impl exists.</li>
<li>It prevents downstream crates from creating such impls.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="never_patterns"><a class="header" href="#never_patterns"><code>never_patterns</code></a></h1>
<p>Allows the <code>!</code> pattern.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118155">#118155</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="never_type"><a class="header" href="#never_type"><code>never_type</code></a></h1>
<p>Allows the <code>!</code> type. Does not imply ‘exhaustive_patterns’ (below) any more.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/35121">#35121</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="new_range"><a class="header" href="#new_range"><code>new_range</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123741">#123741</a></p>
<hr>
<p>Switch the syntaxes <code>a..</code>, <code>a..b</code>, and <code>a..=b</code> to resolve the new range types.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="no_core"><a class="header" href="#no_core"><code>no_core</code></a></h1>
<p>Allows <code>#![no_core]</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29639">#29639</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="non_exhaustive_omitted_patterns_lint"><a class="header" href="#non_exhaustive_omitted_patterns_lint"><code>non_exhaustive_omitted_patterns_lint</code></a></h1>
<p>Allows using the <code>non_exhaustive_omitted_patterns</code> lint.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89554">#89554</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="non_lifetime_binders"><a class="header" href="#non_lifetime_binders"><code>non_lifetime_binders</code></a></h1>
<p>Allows <code>for&lt;T&gt;</code> binders in where-clauses</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/108185">#108185</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nvptx_target_feature"><a class="header" href="#nvptx_target_feature"><code>nvptx_target_feature</code></a></h1>
<p>Target feaures on nvptx.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150254">#150254</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="offset_of_enum"><a class="header" href="#offset_of_enum"><code>offset_of_enum</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/120141">#120141</a></p>
<hr>
<p>When the <code>offset_of_enum</code> feature is enabled, the <a href="../std/mem/macro.offset_of.html"><code>offset_of!</code></a> macro may be used to obtain the
offsets of fields of <code>enum</code>s; to express this, <code>enum</code> variants may be traversed as if they were
fields. Variants themselves do not have an offset, so they cannot appear as the last path component.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(offset_of_enum)]
<span class="boring">fn main() {
</span>use std::mem;

#[repr(u8)]
enum Enum {
    A(u8, u16),
    B { one: u8, two: u16 },
}

assert_eq!(mem::offset_of!(Enum, A.0), 1);
assert_eq!(mem::offset_of!(Enum, B.two), 2);

assert_eq!(mem::offset_of!(Option&lt;&amp;u8&gt;, Some.0), 0);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="offset_of_slice"><a class="header" href="#offset_of_slice"><code>offset_of_slice</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/126151">#126151</a></p>
<hr>
<p>When the <code>offset_of_slice</code> feature is enabled, the <a href="../std/mem/macro.offset_of.html"><code>offset_of!</code></a> macro may be used to determine
the offset of fields whose type is <code>[T]</code>, that is, a slice of dynamic size.</p>
<p>In general, fields whose type is dynamically sized do not have statically known offsets because
they do not have statically known alignments. However, <code>[T]</code> has the same alignment as <code>T</code>, so
it specifically may be allowed.</p>
<pre class="playground"><code class="language-rust">#![feature(offset_of_slice)]

#[repr(C)]
pub struct Struct {
    head: u32,
    tail: [u8],
}

fn main() {
    assert_eq!(std::mem::offset_of!(Struct, tail), 4);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="optimize_attribute"><a class="header" href="#optimize_attribute"><code>optimize_attribute</code></a></h1>
<p>Allows using <code>#[optimize(X)]</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54882">#54882</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_runtime"><a class="header" href="#panic_runtime"><code>panic_runtime</code></a></h1>
<p>Allows using the <code>#![panic_runtime]</code> attribute.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/32837">#32837</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="patchable_function_entry"><a class="header" href="#patchable_function_entry"><code>patchable_function_entry</code></a></h1>
<p>Allows specifying nop padding on functions for dynamic patching.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123115">#123115</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern_complexity_limit"><a class="header" href="#pattern_complexity_limit"><code>pattern_complexity_limit</code></a></h1>
<p>Set the maximum pattern complexity allowed (not limited by default).</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern_types"><a class="header" href="#pattern_types"><code>pattern_types</code></a></h1>
<p>Allows using pattern types.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123646">#123646</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pin_ergonomics"><a class="header" href="#pin_ergonomics"><code>pin_ergonomics</code></a></h1>
<p>Experimental features that make <code>Pin</code> more ergonomic.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130494">#130494</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="postfix-match"><a class="header" href="#postfix-match"><code>postfix-match</code></a></h1>
<p><code>postfix-match</code> adds the feature for matching upon values postfix
the expressions that generate the values.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121618">#121618</a>.</p>
<hr>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(postfix_match)]

<span class="boring">fn main() {
</span>enum Foo {
    Bar,
    Baz
}

fn get_foo() -&gt; Foo {
    Foo::Bar
}

get_foo().match {
    Foo::Bar =&gt; {},
    Foo::Baz =&gt; panic!(),
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="powerpc_target_feature"><a class="header" href="#powerpc_target_feature"><code>powerpc_target_feature</code></a></h1>
<p>Target features on powerpc.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150255">#150255</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="prelude_import"><a class="header" href="#prelude_import"><code>prelude_import</code></a></h1>
<p>Allows using <code>#[prelude_import]</code> on glob <code>use</code> items.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="prfchw_target_feature"><a class="header" href="#prfchw_target_feature"><code>prfchw_target_feature</code></a></h1>
<p>The prfchw target feature on x86.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150256">#150256</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_hygiene"><a class="header" href="#proc_macro_hygiene"><code>proc_macro_hygiene</code></a></h1>
<p>Allows macro attributes on expressions, statements and non-inline modules.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54727">#54727</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="profiler_runtime"><a class="header" href="#profiler_runtime"><code>profiler_runtime</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/42524">#42524</a>.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="raw_dylib_elf"><a class="header" href="#raw_dylib_elf"><code>raw_dylib_elf</code></a></h1>
<p>Allows the use of raw-dylibs on ELF platforms</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/135694">#135694</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="reborrow"><a class="header" href="#reborrow"><code>reborrow</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145612">#145612</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ref_pat_eat_one_layer_2024"><a class="header" href="#ref_pat_eat_one_layer_2024"><code>ref_pat_eat_one_layer_2024</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123076">#123076</a></p>
<hr>
<p>This feature is incomplete and not yet intended for general use.</p>
<p>This implements experimental, Edition-dependent match ergonomics under consideration for inclusion
in Rust, allowing <code>&amp;</code> patterns in more places. For example:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![feature(ref_pat_eat_one_layer_2024)]
#![allow(incomplete_features)]
<span class="boring">fn main() {
</span><span class="boring">
</span><span class="boring">// Tests type equality in a way that avoids coercing `&amp;&amp;T` or `&amp;mut T` to `&amp;T`.
</span><span class="boring">trait Eq&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; Eq&lt;T&gt; for T {}
</span><span class="boring">fn has_type&lt;T&gt;(_: impl Eq&lt;T&gt;) {}
</span>
// `&amp;` can match against a `ref` binding mode instead of a reference type:
let (x, &amp;y) = &amp;(0, 1);
has_type::&lt;&amp;u8&gt;(x);
has_type::&lt;u8&gt;(y);

// `&amp;` can match against `&amp;mut` references:
let &amp;z = &amp;mut 2;
has_type::&lt;u8&gt;(z);
<span class="boring">}</span></code></pre>
<p>For specifics, see the corresponding typing rules for <a href="https://nadrieril.github.io/typing-rust-patterns/?compare=false&amp;opts1=AQEBAQIBAQABAAAAAQEBAAEBAAABAAA%3D&amp;mode=rules&amp;do_cmp=false">Editions 2021 and earlier</a> and for
<a href="https://nadrieril.github.io/typing-rust-patterns/?compare=false&amp;opts1=AQEBAAABAQABAgIAAQEBAAEBAAABAAA%3D&amp;mode=rules&amp;do_cmp=false">Editions 2024 and later</a>. For more information on binding modes, see <a href="https://doc.rust-lang.org/reference/patterns.html#binding-modes">The Rust Reference</a>.</p>
<p>For alternative experimental match ergonomics, see the feature
<a href="#ref_pat_eat_one_layer_2024_structural"><code>ref_pat_eat_one_layer_2024_structural</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ref_pat_eat_one_layer_2024_structural"><a class="header" href="#ref_pat_eat_one_layer_2024_structural"><code>ref_pat_eat_one_layer_2024_structural</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123076">#123076</a></p>
<hr>
<p>This feature is incomplete and not yet intended for general use.</p>
<p>This implements experimental, Edition-dependent match ergonomics under consideration for inclusion
in Rust, allowing <code>&amp;</code> patterns in more places. For example:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![feature(ref_pat_eat_one_layer_2024_structural)]
#![allow(incomplete_features)]
<span class="boring">fn main() {
</span><span class="boring">
</span><span class="boring">// Tests type equality in a way that avoids coercing `&amp;&amp;T` or `&amp;mut T` to `&amp;T`.
</span><span class="boring">trait Eq&lt;T&gt; {}
</span><span class="boring">impl&lt;T&gt; Eq&lt;T&gt; for T {}
</span><span class="boring">fn has_type&lt;T&gt;(_: impl Eq&lt;T&gt;) {}
</span>
// `&amp;` can match against a `ref` binding mode instead of a reference type:
let (x, &amp;y) = &amp;(0, 1);
has_type::&lt;&amp;u8&gt;(x);
has_type::&lt;u8&gt;(y);

// `&amp;` can match against `&amp;mut` references:
let &amp;z = &amp;mut 2;
has_type::&lt;u8&gt;(z);
<span class="boring">}</span></code></pre>
<p>For specifics, see the corresponding typing rules for <a href="https://nadrieril.github.io/typing-rust-patterns/?compare=false&amp;opts1=AQEBAQIBAQEBAAAAAAAAAAAAAAAAAAA%3D&amp;mode=rules&amp;do_cmp=false">Editions 2021 and earlier</a> and for
<a href="https://nadrieril.github.io/typing-rust-patterns/?compare=false&amp;opts1=AQEBAgEBAQEBAgIAAAAAAAAAAAAAAAA%3D&amp;mode=rules&amp;do_cmp=false">Editions 2024 and later</a>. For more information on binding modes, see <a href="https://doc.rust-lang.org/reference/patterns.html#binding-modes">The Rust Reference</a>.</p>
<p>For alternative experimental match ergonomics, see the feature
<a href="#ref_pat_eat_one_layer_2024"><code>ref_pat_eat_one_layer_2024</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="register_tool"><a class="header" href="#register_tool"><code>register_tool</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/66079">#66079</a></p>
<hr>
<p>The <code>register_tool</code> language feature informs the compiler that attributes in your code are meant to be used with tools other than the compiler itself. This can be useful if your code has semantic meaning without the external tool, but enables additional features when the tool is present.</p>
<p><code>register_tool</code> also allows configuring lint levels for external tools.</p>
<p>Tool attributes are only meant for ignorable attributes. If your code <em>changes</em> meaning when the attribute is present, it should not use a tool attribute (because it cannot be compiled with anything other than the external tool, and in a sense is a fork of the language).</p>
<hr>
<p><code>#![register_tool(tool)]</code> is an attribute, and is only valid at the crate root.
Attributes using the registered tool are checked for valid syntax, and lint attributes are checked to be in a valid format. However, the compiler cannot validate the semantics of the attribute, nor can it tell whether the configured lint is present in the external tool.</p>
<p>Semantically, <code>clippy::*</code>, <code>rustdoc::*</code>, and <code>rustfmt::*</code> lints and attributes all behave as if <code>#![register_tool(clippy, rustdoc, rustfmt)]</code> were injected into the crate root, except that the <code>rustdoc</code> namespace can only be used for lints, not for attributes.
When compiling with <code>-Z unstable-features</code>, <code>rustc::*</code> lints can also be used. Like <code>rustdoc</code>, the <code>rustc</code> namespace can only be used with lints, not attributes.</p>
<p>The compiler will emit an error if it encounters a lint/attribute whose namespace isn’t a registered tool.</p>
<p>Tool namespaces cannot be nested; <code>register_tool(main_tool::subtool)</code> is an error.</p>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<p>Tool attributes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(register_tool)]
#![register_tool(c2rust)]

<span class="boring">fn main() {
</span>// Mark which C header file this module was generated from.
#[c2rust::header_src = "operations.h"]
pub mod operations_h {
    use std::ffi::c_int;

    // Mark which source line this struct was generated from.
    #[c2rust::src_loc = "11:0"]
    pub struct Point {
        pub x: c_int,
        pub y: c_int,
    }
}
<span class="boring">}</span></code></pre>
<p>Tool lints:</p>
<pre><code>#![feature(register_tool)]
#![register_tool(bevy)]
#![deny(bevy::duplicate_bevy_dependencies)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="repr_simd"><a class="header" href="#repr_simd"><code>repr_simd</code></a></h1>
<p>Allows <code>repr(simd)</code> and importing the various simd intrinsics.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27731">#27731</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="return_type_notation"><a class="header" href="#return_type_notation"><code>return_type_notation</code></a></h1>
<p>Allows bounding the return type of AFIT/RPITIT.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/109417">#109417</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="riscv_target_feature"><a class="header" href="#riscv_target_feature"><code>riscv_target_feature</code></a></h1>
<p>Target features on riscv.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150257">#150257</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rtm_target_feature"><a class="header" href="#rtm_target_feature"><code>rtm_target_feature</code></a></h1>
<p>The rtm target feature on x86.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150258">#150258</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust_cold_cc"><a class="header" href="#rust_cold_cc"><code>rust_cold_cc</code></a></h1>
<p>Allows <code>extern "rust-cold"</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/97544">#97544</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_allow_const_fn_unstable"><a class="header" href="#rustc_allow_const_fn_unstable"><code>rustc_allow_const_fn_unstable</code></a></h1>
<p>Allows using <code>#[rustc_allow_const_fn_unstable]</code>. This is an attribute on <code>const fn</code> for the same purpose as <code>#[allow_internal_unstable]</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/69399">#69399</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_attrs"><a class="header" href="#rustc_attrs"><code>rustc_attrs</code></a></h1>
<p>This feature has no tracking issue, and is therefore internal to
the compiler, not being intended for general use.</p>
<p>Note: <code>rustc_attrs</code> enables many rustc-internal attributes and this page
only discuss a few of them.</p>
<hr>
<p>The <code>rustc_attrs</code> feature allows debugging rustc type layouts by using
<code>#[rustc_layout(...)]</code> to debug layout at compile time (it even works
with <code>cargo check</code>) as an alternative to <code>rustc -Z print-type-sizes</code>
that is way more verbose.</p>
<p>Options provided by <code>#[rustc_layout(...)]</code> are <code>debug</code>, <code>size</code>, <code>align</code>,
<code>abi</code>. Note that it only works on sized types without generics.</p>
<h2 id="examples-13"><a class="header" href="#examples-13">Examples</a></h2>
<pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![feature(rustc_attrs)]

<span class="boring">fn main() {
</span>#[rustc_layout(abi, size)]
pub enum X {
    Y(u8, u8, u8),
    Z(isize),
}
<span class="boring">}</span></code></pre>
<p>When that is compiled, the compiler will error with something like</p>
<pre><code class="language-text">error: abi: Aggregate { sized: true }
 --&gt; src/lib.rs:4:1
  |
4 | / pub enum T {
5 | |     Y(u8, u8, u8),
6 | |     Z(isize),
7 | | }
  | |_^

error: size: Size { raw: 16 }
 --&gt; src/lib.rs:4:1
  |
4 | / pub enum T {
5 | |     Y(u8, u8, u8),
6 | |     Z(isize),
7 | | }
  | |_^

error: aborting due to 2 previous errors
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustc_private"><a class="header" href="#rustc_private"><code>rustc_private</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27812">#27812</a></p>
<hr>
<p>This feature allows access to unstable internal compiler crates such as <code>rustc_driver</code>.</p>
<p>The presence of this feature changes the way the linkage format for dylibs is calculated in a way
that is necessary for linking against dylibs that statically link <code>std</code> (such as <code>rustc_driver</code>).
This makes this feature “viral” in linkage; its use in a given crate makes its use required in
dependent crates which link to it (including integration tests, which are built as separate crates).</p>
<h2 id="common-linker-failures-related-to-missing-llvm-libraries"><a class="header" href="#common-linker-failures-related-to-missing-llvm-libraries">Common linker failures related to missing LLVM libraries</a></h2>
<h3 id="when-using-rustc-private-with-official-toolchains"><a class="header" href="#when-using-rustc-private-with-official-toolchains">When using <code>rustc-private</code> with Official Toolchains</a></h3>
<p>When using the <code>rustc_private</code> feature with official toolchains distributed via rustup, you’ll need to install:</p>
<ol>
<li>The <code>rustc-dev</code> component (provides compiler libraries)</li>
<li>The <code>llvm-tools</code> component (provides LLVM libraries needed for linking)</li>
</ol>
<p>You can install these components using <code>rustup</code>:</p>
<pre><code class="language-text">rustup component add rustc-dev llvm-tools
</code></pre>
<p>Without the <code>llvm-tools</code> component, you may encounter linking errors like:</p>
<pre><code class="language-text">error: linking with `cc` failed: exit status: 1
  |
  = note: rust-lld: error: unable to find library -lLLVM-{version}
</code></pre>
<h3 id="when-using-rustc-private-with-custom-toolchains"><a class="header" href="#when-using-rustc-private-with-custom-toolchains">When using <code>rustc-private</code> with Custom Toolchains</a></h3>
<p>For custom-built toolchains or environments not using rustup, different configuration may be required:</p>
<ul>
<li>Ensure LLVM libraries are available in your library search paths</li>
<li>You might need to configure library paths explicitly depending on your LLVM installation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustdoc_internals"><a class="header" href="#rustdoc_internals"><code>rustdoc_internals</code></a></h1>
<p>Allows using internal rustdoc features like <code>doc(keyword)</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/90418">#90418</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rustdoc_missing_doc_code_examples"><a class="header" href="#rustdoc_missing_doc_code_examples"><code>rustdoc_missing_doc_code_examples</code></a></h1>
<p>Allows using the <code>rustdoc::missing_doc_code_examples</code> lint</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/101730">#101730</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="s390x_target_feature"><a class="header" href="#s390x_target_feature"><code>s390x_target_feature</code></a></h1>
<p>Target features on s390x.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150259">#150259</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sanitize"><a class="header" href="#sanitize"><code>sanitize</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/39699">#39699</a></p>
<hr>
<p>The <code>sanitize</code> attribute can be used to selectively disable or enable sanitizer
instrumentation in an annotated function. This might be useful to: avoid
instrumentation overhead in a performance critical function, or avoid
instrumenting code that contains constructs unsupported by given sanitizer.</p>
<p>The precise effect of this annotation depends on particular sanitizer in use.
For example, with <code>sanitize(thread = "off")</code>, the thread sanitizer will no
longer instrument non-atomic store / load operations, but it will instrument
atomic operations to avoid reporting false positives and provide meaning full
stack traces.</p>
<p>This attribute was previously named <code>no_sanitize</code>.</p>
<h2 id="examples-14"><a class="header" href="#examples-14">Examples</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(sanitize)]

<span class="boring">fn main() {
</span>#[sanitize(address = "off")]
fn foo() {
  // ...
}
<span class="boring">}</span></code></pre>
<p>It is also possible to disable sanitizers for entire modules and enable them
for single items or functions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(sanitize)]

<span class="boring">fn main() {
</span>#[sanitize(address = "off")]
mod foo {
  fn unsanitized() {
    // ...
  }

  #[sanitize(address = "on")]
  fn sanitized() {
    // ...
  }
}
<span class="boring">}</span></code></pre>
<p>It’s also applicable to impl blocks.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(sanitize)]

<span class="boring">fn main() {
</span>trait MyTrait {
  fn foo(&amp;self);
  fn bar(&amp;self);
}

#[sanitize(address = "off")]
impl MyTrait for () {
  fn foo(&amp;self) {
    // ...
  }

  #[sanitize(address = "on")]
  fn bar(&amp;self) {
    // ...
  }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="simd_ffi"><a class="header" href="#simd_ffi"><code>simd_ffi</code></a></h1>
<p>Allows the use of SIMD types in functions declared in <code>extern</code> blocks.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27731">#27731</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sized_hierarchy"><a class="header" href="#sized_hierarchy"><code>sized_hierarchy</code></a></h1>
<p>Introduces a hierarchy of <code>Sized</code> traits (RFC 3729).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144404">#144404</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sparc_target_feature"><a class="header" href="#sparc_target_feature"><code>sparc_target_feature</code></a></h1>
<p>Target features on sparc.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132783">#132783</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="specialization"><a class="header" href="#specialization"><code>specialization</code></a></h1>
<p>Allows specialization of implementations (RFC 1210).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/31844">#31844</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="staged_api"><a class="header" href="#staged_api"><code>staged_api</code></a></h1>
<p>Allows using the <code>#[stable]</code> and <code>#[unstable]</code> attributes.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="static_align"><a class="header" href="#static_align"><code>static_align</code></a></h1>
<p>Allows using <code>#[rustc_align_static(...)]</code> on static items.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146177">#146177</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stmt_expr_attributes"><a class="header" href="#stmt_expr_attributes"><code>stmt_expr_attributes</code></a></h1>
<p>Allows attributes on expressions and non-item statements.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/15701">#15701</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="strict_provenance_lints"><a class="header" href="#strict_provenance_lints"><code>strict_provenance_lints</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130351">#130351</a></p>
<hr>
<p>The <code>strict_provenance_lints</code> feature allows to enable the <code>fuzzy_provenance_casts</code> and <code>lossy_provenance_casts</code> lints.
These lint on casts between integers and pointers, that are recommended against or invalid in the strict provenance model.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre class="playground"><code class="language-rust">#![feature(strict_provenance_lints)]
#![warn(fuzzy_provenance_casts)]

fn main() {
    let _dangling = 16_usize as *const u8;
    //~^ WARNING: strict provenance disallows casting integer `usize` to pointer `*const u8`
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structural_match"><a class="header" href="#structural_match"><code>structural_match</code></a></h1>
<p>Allows using <code>#[structural_match]</code> which indicates that a type is structurally matchable. FIXME: Subsumed by trait <code>StructuralPartialEq</code>, cannot move to removed until a library feature with the same name exists.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/31434">#31434</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="super_let"><a class="header" href="#super_let"><code>super_let</code></a></h1>
<p>Allows <code>super let</code> statements.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139076">#139076</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="supertrait_item_shadowing"><a class="header" href="#supertrait_item_shadowing"><code>supertrait_item_shadowing</code></a></h1>
<p>Allows subtrait items to shadow supertrait items.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89151">#89151</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="target_feature_inline_always"><a class="header" href="#target_feature_inline_always"><code>target_feature_inline_always</code></a></h1>
<p>Allows the use of target_feature when a function is marked inline(always).</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145574">#145574</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="test_unstable_lint"><a class="header" href="#test_unstable_lint"><code>test_unstable_lint</code></a></h1>
<p>Added for testing unstable lints; perma-unstable.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="thread_local"><a class="header" href="#thread_local"><code>thread_local</code></a></h1>
<p>Allows using <code>#[thread_local]</code> on <code>static</code> items.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29594">#29594</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trait_alias"><a class="header" href="#trait_alias"><code>trait_alias</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/41517">#41517</a></p>
<hr>
<p>The <code>trait_alias</code> feature adds support for trait aliases. These allow aliases
to be created for one or more traits (currently just a single regular trait plus
any number of auto-traits), and used wherever traits would normally be used as
either bounds or trait objects.</p>
<pre class="playground"><code class="language-rust">#![feature(trait_alias)]

trait Foo = std::fmt::Debug + Send;
trait Bar = Foo + Sync;

// Use trait alias as bound on type parameter.
fn foo&lt;T: Foo&gt;(v: &amp;T) {
    println!("{:?}", v);
}

pub fn main() {
    foo(&amp;1);

    // Use trait alias for trait objects.
    let a: &amp;Bar = &amp;123;
    println!("{:?}", a);
    let b = Box::new(456) as Box&lt;dyn Foo&gt;;
    println!("{:?}", b);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transmute_generic_consts"><a class="header" href="#transmute_generic_consts"><code>transmute_generic_consts</code></a></h1>
<p>Allows for transmuting between arrays with sizes that contain generic consts.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/109929">#109929</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="transparent_unions"><a class="header" href="#transparent_unions"><code>transparent_unions</code></a></h1>
<p>The tracking issue for this feature is <a href="https://github.com/rust-lang/rust/issues/60405">#60405</a></p>
<hr>
<p>The <code>transparent_unions</code> feature allows you mark <code>union</code>s as
<code>#[repr(transparent)]</code>. A <code>union</code> may be <code>#[repr(transparent)]</code> in exactly the
same conditions in which a <code>struct</code> may be <code>#[repr(transparent)]</code> (generally,
this means the <code>union</code> must have exactly one non-zero-sized field). Some
concrete illustrations follow.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(transparent_unions)]

<span class="boring">fn main() {
</span>// This union has the same representation as `f32`.
#[repr(transparent)]
union SingleFieldUnion {
    field: f32,
}

// This union has the same representation as `usize`.
#[repr(transparent)]
union MultiFieldUnion {
    field: usize,
    nothing: (),
}
<span class="boring">}</span></code></pre>
<p>For consistency with transparent <code>struct</code>s, <code>union</code>s must have exactly one
non-zero-sized field. If all fields are zero-sized, the <code>union</code> must not be
<code>#[repr(transparent)]</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(transparent_unions)]

<span class="boring">fn main() {
</span>// This (non-transparent) union is already valid in stable Rust:
pub union GoodUnion {
    pub nothing: (),
}

// Error: transparent union needs exactly one non-zero-sized field, but has 0
// #[repr(transparent)]
// pub union BadUnion {
//     pub nothing: (),
// }
<span class="boring">}</span></code></pre>
<p>The one exception is if the <code>union</code> is generic over <code>T</code> and has a field of type
<code>T</code>, it may be <code>#[repr(transparent)]</code> even if <code>T</code> is a zero-sized type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(transparent_unions)]

<span class="boring">fn main() {
</span>// This union has the same representation as `T`.
#[repr(transparent)]
pub union GenericUnion&lt;T: Copy&gt; { // Unions with non-`Copy` fields are unstable.
    pub field: T,
    pub nothing: (),
}

// This is okay even though `()` is a zero-sized type.
pub const THIS_IS_OKAY: GenericUnion&lt;()&gt; = GenericUnion { field: () };
<span class="boring">}</span></code></pre>
<p>Like transparent <code>struct</code>s, a transparent <code>union</code> of type <code>U</code> has the same
layout, size, and ABI as its single non-ZST field. If it is generic over a type
<code>T</code>, and all its fields are ZSTs except for exactly one field of type <code>T</code>, then
it has the same layout and ABI as <code>T</code> (even if <code>T</code> is a ZST when monomorphized).</p>
<p>Like transparent <code>struct</code>s, transparent <code>union</code>s are FFI-safe if and only if
their underlying representation type is also FFI-safe.</p>
<p>A <code>union</code> may not be eligible for the same nonnull-style optimizations that a
<code>struct</code> or <code>enum</code> (with the same fields) are eligible for. Adding
<code>#[repr(transparent)]</code> to  <code>union</code> does not change this. To give a more concrete
example, it is unspecified whether <code>size_of::&lt;T&gt;()</code> is equal to
<code>size_of::&lt;Option&lt;T&gt;&gt;()</code>, where <code>T</code> is a <code>union</code> (regardless of whether or not
it is transparent). The Rust compiler is free to perform this optimization if
possible, but is not required to, and different compiler versions may differ in
their application of these optimizations.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="trivial_bounds"><a class="header" href="#trivial_bounds"><code>trivial_bounds</code></a></h1>
<p>Allows inconsistent bounds in where clauses.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/48214">#48214</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_blocks"><a class="header" href="#try_blocks"><code>try_blocks</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/31436">#31436</a></p>
<hr>
<p>The <code>try_blocks</code> feature adds support for <code>try</code> blocks. A <code>try</code>
block creates a new scope one can use the <code>?</code> operator in.</p>
<pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span>#![feature(try_blocks)]

<span class="boring">fn main() {
</span>use std::num::ParseIntError;

let result: Result&lt;i32, ParseIntError&gt; = try {
    "1".parse::&lt;i32&gt;()?
        + "2".parse::&lt;i32&gt;()?
        + "3".parse::&lt;i32&gt;()?
};
assert_eq!(result, Ok(6));

let result: Result&lt;i32, ParseIntError&gt; = try {
    "1".parse::&lt;i32&gt;()?
        + "foo".parse::&lt;i32&gt;()?
        + "3".parse::&lt;i32&gt;()?
};
assert!(result.is_err());
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_blocks_heterogeneous"><a class="header" href="#try_blocks_heterogeneous"><code>try_blocks_heterogeneous</code></a></h1>
<p>Allows using <code>try bikeshed TargetType {...}</code> expressions.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149488">#149488</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="type_alias_impl_trait"><a class="header" href="#type_alias_impl_trait"><code>type_alias_impl_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/63063">#63063</a></p>
<hr>
<blockquote>
<p>This feature is not to be confused with <a href="#trait_alias"><code>trait_alias</code></a> or <a href="#impl_trait_in_assoc_type"><code>impl_trait_in_assoc_type</code></a>.</p>
</blockquote>
<h3 id="what-is-impl-trait"><a class="header" href="#what-is-impl-trait">What is <code>impl Trait</code>?</a></h3>
<p><code>impl Trait</code> in return position is useful for declaring types that are constrained by traits, but whose concrete type should be hidden:</p>
<pre class="playground"><code class="language-rust">use std::fmt::Debug;

fn new() -&gt; impl Debug {
    42
}

fn main() {
    let thing = new();
    // What actually is a `thing`?
    // No idea but we know it implements `Debug`, so we can debug print it
    println!("{thing:?}");
}</code></pre>
<p>See the <a href="https://doc.rust-lang.org/stable/reference/types/impl-trait.html#abstract-return-types">reference</a> for more information about <code>impl Trait</code> in return position.</p>
<h3 id="type_alias_impl_trait-1"><a class="header" href="#type_alias_impl_trait-1"><code>type_alias_impl_trait</code></a></h3>
<p>However, we might want to use an <code>impl Trait</code> in multiple locations but actually use the same concrete type everywhere while keeping it hidden.
This can be useful in libraries where you want to hide implementation details.</p>
<p>The <code>#[define_opaque]</code> attribute must be used to explicitly list opaque items constrained by the item it’s on.</p>
<pre class="playground"><code class="language-rust">#![feature(type_alias_impl_trait)]
<span class="boring">#![allow(unused_variables, dead_code)]
</span>trait Trait {}

struct MyType;

impl Trait for MyType {}

type Alias = impl Trait;

#[define_opaque(Alias)] // To constrain the type alias to `MyType`
fn new() -&gt; Alias {
    MyType
}

#[define_opaque(Alias)] // So we can name the concrete type inside this item
fn main() {
    let thing: MyType = new();
}

// It can be a part of a struct too
struct HaveAlias {
    stuff: String,
    thing: Alias,
}</code></pre>
<p>In this example, the concrete type referred to by <code>Alias</code> is guaranteed to be the same wherever <code>Alias</code> occurs.</p>
<blockquote>
<p>Originally this feature included type aliases as an associated type of a trait. In <a href="https://github.com/rust-lang/rust/pull/110237">#110237</a> this was split off to <a href="#impl_trait_in_assoc_type"><code>impl_trait_in_assoc_type</code></a>.</p>
</blockquote>
<h3 id="type_alias_impl_trait-in-argument-position"><a class="header" href="#type_alias_impl_trait-in-argument-position"><code>type_alias_impl_trait</code> in argument position.</a></h3>
<p>Note that using <code>Alias</code> as an argument type is <em>not</em> the same as argument-position <code>impl Trait</code>, as <code>Alias</code> refers to a unique type, whereas the concrete type for argument-position <code>impl Trait</code> is chosen by the caller.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![feature(type_alias_impl_trait)]
</span><span class="boring">#![allow(unused_variables)]
</span><span class="boring">pub mod x {
</span><span class="boring">pub trait Trait {}
</span><span class="boring">
</span><span class="boring">struct MyType;
</span><span class="boring">
</span><span class="boring">impl Trait for MyType {}
</span><span class="boring">
</span><span class="boring">pub type Alias = impl Trait;
</span><span class="boring">
</span><span class="boring">#[define_opaque(Alias)]
</span><span class="boring">pub fn new() -&gt; Alias {
</span><span class="boring">    MyType
</span><span class="boring">}
</span><span class="boring">}
</span><span class="boring">use x::*;
</span>// this...
pub fn take_alias(x: Alias) {
    // ...
}

// ...is *not* the same as
pub fn take_impl(x: impl Trait) {
    // ...
}
<span class="boring">fn main(){}</span></code></pre>
<pre class="playground"><code class="language-rust compile_fail E0308"><span class="boring">#![feature(type_alias_impl_trait)]
</span><span class="boring">#![allow(unused_variables)]
</span><span class="boring">pub mod x {
</span><span class="boring">pub trait Trait {}
</span><span class="boring">
</span><span class="boring">struct MyType;
</span><span class="boring">
</span><span class="boring">impl Trait for MyType {}
</span><span class="boring">
</span><span class="boring">pub type Alias = impl Trait;
</span><span class="boring">
</span><span class="boring">#[define_opaque(Alias)]
</span><span class="boring">pub fn new() -&gt; Alias {
</span><span class="boring">    MyType
</span><span class="boring">}
</span><span class="boring">}
</span><span class="boring">use x::*;
</span><span class="boring">pub fn take_alias(x: Alias) {
</span><span class="boring">    // ...
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn take_impl(x: impl Trait) {
</span><span class="boring">   // ...
</span><span class="boring">}
</span><span class="boring">
</span>// a user's crate using the trait and type alias
struct UserType;
impl Trait for UserType {}

<span class="boring">fn main(){
</span>let x = UserType;
take_alias(x);
// ERROR expected opaque type, found `UserType`
// this function *actually* takes a `MyType` as is constrained in `new`

let x = UserType;
take_impl(x);
// OK

let x = new();
take_alias(x);
// OK

let x = new();
take_impl(x);
// OK
<span class="boring">}</span></code></pre>
<p>Note that the user cannot use <code>#[define_opaque(Alias)]</code> to reify the opaque type because only the crate where the type alias is declared may do so. But if this happened in the same crate and the opaque type was reified, they’d get a familiar error: “expected <code>MyType</code>, got <code>UserType</code>”.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type_changing_struct_update"><a class="header" href="#type_changing_struct_update"><code>type_changing_struct_update</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/86555">#86555</a></p>
<hr>
<p>This implements <a href="https://github.com/rust-lang/rfcs/blob/master/text/2528-type-changing-struct-update-syntax.md">RFC2528</a>. When turned on, you can create instances of the same struct
that have different generic type or lifetime parameters.</p>
<pre class="playground"><code class="language-rust">#![allow(unused_variables, dead_code)]
#![feature(type_changing_struct_update)]

fn main () {
    struct Foo&lt;T, U&gt; {
        field1: T,
        field2: U,
    }

    let base: Foo&lt;String, i32&gt; = Foo {
        field1: String::from("hello"),
        field2: 1234,
    };
    let updated: Foo&lt;f64, i32&gt; = Foo {
        field1: 3.14,
        ..base
    };
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unboxed_closures"><a class="header" href="#unboxed_closures"><code>unboxed_closures</code></a></h1>
<p>The tracking issue for this feature is <a href="https://github.com/rust-lang/rust/issues/29625">#29625</a></p>
<p>See Also: <a href="#fn_traits"><code>fn_traits</code></a></p>
<hr>
<p>The <code>unboxed_closures</code> feature allows you to write functions using the <code>"rust-call"</code> ABI,
required for implementing the <a href="../std/ops/trait.Fn.html"><code>Fn*</code></a> family of traits. <code>"rust-call"</code> functions must have
exactly one (non self) argument, a tuple representing the argument list.</p>
<pre class="playground"><code class="language-rust">#![feature(unboxed_closures)]

extern "rust-call" fn add_args(args: (u32, u32)) -&gt; u32 {
    args.0 + args.1
}

fn main() {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unqualified_local_imports"><a class="header" href="#unqualified_local_imports"><code>unqualified_local_imports</code></a></h1>
<p>Helps with formatting for <code>group_imports = "StdExternalCrate"</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138299">#138299</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsafe_binders"><a class="header" href="#unsafe_binders"><code>unsafe_binders</code></a></h1>
<p>Allows using <code>unsafe&lt;'a&gt; &amp;'a T</code> unsafe binder types.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130516">#130516</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsafe_fields"><a class="header" href="#unsafe_fields"><code>unsafe_fields</code></a></h1>
<p>Allows declaring fields <code>unsafe</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132922">#132922</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsized_const_params"><a class="header" href="#unsized_const_params"><code>unsized_const_params</code></a></h1>
<p>Allows const generic parameters to be defined with types that are not <code>Sized</code>, e.g. <code>fn foo&lt;const N: [u8]&gt;() {</code>.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/95174">#95174</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsized_fn_params"><a class="header" href="#unsized_fn_params"><code>unsized_fn_params</code></a></h1>
<p>Allows unsized fn parameters.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/48055">#48055</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="used_with_arg"><a class="header" href="#used_with_arg"><code>used_with_arg</code></a></h1>
<p>Allows using the <code>#[used(linker)]</code> (or <code>#[used(compiler)]</code>) attribute.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93798">#93798</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasm_target_feature"><a class="header" href="#wasm_target_feature"><code>wasm_target_feature</code></a></h1>
<p>Target features on wasm.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150260">#150260</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="where_clause_attrs"><a class="header" href="#where_clause_attrs"><code>where_clause_attrs</code></a></h1>
<p>Allows use of attributes in <code>where</code> clauses.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/115590">#115590</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="with_negative_coherence"><a class="header" href="#with_negative_coherence"><code>with_negative_coherence</code></a></h1>
<p>Use for stable + negative coherence and strict coherence depending on trait’s rustc_strict_coherence value.</p>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="x86_amx_intrinsics"><a class="header" href="#x86_amx_intrinsics"><code>x86_amx_intrinsics</code></a></h1>
<p>Allows use of x86 <code>AMX</code> target-feature attributes and intrinsics</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/126622">#126622</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="x87_target_feature"><a class="header" href="#x87_target_feature"><code>x87_target_feature</code></a></h1>
<p>The x87 target feature on x86.</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150261">#150261</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="xop_target_feature"><a class="header" href="#xop_target_feature"><code>xop_target_feature</code></a></h1>
<p>Allows use of the <code>xop</code> target-feature</p>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/127208">#127208</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="yeet_expr"><a class="header" href="#yeet_expr"><code>yeet_expr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96373">#96373</a></p>
<hr>
<p>The <code>yeet_expr</code> feature adds support for <code>do yeet</code> expressions,
which can be used to early-exit from a function or <code>try</code> block.</p>
<p>These are highly experimental, thus the placeholder syntax.</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(yeet_expr)]

<span class="boring">fn main() {
</span>fn foo() -&gt; Result&lt;String, i32&gt; {
    do yeet 4;
}
assert_eq!(foo(), Err(4));

fn bar() -&gt; Option&lt;String&gt; {
    do yeet;
}
assert_eq!(bar(), None);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="yield_expr"><a class="header" href="#yield_expr"><code>yield_expr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/43122">#43122</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="library-features"><a class="header" href="#library-features">Library Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="abort_unwind"><a class="header" href="#abort_unwind"><code>abort_unwind</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130338">#130338</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="acceptfilter"><a class="header" href="#acceptfilter"><code>acceptfilter</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121891">#121891</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="addr_parse_ascii"><a class="header" href="#addr_parse_ascii"><code>addr_parse_ascii</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/101035">#101035</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="align_to_uninit_mut"><a class="header" href="#align_to_uninit_mut"><code>align_to_uninit_mut</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139062">#139062</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="alloc_error_hook"><a class="header" href="#alloc_error_hook"><code>alloc_error_hook</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/51245">#51245</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="alloc_internals"><a class="header" href="#alloc_internals"><code>alloc_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="alloc_slice_into_array"><a class="header" href="#alloc_slice_into_array"><code>alloc_slice_into_array</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148082">#148082</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="allocator_api"><a class="header" href="#allocator_api"><code>allocator_api</code></a></h1>
<p>The tracking issue for this feature is <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a></p>
<hr>
<p>Sometimes you want the memory for one collection to use a different
allocator than the memory for another collection. In this case,
replacing the global allocator is not a workable option. Instead,
you need to pass in an instance of an <code>AllocRef</code> to each collection
for which you want a custom allocator.</p>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="alloctests"><a class="header" href="#alloctests"><code>alloctests</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="arc_is_unique"><a class="header" href="#arc_is_unique"><code>arc_is_unique</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138938">#138938</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="array_into_iter_constructors"><a class="header" href="#array_into_iter_constructors"><code>array_into_iter_constructors</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/91583">#91583</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="array_ptr_get"><a class="header" href="#array_ptr_get"><code>array_ptr_get</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/119834">#119834</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="array_try_from_fn"><a class="header" href="#array_try_from_fn"><code>array_try_from_fn</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89379">#89379</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="array_try_map"><a class="header" href="#array_try_map"><code>array_try_map</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/79711">#79711</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ascii_char"><a class="header" href="#ascii_char"><code>ascii_char</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/110998">#110998</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ascii_char_variants"><a class="header" href="#ascii_char_variants"><code>ascii_char_variants</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/110998">#110998</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="assert_matches"><a class="header" href="#assert_matches"><code>assert_matches</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/82775">#82775</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_fn_traits"><a class="header" href="#async_fn_traits"><code>async_fn_traits</code></a></h1>
<p>See Also: <a href="#fn_traits"><code>fn_traits</code></a></p>
<hr>
<p>The <code>async_fn_traits</code> feature allows for implementation of the <a href="../std/ops/trait.AsyncFn.html"><code>AsyncFn*</code></a> traits
for creating custom closure-like types that return futures.</p>
<p>The main difference to the <code>Fn*</code> family of traits is that <code>AsyncFn</code> can return a future
that borrows from itself (<code>FnOnce::Output</code> has no lifetime parameters, while <code>AsyncFnMut::CallRefFuture</code> does).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_gen_internals"><a class="header" href="#async_gen_internals"><code>async_gen_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_iter_from_iter"><a class="header" href="#async_iter_from_iter"><code>async_iter_from_iter</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/81798">#81798</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="async_iterator"><a class="header" href="#async_iterator"><code>async_iterator</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/79024">#79024</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="atomic_from_mut"><a class="header" href="#atomic_from_mut"><code>atomic_from_mut</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/76314">#76314</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="atomic_internals"><a class="header" href="#atomic_internals"><code>atomic_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="atomic_ptr_null"><a class="header" href="#atomic_ptr_null"><code>atomic_ptr_null</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150733">#150733</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="atomic_try_update"><a class="header" href="#atomic_try_update"><code>atomic_try_update</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/135894">#135894</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="autodiff-1"><a class="header" href="#autodiff-1"><code>autodiff</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/124509">#124509</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="backtrace_frames"><a class="header" href="#backtrace_frames"><code>backtrace_frames</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/79676">#79676</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bigint_helper_methods"><a class="header" href="#bigint_helper_methods"><code>bigint_helper_methods</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/85532">#85532</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bikeshed_guaranteed_no_drop"><a class="header" href="#bikeshed_guaranteed_no_drop"><code>bikeshed_guaranteed_no_drop</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="binary_heap_drain_sorted"><a class="header" href="#binary_heap_drain_sorted"><code>binary_heap_drain_sorted</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/59278">#59278</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="binary_heap_into_iter_sorted"><a class="header" href="#binary_heap_into_iter_sorted"><code>binary_heap_into_iter_sorted</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/59278">#59278</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="binary_heap_peek_mut_refresh"><a class="header" href="#binary_heap_peek_mut_refresh"><code>binary_heap_peek_mut_refresh</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138355">#138355</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bool_to_result"><a class="header" href="#bool_to_result"><code>bool_to_result</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142748">#142748</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bound_as_ref"><a class="header" href="#bound_as_ref"><code>bound_as_ref</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/80996">#80996</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bound_copied"><a class="header" href="#bound_copied"><code>bound_copied</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145966">#145966</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="box_as_ptr"><a class="header" href="#box_as_ptr"><code>box_as_ptr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/129090">#129090</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="box_into_boxed_slice"><a class="header" href="#box_into_boxed_slice"><code>box_into_boxed_slice</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/71582">#71582</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="box_into_inner"><a class="header" href="#box_into_inner"><code>box_into_inner</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/80437">#80437</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="box_take"><a class="header" href="#box_take"><code>box_take</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147212">#147212</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="box_vec_non_null"><a class="header" href="#box_vec_non_null"><code>box_vec_non_null</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130364">#130364</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="breakpoint"><a class="header" href="#breakpoint"><code>breakpoint</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133724">#133724</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bstr"><a class="header" href="#bstr"><code>bstr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134915">#134915</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bstr_internals"><a class="header" href="#bstr_internals"><code>bstr_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="btree_cursors"><a class="header" href="#btree_cursors"><code>btree_cursors</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/107540">#107540</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="btree_set_entry"><a class="header" href="#btree_set_entry"><code>btree_set_entry</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133549">#133549</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="btreemap_alloc"><a class="header" href="#btreemap_alloc"><code>btreemap_alloc</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/32838">#32838</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="buf_read_has_data_left"><a class="header" href="#buf_read_has_data_left"><code>buf_read_has_data_left</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/86423">#86423</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bufreader_peek"><a class="header" href="#bufreader_peek"><code>bufreader_peek</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/128405">#128405</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="c_size_t"><a class="header" href="#c_size_t"><code>c_size_t</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/88345">#88345</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="c_void_variant"><a class="header" href="#c_void_variant"><code>c_void_variant</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="can_vector"><a class="header" href="#can_vector"><code>can_vector</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/69941">#69941</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cast_maybe_uninit"><a class="header" href="#cast_maybe_uninit"><code>cast_maybe_uninit</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145036">#145036</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cell_get_cloned"><a class="header" href="#cell_get_cloned"><code>cell_get_cloned</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145329">#145329</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cell_leak"><a class="header" href="#cell_leak"><code>cell_leak</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/69099">#69099</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_accessible"><a class="header" href="#cfg_accessible"><code>cfg_accessible</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/64797">#64797</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_eval"><a class="header" href="#cfg_eval"><code>cfg_eval</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/82679">#82679</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg_select"><a class="header" href="#cfg_select"><code>cfg_select</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/115585">#115585</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="char_internals"><a class="header" href="#char_internals"><code>char_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="char_max_len"><a class="header" href="#char_max_len"><code>char_max_len</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121714">#121714</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="clamp_magnitude"><a class="header" href="#clamp_magnitude"><code>clamp_magnitude</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148519">#148519</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="clone_from_ref"><a class="header" href="#clone_from_ref"><code>clone_from_ref</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149075">#149075</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="clone_to_uninit"><a class="header" href="#clone_to_uninit"><code>clone_to_uninit</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/126799">#126799</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cmp_minmax"><a class="header" href="#cmp_minmax"><code>cmp_minmax</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/115939">#115939</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="coerce_pointee_validated"><a class="header" href="#coerce_pointee_validated"><code>coerce_pointee_validated</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="coerce_unsized"><a class="header" href="#coerce_unsized"><code>coerce_unsized</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/18598">#18598</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cold_path"><a class="header" href="#cold_path"><code>cold_path</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136873">#136873</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="command_resolved_envs"><a class="header" href="#command_resolved_envs"><code>command_resolved_envs</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149070">#149070</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="concat_bytes"><a class="header" href="#concat_bytes"><code>concat_bytes</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87555">#87555</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_alloc_error"><a class="header" href="#const_alloc_error"><code>const_alloc_error</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/92523">#92523</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_array"><a class="header" href="#const_array"><code>const_array</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147606">#147606</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_btree_len"><a class="header" href="#const_btree_len"><code>const_btree_len</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_carrying_mul_add"><a class="header" href="#const_carrying_mul_add"><code>const_carrying_mul_add</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/85532">#85532</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_cell_traits"><a class="header" href="#const_cell_traits"><code>const_cell_traits</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147787">#147787</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_clone"><a class="header" href="#const_clone"><code>const_clone</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142757">#142757</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_cmp"><a class="header" href="#const_cmp"><code>const_cmp</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143800">#143800</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_control_flow"><a class="header" href="#const_control_flow"><code>const_control_flow</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148739">#148739</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_convert"><a class="header" href="#const_convert"><code>const_convert</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143773">#143773</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_default"><a class="header" href="#const_default"><code>const_default</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143894">#143894</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_drop_guard"><a class="header" href="#const_drop_guard"><code>const_drop_guard</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_drop_in_place"><a class="header" href="#const_drop_in_place"><code>const_drop_in_place</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/109342">#109342</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_eval_select"><a class="header" href="#const_eval_select"><code>const_eval_select</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/124625">#124625</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_format_args"><a class="header" href="#const_format_args"><code>const_format_args</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_heap"><a class="header" href="#const_heap"><code>const_heap</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/79597">#79597</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_index"><a class="header" href="#const_index"><code>const_index</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143775">#143775</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_manually_drop_take"><a class="header" href="#const_manually_drop_take"><code>const_manually_drop_take</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148773">#148773</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_never_short_circuit"><a class="header" href="#const_never_short_circuit"><code>const_never_short_circuit</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_ops"><a class="header" href="#const_ops"><code>const_ops</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143802">#143802</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_option_ops"><a class="header" href="#const_option_ops"><code>const_option_ops</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143956">#143956</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_range"><a class="header" href="#const_range"><code>const_range</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_range_bounds"><a class="header" href="#const_range_bounds"><code>const_range_bounds</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/108082">#108082</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_raw_ptr_comparison"><a class="header" href="#const_raw_ptr_comparison"><code>const_raw_ptr_comparison</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/53020">#53020</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_ref_cell"><a class="header" href="#const_ref_cell"><code>const_ref_cell</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137844">#137844</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_result_trait_fn"><a class="header" href="#const_result_trait_fn"><code>const_result_trait_fn</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144211">#144211</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_result_unwrap_unchecked"><a class="header" href="#const_result_unwrap_unchecked"><code>const_result_unwrap_unchecked</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148714">#148714</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_select_unpredictable"><a class="header" href="#const_select_unpredictable"><code>const_select_unpredictable</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145938">#145938</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_slice_from_mut_ptr_range"><a class="header" href="#const_slice_from_mut_ptr_range"><code>const_slice_from_mut_ptr_range</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89792">#89792</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_slice_from_ptr_range"><a class="header" href="#const_slice_from_ptr_range"><code>const_slice_from_ptr_range</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89792">#89792</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_slice_make_iter"><a class="header" href="#const_slice_make_iter"><code>const_slice_make_iter</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137737">#137737</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_split_off_first_last"><a class="header" href="#const_split_off_first_last"><code>const_split_off_first_last</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138539">#138539</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_swap_with_slice"><a class="header" href="#const_swap_with_slice"><code>const_swap_with_slice</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142204">#142204</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_try_residual"><a class="header" href="#const_try_residual"><code>const_try_residual</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/91285">#91285</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="const_type_name"><a class="header" href="#const_type_name"><code>const_type_name</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/63084">#63084</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="container_error_extra"><a class="header" href="#container_error_extra"><code>container_error_extra</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="context_ext"><a class="header" href="#context_ext"><code>context_ext</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123392">#123392</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="control_flow_into_value"><a class="header" href="#control_flow_into_value"><code>control_flow_into_value</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137461">#137461</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="control_flow_ok"><a class="header" href="#control_flow_ok"><code>control_flow_ok</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/140266">#140266</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="convert_float_to_int"><a class="header" href="#convert_float_to_int"><code>convert_float_to_int</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/67057">#67057</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="copied_into_inner"><a class="header" href="#copied_into_inner"><code>copied_into_inner</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="core_float_math"><a class="header" href="#core_float_math"><code>core_float_math</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137578">#137578</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="core_intrinsics"><a class="header" href="#core_intrinsics"><code>core_intrinsics</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="core_intrinsics_fallbacks"><a class="header" href="#core_intrinsics_fallbacks"><code>core_intrinsics_fallbacks</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="core_io_borrowed_buf"><a class="header" href="#core_io_borrowed_buf"><code>core_io_borrowed_buf</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/117693">#117693</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="core_private_bignum"><a class="header" href="#core_private_bignum"><code>core_private_bignum</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="core_private_diy_float"><a class="header" href="#core_private_diy_float"><code>core_private_diy_float</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="coroutine_trait"><a class="header" href="#coroutine_trait"><code>coroutine_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/43122">#43122</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cow_is_borrowed"><a class="header" href="#cow_is_borrowed"><code>cow_is_borrowed</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/65143">#65143</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cstr_bytes"><a class="header" href="#cstr_bytes"><code>cstr_bytes</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/112115">#112115</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cstr_display"><a class="header" href="#cstr_display"><code>cstr_display</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139984">#139984</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cstr_internals"><a class="header" href="#cstr_internals"><code>cstr_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="current_thread_id"><a class="header" href="#current_thread_id"><code>current_thread_id</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147194">#147194</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="cursor_split"><a class="header" href="#cursor_split"><code>cursor_split</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/86369">#86369</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="darwin_objc"><a class="header" href="#darwin_objc"><code>darwin_objc</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145496">#145496</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="deadline_api"><a class="header" href="#deadline_api"><code>deadline_api</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/46316">#46316</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="debug_closure_helpers"><a class="header" href="#debug_closure_helpers"><code>debug_closure_helpers</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/117729">#117729</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="dec2flt"><a class="header" href="#dec2flt"><code>dec2flt</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="deque_extend_front"><a class="header" href="#deque_extend_front"><code>deque_extend_front</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146975">#146975</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="deref_pure_trait"><a class="header" href="#deref_pure_trait"><code>deref_pure_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87121">#87121</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="derive_clone_copy_internals"><a class="header" href="#derive_clone_copy_internals"><code>derive_clone_copy_internals</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="derive_coerce_pointee"><a class="header" href="#derive_coerce_pointee"><code>derive_coerce_pointee</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123430">#123430</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="derive_const"><a class="header" href="#derive_const"><code>derive_const</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118304">#118304</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="derive_eq_internals"><a class="header" href="#derive_eq_internals"><code>derive_eq_internals</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="dir_entry_ext2"><a class="header" href="#dir_entry_ext2"><code>dir_entry_ext2</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/85573">#85573</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="dirfd"><a class="header" href="#dirfd"><code>dirfd</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/120426">#120426</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="dirhandle"><a class="header" href="#dirhandle"><code>dirhandle</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/120426">#120426</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="discriminant_kind"><a class="header" href="#discriminant_kind"><code>discriminant_kind</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="disjoint_bitor"><a class="header" href="#disjoint_bitor"><code>disjoint_bitor</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/135758">#135758</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="dispatch_from_dyn"><a class="header" href="#dispatch_from_dyn"><code>dispatch_from_dyn</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="downcast_unchecked"><a class="header" href="#downcast_unchecked"><code>downcast_unchecked</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/90850">#90850</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="drain_keep_rest"><a class="header" href="#drain_keep_rest"><code>drain_keep_rest</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/101122">#101122</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="drop_guard"><a class="header" href="#drop_guard"><code>drop_guard</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144426">#144426</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="duration_constants"><a class="header" href="#duration_constants"><code>duration_constants</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/57391">#57391</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="duration_constructors"><a class="header" href="#duration_constructors"><code>duration_constructors</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/120301">#120301</a></p>
<hr>
<p>Add the methods <code>from_days</code> and <code>from_weeks</code> to <code>Duration</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="duration_integer_division"><a class="header" href="#duration_integer_division"><code>duration_integer_division</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149573">#149573</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="duration_millis_float"><a class="header" href="#duration_millis_float"><code>duration_millis_float</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/122451">#122451</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="duration_units"><a class="header" href="#duration_units"><code>duration_units</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/120301">#120301</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="edition_panic"><a class="header" href="#edition_panic"><code>edition_panic</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="error_generic_member_access"><a class="header" href="#error_generic_member_access"><code>error_generic_member_access</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99301">#99301</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="error_iter"><a class="header" href="#error_iter"><code>error_iter</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/58520">#58520</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="error_reporter"><a class="header" href="#error_reporter"><code>error_reporter</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/90172">#90172</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="error_type_id"><a class="header" href="#error_type_id"><code>error_type_id</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/60784">#60784</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="exact_bitshifts"><a class="header" href="#exact_bitshifts"><code>exact_bitshifts</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144336">#144336</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="exact_div"><a class="header" href="#exact_div"><code>exact_div</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139911">#139911</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="exact_size_is_empty"><a class="header" href="#exact_size_is_empty"><code>exact_size_is_empty</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/35428">#35428</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="exclusive_wrapper"><a class="header" href="#exclusive_wrapper"><code>exclusive_wrapper</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/98407">#98407</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="exit_status_error"><a class="header" href="#exit_status_error"><code>exit_status_error</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/84908">#84908</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="exitcode_exit_method"><a class="header" href="#exitcode_exit_method"><code>exitcode_exit_method</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/97100">#97100</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="extend_one"><a class="header" href="#extend_one"><code>extend_one</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="extend_one_unchecked"><a class="header" href="#extend_one_unchecked"><code>extend_one_unchecked</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fd"><a class="header" href="#fd"><code>fd</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="file_buffered"><a class="header" href="#file_buffered"><code>file_buffered</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130804">#130804</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="float_algebraic"><a class="header" href="#float_algebraic"><code>float_algebraic</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136469">#136469</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="float_erf"><a class="header" href="#float_erf"><code>float_erf</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136321">#136321</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="float_gamma"><a class="header" href="#float_gamma"><code>float_gamma</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99842">#99842</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="float_minimum_maximum"><a class="header" href="#float_minimum_maximum"><code>float_minimum_maximum</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/91079">#91079</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="flt2dec"><a class="header" href="#flt2dec"><code>flt2dec</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fmt_arguments_from_str"><a class="header" href="#fmt_arguments_from_str"><code>fmt_arguments_from_str</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148905">#148905</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fmt_helpers_for_derive"><a class="header" href="#fmt_helpers_for_derive"><code>fmt_helpers_for_derive</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fmt_internals"><a class="header" href="#fmt_internals"><code>fmt_internals</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fn_ptr_trait"><a class="header" href="#fn_ptr_trait"><code>fn_ptr_trait</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fn_traits"><a class="header" href="#fn_traits"><code>fn_traits</code></a></h1>
<p>The tracking issue for this feature is <a href="https://github.com/rust-lang/rust/issues/29625">#29625</a></p>
<p>See Also: <a href="#unboxed_closures"><code>unboxed_closures</code></a></p>
<hr>
<p>The <code>fn_traits</code> feature allows for implementation of the <a href="../std/ops/trait.Fn.html"><code>Fn*</code></a> traits
for creating custom closure-like types.</p>
<pre class="playground"><code class="language-rust">#![feature(unboxed_closures)]
#![feature(fn_traits)]

struct Adder {
    a: u32
}

impl FnOnce&lt;(u32, )&gt; for Adder {
    type Output = u32;
    extern "rust-call" fn call_once(self, b: (u32, )) -&gt; Self::Output {
        self.a + b.0
    }
}

fn main() {
    let adder = Adder { a: 3 };
    assert_eq!(adder(2), 5);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="forget_unsized"><a class="header" href="#forget_unsized"><code>forget_unsized</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="format_args_nl"><a class="header" href="#format_args_nl"><code>format_args_nl</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="formatting_options"><a class="header" href="#formatting_options"><code>formatting_options</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118117">#118117</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="freeze"><a class="header" href="#freeze"><code>freeze</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121675">#121675</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fs_set_times"><a class="header" href="#fs_set_times"><code>fs_set_times</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147455">#147455</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="funnel_shifts"><a class="header" href="#funnel_shifts"><code>funnel_shifts</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145686">#145686</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="future_join"><a class="header" href="#future_join"><code>future_join</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/91642">#91642</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="gen_future"><a class="header" href="#gen_future"><code>gen_future</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generic_assert_internals"><a class="header" href="#generic_assert_internals"><code>generic_assert_internals</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/44838">#44838</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generic_atomic"><a class="header" href="#generic_atomic"><code>generic_atomic</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130539">#130539</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="get_disjoint_mut_helpers"><a class="header" href="#get_disjoint_mut_helpers"><code>get_disjoint_mut_helpers</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="get_mut_unchecked"><a class="header" href="#get_mut_unchecked"><code>get_mut_unchecked</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/63292">#63292</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="gethostname"><a class="header" href="#gethostname"><code>gethostname</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/135142">#135142</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="gpu_intrinsics"><a class="header" href="#gpu_intrinsics"><code>gpu_intrinsics</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="hash_set_entry"><a class="header" href="#hash_set_entry"><code>hash_set_entry</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/60896">#60896</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="hasher_prefixfree_extras"><a class="header" href="#hasher_prefixfree_extras"><code>hasher_prefixfree_extras</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96762">#96762</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="hashmap_internals"><a class="header" href="#hashmap_internals"><code>hashmap_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="hint_must_use"><a class="header" href="#hint_must_use"><code>hint_must_use</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/94745">#94745</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="hint_prefetch"><a class="header" href="#hint_prefetch"><code>hint_prefetch</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146941">#146941</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="inplace_iteration"><a class="header" href="#inplace_iteration"><code>inplace_iteration</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="int_format_into"><a class="header" href="#int_format_into"><code>int_format_into</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138215">#138215</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="int_from_ascii"><a class="header" href="#int_from_ascii"><code>int_from_ascii</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134821">#134821</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="int_lowest_highest_one"><a class="header" href="#int_lowest_highest_one"><code>int_lowest_highest_one</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/145203">#145203</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="int_roundings"><a class="header" href="#int_roundings"><code>int_roundings</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/88581">#88581</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="integer_atomics"><a class="header" href="#integer_atomics"><code>integer_atomics</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99069">#99069</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="internal_impls_macro"><a class="header" href="#internal_impls_macro"><code>internal_impls_macro</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="internal_output_capture"><a class="header" href="#internal_output_capture"><code>internal_output_capture</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="io_const_error"><a class="header" href="#io_const_error"><code>io_const_error</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133448">#133448</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="io_const_error_internals"><a class="header" href="#io_const_error_internals"><code>io_const_error_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="io_error_inprogress"><a class="header" href="#io_error_inprogress"><code>io_error_inprogress</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130840">#130840</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="io_error_more"><a class="header" href="#io_error_more"><code>io_error_more</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/86442">#86442</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="io_error_uncategorized"><a class="header" href="#io_error_uncategorized"><code>io_error_uncategorized</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="io_slice_as_bytes"><a class="header" href="#io_slice_as_bytes"><code>io_slice_as_bytes</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132818">#132818</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ip"><a class="header" href="#ip"><code>ip</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27709">#27709</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ip_as_octets"><a class="header" href="#ip_as_octets"><code>ip_as_octets</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137259">#137259</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="is_ascii_octdigit"><a class="header" href="#is_ascii_octdigit"><code>is_ascii_octdigit</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/101288">#101288</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="is_loongarch_feature_detected"><a class="header" href="#is_loongarch_feature_detected"><code>is_loongarch_feature_detected</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/117425">#117425</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="is_riscv_feature_detected"><a class="header" href="#is_riscv_feature_detected"><code>is_riscv_feature_detected</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111192">#111192</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="isolate_most_least_significant_one"><a class="header" href="#isolate_most_least_significant_one"><code>isolate_most_least_significant_one</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136909">#136909</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_advance_by"><a class="header" href="#iter_advance_by"><code>iter_advance_by</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/77404">#77404</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_array_chunks"><a class="header" href="#iter_array_chunks"><code>iter_array_chunks</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/100450">#100450</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_collect_into"><a class="header" href="#iter_collect_into"><code>iter_collect_into</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/94780">#94780</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_from_coroutine"><a class="header" href="#iter_from_coroutine"><code>iter_from_coroutine</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/43122">#43122</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_intersperse"><a class="header" href="#iter_intersperse"><code>iter_intersperse</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/79524">#79524</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_is_partitioned"><a class="header" href="#iter_is_partitioned"><code>iter_is_partitioned</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/62544">#62544</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_macro"><a class="header" href="#iter_macro"><code>iter_macro</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142269">#142269</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_map_windows"><a class="header" href="#iter_map_windows"><code>iter_map_windows</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87155">#87155</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_next_chunk"><a class="header" href="#iter_next_chunk"><code>iter_next_chunk</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/98326">#98326</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_order_by"><a class="header" href="#iter_order_by"><code>iter_order_by</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/64295">#64295</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iter_partition_in_place"><a class="header" href="#iter_partition_in_place"><code>iter_partition_in_place</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/62543">#62543</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iterator_try_collect"><a class="header" href="#iterator_try_collect"><code>iterator_try_collect</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/94047">#94047</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iterator_try_reduce"><a class="header" href="#iterator_try_reduce"><code>iterator_try_reduce</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/87053">#87053</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="junction_point"><a class="header" href="#junction_point"><code>junction_point</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121709">#121709</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="layout_for_ptr"><a class="header" href="#layout_for_ptr"><code>layout_for_ptr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/69835">#69835</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="lazy_cell_into_inner"><a class="header" href="#lazy_cell_into_inner"><code>lazy_cell_into_inner</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/125623">#125623</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="legacy_receiver_trait"><a class="header" href="#legacy_receiver_trait"><code>legacy_receiver_trait</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="liballoc_internals"><a class="header" href="#liballoc_internals"><code>liballoc_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="libstd_sys_internals"><a class="header" href="#libstd_sys_internals"><code>libstd_sys_internals</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="likely_unlikely"><a class="header" href="#likely_unlikely"><code>likely_unlikely</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136873">#136873</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="linked_list_cursors"><a class="header" href="#linked_list_cursors"><code>linked_list_cursors</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/58533">#58533</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="linked_list_remove"><a class="header" href="#linked_list_remove"><code>linked_list_remove</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/69210">#69210</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="linked_list_retain"><a class="header" href="#linked_list_retain"><code>linked_list_retain</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/114135">#114135</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="linux_pidfd"><a class="header" href="#linux_pidfd"><code>linux_pidfd</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/82971">#82971</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="local_key_cell_update"><a class="header" href="#local_key_cell_update"><code>local_key_cell_update</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143989">#143989</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="local_waker"><a class="header" href="#local_waker"><code>local_waker</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118959">#118959</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="lock_value_accessors"><a class="header" href="#lock_value_accessors"><code>lock_value_accessors</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133407">#133407</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="log_syntax"><a class="header" href="#log_syntax"><code>log_syntax</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/29598">#29598</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="map_try_insert"><a class="header" href="#map_try_insert"><code>map_try_insert</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/82766">#82766</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="mapped_lock_guards"><a class="header" href="#mapped_lock_guards"><code>mapped_lock_guards</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/117108">#117108</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="maybe_dangling"><a class="header" href="#maybe_dangling"><code>maybe_dangling</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118166">#118166</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="maybe_uninit_array_assume_init"><a class="header" href="#maybe_uninit_array_assume_init"><code>maybe_uninit_array_assume_init</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96097">#96097</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="maybe_uninit_as_bytes"><a class="header" href="#maybe_uninit_as_bytes"><code>maybe_uninit_as_bytes</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93092">#93092</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="maybe_uninit_fill"><a class="header" href="#maybe_uninit_fill"><code>maybe_uninit_fill</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/117428">#117428</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="maybe_uninit_uninit_array_transpose"><a class="header" href="#maybe_uninit_uninit_array_transpose"><code>maybe_uninit_uninit_array_transpose</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96097">#96097</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="mem_conjure_zst"><a class="header" href="#mem_conjure_zst"><code>mem_conjure_zst</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/95383">#95383</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="mem_copy_fn"><a class="header" href="#mem_copy_fn"><code>mem_copy_fn</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/98262">#98262</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="min_const_control_flow"><a class="header" href="#min_const_control_flow"><code>min_const_control_flow</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148738">#148738</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="more_float_constants"><a class="header" href="#more_float_constants"><code>more_float_constants</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146939">#146939</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="motor_ext"><a class="header" href="#motor_ext"><code>motor_ext</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147456">#147456</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="mpmc_channel"><a class="header" href="#mpmc_channel"><code>mpmc_channel</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/126840">#126840</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="mutex_data_ptr"><a class="header" href="#mutex_data_ptr"><code>mutex_data_ptr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/140368">#140368</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="new_range_api"><a class="header" href="#new_range_api"><code>new_range_api</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/125687">#125687</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="next_index"><a class="header" href="#next_index"><code>next_index</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130711">#130711</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nonpoison_condvar"><a class="header" href="#nonpoison_condvar"><code>nonpoison_condvar</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nonpoison_mutex"><a class="header" href="#nonpoison_mutex"><code>nonpoison_mutex</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nonpoison_rwlock"><a class="header" href="#nonpoison_rwlock"><code>nonpoison_rwlock</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nonzero_bitwise"><a class="header" href="#nonzero_bitwise"><code>nonzero_bitwise</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/128281">#128281</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nonzero_from_mut"><a class="header" href="#nonzero_from_mut"><code>nonzero_from_mut</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/106290">#106290</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nonzero_internals"><a class="header" href="#nonzero_internals"><code>nonzero_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="nonzero_ops"><a class="header" href="#nonzero_ops"><code>nonzero_ops</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/84186">#84186</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="normalize_lexically"><a class="header" href="#normalize_lexically"><code>normalize_lexically</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134694">#134694</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="numfmt"><a class="header" href="#numfmt"><code>numfmt</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="objc_class_variant"><a class="header" href="#objc_class_variant"><code>objc_class_variant</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="objc_selector_variant"><a class="header" href="#objc_selector_variant"><code>objc_selector_variant</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="once_cell_get_mut"><a class="header" href="#once_cell_get_mut"><code>once_cell_get_mut</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121641">#121641</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="once_cell_try"><a class="header" href="#once_cell_try"><code>once_cell_try</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/109737">#109737</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="once_cell_try_insert"><a class="header" href="#once_cell_try_insert"><code>once_cell_try_insert</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/116693">#116693</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="one_sided_range"><a class="header" href="#one_sided_range"><code>one_sided_range</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/69780">#69780</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="oneshot_channel"><a class="header" href="#oneshot_channel"><code>oneshot_channel</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143674">#143674</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="option_array_transpose"><a class="header" href="#option_array_transpose"><code>option_array_transpose</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130828">#130828</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="option_into_flat_iter"><a class="header" href="#option_into_flat_iter"><code>option_into_flat_iter</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148441">#148441</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="option_reduce"><a class="header" href="#option_reduce"><code>option_reduce</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144273">#144273</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="option_reference_flattening"><a class="header" href="#option_reference_flattening"><code>option_reference_flattening</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149221">#149221</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="option_zip"><a class="header" href="#option_zip"><code>option_zip</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/70086">#70086</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="os_str_slice"><a class="header" href="#os_str_slice"><code>os_str_slice</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/118485">#118485</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="os_string_truncate"><a class="header" href="#os_string_truncate"><code>os_string_truncate</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133262">#133262</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_abort"><a class="header" href="#panic_abort"><code>panic_abort</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/32837">#32837</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_always_abort"><a class="header" href="#panic_always_abort"><code>panic_always_abort</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/84438">#84438</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_backtrace_config"><a class="header" href="#panic_backtrace_config"><code>panic_backtrace_config</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93346">#93346</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_can_unwind"><a class="header" href="#panic_can_unwind"><code>panic_can_unwind</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/92988">#92988</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_internals"><a class="header" href="#panic_internals"><code>panic_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_unwind"><a class="header" href="#panic_unwind"><code>panic_unwind</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/32837">#32837</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic_update_hook"><a class="header" href="#panic_update_hook"><code>panic_update_hook</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/92649">#92649</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="partial_ord_chaining_methods"><a class="header" href="#partial_ord_chaining_methods"><code>partial_ord_chaining_methods</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="path_is_empty"><a class="header" href="#path_is_empty"><code>path_is_empty</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148494">#148494</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="path_trailing_sep"><a class="header" href="#path_trailing_sep"><code>path_trailing_sep</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142503">#142503</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern"><a class="header" href="#pattern"><code>pattern</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern_type_macro"><a class="header" href="#pattern_type_macro"><code>pattern_type_macro</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123646">#123646</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern_type_range_trait"><a class="header" href="#pattern_type_range_trait"><code>pattern_type_range_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123646">#123646</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="peer_credentials_unix_socket"><a class="header" href="#peer_credentials_unix_socket"><code>peer_credentials_unix_socket</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/42839">#42839</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="phantom_variance_markers"><a class="header" href="#phantom_variance_markers"><code>phantom_variance_markers</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/135806">#135806</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pin_coerce_unsized_trait"><a class="header" href="#pin_coerce_unsized_trait"><code>pin_coerce_unsized_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150112">#150112</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pin_derefmut_internals"><a class="header" href="#pin_derefmut_internals"><code>pin_derefmut_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pointer_is_aligned_to"><a class="header" href="#pointer_is_aligned_to"><code>pointer_is_aligned_to</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96284">#96284</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pointer_try_cast_aligned"><a class="header" href="#pointer_try_cast_aligned"><code>pointer_try_cast_aligned</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/141221">#141221</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="portable_simd"><a class="header" href="#portable_simd"><code>portable_simd</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/86656">#86656</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="prelude_future"><a class="header" href="#prelude_future"><code>prelude_future</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="prelude_next"><a class="header" href="#prelude_next"><code>prelude_next</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="print_internals"><a class="header" href="#print_internals"><code>print_internals</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_def_site"><a class="header" href="#proc_macro_def_site"><code>proc_macro_def_site</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54724">#54724</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_diagnostic"><a class="header" href="#proc_macro_diagnostic"><code>proc_macro_diagnostic</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54140">#54140</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_expand"><a class="header" href="#proc_macro_expand"><code>proc_macro_expand</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/90765">#90765</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_internals"><a class="header" href="#proc_macro_internals"><code>proc_macro_internals</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27812">#27812</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_quote"><a class="header" href="#proc_macro_quote"><code>proc_macro_quote</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54722">#54722</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_span"><a class="header" href="#proc_macro_span"><code>proc_macro_span</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54725">#54725</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_totokens"><a class="header" href="#proc_macro_totokens"><code>proc_macro_totokens</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130977">#130977</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_tracked_env"><a class="header" href="#proc_macro_tracked_env"><code>proc_macro_tracked_env</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99515">#99515</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_tracked_path"><a class="header" href="#proc_macro_tracked_path"><code>proc_macro_tracked_path</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99515">#99515</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="proc_macro_value"><a class="header" href="#proc_macro_value"><code>proc_macro_value</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136652">#136652</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="process_chroot"><a class="header" href="#process_chroot"><code>process_chroot</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/141298">#141298</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="process_exitcode_internals"><a class="header" href="#process_exitcode_internals"><code>process_exitcode_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="process_internals"><a class="header" href="#process_internals"><code>process_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="process_setsid"><a class="header" href="#process_setsid"><code>process_setsid</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/105376">#105376</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="profiler_runtime_lib"><a class="header" href="#profiler_runtime_lib"><code>profiler_runtime_lib</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="profiling_marker_api"><a class="header" href="#profiling_marker_api"><code>profiling_marker_api</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148197">#148197</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ptr_alignment_type"><a class="header" href="#ptr_alignment_type"><code>ptr_alignment_type</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/102070">#102070</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ptr_as_ref_unchecked"><a class="header" href="#ptr_as_ref_unchecked"><code>ptr_as_ref_unchecked</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/122034">#122034</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ptr_as_uninit"><a class="header" href="#ptr_as_uninit"><code>ptr_as_uninit</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/75402">#75402</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ptr_cast_array"><a class="header" href="#ptr_cast_array"><code>ptr_cast_array</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144514">#144514</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ptr_internals"><a class="header" href="#ptr_internals"><code>ptr_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ptr_mask"><a class="header" href="#ptr_mask"><code>ptr_mask</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/98290">#98290</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ptr_metadata"><a class="header" href="#ptr_metadata"><code>ptr_metadata</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/81513">#81513</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pub_crate_should_not_need_unstable_attr"><a class="header" href="#pub_crate_should_not_need_unstable_attr"><code>pub_crate_should_not_need_unstable_attr</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="push_mut"><a class="header" href="#push_mut"><code>push_mut</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/135974">#135974</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="random"><a class="header" href="#random"><code>random</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130703">#130703</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="range_bounds_is_empty"><a class="header" href="#range_bounds_is_empty"><code>range_bounds_is_empty</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/137300">#137300</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="range_into_bounds"><a class="header" href="#range_into_bounds"><code>range_into_bounds</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136903">#136903</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="raw_os_error_ty"><a class="header" href="#raw_os_error_ty"><code>raw_os_error_ty</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/107792">#107792</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="raw_slice_split"><a class="header" href="#raw_slice_split"><code>raw_slice_split</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/95595">#95595</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="raw_vec_internals"><a class="header" href="#raw_vec_internals"><code>raw_vec_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="read_array"><a class="header" href="#read_array"><code>read_array</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148848">#148848</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="read_buf"><a class="header" href="#read_buf"><code>read_buf</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/78485">#78485</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="read_buf_at"><a class="header" href="#read_buf_at"><code>read_buf_at</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/140771">#140771</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="reentrant_lock"><a class="header" href="#reentrant_lock"><code>reentrant_lock</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121440">#121440</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="reentrant_lock_data_ptr"><a class="header" href="#reentrant_lock_data_ptr"><code>reentrant_lock_data_ptr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/140368">#140368</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="refcell_try_map"><a class="header" href="#refcell_try_map"><code>refcell_try_map</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/143801">#143801</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="restricted_std"><a class="header" href="#restricted_std"><code>restricted_std</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="result_option_map_or_default"><a class="header" href="#result_option_map_or_default"><code>result_option_map_or_default</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/138099">#138099</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rev_into_inner"><a class="header" href="#rev_into_inner"><code>rev_into_inner</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144277">#144277</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rt"><a class="header" href="#rt"><code>rt</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="rwlock_data_ptr"><a class="header" href="#rwlock_data_ptr"><code>rwlock_data_ptr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/140368">#140368</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sealed"><a class="header" href="#sealed"><code>sealed</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="seek_io_take_position"><a class="header" href="#seek_io_take_position"><code>seek_io_take_position</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/97227">#97227</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="seek_stream_len"><a class="header" href="#seek_stream_len"><code>seek_stream_len</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/59359">#59359</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="set_permissions_nofollow"><a class="header" href="#set_permissions_nofollow"><code>set_permissions_nofollow</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/141607">#141607</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="set_ptr_value"><a class="header" href="#set_ptr_value"><code>set_ptr_value</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/75091">#75091</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="setgroups"><a class="header" href="#setgroups"><code>setgroups</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/90747">#90747</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sgx_platform"><a class="header" href="#sgx_platform"><code>sgx_platform</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/56975">#56975</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sized_type_properties"><a class="header" href="#sized_type_properties"><code>sized_type_properties</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_concat_ext"><a class="header" href="#slice_concat_ext"><code>slice_concat_ext</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_concat_trait"><a class="header" href="#slice_concat_trait"><code>slice_concat_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_from_ptr_range"><a class="header" href="#slice_from_ptr_range"><code>slice_from_ptr_range</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89792">#89792</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_index_methods"><a class="header" href="#slice_index_methods"><code>slice_index_methods</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_internals"><a class="header" href="#slice_internals"><code>slice_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_iter_mut_as_mut_slice"><a class="header" href="#slice_iter_mut_as_mut_slice"><code>slice_iter_mut_as_mut_slice</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93079">#93079</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_partial_sort_unstable"><a class="header" href="#slice_partial_sort_unstable"><code>slice_partial_sort_unstable</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149046">#149046</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_partition_dedup"><a class="header" href="#slice_partition_dedup"><code>slice_partition_dedup</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/54279">#54279</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_pattern"><a class="header" href="#slice_pattern"><code>slice_pattern</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/56345">#56345</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_ptr_get"><a class="header" href="#slice_ptr_get"><code>slice_ptr_get</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/74265">#74265</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_range"><a class="header" href="#slice_range"><code>slice_range</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/76393">#76393</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_split_once"><a class="header" href="#slice_split_once"><code>slice_split_once</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/112811">#112811</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="slice_swap_unchecked"><a class="header" href="#slice_swap_unchecked"><code>slice_swap_unchecked</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/88539">#88539</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sliceindex_wrappers"><a class="header" href="#sliceindex_wrappers"><code>sliceindex_wrappers</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146179">#146179</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="smart_pointer_try_map"><a class="header" href="#smart_pointer_try_map"><code>smart_pointer_try_map</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144419">#144419</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="solid_ext"><a class="header" href="#solid_ext"><code>solid_ext</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sort_floats"><a class="header" href="#sort_floats"><code>sort_floats</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/93396">#93396</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="split_array"><a class="header" href="#split_array"><code>split_array</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/90091">#90091</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="split_as_slice"><a class="header" href="#split_as_slice"><code>split_as_slice</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96137">#96137</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="std_internals"><a class="header" href="#std_internals"><code>std_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdarch_aarch64_feature_detection"><a class="header" href="#stdarch_aarch64_feature_detection"><code>stdarch_aarch64_feature_detection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/127764">#127764</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdarch_arm_feature_detection"><a class="header" href="#stdarch_arm_feature_detection"><code>stdarch_arm_feature_detection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111190">#111190</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdarch_internal"><a class="header" href="#stdarch_internal"><code>stdarch_internal</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdarch_loongarch_feature_detection"><a class="header" href="#stdarch_loongarch_feature_detection"><code>stdarch_loongarch_feature_detection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/117425">#117425</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdarch_mips_feature_detection"><a class="header" href="#stdarch_mips_feature_detection"><code>stdarch_mips_feature_detection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111188">#111188</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdarch_powerpc_feature_detection"><a class="header" href="#stdarch_powerpc_feature_detection"><code>stdarch_powerpc_feature_detection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111191">#111191</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdarch_riscv_feature_detection"><a class="header" href="#stdarch_riscv_feature_detection"><code>stdarch_riscv_feature_detection</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111192">#111192</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdio_makes_pipe"><a class="header" href="#stdio_makes_pipe"><code>stdio_makes_pipe</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/98288">#98288</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdio_swap"><a class="header" href="#stdio_swap"><code>stdio_swap</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/150667">#150667</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="step_trait"><a class="header" href="#step_trait"><code>step_trait</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/42168">#42168</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_as_str"><a class="header" href="#str_as_str"><code>str_as_str</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/130366">#130366</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_from_raw_parts"><a class="header" href="#str_from_raw_parts"><code>str_from_raw_parts</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/119206">#119206</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_from_utf16_endian"><a class="header" href="#str_from_utf16_endian"><code>str_from_utf16_endian</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/116258">#116258</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_internals"><a class="header" href="#str_internals"><code>str_internals</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_lines_remainder"><a class="header" href="#str_lines_remainder"><code>str_lines_remainder</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/77998">#77998</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_split_inclusive_remainder"><a class="header" href="#str_split_inclusive_remainder"><code>str_split_inclusive_remainder</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/77998">#77998</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_split_remainder"><a class="header" href="#str_split_remainder"><code>str_split_remainder</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/77998">#77998</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="str_split_whitespace_remainder"><a class="header" href="#str_split_whitespace_remainder"><code>str_split_whitespace_remainder</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/77998">#77998</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="string_from_utf8_lossy_owned"><a class="header" href="#string_from_utf8_lossy_owned"><code>string_from_utf8_lossy_owned</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/129436">#129436</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="string_into_chars"><a class="header" href="#string_into_chars"><code>string_into_chars</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/133125">#133125</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="string_remove_matches"><a class="header" href="#string_remove_matches"><code>string_remove_matches</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/72826">#72826</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="string_replace_in_place"><a class="header" href="#string_replace_in_place"><code>string_replace_in_place</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147949">#147949</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="strip_circumfix"><a class="header" href="#strip_circumfix"><code>strip_circumfix</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147946">#147946</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="substr_range"><a class="header" href="#substr_range"><code>substr_range</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/126769">#126769</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sync_nonpoison"><a class="header" href="#sync_nonpoison"><code>sync_nonpoison</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sync_poison_mod"><a class="header" href="#sync_poison_mod"><code>sync_poison_mod</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/134646">#134646</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="sync_unsafe_cell"><a class="header" href="#sync_unsafe_cell"><code>sync_unsafe_cell</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/95439">#95439</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="tcp_deferaccept"><a class="header" href="#tcp_deferaccept"><code>tcp_deferaccept</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/119639">#119639</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="tcp_linger"><a class="header" href="#tcp_linger"><code>tcp_linger</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/88494">#88494</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="tcplistener_into_incoming"><a class="header" href="#tcplistener_into_incoming"><code>tcplistener_into_incoming</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/88373">#88373</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="temporary_niche_types"><a class="header" href="#temporary_niche_types"><code>temporary_niche_types</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="test"><a class="header" href="#test"><code>test</code></a></h1>
<p>The tracking issue for this feature is: None.</p>
<hr>
<p>The internals of the <code>test</code> crate are unstable, behind the <code>test</code> flag.  The
most widely used part of the <code>test</code> crate are benchmark tests, which can test
the performance of your code.  Let’s make our <code>src/lib.rs</code> look like this
(comments elided):</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;

pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &amp;mut Bencher) {
        b.iter(|| add_two(2));
    }
}
<span class="boring">}</span></code></pre>
<p>Note the <code>test</code> feature gate, which enables this unstable feature.</p>
<p>We’ve imported the <code>test</code> crate, which contains our benchmarking support.
We have a new function as well, with the <code>bench</code> attribute. Unlike regular
tests, which take no arguments, benchmark tests take a <code>&amp;mut Bencher</code>. This
<code>Bencher</code> provides an <code>iter</code> method, which takes a closure. This closure
contains the code we’d like to benchmark.</p>
<p>We can run benchmark tests with <code>cargo bench</code>:</p>
<pre><code class="language-bash">$ cargo bench
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/release/adder-91b3e234d4ed382a

running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured
</code></pre>
<p>Our non-benchmark test was ignored. You may have noticed that <code>cargo bench</code>
takes a bit longer than <code>cargo test</code>. This is because Rust runs our benchmark
a number of times, and then takes the average. Because we’re doing so little
work in this example, we have a <code>1 ns/iter (+/- 0)</code>, but this would show
the variance if there was one.</p>
<p>Advice on writing benchmarks:</p>
<ul>
<li>Move setup code outside the <code>iter</code> loop; only put the part you want to measure inside</li>
<li>Make the code do “the same thing” on each iteration; do not accumulate or change state</li>
<li>Make the outer function idempotent too; the benchmark runner is likely to run
it many times</li>
<li>Make the inner <code>iter</code> loop short and fast so benchmark runs are fast and the
calibrator can adjust the run-length at fine resolution</li>
<li>Make the code in the <code>iter</code> loop do something simple, to assist in pinpointing
performance improvements (or regressions)</li>
</ul>
<h2 id="gotcha-optimizations"><a class="header" href="#gotcha-optimizations">Gotcha: optimizations</a></h2>
<p>There’s another tricky part to writing benchmarks: benchmarks compiled with
optimizations activated can be dramatically changed by the optimizer so that
the benchmark is no longer benchmarking what one expects. For example, the
compiler might recognize that some calculation has no external effects and
remove it entirely.</p>
<pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;
use test::Bencher;

#[bench]
fn bench_xor_1000_ints(b: &amp;mut Bencher) {
    b.iter(|| {
        (0..1000).fold(0, |old, new| old ^ new);
    });
}
<span class="boring">}</span></code></pre>
<p>gives the following results</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>The benchmarking runner offers two ways to avoid this. Either, the closure that
the <code>iter</code> method receives can return an arbitrary value which forces the
optimizer to consider the result used and ensures it cannot remove the
computation entirely. This could be done for the example above by adjusting the
<code>b.iter</code> call to</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct X;
</span><span class="boring">impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
</span>b.iter(|| {
    // Note lack of `;` (could also use an explicit `return`).
    (0..1000).fold(0, |old, new| old ^ new)
});
<span class="boring">}</span></code></pre>
<p>Or, the other option is to call the generic <code>test::black_box</code> function, which
is an opaque “black box” to the optimizer and so forces it to consider any
argument as used.</p>
<pre class="playground"><code class="language-rust">#![feature(test)]

extern crate test;

<span class="boring">fn main() {
</span><span class="boring">struct X;
</span><span class="boring">impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
</span>b.iter(|| {
    let n = test::black_box(1000);

    (0..n).fold(0, |a, b| a ^ b)
})
<span class="boring">}</span></code></pre>
<p>Neither of these read or modify the value, and are very cheap for small values.
Larger values can be passed indirectly to reduce overhead (e.g.
<code>black_box(&amp;huge_struct)</code>).</p>
<p>Performing either of the above changes gives the following benchmarking results</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>However, the optimizer can still modify a testcase in an undesirable manner
even when using either of the above.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="thin_box"><a class="header" href="#thin_box"><code>thin_box</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/92791">#92791</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="thread_id_value"><a class="header" href="#thread_id_value"><code>thread_id_value</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/67939">#67939</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="thread_local_internals"><a class="header" href="#thread_local_internals"><code>thread_local_internals</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="thread_raw"><a class="header" href="#thread_raw"><code>thread_raw</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/97523">#97523</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="thread_sleep_until"><a class="header" href="#thread_sleep_until"><code>thread_sleep_until</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/113752">#113752</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="thread_spawn_hook"><a class="header" href="#thread_spawn_hook"><code>thread_spawn_hook</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/132951">#132951</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="time_saturating_systemtime"><a class="header" href="#time_saturating_systemtime"><code>time_saturating_systemtime</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/151199">#151199</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="time_systemtime_limits"><a class="header" href="#time_systemtime_limits"><code>time_systemtime_limits</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149067">#149067</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trace_macros"><a class="header" href="#trace_macros"><code>trace_macros</code></a></h1>
<p>The tracking issue for this feature is <a href="https://github.com/rust-lang/rust/issues/29598">#29598</a>.</p>
<hr>
<p>With <code>trace_macros</code> you can trace the expansion of macros in your code.</p>
<h2 id="examples-15"><a class="header" href="#examples-15">Examples</a></h2>
<pre class="playground"><code class="language-rust">#![feature(trace_macros)]

fn main() {
    trace_macros!(true);
    println!("Hello, Rust!");
    trace_macros!(false);
}</code></pre>
<p>The <code>cargo build</code> output:</p>
<pre><code class="language-txt">note: trace_macro
 --&gt; src/main.rs:5:5
  |
5 |     println!("Hello, Rust!");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: expanding `println! { "Hello, Rust!" }`
  = note: to `print ! ( concat ! ( "Hello, Rust!" , "\n" ) )`
  = note: expanding `print! { concat ! ( "Hello, Rust!" , "\n" ) }`
  = note: to `$crate :: io :: _print ( format_args ! ( concat ! ( "Hello, Rust!" , "\n" ) )
          )`

    Finished dev [unoptimized + debuginfo] target(s) in 0.60 secs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transmutability"><a class="header" href="#transmutability"><code>transmutability</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/99571">#99571</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trim_prefix_suffix"><a class="header" href="#trim_prefix_suffix"><code>trim_prefix_suffix</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142312">#142312</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trivial_clone"><a class="header" href="#trivial_clone"><code>trivial_clone</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trusted_fused"><a class="header" href="#trusted_fused"><code>trusted_fused</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trusted_len"><a class="header" href="#trusted_len"><code>trusted_len</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/37572">#37572</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trusted_len_next_unchecked"><a class="header" href="#trusted_len_next_unchecked"><code>trusted_len_next_unchecked</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/37572">#37572</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trusted_random_access"><a class="header" href="#trusted_random_access"><code>trusted_random_access</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="trusted_step"><a class="header" href="#trusted_step"><code>trusted_step</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/85731">#85731</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_as_dyn"><a class="header" href="#try_as_dyn"><code>try_as_dyn</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/144361">#144361</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_find"><a class="header" href="#try_find"><code>try_find</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/63178">#63178</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_reserve_kind"><a class="header" href="#try_reserve_kind"><code>try_reserve_kind</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/48043">#48043</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_trait_v2"><a class="header" href="#try_trait_v2"><code>try_trait_v2</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/84277">#84277</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_trait_v2_residual"><a class="header" href="#try_trait_v2_residual"><code>try_trait_v2_residual</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/91285">#91285</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_trait_v2_yeet"><a class="header" href="#try_trait_v2_yeet"><code>try_trait_v2_yeet</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96374">#96374</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="try_with_capacity"><a class="header" href="#try_with_capacity"><code>try_with_capacity</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/91913">#91913</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="tuple_trait"><a class="header" href="#tuple_trait"><code>tuple_trait</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="type_ascription"><a class="header" href="#type_ascription"><code>type_ascription</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/23416">#23416</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="type_info"><a class="header" href="#type_info"><code>type_info</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146922">#146922</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ub_checks"><a class="header" href="#ub_checks"><code>ub_checks</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="uefi_std"><a class="header" href="#uefi_std"><code>uefi_std</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/100499">#100499</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="uint_bit_width"><a class="header" href="#uint_bit_width"><code>uint_bit_width</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142326">#142326</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="uint_gather_scatter_bits"><a class="header" href="#uint_gather_scatter_bits"><code>uint_gather_scatter_bits</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149069">#149069</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unicode_internals"><a class="header" href="#unicode_internals"><code>unicode_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unique_rc_arc"><a class="header" href="#unique_rc_arc"><code>unique_rc_arc</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/112566">#112566</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unix_file_vectored_at"><a class="header" href="#unix_file_vectored_at"><code>unix_file_vectored_at</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/89517">#89517</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unix_mkfifo"><a class="header" href="#unix_mkfifo"><code>unix_mkfifo</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/139324">#139324</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unix_send_signal"><a class="header" href="#unix_send_signal"><code>unix_send_signal</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/141975">#141975</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unix_set_mark"><a class="header" href="#unix_set_mark"><code>unix_set_mark</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96467">#96467</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unix_socket_ancillary_data"><a class="header" href="#unix_socket_ancillary_data"><code>unix_socket_ancillary_data</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/76915">#76915</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unix_socket_exclbind"><a class="header" href="#unix_socket_exclbind"><code>unix_socket_exclbind</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123481">#123481</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unix_socket_peek"><a class="header" href="#unix_socket_peek"><code>unix_socket_peek</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/76923">#76923</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsafe_cell_access"><a class="header" href="#unsafe_cell_access"><code>unsafe_cell_access</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/136327">#136327</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsafe_pinned"><a class="header" href="#unsafe_pinned"><code>unsafe_pinned</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/125735">#125735</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsize"><a class="header" href="#unsize"><code>unsize</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/18598">#18598</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="unwrap_infallible"><a class="header" href="#unwrap_infallible"><code>unwrap_infallible</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/61695">#61695</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="update_panic_count"><a class="header" href="#update_panic_count"><code>update_panic_count</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="utf16_extra"><a class="header" href="#utf16_extra"><code>utf16_extra</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/94919">#94919</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="variant_count"><a class="header" href="#variant_count"><code>variant_count</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/73662">#73662</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_deque_extract_if"><a class="header" href="#vec_deque_extract_if"><code>vec_deque_extract_if</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/147750">#147750</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_deque_iter_as_slices"><a class="header" href="#vec_deque_iter_as_slices"><code>vec_deque_iter_as_slices</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/123947">#123947</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_deque_truncate_front"><a class="header" href="#vec_deque_truncate_front"><code>vec_deque_truncate_front</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/140667">#140667</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_from_fn"><a class="header" href="#vec_from_fn"><code>vec_from_fn</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149698">#149698</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_into_chunks"><a class="header" href="#vec_into_chunks"><code>vec_into_chunks</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/142137">#142137</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_peek_mut"><a class="header" href="#vec_peek_mut"><code>vec_peek_mut</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/122742">#122742</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_push_within_capacity"><a class="header" href="#vec_push_within_capacity"><code>vec_push_within_capacity</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/100486">#100486</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_recycle"><a class="header" href="#vec_recycle"><code>vec_recycle</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148227">#148227</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_split_at_spare"><a class="header" href="#vec_split_at_spare"><code>vec_split_at_spare</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/81944">#81944</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="vec_try_remove"><a class="header" href="#vec_try_remove"><code>vec_try_remove</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146954">#146954</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="waker_fn"><a class="header" href="#waker_fn"><code>waker_fn</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149580">#149580</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="waker_from_fn_ptr"><a class="header" href="#waker_from_fn_ptr"><code>waker_from_fn_ptr</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/148457">#148457</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="wasi_ext"><a class="header" href="#wasi_ext"><code>wasi_ext</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/71213">#71213</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_by_handle"><a class="header" href="#windows_by_handle"><code>windows_by_handle</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/63010">#63010</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_c"><a class="header" href="#windows_c"><code>windows_c</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_change_time"><a class="header" href="#windows_change_time"><code>windows_change_time</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/121478">#121478</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_freeze_file_times"><a class="header" href="#windows_freeze_file_times"><code>windows_freeze_file_times</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/149715">#149715</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_handle"><a class="header" href="#windows_handle"><code>windows_handle</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_net"><a class="header" href="#windows_net"><code>windows_net</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_exit_code_from"><a class="header" href="#windows_process_exit_code_from"><code>windows_process_exit_code_from</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/111688">#111688</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_extensions_async_pipes"><a class="header" href="#windows_process_extensions_async_pipes"><code>windows_process_extensions_async_pipes</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/98289">#98289</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_extensions_force_quotes"><a class="header" href="#windows_process_extensions_force_quotes"><code>windows_process_extensions_force_quotes</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/82227">#82227</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_extensions_inherit_handles"><a class="header" href="#windows_process_extensions_inherit_handles"><code>windows_process_extensions_inherit_handles</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/146407">#146407</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_extensions_main_thread_handle"><a class="header" href="#windows_process_extensions_main_thread_handle"><code>windows_process_extensions_main_thread_handle</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/96723">#96723</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_extensions_raw_attribute"><a class="header" href="#windows_process_extensions_raw_attribute"><code>windows_process_extensions_raw_attribute</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/114854">#114854</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_extensions_show_window"><a class="header" href="#windows_process_extensions_show_window"><code>windows_process_extensions_show_window</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/127544">#127544</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_process_extensions_startupinfo"><a class="header" href="#windows_process_extensions_startupinfo"><code>windows_process_extensions_startupinfo</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/141010">#141010</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows_stdio"><a class="header" href="#windows_stdio"><code>windows_stdio</code></a></h1>
<p>This feature is internal to the Rust compiler and is not intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="wrapping_int_impl"><a class="header" href="#wrapping_int_impl"><code>wrapping_int_impl</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/32463">#32463</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="wrapping_next_power_of_two"><a class="header" href="#wrapping_next_power_of_two"><code>wrapping_next_power_of_two</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/32463">#32463</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="write_all_vectored"><a class="header" href="#write_all_vectored"><code>write_all_vectored</code></a></h1>
<p>The tracking issue for this feature is: <a href="https://github.com/rust-lang/rust/issues/70436">#70436</a></p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="wtf8_internals"><a class="header" href="#wtf8_internals"><code>wtf8_internals</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="yeet_desugar_details"><a class="header" href="#yeet_desugar_details"><code>yeet_desugar_details</code></a></h1>
<p>This feature has no tracking issue, and is therefore likely internal to the compiler, not being intended for general use.</p>
<hr>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
