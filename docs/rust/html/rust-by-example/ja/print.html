<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Example</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                const mdbookPath = "print.md";
                const mdbookPathToRoot = "";
                const rightButtonsElement = document.querySelector('.right-buttons');
                rightButtonsElement.insertAdjacentHTML("afterbegin", `
                    <button id="language-toggle" class="icon-button" type="button"
                            title="Change language" aria-label="Change language"
                            aria-haspopup="true" aria-expanded="false"
                            aria-controls="language-list">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M352 256c0 22.2-1.2 43.6-3.3 64H163.3c-2.2-20.4-3.3-41.8-3.3-64s1.2-43.6 3.3-64H348.7c2.2 20.4 3.3 41.8 3.3 64zm28.8-64H503.9c5.3 20.5 8.1 41.9 8.1 64s-2.8 43.5-8.1 64H380.8c2.1-20.6 3.2-42 3.2-64s-1.1-43.4-3.2-64zm112.6-32H376.7c-10-63.9-29.8-117.4-55.3-151.6c78.3 20.7 142 77.5 171.9 151.6zm-149.1 0H167.7c6.1-36.4 15.5-68.6 27-94.7c10.5-23.6 22.2-40.7 33.5-51.5C239.4 3.2 248.7 0 256 0s16.6 3.2 27.8 13.8c11.3 10.8 23 27.9 33.5 51.5c11.6 26 21 58.2 27 94.7zm-209 0H18.6C48.6 85.9 112.2 29.1 190.6 8.4C165.1 42.6 145.3 96.1 135.3 160zM8.1 192H131.2c-2.1 20.6-3.2 42-3.2 64s1.1 43.4 3.2 64H8.1C2.8 299.5 0 278.1 0 256s2.8-43.5 8.1-64zM194.7 446.6c-11.6-26-20.9-58.2-27-94.6H344.3c-6.1 36.4-15.5 68.6-27 94.6c-10.5 23.6-22.2 40.7-33.5 51.5C272.6 508.8 263.3 512 256 512s-16.6-3.2-27.8-13.8c-11.3-10.8-23-27.9-33.5-51.5zM135.3 352c10 63.9 29.8 117.4 55.3 151.6C112.2 482.9 48.6 426.1 18.6 352H135.3zm358.1 0c-30 74.1-93.6 130.9-171.9 151.6c25.5-34.2 45.2-87.7 55.3-151.6H493.4z"/></svg></span>
                    </button>
                    <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                      <li role="none"><button role="menuitem" class="theme">
                          <a id="en">English</a>
                      </button></li>
                      <li role="none"><button role="menuitem" class="theme">
                          <a id="ja">日本語</a>
                      </button></li>
                      <li role="none"><button role="menuitem" class="theme">
                          <a id="zh">中文</a>
                      </button></li>
                      <li role="none"><button role="menuitem" class="theme">
                          <a id="es">Español</a>
                      </button></li>
                      <li role="none"><button role="menuitem" class="theme">
                          <a id="ko">한국어</a>
                      </button></li>
                    </ul>
                `);
        
                const language = document.documentElement.getAttribute("lang");
                let langToggle = document.getElementById("language-toggle");
                let langList = document.getElementById("language-list");
                langToggle.addEventListener("click", (event) => {
                    langList.style.display =
                        langList.style.display == "block" ? "none" : "block";
                });
                let selectedLang = document.getElementById(language);
                if (selectedLang) {
                    selectedLang.parentNode.classList.add("theme-selected");
                }
        
                // The path to the root, taking the current language into account.
                let full_path_to_root =
                    language == "en" ? `${mdbookPathToRoot}` : `${mdbookPathToRoot}../`;
                // The page path (mdbook only gives us access to the path to the Markdown file).
                let path = mdbookPath.replace(/\.md$/, ".html");
                const langAnchors = Array.from(langList.querySelectorAll("a"));
                for (let lang of langAnchors) {
                    if (lang.id == "en") {
                        lang.href = `${full_path_to_root}${path}`;
                    } else {
                        lang.href = `${full_path_to_root}${lang.id}/${path}`;
                    }
                }
        
                // Hide languages whose target page is not available (e.g., not deployed).
                // This prevents users from hitting 404s on sites that only ship some locales.
                for (let lang of langAnchors) {
                    const url = lang.href;
                    // Attempt a lightweight HEAD request; fall back to hiding on failure.
                    fetch(url, { method: "HEAD" }).then((resp) => {
                        if (!resp.ok) {
                            const li = lang.parentNode && lang.parentNode.parentNode;
                            if (li) li.style.display = "none";
                        }
                    }).catch(() => {
                        const li = lang.parentNode && lang.parentNode.parentNode;
                        if (li) li.style.display = "none";
                    });
                }
            });
        </script>

        <meta name="description" content="Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust concepts and standard libraries.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/language-picker-2070e7fe.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-8c1736ca.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-5df99dd2.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/rust-by-example" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="rust-by-example"><a class="header" href="#rust-by-example">Rust by Example</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> は安全性、速度、並列性にフォーカスした現代的なシステムプログラミング用のプログラミング言語です。ガベージコレクション無しでメモリ安全であることが、これを可能にしています。</p>
<p>Rust by Example(RBE)はRustの実行可能なサンプルスクリプト集で、ここではRustの様々なコンセプトと標準ライブラリを紹介していきます。この例をより活用するためには<a href="https://www.rust-lang.org/tools/install">Rustをローカルにインストール</a>し、<a href="https://doc.rust-lang.org/std/">公式ドキュメント</a>をチェックすることをおすすめします。興味がある方は<a href="https://github.com/rust-lang/rust-by-example">このサイト自体のソース</a>のチェックもどうぞ。</p>
<p>それでははじめましょう!</p>
<ul>
<li>
<p><a href="#hello-world">Hello World</a> - お決まりのHello Worldプログラムから始めましょう。</p>
</li>
<li>
<p><a href="#基本データ型">基本データ型</a> - 符号付き整数や符号無し整数、その他の基本データ型について学びましょう。</p>
</li>
<li>
<p><a href="#カスタム型">カスタム型</a> - <code>struct</code>と<code>enum</code>について。</p>
</li>
<li>
<p><a href="#変数束縛">変数の束縛</a> - ミュータブルな束縛、スコープ、シャドーイングについて。</p>
</li>
<li>
<p><a href="#型">型</a> - 型を変更したり定義したりすることを学びましょう。</p>
</li>
<li>
<p><a href="#型変換">型変換</a> - 文字列や整数、浮動小数点数など様々な型から型への変換について。</p>
</li>
<li>
<p><a href="#式">式</a> - 式とその使い方について学びましょう。</p>
</li>
<li>
<p><a href="#制御フロー">制御フロー</a> - <code>if</code>や<code>else</code>、<code>for</code>など。</p>
</li>
<li>
<p><a href="#関数">関数</a> - メソッド、クロージャ、高階関数について。</p>
</li>
<li>
<p><a href="#モジュール">モジュール</a> - プログラムをモジュールを使って整理しましょう。</p>
</li>
<li>
<p><a href="#クレート">クレート</a> - クレートは、Rustにおいてコンパイルされる単位です。ライブラリの作り方について学びます。</p>
</li>
<li>
<p><a href="#cargo">Cargo</a> - Rustの公式パッケージマネージャの基本的な機能を学びます。</p>
</li>
<li>
<p><a href="#アトリビュート">アトリビュート</a> - アトリビュートは、モジュールやクレート、要素に適用されるメタデータです。</p>
</li>
<li>
<p><a href="#ジェネリクス">ジェネリクス</a> - 様々な型の引数を取れる関数やデータ型を書く方法を学びましょう。</p>
</li>
<li>
<p><a href="#スコープの規則">スコープの規則</a> - スコープは所有権、借用、ライフタイムにおいて重要な役割を果たします。</p>
</li>
<li>
<p><a href="#トレイト-2">トレイト</a> - トレイトとは、未知の型<code>Self</code>に対して定義された一連のメソッドです。</p>
</li>
<li>
<p><a href="#macro_rules">マクロ</a> - マクロはコードを書くためのコードです。メタプログラミングとしても知られています。</p>
</li>
<li>
<p><a href="#エラーハンドリング">エラーハンドリング</a> - 失敗に対処するRust流のやり方を学びましょう。</p>
</li>
<li>
<p><a href="#標準ライブラリの型">標準ライブラリの型</a> - <code>std</code>ライブラリによって提供されるいくつかのカスタム型について学びます。</p>
</li>
<li>
<p><a href="#標準ライブラリのその他">標準ライブラリのその他</a> - ファイルハンドリングとスレッドのためのカスタム型について。</p>
</li>
<li>
<p><a href="#テスト-1">テスト</a> - Rustにおけるテストのすべて。</p>
</li>
<li>
<p><a href="#安全でない操作">安全でない操作</a> - 安全でない操作について学びましょう。</p>
</li>
<li>
<p><a href="#互換性">互換性</a> - Rustの進化と互換性について。</p>
</li>
<li>
<p><a href="#周辺情報">周辺情報</a> - ドキュメント、ベンチマークの方法。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>ここでは伝統的な “Hello World!” プログラムのソースを紹介します。</p>
<pre class="playground"><code class="language-rust editable edition2021">// これはコメントです。コンパイラによって無視されます。
// 右にある「Run」ボタンからこのコードをテストできます。
// キーボードを使いたければ「Ctrl + Enter」もOKです。

// このコードは編集可能です。ぜひハックしてみましょう！
// 「Reset」ボタンでいつでも元のコードに戻すことができます -&gt;

// main関数です。
fn main() {
    // コンパイルされたバイナリが実行されるとこの関数が呼び出されます。

    // コンソールに文字列を出力します。
    println!("Hello World!");
}</code></pre>
<p><code>println!</code>は文字列をコンソールに出力するための<a href="#macro_rules"> <em>マクロ</em> </a>です。</p>
<p>バイナリファイルは<code>rustc</code>と呼ばれるRustコンパイラを用いて生成することができます。</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<p>すると<code>hello</code>という名前の実行可能なバイナリファイルができます。</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<h3 id="演習"><a class="header" href="#演習">演習</a></h3>
<p>上に書いている ‘Run’ をクリックしてアウトプットを見てみましょう。次に、<code>println!</code>マクロをもう一行追加してアウトプットがどうなるか見てみましょう。</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="コメント"><a class="header" href="#コメント">コメント</a></h1>
<p>あらゆるプログラムにはコメントが必要です。Rustには何種類かのコメントがあります</p>
<h2 id="regular-comments"><a class="header" href="#regular-comments">Regular Comments</a></h2>
<p>These are ignored by the compiler:</p>
<ul>
<li><strong>Line comments</strong>: Start with <code>//</code> and continue to the end of the line</li>
<li><strong>Block comments</strong>: Enclosed in <code>/* ... */</code> and can span multiple lines</li>
</ul>
<h2 id="documentation-comments-doc-comments-which-are-parsed-into-html-library-documentation"><a class="header" href="#documentation-comments-doc-comments-which-are-parsed-into-html-library-documentation">Documentation Comments (Doc Comments) which are parsed into HTML library <a href="#ドキュメンテーション">documentation</a>:</a></h2>
<ul>
<li><code>///</code> - Generates docs for the item that follows it</li>
<li><code>//!</code> - Generates docs for the enclosing item (typically used at the top of a file or module)</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // Line comments start with two slashes.
    // Everything after the slashes is ignored by the compiler.

    // Example: This line won't execute
    // println!("Hello, world!");

    // Try removing the slashes above and running the code again.

    /*
     * Block comments are useful for temporarily disabling code.
     * They can also be nested: /* like this */ which makes it easy
     * to comment out large sections quickly.
     */

    /*
    Note: The asterisk column on the left is just for style - 
    it's not required by the language.
    */

    // Block comments make it easy to toggle code on/off by adding
    // or removing just one slash:

    /* &lt;- Add a '/' here to uncomment the entire block below

    println!("Now");
    println!("everything");
    println!("executes!");
    // Line comments inside remain unaffected

    // */

    // Block comments can also be used within expressions:
    let x = 5 + /* 90 + */ 5;
    println!("Is `x` 10 or 100? x = {}", x);
}</code></pre>
<h3 id="参照"><a class="header" href="#参照">参照</a></h3>
<p><a href="#ドキュメンテーション">ライブラリドキュメンテーション</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="フォーマットして出力"><a class="header" href="#フォーマットして出力">フォーマットして出力</a></h1>
<p>Printing is handled by a series of <a href="#macro_rules"><code>macros</code></a> defined in <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> some of which are:</p>
<ul>
<li><code>format!</code>：フォーマットされたテキストを<a href="#文字列"><code>String</code></a>に書き込みます。</li>
<li><code>print!</code>：<code>format!</code>と同様ですが、コンソール (io::stdout) にそのテキストを出力します。</li>
<li><code>println!</code>：<code>print!</code>と同じですが改行が付け加えられます。</li>
<li><code>eprint!</code>：<code>format!</code>と同様ですが、標準エラー出力 (io::stderr) にそのテキストを出力します。</li>
<li><code>eprintln!</code>：<code>eprint!</code>と同じですが改行が付け加えられます。</li>
</ul>
<p>すべて同じやり方でテキストをパースし、正しくフォーマットできるかコンパイル時にチェックします。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 一般的に`{}`はどんな引数であろうと自動的に置き換えられます。
    // 例えば以下は文字列に変換されます。
    println!("{} days", 31);

    // 位置引数を利用できます。
    // `{}`の内側に整数を指定することで、どの引数で置換されるかが決まります。
    // 引数は0から始まります。
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");

    // 名前での指定も可能です。
    println!("{subject} {verb} {object}",
             object="the lazy dog",
             subject="the quick brown fox",
             verb="jumps over");

    // `:`のあとにフォーマット文字を指定して
    // 異なるフォーマットにすることも可能です。
    println!("Base 10:               {}",   69420); // 69420
    println!("Base 2 (binary):       {:b}", 69420); // 10000111100101100
    println!("Base 8 (octal):        {:o}", 69420); // 207454
    println!("Base 16 (hexadecimal): {:x}", 69420); // 10f2c

    // 特定の幅に右詰めすることもできます。この出力は "    1" になります。
    // （4つの空白と"1"で合計幅は5です）
    println!("{number:&gt;5}", number=1);

    // 数字を0埋めすることもできます。
    println!("{number:0&gt;5}", number=1); // 00001
    // 記号を反対にすると左寄せになり、"10000"が出力されます。
    println!("{number:0&lt;5}", number=1); // 10000

    // フォーマット指定子の中に`$`をつけることで名前付き引数を利用できます。
    println!("{number:0&gt;width$}", number=1, width=5);

    // 引数の数が正しいかのチェックも行ってくれます。
    println!("My name is {0}, {1} {0}", "Bond");
    // FIXME ^ 不足している引数 "James" を追加しましょう。

    // `{}`でフォーマットできるのは、fmt::Displayを実装している型のみです。
    // ユーザーが定義した型はデフォルトではfmt::Displayを実装していません。

    #[allow(dead_code)] // 未使用モジュールを警告する`dead_code`を無効化。
    struct Structure(i32);

    // `Structure`はfmt::Displayを実装していないので、
    // 以下はコンパイルできません。
    // println!("This struct `{}` won't print...", Structure(3));
    // TODO ^ この行をアンコメントしてみましょう。

    // Rust 1.58以上では、周囲の変数から直接引数に取ることができます。
    // 上で見たように、以下のコードは4つのスペースと1を、"    1" と出力します。
    let number: f64 = 1.0;
    let width: usize = 5;
    println!("{number:&gt;width$}");
}</code></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>はいくつもの<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">トレイト</a>を持ち、それによってどのようにディスプレイに表示されるかが決まります。特に大事な形式は以下の2つです。</p>
<ul>
<li><code>fmt::Debug</code>：<code>{:?}</code>というマーカーを使用し、デバッグ目的に使われます。</li>
<li><code>fmt::Display</code>：<code>{}</code>というマーカーを使用し、より美しく、ユーザフレンドリーに表示します。</li>
</ul>
<p>この例で用いられている型は、標準ライブラリに含まれているため、ここでは<code>fmt::Display</code>を使用しています。カスタム型をテキストとして表示する場合は、さらに手順が必要です。</p>
<p><code>fmt::Display</code>トレイトを実装すると、自動的に<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>トレイトが実装されます。これにより<a href="#文字列"><code>String</code></a>型への<a href="#stringとの型変換">型変換</a>ができるようになります。</p>
<p><em>43行目</em> の<code>#[allow(dead_code)]</code>は、直後のモジュールにのみ適用される<a href="#アトリビュート">アトリビュート</a>です。</p>
<h3 id="演習-1"><a class="header" href="#演習-1">演習</a></h3>
<ul>
<li>上の例（FIXME を参照）を実行した際に生じるエラーを修復しましょう。</li>
<li><code>Structure</code>構造体をフォーマットする行をアンコメントしてみましょう。（TODO を参照）</li>
<li><code>println!</code>マクロを追加し、表示される小数部の桁数を調整して<code>Pi is roughly 3.142</code>という文字列を出力しましょう。ただし、円周率の値は<code>let pi = 3.141592</code>を使ってください。（ヒント：小数部の桁数を調整する方法については、<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>をチェックする必要があるかもしれません。）</li>
</ul>
<h3 id="参照-1"><a class="header" href="#参照-1">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="#macro_rules">マクロ</a>, <a href="#構造体">構造体</a>, <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">トレイト</a>, <a href="#dead_code"><code>dead_code</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p><code>std::fmt</code>のフォーマット用<code>トレイト</code>を使用したい型は、出力できるように実装されている必要があります。<code>std</code>ライブラリの型のように自動で出力可能なものもありますが、他はすべて <em>手動で実装する必要があります。</em></p>
<p><code>fmt::Debug</code>という<code>トレイト</code>はこれを簡略化します。 <em>すべての</em> 型は<code>fmt::Debug</code>の実装を<code>導出(derive)</code>、（すなわち自動で作成）することができるためです。<code>fmt::Display</code>の場合はやはり手動で実装しなくてはなりません。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// この構造体は`fmt::Display`、`fmt::Debug`のいずれによっても
// 出力することができません。
struct UnPrintable(i32);

// `derive`アトリビュートは、
// この構造体を`fmt::Debug`で出力するための実装を自動で提供します。
#[derive(Debug)]
struct DebugPrintable(i32);
<span class="boring">}</span></code></pre>
<p><code>std</code>ライブラリの型の場合は、自動的に<code>{:?}</code>により出力可能になっています。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `Structure`という構造体のための`fmt::Debug`を導出しています。
// `Structure`は単一の`i32`をメンバに持っています。
#[derive(Debug)]
struct Structure(i32);

// `Deep`という構造体の中に`Structure`を入れ、これを出力可能にしています。
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // `{:?}`による出力は`{}`に似ています。
    println!("{:?} months in a year.", 12);
    println!("{1:?} {0:?} is the {actor:?} name.",
             "Slater",
             "Christian",
             actor="actor's");

    // `Structure`は出力可能です！
    println!("Now {:?} will print!", Structure(3));

    // `derive`を用いることの問題は、結果がどのように見えるか
    // コントロールする方法がないことです。
    // 出力を`7`だけにするためにはどうしたらよいでしょう？
    println!("Now {:?} will print!", Deep(Structure(7)));
}</code></pre>
<p><code>fmt::Debug</code>は確実に出力可能にしてくれるのですが、一方である種の美しさを犠牲にしています。Rustは<code>{:#?}</code>による「見栄えの良い出力」も提供します。</p>
<pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = "Peter";
    let age = 27;
    let peter = Person { name, age };

    // 見栄えのよい出力
    println!("{:#?}", peter);
}</code></pre>
<p>手動で<code>fmt::Display</code>を実装することで出力結果を思い通りにできます。</p>
<h3 id="参照-2"><a class="header" href="#参照-2">参照</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html">アトリビュート</a>, <a href="#導出derive"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="#構造体">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="display"><a class="header" href="#display">Display</a></h1>
<p><code>fmt::Debug</code>はコンパクトでクリーンであるようには見えませんね。大抵の場合は、アウトプットの見た目をカスタマイズしたほうが好ましいでしょう。これは<code>{}</code>を使用する<a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a>を手動で実装することで可能です。実装はこのようになります。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// （`use`を使用し、）`fmt`モジュールをインポートします。
use std::fmt;

// `fmt::Display`を実装するための構造体を定義します。
// これは`Structure`と名付けられた、`i32`を含むタプル構造体です。
struct Structure(i32);

// `{}` というマーカーを使用するためには、
// この型専用の`fmt::Display`というトレイトが実装されていなくてはなりません。
impl fmt::Display for Structure {
    // このトレイトは`fmt`が正確にこの通りのシグネチャであることを要求します。
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 最初の要素だけを、与えられた出力ストリーム`f`に書き込みます。
        // 操作が成功したかどうかを表す`fmt::Result`を返します。
        // `write!`は`println!`に非常によく似た文法を使用していることに注目。
        write!(f, "{}", self.0)
    }
}
<span class="boring">}</span></code></pre>
<p><code>fmt::Display</code>は<code>fmt::Debug</code>より綺麗かもしれませんが、<code>std</code>ライブラリの場合は問題が生じます。曖昧な型はどのように表示すれば良いでしょう？例えば、<code>std</code>ライブラリがあらゆる<code>Vec&lt;T&gt;</code>に対して単一のスタイルを提供していた場合、どのようなスタイルに整形すればよいでしょう？以下の2つのどちらかを選ぶべきでしょうか？</p>
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> （<code>:</code>で分割）</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> （<code>,</code>で分割）</li>
</ul>
<p>答えはNOです。あらゆる型に対して理想的なスタイルなどというものはありませんし、<code>std</code>ライブラリによってそれが提供されているわけでもありません。<code>fmt::Display</code>は<code>Vec&lt;T&gt;</code>のようなジェネリックなコンテナ用に定義されているわけではありませんので、このような場合は<code>fmt::Debug</code>を使用するべきです。</p>
<p>ジェネリック <em>でない</em> コンテナ型の場合は、このような問題は生じませんので問題なく<code>fmt::Display</code>を実装することができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt; // `fmt`のインポート

// 2つの数字を扱うための構造体です。出力を`Display`と比較するため`Debug`
// を導出しています。
#[derive(Debug)]
struct MinMax(i64, i64);

// `MinMax`用の`Display`を実装しています。
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // `self.number`でそれぞれのデータポイントを参照できます。
        write!(f, "({}, {})", self.0, self.1)
    }
}

// 比較のため、フィールドに名前をつけられる様な構造体を定義しましょう。
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// 先程と同様にして、`Point2D`用の`Display`を実装しています。
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // `x`と`y`のみが明示的になるようにカスタマイズ。
        write!(f, "x: {}, y: {}", self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!("Compare structures:");
    println!("Display: {}", minmax);
    println!("Debug: {:?}", minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!("The big range is {big} and the small is {small}",
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!("Compare points:");
    println!("Display: {}", point);
    println!("Debug: {:?}", point);

    // `Debug`と`Display`は実装されていますが、`fmt::Binary`はされていないため
    // `{:b}`使用している以下の例はエラーになります。
    // println!("What does Point2D look like in binary: {:b}?", point);
}</code></pre>
<p><code>fmt::Display</code>は実装されていますが、<code>fmt::Binary</code>はされていないので使用できません。<code>std::fmt</code>にはそのような<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">トレイト</a>が数多くあり、それぞれに独自の実装が必要です。詳しくは<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>を参照してください。</p>
<h3 id="演習-2"><a class="header" href="#演習-2">演習</a></h3>
<p>上記の例のアウトプットを確認し、<code>Point2D</code>構造体を参考として、複素数を格納するための<code>Complex</code>構造体を定義しましょう。うまく行けば以下のように出力されるはずです。</p>
<pre><code class="language-txt">Display: 3.3 +7.2i
Debug: Complex { real: 3.3, imag: 7.2 }

Display: 4.7 -2.3i
Debug: Complex { real: 4.7, imag: -2.3 }
</code></pre>
<p>Bonus: Add a space before the <code>+</code>/<code>-</code> signs.</p>
<p>Hints in case you get stuck:</p>
<ul>
<li>Check the documentation for <a href="https://doc.rust-lang.org/std/fmt/#sign0"><code>Sign/#/0</code></a> in <code>std::fmt</code>.</li>
<li>Bonus: Check <a href="#ifelse"><code>if</code>-<code>else</code></a> branching and the <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.abs"><code>abs</code></a> function.</li>
</ul>
<h3 id="参照-3"><a class="header" href="#参照-3">参照</a></h3>
<p><a href="#導出derive">導出</a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="#macro_rules">マクロ</a>, <a href="#構造体">構造体</a>, <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">トレイト</a>, <a href="#use宣言"><code>use</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="テストケースリスト"><a class="header" href="#テストケースリスト">テストケース：リスト</a></h1>
<p>構造体のそれぞれの要素を別々に扱う<code>fmt::Display</code>を実装するのはトリッキーです。というのも、それぞれの<code>write!</code>が別々の<code>fmt::Result</code>を生成するためです。適切に処理するためには <em>すべての</em> 結果に対して処理を書かなくてはなりません。このような場合は<code>?</code>演算子が使えます。</p>
<p>以下のように<code>?</code>を<code>write!</code>に対して使用します。</p>
<pre><code class="language-rust ignore">// `write!`を実行し、エラーが生じた場合はエラーを返します。そうでなければ実行を継続します。
write!(f, "{}", value)?;</code></pre>
<p><code>?</code>を使用すれば、<code>Vec</code>用の<code>fmt::Display</code>はより簡単に実装できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt; // `fmt`モジュールのインポート

// `Vec`を含む`List`という名の構造体を定義。
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // タプルインデックスを使って値を取り出し、それへの参照`vec`を作ります。
        let vec = &amp;self.0;

        write!(f, "[")?;

        // Iterate over `v` in `vec` while enumerating the iteration
        // index in `index`.
        for (index, v) in vec.iter().enumerate() {
            // 先頭以外の全要素にカンマを付けます。
            // ?演算子を使ってエラーを返します。
            if index != 0 { write!(f, ", ")?; }
            write!(f, "{}", v)?;
        }

        // 開きっぱなしのブラケットを閉じて、`fmt::Result`の値を返します。
        write!(f, "]")
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!("{}", v);
}</code></pre>
<h3 id="演習-3"><a class="header" href="#演習-3">演習</a></h3>
<p>上記のプログラムを変更して、ベクタの各要素のインデックスも表示するようにしてみましょう。変更後の出力は次のようになります。</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]</code></pre>
<h3 id="参照-4"><a class="header" href="#参照-4">参照</a></h3>
<p><a href="#forループ"><code>for</code></a>, <a href="#refパターン"><code>ref</code></a>, <a href="#result-1"><code>Result</code></a>, <a href="#構造体">構造体</a>, <a href="#"><code>?</code></a>, <a href="#ベクタ型"><code>vec!</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="フォーマット"><a class="header" href="#フォーマット">フォーマット</a></h1>
<p>これまで、文字列がどのようにフォーマットされるかは <em>フォーマット文字列</em> によって決まるということを見てきました 。</p>
<ul>
<li><code>format!("{}", foo)</code> -&gt; <code>"3735928559"</code></li>
<li><code>format!("0x{:X}", foo)</code> -&gt; <a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>"0xDEADBEEF"</code></a></li>
<li><code>format!("0o{:o}", foo)</code> -&gt; <code>"0o33653337357"</code></li>
</ul>
<p>ここでは（<code>foo</code>）という単一の変数が<code>X</code>、<code>o</code>、 <em>指定なし</em> 、という様々な <em>引数タイプ</em> に応じてフォーマットされています。</p>
<p>フォーマットの機能はそれぞれの引数タイプごとに個別のトレイトを用いて実装されています。最も一般的なトレイトは<code>Display</code>で、これは引数タイプが未指定（たとえば<code>{}</code>）の時に呼び出されます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // 緯度
    lat: f32,
    // 経度
    lon: f32,
}

impl Display for City {
    // `f`はバッファです。このメソッドは
    // ここにフォーマットされた文字列を書き込みます。
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!`は`format!`に似ていますが、フォーマットされた文字列を
        // バッファ（第一引数）に書き込みます。
        write!(f, "{}: {:.3}°{} {:.3}°{}",
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: "Dublin", lat: 53.347778, lon: -6.259722 },
        City { name: "Oslo", lat: 59.95, lon: 10.75 },
        City { name: "Vancouver", lat: 49.25, lon: -123.1 },
    ] {
        println!("{}", city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ] {
        // fmt::Displayに実装を追加したら、 {} を使用するように変更してください。
        println!("{:?}", color);
    }
}</code></pre>
<p>フォーマット用トレイトの全リストは<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">こちら</a>から、引数タイプについては<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code>のドキュメンテーション</a>から参照できます。</p>
<h3 id="演習-4"><a class="header" href="#演習-4">演習</a></h3>
<p>上にあるソースコード中の<code>Color</code>という構造体のための<code>fmt::Display</code>トレイトの実装を追加しましょう。出力は以下のようになるはずです。</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>Two hints if you get stuck:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/#named-parameters">それぞれの色を2回以上記述する必要があるかもしれません。</a></li>
<li>You can <a href="https://doc.rust-lang.org/std/fmt/#width">pad with zeros to a width of 2</a> with <code>:0&gt;2</code>. For hexadecimals, you can use <code>:02X</code>.</li>
</ul>
<p>Bonus:</p>
<ul>
<li>If you would like to experiment with <a href="#型キャスト">type casting</a> in advance, the formula for <a href="https://www.rapidtables.com/web/color/RGB_Color.html#rgb-format">calculating a color in the RGB color space</a> is <code>RGB = (R * 65_536) + (G * 256) + B</code>, where <code>R is RED, G is GREEN, and B is BLUE</code>. An unsigned 8-bit integer (<code>u8</code>) can only hold numbers up to 255. To cast <code>u8</code> to <code>u32</code>, you can write <code>variable_name as u32</code>.</li>
</ul>
<h3 id="参照-5"><a class="header" href="#参照-5">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="基本データ型"><a class="header" href="#基本データ型">基本データ型</a></h1>
<p>Rustは様々な基本データ型の使用をサポートしています。以下がその例です。</p>
<h3 id="スカラー型"><a class="header" href="#スカラー型">スカラー型</a></h3>
<ul>
<li>符号付き整数：<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code>（ポインタのサイズ）</li>
<li>符号無し整数：<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>（ポインタのサイズ）</li>
<li>浮動小数点数：<code>f32</code>, <code>f64</code></li>
<li><code>char</code>：<code>'a'</code>, <code>'α'</code>, <code>'∞'</code>などのUnicodeのスカラー値（それぞれ4バイト）</li>
<li><code>bool</code>：<code>true</code>または<code>false</code></li>
<li>ユニット型 <code>()</code>：唯一の値として空のタプル<code>()</code>を持つ</li>
</ul>
<p>ユニット型はその値がタプルですが、複合型とはみなされません。内部に複数の値を含んでいるわけではないからです。</p>
<h3 id="複合型"><a class="header" href="#複合型">複合型</a></h3>
<ul>
<li>配列： 例えば<code>[1, 2, 3]</code></li>
<li>タプル：例えば<code>(1, true)</code></li>
</ul>
<p>変数は常に <em>型指定</em> できます。数値型の場合はさらにサフィックスでの指定も可能です。指定しない場合デフォルトになります。整数は<code>i32</code>が、浮動小数点は<code>f64</code>がデフォルトです。また、Rustは文脈から型を推論することもできます。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 変数に型を指定。
    let logical: bool = true;

    let a_float: f64 = 1.0;  // 通常の型指定
    let an_integer   = 5i32; // サフィックスによる型指定

    // サフィックスを指定しない場合、デフォルトを選択。
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // 型を文脈から推論することも可能。
    let mut inferred_type = 12; // 型 i64 は次行の内容に基づいて推論。
    inferred_type = 4294967296i64;

    // ミュータブルな変数は値を変更できます。
    let mut mutable = 12; // ミュータブルな`i32`
    mutable = 21;

    // エラー！ミュータブルな変数でも型は不変。
    mutable = true;

    // 変数はシャドーイングによって上書きできます。
    let mutable = true;

    /* Compound types - Array and Tuple */

    // Array signature consists of Type T and length as [T; length].
    let my_array: [i32; 5] = [1, 2, 3, 4, 5];

    // Tuple is a collection of values of different types
    // and is constructed using parentheses ().
    let my_tuple = (5u32, 1u8, true, -5.04f32);
}</code></pre>
<h3 id="参照-6"><a class="header" href="#参照-6">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/"><code>std</code> ライブラリ</a>, <a href="#ミュータビリティ"><code>mut</code></a>, <a href="#型推論">型推論</a>, <a href="#スコープとシャドーイング">シャドーイング</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="リテラルと演算子"><a class="header" href="#リテラルと演算子">リテラルと演算子</a></h1>
<p>整数<code>1</code>、浮動小数点数<code>1.2</code>、文字<code>'a'</code>、文字列<code>"abc"</code>、ブーリアン<code>true</code>、ユニット<code>()</code>は、リテラルを使って表すことが可能です。</p>
<p>また整数型の場合、プレフィックスに<code>0x</code>、<code>0o</code>、<code>0b</code>を指定することでそれぞれ16進数、8進数、2進数を使って表すことができます。</p>
<p>可読性のため、<code>_</code>（アンダースコア）を数値リテラルの間に挿入することができます。例えば<code>1_000</code>は<code>1000</code>と、<code>0.000_001</code>は<code>0.000001</code>とそれぞれ同一です。</p>
<p>また、Rustは<code>1e6</code>や<code>7.6e-4</code>などの科学的な<a href="https://en.wikipedia.org/wiki/Scientific_notation#E_notation">E表記</a>をサポートしています。この表記は<code>f64</code>になります。</p>
<p>コンパイラに、リテラルの型を伝えたい場合があります。現在の仕様では、リテラルが32ビット符号無し整数であることを伝える場合、<code>u32</code>サフィックスを、符号付き32ビット整数であれば<code>i32</code>サフィックスを使用します。</p>
<p>Rustで使用可能な<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">演算子とその優先順位</a>は、<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">Cなどの言語のもの</a>とほぼ同じです。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 整数の足し算
    println!("1 + 2 = {}", 1u32 + 2);

    // 整数の引き算
    println!("1 - 2 = {}", 1i32 - 2);
    // TODO ^ 型が重要であることを実感するため`1i32`を`1u32`に変更してみましょう。

    // 科学的表記
    println!("1e4 is {}, -2.5e-3 is {}", 1e4, -2.5e-3);

    // 短絡評価できる論理演算子
    println!("true AND false is {}", true &amp;&amp; false);
    println!("true OR false is {}", true || false);
    println!("NOT true is {}", !true);

    // ビットワイズ演算
    println!("0011 AND 0101 is {:04b}", 0b0011u32 &amp; 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 &lt;&lt; 5 is {}", 1u32 &lt;&lt; 5);
    println!("0x80 &gt;&gt; 2 is 0x{:x}", 0x80u32 &gt;&gt; 2);

    // 可読性のための`_`（アンダースコア）の使用
    println!("One million is written as {}", 1_000_000u32);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="タプル"><a class="header" href="#タプル">タプル</a></h1>
<p>タプルは異なる型の値の集合です。括弧<code>()</code>を用いて生成します。タプル自体がそのメンバに対する型シグネチャを保持していますので、明示すると<code>(T1, T2, ...)</code>のようになります。タプルは大きさに制限がありませんので、関数が複数の値を返したい時に使われます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// タプルを関数の引数と返り値として使用しています。
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let`でタプルの中の値を別の変数に束縛することができます。
    let (int_param, bool_param) = pair;

    (bool_param, int_param)
}

// 以下の構造体は後ほど「演習」で用います。
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // 様々な型を値に持つタプル
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // インデックスを用いて、タプル内の要素を参照できます。
    println!("Long tuple first value: {}", long_tuple.0);
    println!("Long tuple second value: {}", long_tuple.1);

    // タプルはタプルのメンバになれます。
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // タプルは出力できます。
    println!("tuple of tuples: {:?}", tuple_of_tuples);

    // しかし長すぎるタプル（12要素より多いもの）は出力できません。
    //let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    //println!("Too long tuple: {:?}", too_long_tuple);
    // TODO ^ 上記2行のコメントを外して、コンパイルエラーを確認しましょう。

    let pair = (1, true);
    println!("Pair is {:?}", pair);

    println!("The reversed pair is {:?}", reverse(pair));

    // 要素を1つしか持たないタプルを作成する場合、括弧で囲まれたただのリテラル
    // と区別するため、カンマが必要になります。
    println!("One element tuple: {:?}", (5u32,));
    println!("Just an integer: {:?}", (5u32));

    // タプルを分解して別の変数にそれぞれの値を代入。
    let tuple = (1, "hello", 4.5, true);

    let (a, b, c, d) = tuple;
    println!("{:?}, {:?}, {:?}, {:?}", a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix);
}</code></pre>
<h3 id="演習-5"><a class="header" href="#演習-5">演習</a></h3>
<ol>
<li>
<p><em>復習</em> ：上にある<code>Matrix</code>という構造体に、<code>fmt::Display</code>トレイトを追加しましょう。デバッグフォーマット<code>{:?}</code>ではなくディスプレイフォーマット<code>{}</code>で出力すれば次のようになるはずです。</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>必要に応じて<a href="#display">ディスプレイのページ</a>に戻りましょう。</p>
</li>
<li>
<p><code>reverse</code>関数を雛形にした<code>transpose</code>関数を実装してください。この関数は<code>Matrix</code>を引数として受け取り、要素のうち2つを入れ替えたものを返します。つまり</p>
<pre><code class="language-rust ignore">println!("Matrix:\n{}", matrix);
println!("Transpose:\n{}", transpose(matrix));</code></pre>
<p>は以下の様な出力になります。</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="配列とスライス"><a class="header" href="#配列とスライス">配列とスライス</a></h1>
<p>配列は<code>T</code>という単一の型のオブジェクトの集合です。それらのオブジェクトはメモリ上の連続した領域に保存されます。配列は<code>[]</code>を用いて生成されます。長さはコンパイル時には決定されていて、<code>[T; length]</code>という形で指定できます。</p>
<p>スライスは配列に似ていますが、コンパイル時に長さが決定されていません。スライスは2ワードからなるオブジェクトであり、最初のワードがデータへのポインタ、2番目のワードがスライスの長さです。ワード長は<code>usize</code>と同一で、プロセッサのアーキテクチャによって決まります。例えばx86-64では64ビットです。スライスは配列の一部を借用するのに使用され、<code>&amp;[T]</code>という型シグネチャを持ちます。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">use std::mem;

// この関数はスライスを借用します。
fn analyze_slice(slice: &amp;[i32]) {
    println!("First element of the slice: {}", slice[0]);
    println!("The slice has {} elements", slice.len());
}

fn main() {
    // 固定長の配列（型シグネチャは冗長なので、なくても可）
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // すべての要素を同じ値で初期化する場合
    let ys: [i32; 500] = [0; 500];

    // インデックスは0から。
    println!("First element of the array: {}", xs[0]);
    println!("Second element of the array: {}", xs[1]);

    // `len`は配列の要素数を返します。
    println!("Number of elements in array: {}", xs.len());

    // 配列はスタック上に置かれます。
    println!("Array occupies {} bytes", mem::size_of_val(&amp;xs));

    // 配列は自動的にスライスとして借用されます。
    println!("Borrow the whole array as a slice.");
    analyze_slice(&amp;xs);

    // スライスは配列の一部を指すことができます。
    // [starting_index..ending_index] の形をとり、
    // `starting_index`はスライスの先頭の位置を表し、
    // `ending_index`はスライスの末尾の1つ先の位置を表します。
    println!("Borrow a section of the array as a slice.");
    analyze_slice(&amp;ys[1 .. 4]);

    // 空のスライス`&amp;[]`の例：
    let empty_array: [u32; 0] = [];
    assert_eq!(&amp;empty_array, &amp;[]);
    assert_eq!(&amp;empty_array, &amp;[][..]); // 同じ意味だがより冗長な書き方

    // 配列は、`Option`を返す`.get`で安全にアクセスできます。
    // `Option`は以下のようにマッチさせることもできるし、
    // 運よく処理を続ける代わりに、`.expect()`で素敵なメッセージとともに
    // プログラムを終了することもできます。
    for i in 0..xs.len() + 1 { // おっと、1要素余分！
        match xs.get(i) {
            Some(xval) =&gt; println!("{}: {}", i, xval),
            None =&gt; println!("Slow down! {} is too far!", i),
        }
    }

    // Out of bound indexing on array with constant value causes compile time error.
    //println!("{}", xs[5]);
    // Out of bound indexing on slice causes runtime error.
    //println!("{}", xs[..][5]);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="カスタム型"><a class="header" href="#カスタム型">カスタム型</a></h1>
<p>Rustでのカスタムデータ型の作成は主に以下の2つのキーワードを介して行われます。</p>
<ul>
<li><code>struct</code>：構造体を定義する</li>
<li><code>enum</code>：列挙型を定義する</li>
</ul>
<p><code>const</code>、あるいは<code>static</code>というキーワードによって定数を定義することもできます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="構造体"><a class="header" href="#構造体">構造体</a></h1>
<p><code>struct</code>というキーワードを用いて作成できる構造体には3種類あります。</p>
<ul>
<li>タプル構造体。（すなわちタプルに名前が付いたようなもの）</li>
<li>クラシックな<a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C言語スタイルの構造体。</a></li>
<li>ユニット構造体。これはフィールドを持たず、ジェネリック型を扱う際に有効です。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">// 使用されていないコードよる警告を隠すアトリビュート
#![allow(dead_code)]

#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// ユニット構造体
struct Unit;

// タプル構造体
struct Pair(i32, f32);

// 2つのフィールドを持つ（クラシックな）構造体
struct Point {
    x: f32,
    y: f32,
}

// 構造体は他の構造体のフィールドになることができます。
struct Rectangle {
    // 長方形は座標空間上における左上隅と右下隅の位置によって指定できます。
    top_left: Point,
    bottom_right: Point,
}

fn main() {
    // 構造体をフィールド初期化の簡略記法で生成。
    let name = String::from("Peter");
    let age = 27;
    let peter = Person { name, age };

    // 構造体のデバッグ表示
    println!("{:?}", peter);

    // `Point`のインスタンス化
    let point: Point = Point { x: 5.2, y: 0.4 };
    let another_point: Point = Point { x: 10.3, y: 0.2 };

    // pointのフィールドにアクセスします。
    println!("point coordinates: ({}, {})", point.x, point.y);

    // 構造体の更新記法を用いて、別の構造体のフィールドの値を基に
    // 新たなpointを生成。
    let bottom_right = Point { x: 10.3, ..another_point };

    // `bottom_right.y`の値は`another_point.y`と同一ですが、
    // これは`another_point`のフィールドの値を用いて生成したためです。
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    // `let`を使用してpointをデストラクトします。
    let Point { x: left_edge, y: top_edge } = point;

    let _rectangle = Rectangle {
        // 構造体の定義とインスタンスの作成を同時に行います。
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // ユニット構造体のインスタンス化
    let _unit = Unit;

    // タプル構造体のインスタンス化
    let pair = Pair(1, 0.1);

    // タプル構造体のフィールドにアクセス
    println!("pair contains {:?} and {:?}", pair.0, pair.1);

    // タプル構造体のデストラクト
    let Pair(integer, decimal) = pair;

    println!("pair contains {:?} and {:?}", integer, decimal);
}</code></pre>
<h3 id="演習-6"><a class="header" href="#演習-6">演習</a></h3>
<ol>
<li><code>Rectangle</code>の面積を計算する<code>rect_area</code>関数を追加してください。ネストしたデストラクトを使ってみましょう。</li>
<li><code>Point</code>と<code>f32</code>を引数とし、<code>Rectangle</code>を返す<code>square</code>関数を追加してください。<code>Rectangle</code>の左上の点が<code>Point</code>になり、<code>f32</code>が<code>Rectangle</code>の幅と高さになります。</li>
</ol>
<h3 id="参照-7"><a class="header" href="#参照-7">参照</a></h3>
<p><a href="#アトリビュート">アトリビュート</a>, <a href="#生識別子">生識別子</a>, <a href="#デストラクト">デストラクト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="列挙型"><a class="header" href="#列挙型">列挙型</a></h1>
<p>列挙型（<code>enum</code>）はいくつかの異なる要素型の中から1つを選ぶような場合に使用します。構造体（<code>struct</code>）の定義を満たすものならば何でも<code>enum</code> の要素型として使用できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `enum`を作成してwebイベントを分類します。
// 名前と型情報を併せたものが要素型になっていることに注意。
// `PageLoad != PageUnload`、
// `KeyPress(char) != Paste(String)`です。
// 要素型は互いに異なり、互いに非依存です。
enum WebEvent {
    // `enum`要素型はユニット風でも構いません。
    PageLoad,
    PageUnload,
    // タプル構造体風
    KeyPress(char),
    Paste(String),
    // C言語スタイルの構造体風
    Click { x: i64, y: i64 },
}

// 引数として`WebEvent`列挙型をとり、何も返さない関数
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!("page loaded"),
        WebEvent::PageUnload =&gt; println!("page unloaded"),
        // `enum`の要素型から`c`をデストラクトします。
        WebEvent::KeyPress(c) =&gt; println!("pressed '{}'.", c),
        WebEvent::Paste(s) =&gt; println!("pasted \"{}\".", s),
        // `Click`を`x`と`y`にデストラクトします。
        WebEvent::Click { x, y } =&gt; {
            println!("clicked at x={}, y={}.", x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()`は文字列スライスから所有権のある`String`を作成します。
    let pasted  = WebEvent::Paste("my text".to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
</code></pre>
<h2 id="型エイリアス"><a class="header" href="#型エイリアス">型エイリアス</a></h2>
<p>型エイリアスを用いると、列挙型の要素型を別名で参照できます。これは列挙型の名前があまりに長かったり、あまりに一般的だったりで改名したい場合に役立ちます。</p>
<pre class="playground"><code class="language-rust editable edition2021">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

// 型エイリアスを作成します。
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;

fn main() {
    // 長くて不便な列挙型の名前ではなく、別名を使って要素型を参照できます。
    let x = Operations::Add;
}</code></pre>
<p>このやり方がもっともよく見られるのは、<code>impl</code>ブロックで<code>Self</code>という別名を使用する場合です。</p>
<pre class="playground"><code class="language-rust editable edition2021">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}</code></pre>
<p>列挙型や型エイリアスについて詳しく学びたい人は、この機能が安定してRustに取り込まれたときの<a href="https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847">stabilization report</a>を読んでください。</p>
<h3 id="参照-8"><a class="header" href="#参照-8">参照</a></h3>
<p><a href="#match"><code>match</code></a>, <a href="#関数">関数</a>, <a href="#文字列">文字列</a>, <a href="https://rust-lang.github.io/rfcs/2338-type-alias-enum-variants.html">“Type alias enum variants” RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="use"><a class="header" href="#use">use</a></h1>
<p>The <code>use</code> declaration can be used to avoid typing the full module path to access a name:</p>
<pre class="playground"><code class="language-rust editable edition2021">// 使用されていないコードよる警告を隠すアトリビュート
#![allow(dead_code)]

enum Stage {
    Beginner,
    Advanced,
}

enum Role {
    Student,
    Teacher,
}

fn main() {
    // `use`することで絶対名でなくとも使用可能になります。
    use Stage::{Beginner, Advanced};
    // `Role`の中の名前をすべて`use`します。
    use Role::*;

    // `use`しているため、`Stage::Beginner`と同じです。
    let stage = Beginner;
    // `Role::Student`と同じ
    let role = Student;

    match stage {
        // `use`しているのでスコープを明示していません。
        Beginner =&gt; println!("Beginners are starting their learning journey!"),
        Advanced =&gt; println!("Advanced learners are mastering their subjects..."),
    }

    match role {
        // こちらも同じ
        Student =&gt; println!("Students are acquiring knowledge!"),
        Teacher =&gt; println!("Teachers are spreading knowledge!"),
    }
}</code></pre>
<h3 id="参照-9"><a class="header" href="#参照-9">参照</a></h3>
<p><a href="#match"><code>match</code></a>, <a href="#use宣言"><code>use</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="c言語ライクな列挙型"><a class="header" href="#c言語ライクな列挙型">C言語ライクな列挙型</a></h1>
<p>列挙型はC言語の列挙型のような使い方をする事もできます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// 使用されていないコードよる警告を隠すアトリビュート
#![allow(dead_code)]

// 値を明示しない場合、0から整数が順に入ります。
enum Number {
    Zero,
    One,
    Two,
}

// 値を明示する場合
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // 列挙型の中身は整数としてキャストできます。
    println!("zero is {}", Number::Zero as i32);
    println!("one is {}", Number::One as i32);

    println!("roses are #{:06x}", Color::Red as u32);
    println!("violets are #{:06x}", Color::Blue as u32);
}</code></pre>
<h3 id="参照-10"><a class="header" href="#参照-10">参照</a></h3>
<p><a href="#型キャスト">キャスト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="テストケース連結リスト"><a class="header" href="#テストケース連結リスト">テストケース：連結リスト</a></h1>
<p><code>enum</code>の使用が適切なパターンのひとつに、連結リストを作成する場合があります。</p>
<pre class="playground"><code class="language-rust editable edition2021">use crate::List::*;

enum List {
    // Cons：要素をラップし、次の要素へのポインタを保持するタプル構造体
    Cons(u32, Box&lt;List&gt;),
    // Nil：連結リストの終端であることを示すノード
    Nil,
}

// 列挙型にはメソッドを付与することができます。
impl List {
    // 空リストの作成
    fn new() -&gt; List {
        // `Nil`は`List`型を持ちます。
        Nil
    }

    // リストを受け取り、その始端に新しい要素を付加したものを返す関数
    fn prepend(self, elem: u32) -&gt; List {
        // この`Cons`自体も、その第2要素もどちらもList型です。
        Cons(elem, Box::new(self))
    }

    // リストの長さを返すメソッド
    fn len(&amp;self) -&gt; u32 {
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&amp;List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&amp;T`
        // after Rust 2018 you can use self here and tail (with no ref) below as well,
        // rust will infer &amp;s and ref tail.
        // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html
        match *self {
            // Can't take ownership of the tail, because `self` is borrowed;
            // instead take a reference to the tail
            // And it's a non-tail recursive call which may cause stack overflow for long lists.
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // 空リストならば長さは0
            Nil =&gt; 0
        }
    }

    // リストをヒープ上の文字列として表したものを返すメソッド
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!`は`print!`に似ていますが、コンソール上に出力
                // する代わりに、ヒープ上の文字列を返します。
                format!("{}, {}", head, tail.stringify())
            },
            Nil =&gt; {
                format!("Nil")
            },
        }
    }
}

fn main() {
    // 空の連結リストを作成。
    let mut list = List::new();

    // 要素を追加。
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 追加後の状態を表示。
    println!("linked list has length: {}", list.len());
    println!("{}", list.stringify());
}</code></pre>
<h3 id="参照-11"><a class="header" href="#参照-11">参照</a></h3>
<p><a href="#boxスタックとヒープ"><code>Box</code></a>, <a href="#関連関数とメソッド">メソッド</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定数"><a class="header" href="#定数">定数</a></h1>
<p>Rustには2種類の定数があり、いずれもグローバルスコープを含む任意のスコープで宣言することができます。また、いずれも型を明示しなくてはなりません。</p>
<ul>
<li><code>const</code>：不変の値（通常はこちらを使用します）</li>
<li><code>static</code>：<a href="#スタティックライフタイム"><code>'static</code></a>ライフタイムを持つ変更可能な値。スタティックライフタイムは推論され、明示する必要はありません。可変なスタティック値へのアクセスや変更は<a href="#安全でない操作">安全ではありません</a>。</li>
</ul>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// グローバル変数はあらゆるスコープの外で宣言します。
static LANGUAGE: &amp;str = "Rust";
const THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // 関数内から定数を参照。
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // main 関数の中から定数を参照。
    println!("This is {}", LANGUAGE);
    println!("The threshold is {}", THRESHOLD);
    println!("{} is {}", n, if is_big(n) { "big" } else { "small" });

    // エラー！const`は変更できません。
    THRESHOLD = 5;
    // FIXME ^ この行をコメントアウトしましょう
}</code></pre>
<h3 id="参照-12"><a class="header" href="#参照-12">参照</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md"><code>const</code>/<code>static</code> のRFC</a>, <a href="#スタティックライフタイム"><code>'static</code> ライフタイム</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="変数束縛"><a class="header" href="#変数束縛">変数束縛</a></h1>
<p>Rustは静的な型付けによる型安全性を提供します。変数束縛は宣言時に型を指定できます。とはいえたいていの場合は、コンパイラは変数の型をコンテキストから推測することができますので、型指定の負担を大幅に軽減できます。</p>
<p>値（リテラルなど）は<code>let</code>を用いて変数に束縛することができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // `an_integer`を`copied_integer`へとコピー。
    let copied_integer = an_integer;

    println!("An integer: {:?}", copied_integer);
    println!("A boolean: {:?}", a_boolean);
    println!("Meet the unit value: {:?}", unit);

    // 使用されていない変数があると、コンパイラは警告を出します。
    // 変数名の頭に`_`（アンダーバー）を付けると警告を消すことができます。
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // FIXME ^ 頭にアンダーバーを付けて、警告を抑えましょう。
    // 警告はブラウザ上では表示されないかもしれません。
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ミュータビリティ"><a class="header" href="#ミュータビリティ">ミュータビリティ</a></h1>
<p>変数はデフォルトでイミュータブル（変更不可能）ですが<code>mut</code>構文を使用することで変更可能になります。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!("Before mutation: {}", mutable_binding);

    // 問題ありません。
    mutable_binding += 1;

    println!("After mutation: {}", mutable_binding);

    // エラー！イミュータブルな変数に新しい値を代入することはできません。
    _immutable_binding += 1;
}</code></pre>
<p>コンパイラはミュータビリティに関するエラーの詳細を出してくれます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="スコープとシャドーイング"><a class="header" href="#スコープとシャドーイング">スコープとシャドーイング</a></h1>
<p>変数はスコープを持つため、 <strong>ブロック</strong> の中に閉じ込められています。ブロックとは<code>{}</code>で囲まれた領域のことです。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // この変数はmain関数の間、生存しています。
    let long_lived_binding = 1;

    // ここから下がmain関数より小さいスコープを持つブロックとなります。
    {
        // この変数はこのブロック内のみに存在します。
        let short_lived_binding = 2;

        println!("inner short: {}", short_lived_binding);
    }
    // ブロックの終わり

    // エラー！`short_lived_binding`はこのスコープ内には存在しません。
    println!("outer short: {}", short_lived_binding);
    // FIXME ^ この行をコメントアウトしましょう

    println!("outer long: {}", long_lived_binding);
}</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Variable_shadowing">変数のシャドーイング</a>も可能です。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    let shadowed_binding = 1;

    {
        println!("before being shadowed: {}", shadowed_binding);

        // この変数はスコープ外の同名の変数を *シャドーイング* します。
        let shadowed_binding = "abc";

        println!("shadowed in inner block: {}", shadowed_binding);
    }
    println!("outside inner block: {}", shadowed_binding);

    // この変数束縛は以前に定義した変数を *シャドーイング* します。
    let shadowed_binding = 2;
    println!("shadowed in outer block: {}", shadowed_binding);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="前方宣言"><a class="header" href="#前方宣言">前方宣言</a></h1>
<p>It is possible to declare variable bindings first and initialize them later, but all variable bindings must be initialized before they are used: the compiler forbids use of uninitialized variable bindings, as it would lead to undefined behavior.</p>
<p>It is not common to declare a variable binding and initialize it later in the function. It is more difficult for a reader to find the initialization when initialization is separated from declaration. It is common to declare and initialize a variable binding near where the variable will be used.</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // 変数を宣言。
    let a_binding;

    {
        let x = 2;

        // 変数を初期化。
        a_binding = x * x;
    }

    println!("a binding: {}", a_binding);

    let another_binding;

    // エラー！初期化していない変数の使用
    println!("another binding: {}", another_binding);
    // FIXME ^ この行をコメントアウトしましょう

    another_binding = 1;

    println!("another binding: {}", another_binding);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="値の凍結"><a class="header" href="#値の凍結">値の凍結</a></h1>
<p>データを同じ名前のイミュータブルな変数に束縛しなおすと、データは_凍結_されます。_凍結_したデータは、イミュータブルな束縛がスコープ外になるまで変更できません。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // イミュータブルな`_mutable_integer`でシャドーイングします。
        let _mutable_integer = _mutable_integer;

        // エラー！`_mutable_integer`はこのスコープでは凍結しています。
        _mutable_integer = 50;
        // FIXME ^ この行をコメントアウトしましょう

        // `_mutable_integer`はスコープを抜けます。
    }

    // OK！`_mutable_integer`はこのスコープでは凍結していません。
    _mutable_integer = 3;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="型"><a class="header" href="#型">型</a></h1>
<p>Rustには、基本データ型やユーザ定義型を定義したり変換したりする様々な方法があります。この章は以下の内容を扱います。</p>
<ul>
<li>基本データ型の間で<a href="#型キャスト">キャスト</a>を行う。</li>
<li><a href="#リテラル">リテラル</a>の型をどれにしたいか指定する。</li>
<li><a href="#型推論">型推論</a>を使う。</li>
<li>型を<a href="#エイリアス">エイリアス</a>する。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="型キャスト"><a class="header" href="#型キャスト">型キャスト</a></h1>
<p>Rustは基本データ型について暗黙的な型変換（<code>coerction</code>）を行うことはありません。しかし明示的な型変換（<code>casting</code>）は可能です。その場合<code>as</code>キーワードを使用します。</p>
<p>整数型から整数型へ型変換する場合、C言語で可能なケースの場合はC言語と同じです。C言語で未定義の場合の挙動も、Rustでは完全に定義されています。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// Suppress all errors from casts which overflow.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // エラー！暗黙的な型変換はできません。
    let integer: u8 = decimal;
    // FIXME ^ この行をコメントアウトしましょう

    // 明示的な型変換
    let integer = decimal as u8;
    let character = integer as char;

    // エラー！変換ルールには制限があります。
    // 浮動小数点数を文字に直接変換することはできません。
    let character = decimal as char;
    // FIXME ^ この行をコメントアウトしましょう

    println!("Casting: {} -&gt; {} -&gt; {}", decimal, integer, character);

    // when casting any value to an unsigned type, T,
    // T::MAX + 1 is added or subtracted until the value
    // fits into the new type ONLY when the #![allow(overflowing_literals)]
    // lint is specified like above. Otherwise there will be a compiler error.

    // 1000はすでにu16に収まっているため変化しません。
    println!("1000 as a u16 is: {}", 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // 詳しく見てみると、最下位ビットから8bitが保持され、
    // 残りの上位ビットが切り取られる形になります。
    println!("1000 as a u8 is : {}", 1000 as u8);
    // -1 + 256 = 255
    println!("  -1 as a u8 is : {}", (-1i8) as u8);

    // 正の数では、これは剰余と同じです。
    println!("1000 mod 256 is : {}", 1000 % 256);

    // 符号付きの型にキャストする場合、（ビットとして見た）結果は対応する
    // 符号無し型へのキャストを行った結果と同じです。
    // 最上位ビットが1であれば、その値は負であることを示しています。

    // すでに収まっている場合はそのままです。
    println!(" 128 as a i16 is: {}", 128 as i16);

    // 境界値のケースを考えると、128の8ビットにおける2の補数は -128です。
    println!(" 128 as a i8 is : {}", 128 as i8);

    // 上で示した例を繰り返すと
    // 1000 as u8 -&gt; 232
    println!("1000 as a u8 is : {}", 1000 as u8);
    // 232の8ビットにおける補数は -24。
    println!(" 232 as a i8 is : {}", 232 as i8);

    // Rust 1.45以降、浮動小数点数を整数にキャストするとき、
    // `as`キーワードが *飽和的キャスト* を行います。
    // 浮動小数点数の値が上限を超えたり下限を下回ったりする場合は、
    // 戻り値は越えられた境界の値となります。

    // 300.0 as u8 は 255
    println!(" 300.0 as u8 is : {}", 300.0_f32 as u8);
    // -100.0 as u8 は 0
    println!("-100.0 as u8 is : {}", -100.0_f32 as u8);
    // nan as u8 は 0
    println!("   nan as u8 is : {}", f32::NAN as u8);

    // この挙動は実行時にややコストがかかるため、安全でない方法で回避できます。
    // ただし、結果はオーバーフローしたり *不正確な値* を返す場合があります。
    // この方法は賢く使いましょう。
    unsafe {
        // 300.0 as u8 は 44
        println!(" 300.0 as u8 is : {}", 300.0_f32.to_int_unchecked::&lt;u8&gt;());
        // -100.0 as u8 は 156
        println!("-100.0 as u8 is : {}", (-100.0_f32).to_int_unchecked::&lt;u8&gt;());
        // nan as u8 は 0
        println!("   nan as u8 is : {}", f32::NAN.to_int_unchecked::&lt;u8&gt;());
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="リテラル"><a class="header" href="#リテラル">リテラル</a></h1>
<p>数値型リテラルはサフィックスにより型を指定することが可能です。例えば、<code>42</code>というリテラルに対して<code>i32</code>型を指定するには<code>42i32</code>とします。</p>
<p>サフィックスを指定しない数値型リテラルの場合、その型がどのように使用されるかに依存して決められます。デフォルトでは整数型の場合<code>i32</code>が、浮動小数点数型には<code>f64</code>が使われます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // サフィックスを指定したリテラル。型は初期化とともに確定します。
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // サフィックスを指定しないリテラル。型は使用方法に依存します。
    let i = 1;
    let f = 1.0;

    // `size_of_val`関数は変数のサイズをバイトで返します。
    println!("size of `x` in bytes: {}", std::mem::size_of_val(&amp;x));
    println!("size of `y` in bytes: {}", std::mem::size_of_val(&amp;y));
    println!("size of `z` in bytes: {}", std::mem::size_of_val(&amp;z));
    println!("size of `i` in bytes: {}", std::mem::size_of_val(&amp;i));
    println!("size of `f` in bytes: {}", std::mem::size_of_val(&amp;f));
}</code></pre>
<p>上のコードには現時点では解説していない考えがいくつか使用されています。気になる方のために簡単に説明をしておきましょう。</p>
<ul>
<li><code>std::mem::size_of_val</code>は関数ですが、 <em>絶対パス</em> で呼び出されています。ソースコードは論理的に区切られた <em>モジュール</em> と呼ばれるものにわけられることができます。今回の場合は<code>size_of_val</code>関数は<code>mem</code>モジュール内で定義されており、<code>mem</code>モジュールは<code>std</code> <em>クレート</em> 内で定義されています。より詳しくは<a href="#モジュール">モジュール</a>と<a href="#クレート">クレート</a>を参照してください。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="型推論"><a class="header" href="#型推論">型推論</a></h1>
<p>Rustの型推論エンジンはなかなか賢くできています。初期化の際に評価値の型をチェックするだけでなく、その後にどのような使われ方をしているかを見て推論します。以下がその例です。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // アノテーションのおかげで、コンパイラは`elem`がu8型であることがわかります。
    let elem = 5u8;

    // 空のベクタ（可変長の配列）を生成。
    let mut vec = Vec::new();
    // この時点でコンパイラは`vec`の型を知りませんが、
    // 何らかの値のベクタ（`Vec&lt;_&gt;`）であるということだけは把握しています。

    // `elem`をベクタに挿入。
    vec.push(elem);
    // よし！これでコンパイラは`vec`が`u8`のベクタ（`Vec&lt;u8&gt;`）
    // であることを把握しました。
    // TODO ^ 上の`vec.push(elem)`をコメントアウトしてみましょう。

    println!("{:?}", vec);
}</code></pre>
<p>このように、変数の型アノテーションは必要ありません。これでコンパイラもプログラマもハッピーですね！</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="エイリアス"><a class="header" href="#エイリアス">エイリアス</a></h1>
<p><code>type</code>文を使用することで既存の型に新しい名前を付けることができます。その場合、名前は<code>UpperCamelCase</code>でなくてはなりません。さもなくばコンパイラがエラーを出します。唯一の例外は<code>usize</code>や<code>f32</code>のような基本データ型です。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `NanoSecond` `Inch` `U64` を`u64`の別名として使用します。
type NanoSecond = u64;
type Inch = u64;
type U64 = u64;

fn main() {
    // `NanoSecond` = `Inch` = `U64` = `u64`
    let nanoseconds: NanoSecond = 5 as u64;
    let inches: Inch = 2 as U64;

    // 型のエイリアスは、元の型をより型安全する **わけではない** ことに注意。
    // なぜならば、エイリアスは新たな型を定義している **わけではない** からです。
    println!("{} nanoseconds + {} inches = {} unit?",
             nanoseconds,
             inches,
             nanoseconds + inches);
}</code></pre>
<p>このようにエイリアスを付ける一番の理由はボイラープレートを減らすことです。例えば<code>io::Result&lt;T&gt;</code>型は<code>Result&lt;T, io::Error&gt;</code>の別名です。</p>
<h3 id="参照-13"><a class="header" href="#参照-13">参照</a></h3>
<p><a href="#アトリビュート">アトリビュート</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="型変換"><a class="header" href="#型変換">型変換</a></h1>
<p>基本データ型同士は<a href="#型キャスト">キャスト</a>を用いて変換できます。</p>
<p>Rustはカスタム型（例えば<code>struct</code>や<code>enum</code>）間の変換を<a href="#トレイト-2">トレイト</a>を用いて行います。ジェネリックな型変換には<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>および<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトを使用します。しかし、よくあるケースにおいて、特に<code>String</code>との相互の型変換では、特殊なトレイトが使用されます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fromとinto"><a class="header" href="#fromとinto"><code>From</code>と<code>Into</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>トレイトと<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトは本質的に結びついており、そのことが実際の実装に反映されています。もし型Aが型Bからの型変換をサポートしているのであれば、型Bは型Aへの型変換ができると思うのが自然です。</p>
<h2 id="from"><a class="header" href="#from"><code>From</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>トレイトは、ある型に対し、別の型からその型を作る方法を定義できるようにするものです。そのため、複数の型の間で型変換を行うための非常にシンプルな仕組みを提供しています。標準ライブラリでは、基本データ型やよく使われる型に対して、このトレイトが多数実装されています。</p>
<p>例えば、<code>str</code>から<code>String</code>への型変換は簡単です。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = "hello";
let my_string = String::from(my_str);
<span class="boring">}</span></code></pre>
<p>We can do something similar for defining a conversion for our own type.</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!("My number is {:?}", num);
}</code></pre>
<h2 id="into"><a class="header" href="#into"><code>Into</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトは、単に<code>From</code>トレイトの逆の働きをし、ある型を他の型に変換する方法を定義します。</p>
<p><code>into()</code> の呼び出し時にはほとんどの場合戻り値の型をコンパイラが決定できません。そのため戻り値の型は明示的に指定する必要があります。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::convert::Into;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl Into&lt;Number&gt; for i32 {
    fn into(self) -&gt; Number {
        Number { value: self }
    }
}

fn main() {
    let int = 5;
    // ここの型アノテーションを消してみましょう。
    let num: Number = int.into();
    println!("My number is {:?}", num);
}</code></pre>
<h2 id="from-and-into-are-interchangeable"><a class="header" href="#from-and-into-are-interchangeable"><code>From</code> and <code>Into</code> are interchangeable</a></h2>
<p><code>From</code> と <code>Into</code> は相補的にデザインされているので両方のトレイトを実装する必要はありません。<code>From</code> トレイトを実装すれば、 <code>Into</code> は必要なときに呼ばれます。ただし、逆は真ではない点に注意してください。 <code>Into</code> が実装されていても、 <code>From</code> が自動的に提供されるわけではありません。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

// Define `From`
impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // use `Into`
    let num: Number = int.into();
    println!("My number is {:?}", num);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tryfromとtryinto"><a class="header" href="#tryfromとtryinto"><code>TryFrom</code>と<code>TryInto</code></a></h1>
<p><a href="#fromとinto"><code>From</code>と<code>Into</code></a>と同様に、<a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>と<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a>も型変換を行うジェネリックなトレイトです。<code>From</code>/<code>Into</code>と異なり、<code>TryFrom</code>/<code>TryInto</code>トレイトは失敗する可能性のある型変換に用いられるので、<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>を返します。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stringとの型変換"><a class="header" href="#stringとの型変換">Stringとの型変換</a></h1>
<h2 id="stringへの型変換"><a class="header" href="#stringへの型変換">Stringへの型変換</a></h2>
<p>To convert any type to a <code>String</code> is as simple as implementing the <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> trait for the type. Rather than doing so directly, you should implement the <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a> trait which automatically provides <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> and also allows printing the type as discussed in the section on <a href="#フォーマットして出力"><code>print!</code></a>.</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "Circle of radius {}", self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!("{}", circle.to_string());
}</code></pre>
<h2 id="stringの解析"><a class="header" href="#stringの解析">Stringの解析</a></h2>
<p>文字列からの型変換において、数値への型変換はよく行われるものの一つです。これを行うイディオムは<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a>関数を使用することですが、このときに型を推論できるようにするか、もしくはターボフィッシュ構文（<code>::&lt;&gt;</code>）を使用して型を指定するかのいずれかを行います。以下の例では、どちらの方法も紹介しています。</p>
<p>This will convert the string into the type specified as long as the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait is implemented for that type. This is implemented for numerous types within the standard library.</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let parsed: i32 = "5".parse().unwrap();
    let turbo_parsed = "10".parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!("Sum: {:?}", sum);
}</code></pre>
<p>To obtain this functionality on a user defined type simply implement the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait for that type.</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;
use std::str::FromStr;

#[derive(Debug)]
struct Circle {
    radius: i32,
}

impl FromStr for Circle {
    type Err = ParseIntError;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.trim().parse() {
            Ok(num) =&gt; Ok(Circle{ radius: num }),
            Err(e) =&gt; Err(e),
        }
    }
}

fn main() {
    let radius = "    3 ";
    let circle: Circle = radius.parse().unwrap();
    println!("{:?}", circle);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="式"><a class="header" href="#式">式</a></h1>
<p>Rustのプログラムは（ほとんどの場合）文の連続でできています</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // statement
    // statement
    // statement
}</code></pre>
<p>文にはいくつかの種類があります。最も一般的なのは変数の束縛と<code>;</code>付きの式です。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 変数束縛
    let x = 5;

    // 式;
    x;
    x + 1;
    15;
}</code></pre>
<p>コードブロックも式の一種です。よってブロックを丸ごと値として扱うことができます。その場合ブロック内の最後の式が場所を表す式（例えばローカル変数）に代入されます。ただし、ブロック内の最後の式が<code>;</code>で終わる場合は返り値は<code>()</code>になります。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // この式は`y`に代入されます。
        x_cube + x_squared + x
    };

    let z = {
        // セミコロンがあるので`z`には`()`が入ります。
        2 * x;
    };

    println!("x is {:?}", x);
    println!("y is {:?}", y);
    println!("z is {:?}", z);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="制御フロー"><a class="header" href="#制御フロー">制御フロー</a></h1>
<p>処理の流れをコントロールすることはあらゆるプログラミング言語において重要な要素です。<code>if</code>/<code>else</code>、<code>for</code>等です。Rustの文法を見ていきましょう。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ifelse"><a class="header" href="#ifelse">if/else</a></h1>
<p><code>if</code>-<code>else</code>を用いた条件分岐は他の言語に似ています。多くの言語では条件式の中を括弧でくくる必要がありますが、Rustではその必要はありません。条件式の直後にはブロックが続きます。<code>if</code>-<code>else</code>は式の一種で、いずれの分岐先でも返り値の型は同一でなくてはなりません。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!("{} is negative", n);
    } else if n &gt; 0 {
        print!("{} is positive", n);
    } else {
        print!("{} is zero", n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(", and is a small number, increase ten-fold");

            // この式は`i32`を返します。
            10 * n
        } else {
            println!(", and is a big number, halve the number");

            // ここでも返り値の型は`i32`でなくてはなりません。
            n / 2
            // TODO ^ セミコロン`;`をつけて返り値を返さないようにしてみましょう
        };
    //   ^ ここにセミコロンを付けるのを忘れないように！
    //   `let`による変数束縛の際には必ず必要です。

    println!("{} -&gt; {}", n, big_n);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="loop"><a class="header" href="#loop">loop</a></h1>
<p>Rustには<code>loop</code>というキーワードが存在します。これは無限ループを作成するのに使用します。</p>
<p>ループから抜けだす時は<code>break</code>、即座に次のループに移るときは<code>continue</code>が使用できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut count = 0u32;

    println!("Let's count until infinity!");

    // 無限ループ
    loop {
        count += 1;

        if count == 3 {
            println!("three");

            // 残りの処理をスキップ。
            continue;
        }

        println!("{}", count);

        if count == 5 {
            println!("OK, that's enough");

            // ループを抜ける。
            break;
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ネストとラベル"><a class="header" href="#ネストとラベル">ネストとラベル</a></h1>
<p>ネストしたループを回している時に外側のループを<code>break</code>または<code>continue</code>したい場合があります。こういった場合には<code>'label</code>を用いてループにラベルを貼り、<code>break</code>/<code>continue</code>にそのラベルを渡します。</p>
<pre class="playground"><code class="language-rust editable edition2021">#![allow(unreachable_code, unused_labels)]

fn main() {
    'outer: loop {
        println!("Entered the outer loop");

        'inner: loop {
            println!("Entered the inner loop");

            // これは内側のループのみを中断します。
            //break;

            // こちらは外側を中断します。
            break 'outer;
        }

        println!("This point will never be reached");
    }

    println!("Exited the outer loop");
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="loopが返す値"><a class="header" href="#loopが返す値">loopが返す値</a></h1>
<p><code>loop</code>の用途のひとつに「成功するまである処理を再試行する」ことがあります。もしその処理が値を返すならば、それをコードの他の部分に渡す必要があるでしょう。<code>break</code>の後に値を置くと、それが<code>loop</code>式の値として返されます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="while"><a class="header" href="#while">while</a></h1>
<p><code>while</code>キーワードは条件が真である限り実行され続けるループのために使用します。</p>
<p>悪名高い<a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz問題</a>を<code>while</code>を用いて解いてみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // カウンタとなる変数
    let mut n = 1;

    // `n`が101より小さい場合のループ
    while n &lt; 101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }

        // カウンタに1を追加。
        n += 1;
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="forループ"><a class="header" href="#forループ">forループ</a></h1>
<h2 id="for-と-range"><a class="header" href="#for-と-range">for と range</a></h2>
<p><code>for in</code>構文を用いることで、イテレータのそれぞれの要素に対して処理をすることが可能です。イテレータを作る最も単純な方法は<code>a..b</code>のような範囲記法です。これは「<code>a</code>」から「<code>b</code>のひとつ前」までの要素を順に生成します。</p>
<p>では<code>while</code>の代わりに<code>for</code>を用いてFizzBuzzを書いてみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `n`は1, 2, ...., 100のそれぞれの値を取ります。
    for n in 1..101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
    }
}</code></pre>
<p>上記の代わりに<code>a..=b</code>を用いると、両端の値を含む範囲を指定できます。上記の例は次のように書けます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `n`は1, 2, ...., 100のそれぞれの値を取ります。
    for n in 1..=100 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
    }
}</code></pre>
<h2 id="forとイテレータ"><a class="header" href="#forとイテレータ">forとイテレータ</a></h2>
<p><code>for in</code>構文はイテレータとさまざまな方法でやり取りできます。<a href="#イテレータ">Iterator</a>トレイトの章で説明したように、デフォルトでは<code>for</code>ループにおいて<code>into_iter</code>関数がコレクションに対して適用されます。しかし、コレクションをイテレータに変換する方法はこれだけではありません。</p>
<p><code>into_iter</code>、<code>iter</code>、<code>iter_mut</code>はいずれもコレクションのイテレータへの変換を行いますが、データの「見せ方」の違いにより、そのやり方はそれぞれ異なります。</p>
<ul>
<li><code>iter</code> - この関数は、各周回においてコレクションの要素を借用します。よってコレクションには手を加えないので、ループの実行後もコレクションを再利用できます。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter() {
        match name {
            &amp;"Ferris" =&gt; println!("There is a rustacean among us!"),
            // TODO ^ Try deleting the &amp; and matching just "Ferris"
            _ =&gt; println!("Hello {}", name),
        }
    }

    println!("names: {:?}", names);
}</code></pre>
<ul>
<li><code>into_iter</code> - この関数はコレクションからデータを取り出すので、各周回において要素のデータそのものが提供されます。データを取り出してしまうと、データはループ内に「移動」してしまうので、ループ実行後にコレクションを再利用することはできません。</li>
</ul>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.into_iter() {
        match name {
            "Ferris" =&gt; println!("There is a rustacean among us!"),
            _ =&gt; println!("Hello {}", name),
        }
    }

    println!("names: {:?}", names);
    // FIXME ^ この行をコメントアウトしましょう
}</code></pre>
<ul>
<li><code>iter_mut</code> - この関数はコレクションの各要素をミュータブル（変更可能）で借用するので、コレクションの要素をその場で変更できます。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut "Ferris" =&gt; "There is a rustacean among us!",
            _ =&gt; "Hello",
        }
    }

    println!("names: {:?}", names);
}</code></pre>
<p>上記に示した3つのコードにおいて、<code>match</code>の選択肢の型の違いに注意してください。ここがそれぞれの方法の違いを生む鍵になっています。型が異なれば、当然ながらそれに対して行える処理も変わります。</p>
<h3 id="参照-14"><a class="header" href="#参照-14">参照</a></h3>
<p><a href="#イテレータ">イテレータ</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="match"><a class="header" href="#match">match</a></h1>
<p>Rustは<code>match</code>を用いて、C言語における<code>switch</code>のようなパターンマッチングを行うことができます。マッチする最初のアームが評価され、取りうるすべての値はカバーされていなければなりません。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let number = 13;
    // TODO ^ `number` の値を変えて試してみましょう。

    println!("Tell me about {}", number);
    match number {
        // 単一の値とのマッチをチェック。
        1 =&gt; println!("One!"),
        // いくつかの値とのマッチをチェック。
        2 | 3 | 5 | 7 | 11 =&gt; println!("This is a prime"),
        // TODO ^ 素数のリストに13を加えてみましょう。
        // 特定の範囲の値とのマッチをチェック。
        13..=19 =&gt; println!("A teen"),
        // その他の場合の処理
        _ =&gt; println!("Ain't special"),
        // TODO ^ この全てをキャッチするアームをコメントアウトしてみましょう。
    }

    let boolean = true;
    // マッチは式でもあります。
    let binary = match boolean {
        // マッチは全ての可能な値をカバーしなくてはなりません。
        false =&gt; 0,
        true =&gt; 1,
        // TODO ^ 試しに片方をコメントアウトしてみましょう。
    };

    println!("{} -&gt; {}", boolean, binary);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="デストラクト"><a class="header" href="#デストラクト">デストラクト</a></h1>
<p><code>match</code>は値をさまざまなやり方でデストラクトすることができます。</p>
<ul>
<li><a href="#タプル-1">タプルのデストラクト</a></li>
<li><a href="#配列とスライス-1">配列とスライスのデストラクト</a></li>
<li><a href="#列挙型-1">列挙型のデストラクト</a></li>
<li><a href="#ポインタとref">ポインタのデストラクト</a></li>
<li><a href="#構造体-1">構造体のデストラクト</a></li>
</ul>
<h3 id="参照-15"><a class="header" href="#参照-15">参照</a></h3>
<p><a href="https://doc.rust-lang.org/reference/patterns.html#r-patterns.destructure">The Rust Reference for Destructuring</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="タプル-1"><a class="header" href="#タプル-1">タプル</a></h1>
<p>以下のように、タプルは<code>match</code>を用いてデストラクトすることができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let triple = (0, -2, 3);
    // TODO ^ `triple`に別の値を入れてみましょう。

    println!("Tell me about {:?}", triple);
    // `match`を用いてタプルをデストラクトしてみましょう。
    match triple {
        // 2つ目と3つ目の要素をデストラクト。
        (0, y, z) =&gt; println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..)  =&gt; println!("First is `1` and the rest doesn't matter"),
        (.., 2)  =&gt; println!("last is `2` and the rest doesn't matter"),
        (3, .., 4)  =&gt; println!("First is `3`, last is `4`, and the rest doesn't matter"),
        // `..`を使うと、タプルの残りの部分を無視できます。
        _      =&gt; println!("It doesn't matter what they are"),
        // ここでは`_`は、値を変数に束縛しないことを意味します。
    }
}</code></pre>
<h3 id="参照-16"><a class="header" href="#参照-16">参照</a></h3>
<p><a href="#タプル">タプル</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="配列とスライス-1"><a class="header" href="#配列とスライス-1">配列とスライス</a></h1>
<p>タプル同様、配列とスライスも以下のようにデストラクトできます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 配列中の値を変更してみましょう。または、スライスにしてみましょう。
    let array = [1, -2, 6];

    match array {
        // 2番目と3番目の要素を変数に束縛します。
        [0, second, third] =&gt;
            println!("array[0] = 0, array[1] = {}, array[2] = {}", second, third),

        // _で値を無視できます。
        [1, _, third] =&gt; println!(
            "array[0] = 1, array[2] = {} and array[1] was ignored",
            third
        ),

        // いくつかの値を束縛して残りを無視できます。
        [-1, second, ..] =&gt; println!(
            "array[0] = -1, array[1] = {} and all the other ones were ignored",
            second
        ),
        // 以下のコードはコンパイルできません。
        // [-1, second] =&gt; ...

        // 別の配列やスライスに値を持たせることもできます。
        // (配列かスライスかは、マッチする値の型により異なります)
        [3, second, tail @ ..] =&gt; println!(
            "array[0] = 3, array[1] = {} and the other elements were {:?}",
            second, tail
        ),

        // 例えば、これらのパターンを組み合わせて、
        // 最初と最後の値を束縛し、残りの値を配列に持たせることもできます。
        [first, middle @ .., last] =&gt; println!(
            "array[0] = {}, middle = {:?}, array[2] = {}",
            first, middle, last
        ),
    }
}</code></pre>
<h3 id="参照-17"><a class="header" href="#参照-17">参照</a></h3>
<p><a href="#配列とスライス">配列とスライス</a>, @マークについては<a href="#束縛">束縛</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="列挙型-1"><a class="header" href="#列挙型-1">列挙型</a></h1>
<p>列挙型も似たやり方でデストラクトすることができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `allow`は値を一つだけ使用したことによる警告を抑えるために存在します。
#[allow(dead_code)]
enum Color {
    // これら3つの値は名前のみで扱うことができます。
    Red,
    Blue,
    Green,
    // 以下の値は名前と`u32`のタプルをペアにしています。
    // カラーモデルと呼ばれます。
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // TODO ^ `color`に別の値を入れてみましょう。

    println!("What color is it?");
    // `enum`は`match`を利用してデストラクトすることができます。
    match color {
        Color::Red   =&gt; println!("The color is Red!"),
        Color::Blue  =&gt; println!("The color is Blue!"),
        Color::Green =&gt; println!("The color is Green!"),
        Color::RGB(r, g, b) =&gt;
            println!("Red: {}, green: {}, and blue: {}!", r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!("Hue: {}, saturation: {}, value: {}!", h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!("Hue: {}, saturation: {}, lightness: {}!", h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}!", c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}, key (black): {}!",
                c, m, y, k),
        // 全ての値を列挙したのでその他の場合の処理は必要ありません。
    }
}</code></pre>
<h3 id="参照-18"><a class="header" href="#参照-18">参照</a></h3>
<p><a href="#dead_code"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">カラーモデル</a>, <a href="#列挙型">列挙型</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ポインタとref"><a class="header" href="#ポインタとref">ポインタとref</a></h1>
<p>Rustのポインタは、C/C++のポインタとは異なる概念なので、デストラクトとデリファレンスを同じようなやり方で扱うことはできません。</p>
<ul>
<li>デリファレンスには<code>*</code>を用います。</li>
<li>デストラクトには<code>&amp;</code>, <code>ref</code>, <code>ref mut</code>を用います。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `i32`型への参照を代入します。
    // `&amp;`によって参照であることを明示しています。
    let reference = &amp;4;

    match reference {
        // 上で定義した`reference`という変数が`&amp;val`とのパターンマッチ
        // に用いられた場合、以下の2つの値が比較されていることになります。
        // `&amp;i32`
        // `&amp;val`
        // ^ よって`&amp;`を落とせば、`i32`が`val`に代入されることがわかります。
        &amp;val =&gt; println!("Got a value via destructuring: {:?}", val),
    }

    // `&amp;`を使用したくない場合は、マッチングの前にデリファレンスします。
    match *reference {
        val =&gt; println!("Got a value via dereferencing: {:?}", val),
    }

    // いきなり参照を変数に代入するのではない場合はどうでしょう。
    // 先ほどは右辺値が`&amp;`で始まっていたので参照でしたが、
    // これは違います。
    let _not_a_reference = 3;

    // このような場合、Rustでは変数束縛時に`ref`を宣言します。
    // 要素の参照が作られて、それが束縛対象になります。
    let ref _is_a_reference = 3;

    // 同様にミュータブルな値の場合`ref mut`を使用することで参照を
    // 取得できます。イミュータブルの場合と合わせてみていきましょう。
    let value = 5;
    let mut mut_value = 6;

    // `ref`を使用して参照を作成。
    match value {
        ref r =&gt; println!("Got a reference to a value: {:?}", r),
    }

    // 同様に`ref mut`を使用。
    match mut_value {
        ref mut m =&gt; {
            // 参照を取得、値を変更するためにはデリファレンスします。
            *m += 10;
            println!("We added 10. `mut_value`: {:?}", m);
        },
    }
}</code></pre>
<h3 id="参照-19"><a class="header" href="#参照-19">参照</a></h3>
<p><a href="#refパターン">ref パターン</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="構造体-1"><a class="header" href="#構造体-1">構造体</a></h1>
<p>以下のようにして、構造体も同様にデストラクトすることができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    // 構造体の中の値を変えて、何が起きるか見てみましょう。
    let foo = Foo { x: (1, 2), y: 3 };

    match foo {
        Foo { x: (1, b), y } =&gt; println!("First of x is 1, b = {},  y = {} ", b, y),

        // 構造体をデストラクトして変数をリネーム。
        // 順番は重要ではありません。
        Foo { y: 2, x: i } =&gt; println!("y is 2, i = {:?}", i),

        // 一部の変数を無視することもできます。
        Foo { y, .. } =&gt; println!("y = {}, we don't care about x", y),
        // `x`に言及していないため、以下はエラーになります。
        //Foo { y } =&gt; println!("y = {}", y),
    }

    let faa = Foo { x: (1, 2), y: 3 };

    // matchを使わずとも構造体はデストラクトできます。
    let Foo { x : x0, y: y0 } = faa;
    println!("Outside: x0 = {x0:?}, y0 = {y0}");

    // ネストした構造体もデストラクトできます。
    struct Bar {
        foo: Foo,
    }

    let bar = Bar { foo: faa };
    let Bar { foo: Foo { x: nested_x, y: nested_y } } = bar;
    println!("Nested: nested_x = {nested_x:?}, nested_y = {nested_y:?}");
}</code></pre>
<h3 id="参照-20"><a class="header" href="#参照-20">参照</a></h3>
<p><a href="#構造体">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ガード"><a class="header" href="#ガード">ガード</a></h1>
<p><code>match</code>内の条件文をフィルタリングするために、 <em>ガード</em> を使用することができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">#[allow(dead_code)]
enum Temperature {
    Celsius(i32),
    Fahrenheit(i32),
}

fn main() {
    let temperature = Temperature::Celsius(35);
    // ^ TODO `temperature`の値を変更してみましょう。

    match temperature {
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!("{}C is above 30 Celsius", t),
        //                         ^ `if`とそれに続く条件式がガードです。
        Temperature::Celsius(t) =&gt; println!("{}C is equal to or below 30 Celsius", t),

        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!("{}F is above 86 Fahrenheit", t),
        Temperature::Fahrenheit(t) =&gt; println!("{}F is equal to or below 86 Fahrenheit", t),
    }
}</code></pre>
<p>パターンが全てカバーされているかどうかを判断する際に、ガード条件は考慮されないことに注意してください。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    let number: u8 = 4;

    match number {
        i if i == 0 =&gt; println!("Zero"),
        i if i &gt; 0 =&gt; println!("Greater than zero"),
        // _ =&gt; unreachable!("Should never happen."),
        // TODO ^ アンコメントしてコンパイルエラーを直してみましょう。
    }
}</code></pre>
<h3 id="参照-21"><a class="header" href="#参照-21">参照</a></h3>
<p><a href="#タプル">タプル</a> <a href="#列挙型">列挙型</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="束縛"><a class="header" href="#束縛">束縛</a></h1>
<p>いくつかの変数をまとめてマッチ対象とした場合、そのうちの一つを分岐先で使用することはそのままでは不可能です。<code>match</code>内では<code>@</code>マークを使用して変数を束縛することができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `age`関数は`u32`の値を返します。
fn age() -&gt; u32 {
    15
}

fn main() {
    println!("Tell me what type of person you are");

    match age() {
        0             =&gt; println!("I haven't celebrated my first birthday yet"),
        // Could `match` 1 ..= 12 directly but then what age
        // would the child be?
        // Could `match` n and use an `if` guard, but would
        // not contribute to exhaustiveness checks.
        // (Although in this case that would not matter since
        // a "catch-all" pattern is present at the bottom)
        // Instead, bind to `n` for the sequence of 1 ..= 12.
        // Now the age can be reported.
        n @ 1  ..= 12 =&gt; println!("I'm a child of age {:?}", n),
        n @ 13 ..= 19 =&gt; println!("I'm a teen of age {:?}", n),
        // A similar binding can be done when matching several values.
        n @ (1 | 7 | 15 | 13) =&gt; println!("I'm a teen of age {:?}", n),
        // マッチしなかった場合の処理
        n             =&gt; println!("I'm an old person of age {:?}", n),
    }
}</code></pre>
<p><code>Option</code>のような、列挙型の値をデストラクトするためにも、束縛を利用できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // Got `Some` variant, match if its value, bound to `n`,
        // is equal to 42.
        // Could also use `Some(42)` and print `"The Answer: 42!"`
        // but that would require changing `42` in 2 spots should
        // you ever wish to change it.
        // Could also use `Some(n) if n == 42` and print `"The Answer: {n}!"`
        // but that would not contribute to exhaustiveness checks.
        // (Although in this case that would not matter since
        // the next arm is a "catch-all" pattern)
        Some(n @ 42) =&gt; println!("The Answer: {}!", n),
        // それ以外の数値にマッチ。
        Some(n)      =&gt; println!("Not interesting... {}", n),
        // それ以外にマッチ（`None`の値）。
        _            =&gt; (),
    }
}</code></pre>
<h3 id="参照-22"><a class="header" href="#参照-22">参照</a></h3>
<p><a href="#関数">関数</a>, <a href="#列挙型">列挙型</a>, <a href="#option"><code>Option</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<p>列挙型をマッチさせるとき、場合によっては<code>match</code>を使用すると不自然な書き方になってしまう場合があります。例えば</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `optional`という変数の型を`Option&lt;i32&gt;`に指定。
let optional = Some(7);

match optional {
    Some(i) =&gt; println!("This is a really long string and `{:?}`", i),
    _ =&gt; {},
    // ^ `match`は全てのパターンに対して網羅的でなくてはならないので必要。
    // 冗長に見えませんか？
};

<span class="boring">}</span></code></pre>
<p>この場合は<code>if let</code>を用いたほうが美しく、失敗時の処理も柔軟に行うことができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 全て`Option&lt;i32&gt;`型
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // `if let`文は以下と同じ意味。
    // もしletがnumberをデストラクトした結果が`Some(i)`になるならば
    // ブロック内（`{}`）を実行します。
    if let Some(i) = number {
        println!("Matched {:?}!", i);
    }

    // デストラクトした結果が`Some()`にならない場合の処理を明示したい場合、
    // `else`を使用します。
    if let Some(i) = letter {
        println!("Matched {:?}!", i);
    } else {
        // デストラクト失敗の場合。このブロック内を実行。
        println!("Didn't match a number. Let's go with a letter!");
    }

    // デストラクト失敗時の処理を更に分岐させることもできます。
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!("Matched {:?}!", i);
    // デストラクト失敗。`else if`を評価し、処理をさらに分岐させます。
    } else if i_like_letters {
        println!("Didn't match a number. Let's go with a letter!");
    } else {
        // 今回は`else if`の評価がfalseなので、このブロック内がデフォルト。
        println!("I don't like letters. Let's go with an emoticon :)!");
    }
}</code></pre>
<p>同様に<code>if let</code>は任意の列挙型のマッチに使えます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// 列挙型の例
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // 変数の作成
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);

    // Foo::Barにマッチする変数
    if let Foo::Bar = a {
        println!("a is foobar");
    }

    // 変数bはFoo::Barにマッチしないので出力されません。
    if let Foo::Bar = b {
        println!("b is foobar");
    }

    // 変数cはFoo::Quxにマッチしつつ値を取り出せます。
    // これはSome()と同様です。
    if let Foo::Qux(value) = c {
        println!("c is {}", value);
    }

    // 束縛も可能です。
    if let Foo::Qux(value @ 100) = c {
        println!("c is one hundred");
    }
}</code></pre>
<p>もう一つのメリットは<code>if let</code>がパラメータを持たない列挙型にも使えることです。列挙型が<code>PartialEq</code>を実装または導出していなくても問題ありません。その場合、列挙型のインスタンスは比較できないので<code>if Foo::Bar == a</code>はコンパイルエラーとなりますが、<code>if let</code>は引き続き使えます。</p>
<p>試してみましょう。以下の例を<code>if let</code>を使って直してみてください。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// この列挙型はPartialEqを実装も導出もしていません。
// そのためFoo::Bar == aはエラーとなります。
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // Foo::Barにマッチする変数
    if Foo::Bar == a {
    // ^-- ここでコンパイルエラー。`if let`を使ってみましょう。
        println!("a is foobar");
    }
}</code></pre>
<h3 id="参照-23"><a class="header" href="#参照-23">参照</a></h3>
<p><a href="#列挙型">列挙型</a>, <a href="#option"><code>Option</code></a>, <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="let-else"><a class="header" href="#let-else">let-else</a></h1>
<blockquote>
<p>🛈 Rust 1.65で安定化。</p>
<p>🛈 エディションを指定するには<code>rustc --edition=2021 main.rs</code>のようにします。</p>
</blockquote>
<p><code>let</code>-<code>else</code>を使うと反駁できるパターンにマッチさせつつ、通常の<code>let</code>のように変数束縛することができます。マッチしなかった場合は（<code>break</code>、<code>return</code>、<code>panic!</code>のように）処理を分岐させます。</p>
<pre class="playground"><code class="language-rust edition2021">use std::str::FromStr;

fn get_count_item(s: &amp;str) -&gt; (u64, &amp;str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    (count, item)
}

fn main() {
    assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
}</code></pre>
<p>束縛した変数名のスコープが<code>match</code>や<code>if let</code>-<code>else</code>式との主な違いです。<code>match</code>や<code>if let</code>-<code>else</code>でも似たようなことができますが、残念ながらコードの繰り返しや追加の<code>let</code>が必要になってしまいます。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">fn get_count_item(s: &amp;str) -&gt; (u64, &amp;str) {
</span><span class="boring">    let mut it = s.split(' ');
</span>    let (count_str, item) = match (it.next(), it.next()) {
        (Some(count_str), Some(item)) =&gt; (count_str, item),
        _ =&gt; panic!("Can't segment count item pair: '{s}'"),
    };
    let count = if let Ok(count) = u64::from_str(count_str) {
        count
    } else {
        panic!("Can't parse integer: '{count_str}'");
    };
<span class="boring">    (count, item)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
</span><span class="boring">}</span></code></pre>
<h3 id="参照-24"><a class="header" href="#参照-24">参照</a></h3>
<p><a href="#option">Option</a>, <a href="#match">match</a>, <a href="#if-let">if let</a>, <a href="https://rust-lang.github.io/rfcs/3137-let-else.html">let-else RFC</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="while-let"><a class="header" href="#while-let">while let</a></h1>
<p><code>if let</code>と同様に、<code>while let</code>も不格好な<code>match</code>処理を多少マシにしてくれます。例えば、以下の<code>i</code>をインクリメントする処理を見てください。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `optional`という変数の型を`Option&lt;i32&gt;`に指定。
let mut optional = Some(0);

// 変数の照合を繰り返し行います。
loop {
    match optional {
        // もし`optional`のデストラクトに成功した場合、値に応じて処理を分岐。
        Some(i) =&gt; {
            if i &gt; 9 {
                println!("Greater than 9, quit!");
                optional = None;
            } else {
                println!("`i` is `{:?}`. Try again.", i);
                optional = Some(i + 1);
            }
            // ^ 3つものインデントが必要。
        },
        // デストラクトに失敗した場合、ループを脱出。
        _ =&gt; { break; }
        // ^ どうしてこんな行を書く必要が？もっと良い方法があるはずです！
    }
}
<span class="boring">}</span></code></pre>
<p><code>while let</code>を使ってすっきり書くことができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `optional`という変数の型を`Option&lt;i32&gt;`に指定。
    let mut optional = Some(0);

    // これは次のように読めます。「`let`が`optional`を`Some(i)`にデストラクト
    // している間はブロック内（`{}`）を評価せよ。さもなくば`break`せよ。」
    while let Some(i) = optional {
        if i &gt; 9 {
            println!("Greater than 9, quit!");
            optional = None;
        } else {
            println!("`i` is `{:?}`. Try again.", i);
            optional = Some(i + 1);
        }
        // ^ インデントが少なく、デストラクト失敗時の処理を追加する必要がありません。
    }
    // ^ `if let`の場合は`else`/`else if`句が一つ余分にありましたが、
    // `while let`では必要ありません。
}</code></pre>
<h3 id="参照-25"><a class="header" href="#参照-25">参照</a></h3>
<p><a href="#列挙型">列挙型</a>, <a href="#option"><code>Option</code></a>, <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関数"><a class="header" href="#関数">関数</a></h1>
<p>関数は<code>fn</code>キーワードを用いて定義することができます。引数は変数と同様に型を指定する必要があり、もし関数が値を返すならば<code>-&gt;</code>の後にその型も指定する必要があります。</p>
<p>関数内の最後の式が返り値となります。関数の途中で値を返したい場合は<code>return</code>文を使用します。ループの最中や<code>if</code>文の中からも値を返すことができます。</p>
<p>では、今度は関数を使ってFizzBuzz問題を解いてみましょう！</p>
<pre class="playground"><code class="language-rust editable edition2021">// C/C++とは違い、関数の定義を行う順番に制限はありません。
fn main() {
    // ここで関数を使用し、後ほど定義してもかまいません。
    fizzbuzz_to(100);
}

// ブーリアン型を返す関数
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // 例外的な引数を受けた場合、早めに返します。
    if rhs == 0 {
        return false;
    }

    // これは式であり、`return`キーワードは必要ありません。
    lhs % rhs == 0
}

// 値を「返さない」関数、実際にはユニット型（`()`）を返しています。
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!("fizzbuzz");
    } else if is_divisible_by(n, 3) {
        println!("fizz");
    } else if is_divisible_by(n, 5) {
        println!("buzz");
    } else {
        println!("{}", n);
    }
}

// 関数が`()`を返すとき、返り値の型は省略できます。
fn fizzbuzz_to(n: u32) {
    for n in 1..=n {
        fizzbuzz(n);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関連関数とメソッド"><a class="header" href="#関連関数とメソッド">関連関数とメソッド</a></h1>
<p>関数には特定の型に紐づいたものがあります。これには関連関数とメソッドの2つの形式があります。メソッドは特定のインスタンスに関連付けて呼ばれる関数であるのに対し、関連関数は型全体に対して定義される関数です。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: f64,
    y: f64,
}

// 実装のためのブロック。`Point`の持つ関連関数とメソッドを全て定義します。
impl Point {
    // これは特定の型（すなわち Point）に関連した関数なので関連関数
    //
    // 関連関数はインスタンスからでなく呼び出すことができます。
    // 以下のようにコンストラクタとしてよく使用されます。
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // 引数を2つ取る関連関数
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // こちらはメソッド。`&amp;self`は`self: &amp;Self`の糖衣構文。
    // `Self`は呼び出し元オブジェクトの型。この場合は`Rectangle`。
    fn area(&amp;self) -&gt; f64 {
        // `self`はドット演算子によって構造体のフィールドを参照できます。
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs`は`f64`のメソッドで、呼び出し元の値の絶対値を返します。
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // このメソッドは呼び出し元オブジェクトがミュータブルであることを
    // 必要とします。`&amp;mut self`は`self: &amp;mut Self`の糖衣構文です。
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair`はヒープ上の整数を2つ保持します。
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // このメソッドは呼び出し元オブジェクトを「消費」します。
    // `self`は`self: Self`の糖衣構文です。
    fn destroy(self) {
        // `self`をデストラクト。
        let Pair(first, second) = self;

        println!("Destroying Pair({}, {})", first, second);

        // `first`、`second`はスコープから抜け出すと同時に、解放されます。
    }
}

fn main() {
    let rectangle = Rectangle {
        // 関連関数はコロンを2つ挟んで呼び出すことができます。
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // メソッドはドット演算子を用いて呼び出されます。
    // 最初の引数`&amp;self`は明示せずに受け渡されていることに注目。つまり
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!("Rectangle perimeter: {}", rectangle.perimeter());
    println!("Rectangle area: {}", rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // エラー！`rectangle`はイミュータブルですがこのメソッドは
    // ミュータブルなオブジェクトを必要とします。
    //rectangle.translate(1.0, 0.0);
    // TODO ^ この行をアンコメントしてみましょう。

    // OK！ミュータブルなオブジェクトはミュータブルなメソッドを呼び出せます。
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // エラー！先ほどの`destroy`で`pair`はすでに消費されてしまっています。
    //pair.destroy();
    // TODO ^ この行をアンコメントしてみましょう。
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="クロージャ"><a class="header" href="#クロージャ">クロージャ</a></h1>
<p>Rustにおけるクロージャは、その外側の環境を捕捉した関数のことです。例えば、次のコードは変数<code>x</code>を捕捉したクロージャです。</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<p>クロージャの構文や機能は、その場限りの用途で何かを作るのに便利です。クロージャの呼び出しは関数の呼び出しと全く同じです。しかし、入力の型と戻り値の型は推論させることができますが、入力変数の名前は必ず指定しなくてはなりません。</p>
<p>クロージャの他の特徴を以下に示します。</p>
<ul>
<li>入力変数を囲むのに、<code>()</code>の代わりに<code>||</code>を用います。</li>
<li>本体が単一の式の場合は、本体の区切り文字（<code>{}</code>）を省略できます。（それ以外の場合は必須です）</li>
<li>外側の環境にある変数を捕捉することができます。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let outer_var = 42;

    // 通常の関数は周辺の環境の変数を参照できません。
    //fn function(i: i32) -&gt; i32 { i + outer_var }
    // TODO: 上の行をアンコメントしてコンパイルエラーを見てみましょう。
    // 代わりにクロージャを定義することをコンパイラが提案してくれます。

    // クロージャは匿名なので、参照に束縛して使います。
    // 型アノテーションは、通常の関数と同様の方法で行えますが、必須ではありません。
    // `{}`も必須ではありません。
    // このように定義した無名関数を適切な名前の変数に代入します。
    let closure_annotated = |i: i32| -&gt; i32 { i + outer_var };
    let closure_inferred  = |i     |          i + outer_var  ;

    // クロージャを呼び出す。
    println!("closure_annotated: {}", closure_annotated(1));
    println!("closure_inferred: {}", closure_inferred(1));
    // クロージャの型が一度推論されると、別の型にあらためて推論することはできません。
    //println!("cannot reuse closure_inferred with another type: {}", closure_inferred(42i64));
    // TODO: 上の行をアンコメントしてコンパイルエラーを見てみましょう。

    // 引数なしで`i32`を返すクロージャ。
    // 戻り値の型は推論されます。
    let one = || 1;
    println!("closure returning one: {}", one());

}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="要素の捕捉"><a class="header" href="#要素の捕捉">要素の捕捉</a></h1>
<p>クロージャはとてもフレキシブルに動作するように出来ています。クロージャにおいて型アノテーションをする必要が無いのは前述の仕組みのためですが、この仕組みのおかげでユースケースに応じて参照を取得したり値そのものを取得したりといった動作が可能になります。クロージャは外側の環境にある要素を、以下の形で取得することができます。</p>
<ul>
<li>参照：<code>&amp;T</code></li>
<li>ミュータブルな参照：<code>&amp;mut T</code></li>
<li>値そのもの：<code>T</code></li>
</ul>
<p>クロージャは出来る限り参照を取得しようとし、その他2つは必要なときのみ取得します。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    use std::mem;

    let color = String::from("green");

    // A closure to print `color` which immediately borrows (`&amp;`) `color` and
    // stores the borrow and closure in the `print` variable. It will remain
    // borrowed until `print` is used the last time.
    //
    // `println!` only requires arguments by immutable reference so it doesn't
    // impose anything more restrictive.
    let print = || println!("`color`: {}", color);

    // 借用を行ったクロージャを呼び出します。
    print();

    // `color` can be borrowed immutably again, because the closure only holds
    // an immutable reference to `color`.
    let _reborrow = &amp;color;
    print();

    // 最後に`print`を使用した後は移動や再借用が許可されます。
    let _color_moved = color;


    let mut count = 0;
    // `count`をインクリメントするためのクロージャ。`count`と`&amp;mut count`
    // の両方を取ることができますが、後者のほうが制限が少ないため、
    // （訳注: `count`だと`&amp;mut count`と違い、一度しか呼ぶことができない。）
    // そちらを取ります。直後に`count`を借用します。
    //
    // `inc`には`mut`をつける必要があります。なぜならミュータブルな型が
    // 中で使用されているからです。ミュータブルなクロージャは呼ぶたびに
    // 内部変数を変更します。
    let mut inc = || {
        count += 1;
        println!("`count`: {}", count);
    };

    // ミュータブルな借用を使ってクロージャを実行。
    inc();

    // The closure still mutably borrows `count` because it is called later.
    // An attempt to reborrow will lead to an error.
    // let _reborrow = &amp;count;
    // ^ TODO: try uncommenting this line.
    inc();

    // クロージャはもう`&amp;mut count`を借用する必要がありません。
    // なので、エラーを起こさず再借用することができます。
    let _count_reborrowed = &amp;mut count;


    // コピー不可能な型
    let movable = Box::new(3);

    // `mem::drop`は`T`（ジェネリック型）を取る必要があるため、このクロージャは
    // 参照ではなく値を取ります。その場合、もしもコピー可能な値ならば、
    // 元の値はそのままでコピーのみを取ります。
    // 不可能ならば値そのものを移動させます。
    let consume = || {
        println!("`movable`: {:?}", movable);
        mem::drop(movable);
    };

    // `consume`は変数を消費（開放）するため、一度しか呼び出すことができません。
    consume();
    // consume();
    // ^ TODO: この行のコメントアウトを解除しましょう。
}</code></pre>
<p>バーティカルパイプ（訳注：縦線記号<code>||</code>）の前に<code>move</code>を使用することで、キャプチャする変数の所有権を取ることをクロージャに強制します。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // `Vec`はコピーセマンティクスではない。
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!("{}", contains(&amp;1));
    println!("{}", contains(&amp;4));

    // println!("There're {} elements in vec", haystack.len());
    // ^ 上の行のコメントアウトを解除すると、コンパイル時エラーになります。
    // これは変数の所有権が移った後の再利用を借用チェッカーが許可しないからです。

    // クロージャのシグネチャから`move`を削除すると、クロージャは
    // _haystack_ 変数をイミュータブルで借用するようになります。
    // そのため _haystack_ はまだ利用可能となり、上の行のコメントアウトを
    // 解除してもエラーが発生しなくなります。
}</code></pre>
<h3 id="参照-26"><a class="header" href="#参照-26">参照</a></h3>
<p><a href="#boxスタックとヒープ"><code>Box</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="捕捉時の型推論"><a class="header" href="#捕捉時の型推論">捕捉時の型推論</a></h1>
<p>Rustはたいていの場合、型アノテーションなしでも変数を捕捉する方法を臨機応変に選択してくれますが、関数を書く場合にはこの曖昧さは許されません。引数のパラメータとしてクロージャを取る場合、そのクロージャの完全な型はいくつかの<code>traits</code>の中の1つを使って明示されなければなりません。どれが使われるかは、捕捉された値でクロージャが何をするかによって決まります。制限の少ない順に並べると、下記の通りです。</p>
<ul>
<li><code>Fn</code>：参照（<code>&amp;T</code>）によって捕捉するクロージャ</li>
<li><code>FnMut</code>：ミュータブルな参照（<code>&amp;mut T</code>）によって捕捉するクロージャ</li>
<li><code>FnOnce</code>：値（<code>T</code>）によって捕捉するクロージャ</li>
</ul>
<p>変数ごとに、コンパイラは可能な限り制約の少ない方法でその変数を捕捉します。</p>
<p>例えば、<code>FnOnce</code>というアノテーションの付けられたパラメータを考えてみましょう。これはそのクロージャが<code>&amp;T</code>、<code>&amp;mut T</code>もしくは<code>T</code>の <em>どれか</em> で捕捉することを指定するものですが、コンパイラは捕捉した変数がそのクロージャの中でどのように使用されるかに基づき、最終的に捕捉する方法を選択することになります。</p>
<p>これは、もし移動が可能であれば、いずれの種類の借用であっても同様に可能だからです。その逆は正しくないことに注意してください。パラメータが<code>Fn</code>としてアノテーションされている場合、変数を<code>&amp;mut T</code>や<code>T</code>で捕捉することは許可されません。しかし<code>&amp;T</code>は許可されます。</p>
<p>以下の例で、<code>Fn</code>、<code>FnMut</code>、および<code>FnOnce</code>を入れ替えて、何が起こるのかを見てみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">// クロージャを引数として取り、クロージャを呼び出す関数。
// &lt;F&gt;はFが「ジェネリックな型パラメータ」であることを示します。
fn apply&lt;F&gt;(f: F) where
    // クロージャには引数も返り値もありません。
    F: FnOnce() {
    // ^ TODO: ここを`Fn`あるいは`FnMut`に変えてみましょう。

    f();
}

// クロージャを引数に取り、`i32`を返す関数
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // このクロージャは引数、返り値ともに`i32`。
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = "hello";
    // コピーではなくmoveが起きる型
    let mut farewell = "goodbye".to_owned();

    // 変数を2つ捕捉。`greeting`は参照を、
    // `farewell`は値をそれぞれ捕捉します。
    let diary = || {
        // `greeting`は参照なので、`Fn`が必要です。
        println!("I said {}.", greeting);

        // `farewell`の値を変更するので、この時点で`FnMut`
        // が必要になります。
        farewell.push_str("!!!");
        println!("Then I screamed {}.", farewell);
        println!("Now I can sleep. zzzzz");

        // `mem::drop`を明示的に呼ぶと`farewell`が値で
        // 捕捉される必要性が発生します。よって`FnOnce`が必要になります。
        mem::drop(farewell);
    };

    // クロージャを適用する関数を実行。
    apply(diary);

    // `double`は`apply_to_3`のトレイト境界を満たす。
    let double = |x| 2 * x;

    println!("3 doubled: {}", apply_to_3(double));
}</code></pre>
<h3 id="参照-27"><a class="header" href="#参照-27">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="#ジェネリクス">ジェネリクス</a>, <a href="#where句">where</a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="匿名型"><a class="header" href="#匿名型">匿名型</a></h1>
<p>クロージャが周辺の環境から変数を取得するやり方は非常に明瞭です。何か注意すべき点はあるのでしょうか？もちろんです。関数内でクロージャを使う場合、<a href="#ジェネリクス">ジェネリクス</a>を使用する必要があります。詳しく見ていきましょう。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `F` はジェネリック型でなくてはなりません。
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
<span class="boring">}</span></code></pre>
<p>クロージャが定義されると、コンパイラは裏側で、無名の構造体を作り、そこにクロージャによって使用される外側の変数を入れます。同時に<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>という名のトレイトのいずれか一つを介してこの構造体に関数としての機能を実装し、実際に呼び出されるまで待ちます。</p>
<p>この無名構造体は型が未指定なため、関数を実行する際にはジェネリクスが必要とされます。とはいえ、<code>&lt;T&gt;</code>で指定するだけでは、まだ曖昧です。（訳注：<code>&amp;self</code>、<code>&amp;mut self</code>、<code>self</code>のいずれをとるのかがわからないため）そのため、<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>のいずれか一つを実装することで対応しています。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `F`は引数と戻り値を持たないクロージャ`Fn`を実装していなくてはなりません。
// これはまさに`print`に必要とされるものです。
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // `x`を無名の構造体に入れ、それに対し`Fn`を実装します。
    // （訳注: ここでは`Fn`は`fn Fn(&amp;self) -&gt; {println!("{}", &amp;self)}`）
    // その構造体を`print`に代入します。
    let print = || println!("{}", x);

    apply(print);
}</code></pre>
<h3 id="参照-28"><a class="header" href="#参照-28">参照</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">徹底解説</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関数を受け取る関数"><a class="header" href="#関数を受け取る関数">関数を受け取る関数</a></h1>
<p>これまで、クロージャを引数として渡せることを見てきました。すると次の疑問が浮かんできます。「クロージャではない普通の関数を引数として渡すことは可能なのだろうか？」可能です！もしパラメータとしてクロージャを取る関数を定義すれば、そのクロージャのトレイト境界を満たす任意の関数をパラメータとして渡すことができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// 関数を引数として取り、即座に実行する関数を定義。
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// `Fn`境界を満たすラッパ関数を定義。
fn function() {
    println!("I'm a function!");
}

fn main() {
    // `Fn`境界を満たすクロージャを定義。
    let closure = || println!("I'm a closure!");

    call_me(closure);
    call_me(function);
}</code></pre>
<p>クロージャによる変数の捕捉がどのように行われているかを詳しく見たいときは<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>を参照してください。</p>
<h3 id="参照-29"><a class="header" href="#参照-29">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="クロージャを返す関数"><a class="header" href="#クロージャを返す関数">クロージャを返す関数</a></h1>
<p>クロージャを引数のパラメータとして用いることができるのと同様に、クロージャを戻り値として返すことも可能です。しかし無名のクロージャの型はその定義上、不明であるため、クロージャを返すためには<code>impl Trait</code>を使用する必要があります。</p>
<p>クロージャを返すために有効なトレイトは下記の通りです。</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p>更に、<code>move</code>というキーワードを使用し、全ての捕捉が値でおこなわれることを明示しなければなりません。これは、関数を抜けると同時に参照による捕捉がドロップされ、無効な参照がクロージャに残ってしまうのを防ぐためです。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn create_fn() -&gt; impl Fn() {
    let text = "Fn".to_owned();

    move || println!("This is a: {}", text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = "FnMut".to_owned();

    move || println!("This is a: {}", text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = "FnOnce".to_owned();

    move || println!("This is a: {}", text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}</code></pre>
<h3 id="参照-30"><a class="header" href="#参照-30">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="#ジェネリクス">ジェネリクス</a>, <a href="#impl-trait">impl Trait</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stdにおける使用例"><a class="header" href="#stdにおける使用例"><code>std</code>における使用例</a></h1>
<p>この節では<code>std</code>ライブラリを用いて、クロージャの利用例を幾つかお見せします。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="iteratorany"><a class="header" href="#iteratorany">Iterator::any</a></h1>
<p><code>iterator::any</code>は、イテレータ内に一つでも条件を満たす要素があれば、<code>true</code>を返し、さもなくば<code>false</code>を返すイテレータです。以下がそのシグネチャです</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // イテレートされる値の型
    type Item;

    // `any`は`&amp;mut self`を取るため、イテレータを呼び出した値を借用し
    // 変更しますが、消費することはありません。
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `Self::Item` is the closure parameter type,
        // which is determined by the iterator (e.g., `&amp;T` for `.iter()`,
        // `T` for `.into_iter()`).
        F: FnMut(Self::Item) -&gt; bool;
}</code></pre>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // ベクタ型に対する`iter()`は`&amp;i32`を生成するので、`i32`へとデストラクト。
    println!("2 in vec1: {}", vec1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()`の場合は`i32`を生成するので、デストラクトは必要ありません。
    println!("2 in vec2: {}", vec2.into_iter().any(|x| x == 2));

    // `iter()`は`vec1`とその要素を借用するだけなので、再び利用できます。
    println!("vec1 len: {}", vec1.len());
    println!("First element of vec1 is: {}", vec1[0]);
    // `into_iter()`は`vec2`とその要素をムーブするので、再利用できません。
    // println!("First element of vec2 is: {}", vec2[0]);
    // println!("vec2 len: {}", vec2.len());
    // TODO: 上の2行をアンコメントしてコンパイルエラーを確認しましょう。

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 配列に対する`iter()`は`&amp;i32`を生成します。
    println!("2 in array1: {}", array1.iter()     .any(|&amp;x| x == 2));
    // 配列に`into_iter()`を使うと`&amp;i32`を生成します。
    println!("2 in array2: {}", array2.into_iter().any(|x| x == 2));
}</code></pre>
<h3 id="参照-31"><a class="header" href="#参照-31">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="イテレータによる検索"><a class="header" href="#イテレータによる検索">イテレータによる検索</a></h1>
<p><code>Iterator::find</code>はイテレータを辿る関数で、条件を満たす最初の値を探します。もし条件を満たす値がなければ<code>None</code>を返します。型シグネチャは以下のようになります。</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // イテレートされる値の型
    type Item;

    // `find`は`&amp;mut self`を取るため、イテレータを呼び出した値を借用し
    // 変更しますが、消費することはありません。
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut`はクロージャによって捕捉される変数が変更される
        // 事はあっても消費されることはないということを示します。
        // `&amp;Self::Item`はクロージャが変数を参照として取ることを示します。
        P: FnMut(&amp;Self::Item) -&gt; bool;
}</code></pre>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `vec1.iter()` yields `&amp;i32`.
    let mut iter = vec1.iter();
    // `vec2.into_iter()` yields `i32`.
    let mut into_iter = vec2.into_iter();

    // `iter()` yields `&amp;i32`, and `find` passes `&amp;Item` to the predicate.
    // Since `Item = &amp;i32`, the closure argument has type `&amp;&amp;i32`,
    // which we pattern-match to dereference down to `i32`.
    println!("Find 2 in vec1: {:?}", iter.find(|&amp;&amp;x| x == 2));
    
    // `into_iter()` yields `i32`, and `find` passes `&amp;Item` to the predicate.
    // Since `Item = i32`, the closure argument has type `&amp;i32`,
    // which we pattern-match to dereference down to `i32`.
    println!("Find 2 in vec2: {:?}", into_iter.find(|&amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `array1.iter()` yields `&amp;i32`
    println!("Find 2 in array1: {:?}", array1.iter().find(|&amp;&amp;x| x == 2));
    // `array2.into_iter()` yields `i32`
    println!("Find 2 in array2: {:?}", array2.into_iter().find(|&amp;x| x == 2));
}</code></pre>
<p><code>Iterator::find</code>は要素への参照を返します。要素の <em>インデックス</em> を使用したい場合、<code>Iterator::position</code>を使用してください。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let vec = vec![1, 9, 3, 3, 13, 2];

    // `position` passes the iterator’s `Item` by value to the predicate.
    // `vec.iter()` yields `&amp;i32`, so the predicate receives `&amp;i32`,
    // which we pattern-match to dereference to `i32`.
    let index_of_first_even_number = vec.iter().position(|&amp;x| x % 2 == 0);
    assert_eq!(index_of_first_even_number, Some(5));

    // `vec.into_iter()` yields `i32`, so the predicate receives `i32` directly.
    let index_of_first_negative_number = vec.into_iter().position(|x| x &lt; 0);
    assert_eq!(index_of_first_negative_number, None);
}</code></pre>
<h3 id="参照-32"><a class="header" href="#参照-32">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find_map"><code>std::iter::Iterator::find_map</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>std::iter::Iterator::position</code></a></p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rposition"><code>std::iter::Iterator::rposition</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="高階関数"><a class="header" href="#高階関数">高階関数</a></h1>
<p>Rustには高階関数（<code>Higher Order Functions, HOF</code>）を扱う機能が備わっています。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!("Find the sum of all the numbers with odd squares under 1000");
    let upper = 1000;

    // 宣言型プログラミングによるアプローチ
    // 値を蓄積する変数を宣言。
    let mut acc = 0;
    // 0から無限までイテレートします。
    for n in 0.. {
        // 値を2乗。
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // 上限に達した場合、ループを終了。
            break;
        } else if is_odd(n_squared) {
            // 奇数ならば値を値を足しあわせていきます。
            acc += n;
        }
    }
    println!("imperative style: {}", acc);

    // 関数型プログラミングによるアプローチ
    let sum: u32 =
        (0..).take_while(|&amp;n| n * n &lt; upper) // 上限より小さい値で
             .filter(|&amp;n| is_odd(n * n))     // かつ奇数のものを
             .sum();                         // 合計します。
    println!("functional style: {}", sum);
}</code></pre>
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">Option</a> と <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">イテレータ</a> には高階関数が使用されています。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="発散する関数"><a class="header" href="#発散する関数">発散する関数</a></h1>
<p>発散する関数は決してリターンしない関数です。こうした関数は <code>!</code> を使って、空の型であることが示されます。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!("This call never returns.");
}
<span class="boring">}</span></code></pre>
<p>他の全ての型と異なり、この型はインスタンス化できません。この型が持ちうる全ての値の集合は空です。この型は<code>()</code>型とは異なることに注意してください。<code>()</code>型は値をただ1つだけ持つ型です。</p>
<p>例えば、この関数は通常どおりリターンしますが、戻り値には何の情報も含みません。</p>
<pre class="playground"><code class="language-rust edition2021">fn some_fn() {
    ()
}

fn main() {
    let _a: () = some_fn();
    println!("This function returns and you can see this line.");
}</code></pre>
<p>一方、この関数は呼び出し元に決してリターンしません。</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!("This call never returns.");
    println!("You will never see this line!");
}</code></pre>
<p>Although this might seem like an abstract concept, it is actually very useful and often handy. The main advantage of this type is that it can be cast to any other type, making it versatile in situations where an exact type is required, such as in match branches. This flexibility allows us to write code like this:</p>
<pre class="playground"><code class="language-rust edition2021">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // 変数"addition"の型がu32であるため、
            // このmatch式はu32をリターンしなければならないことに注意。
            let addition: u32 = match i%2 == 1 {
                // 変数"i"はu32型であるため、全く問題ありません。
                true =&gt; i,
                // 一方、"continue"式はu32をリターンしませんが、これでも問題ありません。
                // 決してリターンしないため、このmatch式が要求する型に違反しないからです。
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!("Sum of odd numbers up to 9 (excluding): {}", sum_odd_numbers(9));
}</code></pre>
<p>この型は、ネットワークサーバのような永遠にループする関数（例：<code>loop {}</code>）の戻り値の型や、プロセスを終了させる関数（例：<code>exit()</code>）の戻り値の型としても使用されます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="モジュール"><a class="header" href="#モジュール">モジュール</a></h1>
<p>Rustにはコードを階層的に分割し、お互いの機能を隠蔽・公開するための強力なモジュールシステムがあります。</p>
<p>モジュールは関数、構造体、トレイト、<code>impl</code>ブロック、さらには他のモジュールなどの要素の集合です。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="可視性"><a class="header" href="#可視性">可視性</a></h1>
<p>デフォルトでは、モジュール内の要素はプライベートですが、これは<code>pub</code>で修飾することでパブリックな属性にすることができます。パブリックな属性のみがモジュールの外のスコープからアクセスできます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `my_mod`という名前のモジュール
mod my_mod {
    // モジュール内の要素はデフォルトでプライベート。
    fn private_function() {
        println!("called `my_mod::private_function()`");
    }

    // `pub`を用いてパブリックに変更。
    pub fn function() {
        println!("called `my_mod::function()`");
    }

    // モジュール内からならば、プライベートな属性にアクセスできます。
    pub fn indirect_access() {
        print!("called `my_mod::indirect_access()`, that\n&gt; ");
        private_function();
    }

    // モジュールもネストできます。
    pub mod nested {
        pub fn function() {
            println!("called `my_mod::nested::function()`");
        }

        #[allow(dead_code)]
        fn private_function() {
            println!("called `my_mod::nested::private_function()`");
        }

        // `pub(in path)`形式で宣言された関数は該当のパス内でのみアクセスできます。
        // `path`は親や先祖のモジュールでなくてはなりません。
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!("called `my_mod::nested::public_function_in_my_mod()`, that\n&gt; ");
            public_function_in_nested();
        }

        // `pub(self)`形式で宣言された関数は現在のモジュール内でのみアクセスできます。
        // つまり、プライベートにするのと同じです。
        pub(self) fn public_function_in_nested() {
            println!("called `my_mod::nested::public_function_in_nested()`");
        }

        // `pub(super)`形式で宣言された関数は親モジュール内でのみアクセスできます。
        pub(super) fn public_function_in_super_mod() {
            println!("called `my_mod::nested::public_function_in_super_mod()`");
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!("called `my_mod::call_public_function_in_my_mod()`, that\n&gt; ");
        nested::public_function_in_my_mod();
        print!("&gt; ");
        nested::public_function_in_super_mod();
    }

    // pub(crate)により関数は現在のクレート内でのみアクセスできます。
    pub(crate) fn public_function_in_crate() {
        println!("called `my_mod::public_function_in_crate()`");
    }

    // ネストしたモジュールも、同様の性質を示します。
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!("called `my_mod::private_nested::function()`");
        }

        // 親がプライベートな場合、子要素がより大きなスコープでアクセスできるように宣言されていても、
        // 子要素にアクセス可能な範囲は制限されます。
        #[allow(dead_code)]
        pub(crate) fn restricted_function() {
            println!("called `my_mod::private_nested::restricted_function()`");
        }
    }
}

fn function() {
    println!("called `function()`");
}

fn main() {
    // モジュールによって、同名の関数を区別することができます。
    function();
    my_mod::function();

    // パブリックな要素ならば、たとえネストしたものでも、
    // モジュールの外からアクセスすることができます。
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate)の要素は同じクレートのどこからでも呼び出すことができます。
    my_mod::public_function_in_crate();

    // pub(in path)の要素は指定されたモジュールからのみ呼び出すことができます。
    // エラー！`public_function_in_my_mod`関数はプライベート。
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ 試しにこの行をアンコメントしてみましょう。

    // プライベートな要素は、たとえパブリックなモジュール内に存在していても
    // 直接アクセスすることはできません。

    // エラー！`private_function`はプライベート。
    //my_mod::private_function();
    // TODO ^ 試しにこの行をアンコメントしてみましょう。

    // エラー！`private_function`はプライベート。
    //my_mod::nested::private_function();
    // TODO ^ 試しにこの行をアンコメントしてみましょう。

    // エラー！`private_nested`はプライベートなモジュール。
    //my_mod::private_nested::function();
    // TODO ^ 試しにこの行をアンコメントしてみましょう。

    // エラー！`private_nested`はプライベートなモジュール。
    //my_mod::private_nested::restricted_function();
    // TODO ^ 試しにこの行をアンコメントしてみましょう。
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="構造体の場合"><a class="header" href="#構造体の場合">構造体の場合</a></h1>
<p>構造体はそれ自身に加え、フィールドごとにもパブリック・プライベートを設定することができます。デフォルトではプライベートですが、<code>pub</code>宣言をすることで、フィールドをパブリックにすることができます。これは、構造体がモジュールの外から参照される時に限り意味のあるもので、情報の隠蔽（カプセル化）を達成するための機能です。</p>
<pre class="playground"><code class="language-rust editable edition2021">mod my {
    // パブリックなフィールド`T`（ジェネリック型）を持つパブリックな構造体
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // プライベートなフィールド`T`（ジェネリック型）を持つパブリックな構造体
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // パブリックなコンストラクタメソッドを持つ構造体
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // パブリックなフィールドを持つパブリックな構造体は、通常通り
    // インスタンス化できます。
    let open_box = my::OpenBox { contents: "public information" };

    // フィールドにも普通にアクセスできます。
    println!("The open box contains: {}", open_box.contents);

    // プライベートなフィールドを持つ構造体は、インスタンス化する際に
    // フィールド名を指定することができません。
    // エラー！`ClosedBox`にはプライベートなフィールドがあります。
    //let closed_box = my::ClosedBox { contents: "classified information" };
    // TODO ^ 試しにここをアンコメントしてみましょう。

    // そのような場合でも、パブリックなコンストラクタを介して作成
    // することはできます。
    let _closed_box = my::ClosedBox::new("classified information");

    // パブリックな構造体でも、プライベートなフィールドにはアクセスできません。
    // エラー！`contents`フィールドはプライベートです。
    //println!("The closed box contains: {}", _closed_box.contents);
    // TODO ^ ここをアンコメントしてみましょう。
}</code></pre>
<h3 id="参照-33"><a class="header" href="#参照-33">参照</a></h3>
<p><a href="#ジェネリクス">ジェネリクス</a>, <a href="#関連関数とメソッド">メソッド</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="use宣言"><a class="header" href="#use宣言"><code>use</code>宣言</a></h1>
<p><code>use</code>宣言をすることで、要素の絶対パスを新しい名前に束縛することができ、より簡潔な記述が可能になります。例えば以下のように使えます。</p>
<pre><code class="language-rust editable ignore">use crate::deeply::nested::{
    my_first_function,
    my_second_function,
    AndATraitType
};

fn main() {
    my_first_function();
}</code></pre>
<p><code>as</code>キーワードを使用することで、インポートを別名に束縛することができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `deeply::nested::function`を`other_function`に束縛
use deeply::nested::function as other_function;

fn function() {
    println!("called `function()`");
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!("called `deeply::nested::function()`");
        }
    }
}

fn main() {
    // `deeply::nested::function`へ、より簡潔にアクセス。
    other_function();

    println!("Entering block");
    {
        // これは`use deeply::nested::function as function`と同等
        // この`function()`は外の`function()`をシャドウイングします。
        use crate::deeply::nested::function;

        // `use`束縛は局所的なスコープを持ちます。
        // この場合には`function()`のシャドーイングはこのブロック内のみとなります。
        function();

        println!("Leaving block");
    }

    function();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="superとself"><a class="header" href="#superとself"><code>super</code>と<code>self</code></a></h1>
<p><code>super</code>及び<code>self</code>キーワードは、要素にアクセスする際に、曖昧さをなくし、不必要なハードコーディングを避けるために使用できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn function() {
    println!("called `function()`");
}

mod cool {
    pub fn function() {
        println!("called `cool::function()`");
    }
}

mod my {
    fn function() {
        println!("called `my::function()`");
    }

    mod cool {
        pub fn function() {
            println!("called `my::cool::function()`");
        }
    }

    pub fn indirect_call() {
        // `function`という名の様々な関数をこのスコープ内から参照してみましょう。
        print!("called `my::indirect_call()`, that\n&gt; ");

        // `self`キーワードは現在のモジュールスコープを示します。
        // この場合は`my`です。`self::function()`と`funcition()`は
        // 同じ関数であるため、同じ結果になります。
        self::function();
        function();

        // `my`以下の別のモジュールを呼び出す際に
        // `self`を用いて明示的に参照できます。
        self::cool::function();

        // `super`は親スコープ（`my`の外側）を参照します。
        super::function();

        // 以下は *クレート* スコープ内の`cool::function`を束縛します。
        // この場合、クレートスコープは一番外側のスコープです。
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ファイルの階層構造"><a class="header" href="#ファイルの階層構造">ファイルの階層構造</a></h1>
<p>モジュールはファイル・ディレクトリの階層構造と対応関係にあります。以下の様なファイルで<a href="#可視性">可視性の例</a>を詳しく見ていきましょう。</p>
<pre><code class="language-shell">$ tree .
.
├── my
│   ├── inaccessible.rs
│   └── nested.rs
├── my.rs
└── split.rs
</code></pre>
<p><code>split.rs</code>は以下のようになります。</p>
<pre><code class="language-rust ignore">// このように宣言すると、`my.rs`という名のファイルを探し、
// その内容をこのファイル中で`my`という名から使用することができるようにします。
mod my;

fn function() {
    println!("called `function()`");
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}
</code></pre>
<p><code>my.rs</code>は以下のようになります。</p>
<pre><code class="language-rust ignore">// 同様に`mod inaccessible`、`mod nested`によって、`nested.rs`、`inaccessible.rs`
// の内容をこの中で使用することができるようになります。
// 訳注：`pub`をつけないかぎり、この中でしか使用できません。
mod inaccessible;
pub mod nested;

pub fn function() {
    println!("called `my::function()`");
}

fn private_function() {
    println!("called `my::private_function()`");
}

pub fn indirect_access() {
    print!("called `my::indirect_access()`, that\n&gt; ");

    private_function();
}</code></pre>
<p><code>my/nested.rs</code>は以下のようになります。</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!("called `my::nested::function()`");
}

#[allow(dead_code)]
fn private_function() {
    println!("called `my::nested::private_function()`");
}</code></pre>
<p><code>my/inaccessible.rs</code>は以下のようになります。</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!("called `my::inaccessible::public_function()`");
}</code></pre>
<p>では、以前と同じように実行できるか確認しましょう。</p>
<pre><code class="language-shell">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="クレート"><a class="header" href="#クレート">クレート</a></h1>
<p>クレートはRustにおけるコンパイルの単位です。<code>rustc some_file.rs</code>が呼ばれると、<code>some_file.rs</code>は必ず <em>クレートファイル</em> として扱われます。もし<code>some_file.rs</code>が<code>mod</code>宣言を含んでいるのならば、コンパイルの <em>前に</em> 、そのモジュールファイルの中身が<code>mod</code>の位置に挿入されます。言い換えると、それぞれのモジュールが独立にコンパイルされるということはありませんが、それぞれのクレートは互いに独立にコンパイルされるということです。</p>
<p>クレートはバイナリあるいはライブラリ形式でコンパイルされることが可能です。デフォルトでは<code>rustc</code>はクレートからバイナリを作り出しますが、この振る舞いは<code>--crate-type</code>フラグに<code>lib</code>を渡すことでオーバーライドできます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ライブラリの作成"><a class="header" href="#ライブラリの作成">ライブラリの作成</a></h1>
<p>ではライブラリを作成し、それを別のクレートにリンクする方法を見ていきましょう。</p>
<p><code>rary.rs</code>は以下のようになります。</p>
<pre><code class="language-rust ignore">pub fn public_function() {
    println!("called rary's `public_function()`");
}

fn private_function() {
    println!("called rary's `private_function()`");
}

pub fn indirect_access() {
    print!("called rary's `indirect_access()`, that\n&gt; ");

    private_function();
}</code></pre>
<pre><code class="language-shell">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>ライブラリは「lib」が頭につき、デフォルトでは、その後ろに元となったクレートファイル名をつけます。（訳注: ここでは<code>lib</code> + <code>rary</code>）この振る舞いは<a href="#クレート-1"><code>crate_name</code>アトリビュート</a>を用いてオーバーライドできます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ライブラリの利用"><a class="header" href="#ライブラリの利用">ライブラリの利用</a></h1>
<p>クレートをこの新しいライブラリにリンクするには、<code>rustc</code>の<code>--extern</code>フラグを利用します。クレートの要素を全てライブラリと同じ名前のモジュールにインポートします。一般に、このモジュールは他のモジュールと同じように振る舞います。</p>
<pre><code class="language-rust ignore">// extern crate rary; // Rust 2015以前で必要。

fn main() {
    rary::public_function();

    // エラー！`private_function`はプライベート。
    //rary::private_function();

    rary::indirect_access();
}</code></pre>
<pre><code class="language-txt"># Where library.rlib is the path to the compiled library, assumed that it's
# in the same directory here:
$ rustc executable.rs --extern rary=library.rlib &amp;&amp; ./executable
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p><code>cargo</code>はRustの公式パッケージ管理ツールです。とても便利な機能が多くあり、コードの品質や開発速度の向上に役立ちます。以下はその例です。</p>
<ul>
<li>依存関係の管理と<a href="https://crates.io">crates.io</a>（Rustの公式パッケージレジストリ）との統合</li>
<li>ユニットテスト</li>
<li>ベンチマーク</li>
</ul>
<p>この章では、簡単な基本機能を説明します。包括的なドキュメントは<a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="依存関係"><a class="header" href="#依存関係">依存関係</a></h1>
<p>ほとんどのプログラムはライブラリに依存関係を持ちます。もし依存関係を手動で管理したことがあれば、それがどれだけ苦痛であるか分かるでしょう。幸運なことに、Rustのエコシステムには<code>cargo</code>が標準装備されています！<code>cargo</code>によってプロジェクトの依存関係を管理することができます。</p>
<p>Rustのプロジェクトを新しく作るには下記のようにします。</p>
<pre><code class="language-sh"># バイナリ
cargo new foo

# ライブラリ
cargo new --lib bar
</code></pre>
<p>この章の残りでは、ライブラリではなくバイナリを作ることを想定しますが、コンセプトはすべて同じです。</p>
<p>上のコマンドを実行すると、次のようなファイル階層ができます。</p>
<pre><code class="language-txt">.
├── bar
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
└── foo
    ├── Cargo.toml
    └── src
        └── main.rs
</code></pre>
<p><code>main.rs</code>がこの新規プロジェクト <code>foo</code> のルートのソースファイルです。なにも新しいことはありませんね。<code>Cargo.toml</code>はこのプロジェクトの<code>cargo</code>の設定ファイルです。中を見てみるとこのようになっています。</p>
<pre><code class="language-toml">[package]
name = "foo"
version = "0.1.0"
authors = ["mark"]

[dependencies]
</code></pre>
<p><code>[package]</code>の下の<code>name</code>フィールドがプロジェクトの名前を決定します。これはクレートを公開するときに<code>crates.io</code>によって使われます（詳細は後述）。またコンパイルしたときの出力ファイルの名前でもあります。</p>
<p><code>version</code>フィールドはクレートのバージョン番号で、<a href="http://semver.org/">セマンティックバージョニング</a>を使っています。</p>
<p><code>authors</code>フィールドは作者のリストで、クレートを公開するときに使われます。</p>
<p><code>[dependencies]</code>セクションにはプロジェクトの依存関係を追加できます。</p>
<p>例えば、プログラムに素晴らしいCLIが欲しいとします。<a href="https://crates.io">crates.io</a>（Rustの公式パッケージレジストリ）には素晴らしいパッケージがたくさんあります。よくある選択肢の1つは<a href="https://crates.io/crates/clap">clap</a>です。この記事を書いている時点での<code>clap</code>の最新の公開バージョンは<code>2.27.1</code>です。依存関係をプログラムに追加するには、<code>Cargo.toml</code>の<code>[dependencies]</code>の下に<code>clap = "2.27.1"</code>と単に書き加えます。これだけです！<code>clap</code>をプログラム内で使用できます。</p>
<p><code>cargo</code>は<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">他の形式の依存関係</a>もサポートしています。その一部を示します。</p>
<pre><code class="language-toml">[package]
name = "foo"
version = "0.1.0"
authors = ["mark"]

[dependencies]
clap = "2.27.1" # from crates.io
rand = { git = "https://github.com/rust-lang-nursery/rand" } # from online repo
bar = { path = "../bar" } # from a path in the local filesystem
</code></pre>
<p><code>cargo</code>は依存管理ツール以上のこともできます。<code>Cargo.toml</code>の<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">format specification</a>に全ての設定オプションがリストアップされています。</p>
<p>プロジェクトをビルドするには、プロジェクトディレクトリのどこか（サブディレクトでも！）で<code>cargo build</code>を実行します。また<code>cargo run</code>でビルドと実行をできます。これらのコマンドは、全ての依存関係の解決、必要なクレートのダウンロード、自分のクレートを含む全てのビルドを行うことに注意してください。（<code>make</code>と同様、まだビルドしていないものだけをビルドします。）</p>
<p>Voila！これで完成です！</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="規約"><a class="header" href="#規約">規約</a></h1>
<p>前の章ではこのようなディレクトリ階層がありました。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>しかし同じプロジェクトで2つのバイナリが欲しいとします。その場合は？</p>
<p><code>cargo</code>はこれもサポートしています。以前見た通りデフォルトのバイナリ名は<code>main</code>ですが、<code>bin/</code>ディレクトリに置くことで他のバイナリを追加できます。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>このバイナリだけをコンパイルや実行するように<code>cargo</code>に伝えるには、<code>cargo</code>に<code>--bin my_other_bin</code>フラグを渡します。ここでは<code>my_other_bin</code>が対象のバイナリの名前です。</p>
<p>バイナリの追加に加えて、<code>cargo</code>はベンチマークやテスト、サンプルなどの<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">その他の機能</a>もサポートしています。</p>
<p>次の章ではテストについてより詳しく見ていきます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="テスト"><a class="header" href="#テスト">テスト</a></h1>
<p>知っての通り、テストはどんなソフトウェアにも不可欠です！Rustはユニットテストと統合テストを第一級にサポートしています（TRPLの<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">この章を参照してください</a>）。</p>
<p>上のリンク先のテストの章では、ユニットテストと統合テストの書き方を紹介しています。ユニットテストはテスト対象のモジュール内に、統合テストは<code>tests/</code>ディレクトリ内に置きます。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
│   └── lib.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p><code>tests</code>内の各ファイルは個別の<a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">統合テスト</a>です。これはライブラリを依存クレートから呼ばれたかのようにテストできます。</p>
<p><a href="#テスト-1">テスト</a>の章は3つの異なるテストスタイルについて解説しています。<a href="#ユニットテスト">単体テスト</a>、<a href="#ドキュメンテーションテスト">ドキュメンテーションテスト</a>、そして<a href="#統合テスト">結合テスト</a>です。</p>
<p><code>cargo</code>は、全てのテストを簡単に実行する方法を提供します。</p>
<pre><code class="language-shell">$ cargo test
</code></pre>
<p>出力はこのようになります。</p>
<pre><code class="language-shell">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 4 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>パターンにマッチする名前のテストを実行することもできます。</p>
<pre><code class="language-shell">$ cargo test test_foo
</code></pre>
<pre><code class="language-shell">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>注意：Cargoは複数のテストを並列で実行することがありますので、それらが互いに競合しないようにしてください。</p>
<p>並行性が問題を引き起こす一例として、以下のように、2つのテストが1つのファイルに出力するケースがあります。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // 必要なモジュールをインポートします。
    use std::fs::OpenOptions;
    use std::io::Write;

    // ファイルに書き込むテスト
    #[test]
    fn test_file() {
        // ferris.txtというファイルを開くか、存在しない場合は作成します。
        let mut file = OpenOptions::new()
            .append(true)
            .create(true)
            .open("ferris.txt")
            .expect("Failed to open ferris.txt");

        // "Ferris"と5回書き込みます。
        for _ in 0..5 {
            file.write_all("Ferris\n".as_bytes())
                .expect("Could not write to ferris.txt");
        }
    }

    // 同じファイルに書き込むテスト
    #[test]
    fn test_file_also() {
        // ferris.txtというファイルを開くか、存在しない場合は作成します。
        let mut file = OpenOptions::new()
            .append(true)
            .create(true)
            .open("ferris.txt")
            .expect("Failed to open ferris.txt");

        // "Corro"と5回書き込みます。
        for _ in 0..5 {
            file.write_all("Corro\n".as_bytes())
                .expect("Could not write to ferris.txt");
        }
    }
}
<span class="boring">}</span></code></pre>
<p>以下のような結果を得ようと意図しています。</p>
<pre><code class="language-shell">$ cat ferris.txt
Ferris
Ferris
Ferris
Ferris
Ferris
Corro
Corro
Corro
Corro
Corro
</code></pre>
<p>しかし、実際に<code>ferris.txt</code>に出力されるのは、以下の通りです。</p>
<pre><code class="language-shell">$ cargo test test_file &amp;&amp; cat ferris.txt
Corro
Ferris
Corro
Ferris
Corro
Ferris
Corro
Ferris
Corro
Ferris
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ビルドスクリプト"><a class="header" href="#ビルドスクリプト">ビルドスクリプト</a></h1>
<p><code>cargo</code>による通常のビルドでは十分でないことが時々あります。コード生成や、コンパイルが必要なネイティブコードなど、<code>cargo</code>がクレートをうまくコンパイルするにはなんらかの前提条件が必要かもしれません。この問題を解決するため、Cargoが実行できるビルドスクリプトがあります。</p>
<p>ビルドスクリプトをパッケージに追加するには、以下のように<code>Cargo.toml</code>の中で指定できます。</p>
<pre><code class="language-toml">[package]
...
build = "build.rs"
</code></pre>
<p>それ以外の場合、Cargoはデフォルトでプロジェクトディレクトリから<code>build.rs</code>を探します。</p>
<h2 id="ビルドスクリプトの使い方"><a class="header" href="#ビルドスクリプトの使い方">ビルドスクリプトの使い方</a></h2>
<p>ビルドスクリプトは単にRustのファイルの1つで、パッケージ内の他のファイルをコンパイルする前にコンパイルされて起動されます。そのため、クレートの前提条件を満たすために使用できます。</p>
<p>Cargoは、<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">ここで指定された</a>環境変数を介してスクリプトに入力を与えます。</p>
<p>スクリプトは標準出力に出力します。出力される行は全て、<code>target/debug/build/&lt;pkg&gt;/output</code>に書き込まれます。さらに、行頭に<code>cargo:</code>がついた行はCargoに直接解釈されるため、パッケージのコンパイル時のパラメーターを定義するのに使用できます。</p>
<p>より詳細な仕様や例については、<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">Cargo specification</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="アトリビュート"><a class="header" href="#アトリビュート">アトリビュート</a></h1>
<p>アトリビュートはモジュール、クレート、要素に対するメタデータです。以下がその使用目的です。</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="#cfg">コンパイル時の条件分岐</a></li>
<li><a href="#クレート-1">クレート名、バージョン、種類（バイナリか、ライブラリか）の設定</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lint_%28software%29">リント</a>の無効化</li>
<li>コンパイラ付属の機能（マクロ、グロブ、インポートなど）の使用</li>
<li>外部ライブラリへのリンク</li>
<li>ユニットテスト用の関数を明示</li>
<li>ベンチマーク用の関数を明示</li>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html#attribute-like-macros">アトリビュートマクロ</a></li>
</ul>
<p>Attributes look like <code>#[outer_attribute]</code> or <code>#![inner_attribute]</code>, with the difference between them being where they apply.</p>
<ul>
<li>
<p><code>#[outer_attribute]</code> applies to the <a href="https://doc.rust-lang.org/stable/reference/items.html">item</a> immediately following it. Some examples of items are: a function, a module declaration, a constant, a structure, an enum. Here is an example where attribute <code>#[derive(Debug)]</code> applies to the struct <code>Rectangle</code>:</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p><code>#![inner_attribute]</code> applies to the enclosing <a href="https://doc.rust-lang.org/stable/reference/items.html">item</a> (typically a module or a crate). In other words, this attribute is interpreted as applying to the entire scope in which it’s placed. Here is an example where <code>#![allow(unused_variables)]</code> applies to the whole crate (if placed in <code>main.rs</code>):</p>
<pre class="playground"><code class="language-rust edition2021">#![allow(unused_variables)]

fn main() {
    let x = 3; // This would normally warn about an unused variable.
}</code></pre>
</li>
</ul>
<p>アトリビュートは以下の様な書き方で引数を取ることができます。</p>
<ul>
<li><code>#[attribute = "value"]</code></li>
<li><code>#[attribute(key = "value")]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>アトリビュートは複数の値を取ることができ、複数の行に分割することもできます。</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dead_code"><a class="header" href="#dead_code"><code>dead_code</code></a></h1>
<p>コンパイラは<code>dead_code</code>と呼ばれる<a href="https://en.wikipedia.org/wiki/Lint_%28software%29">リント</a>機能を持つため、使用されていない関数が存在するときに警告を出します。<em>アトリビュート</em> によってこの機能を無効化することができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn used_function() {}

/ `#[allow(dead_code)]`は`dead_code`リントを抑制するアトリビュートです。
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// FIXME ^ 警告を抑制するアトリビュートを追加しましょう。

fn main() {
    used_function();
}</code></pre>
<p>実際のコード中では、使用されていないコードが有る場合はそれを除外するべきです。この文書中では随所でアトリビュートによって警告を抑制していますが、それはあくまでインタラクティブな例を皆さんに提供するためです。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="クレート-1"><a class="header" href="#クレート-1">クレート</a></h1>
<p><code>crate_type</code>アトリビュートは、そのクレートがライブラリ、バイナリのいずれにコンパイルされるべきかをコンパイラに伝えるために使用します。ライブラリの場合は、どのタイプのライブラリであるかも伝えることができます。<code>crate_name</code>はクレートの名前を決定するのに使用します。</p>
<p>しかし、<code>crate_type</code>アトリビュートも<code>crate_name</code>アトリビュートも、RustのパッケージマネージャCargoを利用している場合は<strong>何の</strong>影響もないと知っておくことは重要です。Cargoは大半のRustプロジェクトで利用されており、実世界での<code>crate_type</code>と<code>crate_name</code>の利用は比較的限られています。</p>
<pre class="playground"><code class="language-rust editable edition2021">// このクレートはライブラリです。
#![crate_type = "lib"]
// このライブラリの名前は「rary」です。
#![crate_name = "rary"]

pub fn public_function() {
    println!("called rary's `public_function()`");
}

fn private_function() {
    println!("called rary's `private_function()`");
}

pub fn indirect_access() {
    print!("called rary's `indirect_access()`, that\n&gt; ");

    private_function();
}</code></pre>
<p><code>crate_type</code>アトリビュートが使用されているときは、<code>rustc</code>に<code>--crate-type</code>フラグを伝える必要はありません。</p>
<pre><code class="language-shell">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cfg"><a class="header" href="#cfg"><code>cfg</code></a></h1>
<p>環境に応じたコンパイルをするには2種類の方法があります。</p>
<ul>
<li><code>cfg</code>アトリビュート：<code>#[cfg(...)]</code>をアトリビュートとして使用する。</li>
<li><code>cfg!</code>マクロ：<code>cfg!(...)</code>をブーリアンとして評価する。</li>
</ul>
<p>前者は条件付きコンパイルを行いますが、後者は<code>true</code>または<code>false</code>リテラルに評価され実行時にチェックすることが可能です。いずれの場合も適切なシンタックスで記述する必要があります。</p>
<p><code>#[cfg]</code>と異なり、<code>cfg!</code>はコードを削除せず、trueまたはfalseに評価されるだけです。例えば、<code>cfg!</code>が何を評価しているかに関係なく、<code>cfg!</code>が条件に利用されるとき、if/else式の中のすべてのブロックが有効でなくてはなりません。</p>
<pre class="playground"><code class="language-rust editable edition2021">// この関数はターゲットOSがLinuxの時のみコンパイルされます。
#[cfg(target_os = "linux")]
fn are_you_on_linux() {
    println!("You are running linux!");
}

// そしてこの関数はターゲットOSがLinux *ではない* ときのみコンパイルされます。
#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
    println!("You are *not* running linux!");
}

fn main() {
    are_you_on_linux();

    println!("Are you sure?");
    if cfg!(target_os = "linux") {
        println!("Yes. It's definitely linux!");
    } else {
        println!("Yes. It's definitely *not* linux!");
    }
}</code></pre>
<h3 id="参照-34"><a class="header" href="#参照-34">参照</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">リファレンス</a>, <a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a>, <a href="#macro_rules">マクロ</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="条件の追加"><a class="header" href="#条件の追加">条件の追加</a></h1>
<p><code>target_os</code>のように、いくつかの条件分岐は<code>rustc</code>が暗黙のうちに提供しています。条件を独自に追加する場合には<code>--cfg</code>フラグを用いて<code>rustc</code>に伝える必要があります。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">#[cfg(some_condition)]
fn conditional_function() {
    println!("condition met!");
}

fn main() {
    conditional_function();
}</code></pre>
<p>独自の<code>cfg</code>フラグを用いない場合、何が起きるかやってみてください。</p>
<p><code>cfg</code>フラグがある場合：</p>
<pre><code class="language-shell">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ジェネリクス"><a class="header" href="#ジェネリクス">ジェネリクス</a></h1>
<p>ジェネリクスとは、型と関数の機能をより汎用的に使えるようにするための機能です。これはあらゆる局面でコードの重複を避けるために非常に役立ちますが、多少構文が複雑になります。すなわち、ジェネリック型を使いこなすには、どのようなジェネリック型がきちんと機能するかに細心の注意を払う必要があります。最もシンプルで一般的なジェネリクスの利用法は型パラメータです。</p>
<p>ジェネリック型の型パラメータにはかぎ括弧とアッパー<a href="https://en.wikipedia.org/wiki/CamelCase">キャメルケース</a>（<code>&lt;Aaa, Bbb, ...&gt;</code>）が使われます。ジェネリックな型パラメータはたいていの場合<code>&lt;T&gt;</code>で示されます。Rustの場合、「ジェネリクス」には「１つ以上のジェネリックな型パラメータ<code>&lt;T&gt;</code>を受け付けるもの」という意味もあります。ジェネリックな型パラメータを指定された場合、それは必ずジェネリック型になり、そうでなければ必ず非ジェネリック型、すなわち具象型になります。</p>
<p>例として、あらゆる型の引数<code>T</code>をとる <em>ジェネリック関数</em> <code>foo</code>を定義すると</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }</code></pre>
<p>となります。<code>T</code>はジェネリックな型パラメータに指定されているので、この場所で<code>(arg: T)</code>のように使用するとジェネリック型として扱われます。これは<code>T</code>という構造体がそれ以前に定義されていても同様です。</p>
<p>では、手を動かしながらジェネリック型の構文を体験していきましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `A`という具象型
struct A;

// `Single`という型を定義する際に`A`を使用していますが、その最初の使用よりも先に
// `&lt;A&gt;`がないため、また、`A`自身も具象型であるため、`Single`は具象型となります。
struct Single(A);
//            ^ `Single`による`A`の一番最初の使用はここ。

// ここでは`&lt;T&gt;`が一番初めの`T`の使用よりも先に来ています。
// よって`SingleGen`はジェネリック型となります。
// なぜならば型パラメータ`T`がジェネリックだからです。
// `T`はどんな型にもなりえるため、上で定義した`A`を受け取ることもできます。
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single`は具象型で、`A`のみを受け取ります。
    let _s = Single(A);

    // `_char`という名の変数を生成します。これは`SingleGen&lt;char&gt;`
    // という型で、値は`SingleGen('a')`となります。
    // ここでは、`SingleGen`には明示的な型パラメータが与えられています。
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen`型の変数には明示的に型パラメータを与えなくても構いません。
    let _t    = SingleGen(A); // 上で定義した`A`を使用。
    let _i32  = SingleGen(6); // `i32`を使用。
    let _char = SingleGen('a'); // `char`を使用。
}</code></pre>
<h3 id="参照-35"><a class="header" href="#参照-35">参照</a></h3>
<p><a href="#構造体">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関数-1"><a class="header" href="#関数-1">関数</a></h1>
<p>「型<code>T</code>はその前に<code>&lt;T&gt;</code>があるとジェネリック型になる」というルールは関数に対しても当てはまります。</p>
<p>ジェネリック関数を使用する際、型パラメータを明示する必要がある場合があります。返り値がジェネリック型である場合や、コンパイラが型パラメータを推論するのに十分な情報がない場合です。</p>
<p>型パラメータを明示したうえでの関数呼び出しの構文は<code>fun::&lt;A, B, ...&gt;()</code>のようになります。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct A;          // 具象型`A`
struct S(A);       // 具象型`S`
struct SGen&lt;T&gt;(T); // ジェネリック型`SGen`

// 以下の関数は全て変数の所有権をとった後すぐにスコープを抜けて
// 変数をメモリ上から開放します。

// `S`という型の引数`_s`をとる`reg_fn`という関数を定義。
// `&lt;T&gt;`がないのでジェネリック関数ではありません。
fn reg_fn(_s: S) {}

// Define a function `gen_spec_t` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// It has been explicitly given the type parameter `A`, but because `A` has not
// been specified as a generic type parameter for `gen_spec_t`, it is not generic.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// `gen_spec_i32`という関数を定義。
// これは明示的な型パラメータとして`i32`を与えられた
// `SGen&lt;i32&gt;`型の引数`_s`を取ります。
// この関数もジェネリックではありません。
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// `generic`という関数を定義。`SGen&lt;T&gt;`という型の引数`_s`を取ります。
// `&lt;T&gt;`が`SGen&lt;T&gt;`に先行しているため、これはTに対してジェネリックな関数です。
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // ジェネリックでない関数を使用します。
    reg_fn(S(A));          // 具象型
    gen_spec_t(SGen(A));   // 型パラメータ`A`を暗黙のうちに受け取ります。
    gen_spec_i32(SGen(6)); // 型パラメータ`i32`を暗黙のうちに受け取ります。

    // 型パラメータ`char`を明示的に`generic()`に渡します。
    generic::&lt;char&gt;(SGen('a'));

    // 型パラメータ`char`を暗黙的に`generic()`に渡します。
    generic(SGen('c'));
}</code></pre>
<h3 id="参照-36"><a class="header" href="#参照-36">参照</a></h3>
<p><a href="#関数">関数</a>, <a href="#構造体">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="実装"><a class="header" href="#実装">実装</a></h1>
<p>関数と同様、<code>impl</code>でメソッドを実装する際にもジェネリック型特有の記法が必要です。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 具象型`S`
struct GenericVal&lt;T&gt;(T); // ジェネリック型`GenericVal`

// 型パラメータを指定したうえで、GenericValにメソッドを実装。
impl GenericVal&lt;f32&gt; {} // `f32`の場合のメソッド
impl GenericVal&lt;S&gt; {} // 上で定義した`S`への実装

// ジェネリック型のまま扱うには`&lt;T&gt;`が先に来る必要があります。
impl&lt;T&gt; GenericVal&lt;T&gt; {}
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust editable edition2021">struct Val {
    val: f64,
}

struct GenVal&lt;T&gt; {
    gen_val: T,
}

// Valに対して実装。
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}

// ジェネリック型`T`の場合のメソッドをGenValに対して実装。
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!("{}, {}", x.value(), y.value());
}</code></pre>
<h3 id="参照-37"><a class="header" href="#参照-37">参照</a></h3>
<p><a href="#関数-2">参照を返す関数</a>, <a href="#関連関数とメソッド"><code>impl</code></a>, <a href="#構造体">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="トレイト"><a class="header" href="#トレイト">トレイト</a></h1>
<p>もちろんトレイトもジェネリクスを活用することができます。ここでは<code>Drop</code>トレイトをジェネリックメソッドとして再実装し、自身と引数として受け取った値の両方を<code>drop</code>するようなメソッドにします。</p>
<pre class="playground"><code class="language-rust editable edition2021">// コピー不可な型
// 訳注: `clone()`メソッドを用いないかぎり、値のコピーではなくムーブが起きる型
struct Empty;
struct Null;

// ジェネリック型 `T`に対するトレイト
trait DoubleDrop&lt;T&gt; {
    // `self`に加えてもう一つジェネリック型を受け取り、
    // 何もしないメソッドのシグネチャを定義。
    fn double_drop(self, _: T);
}

// `U`を`self`として、`T`をもう一つの引数として受け取る`DoubleDrop&lt;T&gt;`
// を実装する。`U`,`T`はいずれもジェネリック型。
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // このメソッドは2つの引数の所有権を取り、メモリ上から開放します。
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // `empty`と`null`を開放。
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: これらの行をアンコメントしてみましょう。
}</code></pre>
<h3 id="参照-38"><a class="header" href="#参照-38">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="#構造体">構造体</a>, <a href="#トレイト-2">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="境界"><a class="header" href="#境界">境界</a></h1>
<p>ジェネリックプログラミングをしていると、型パラメータが特定の機能を持っていることを規定するため、トレイトに境界を設ける必要があることがよくあります。例えば、以下の例では、引数の<code>Display</code>トレイトを用いて出力を行うため、<code>T</code>が<code>Display</code>を持っていることを規定しています。つまり、「<code>T</code>は<code>Display</code>を実装 <em>していなくてはならない</em> 」という意味です。</p>
<pre><code class="language-rust ignore">// `Display`トレイトを実装している`T`を引数として取ります。
// `printer`という関数を定義。
fn printer&lt;T: Display&gt;(t: T) {
    println!("{}", t);
}</code></pre>
<p>境界は、ジェネリクスを全ての型ではなく、一定条件を満たす型に対してのみ適用するためにあります。つまり</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// エラー！`Vec&lt;T&gt;`は`Display`を実装していないため、この特殊化
// は失敗します。
let s = S(vec![1]);</code></pre>
<p>境界のもう一つの効果は、ジェネリック型のインスタンスが、境界条件となるトレイトの<a href="#関連関数とメソッド">メソッド</a>にアクセスすることができるようになる点です。以下がその例です。</p>
<pre class="playground"><code class="language-rust editable edition2021">// 出力時のマーカー`{:?}`を実装するトレイト
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// ジェネリック型`T`は`Debug`トレイトを実装していなくてはなりません。
// その限りにおいて、`T`がどのような具象型であろうとも次の関数は動作します。
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!("{:?}", t);
}

// 「`T`は`HasArea`を実装していなくてはならない」という境界条件を
// 満たしていれば、`HasArea`の関数`area`にアクセスできます。
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!("Area: {}", area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!("Area: {}", area(&amp;_triangle));
    // ^ TODO: Try uncommenting these.
    // | Error: Does not implement either `Debug` or `HasArea`.
}</code></pre>
<p>付け加えておくと、<a href="#where句"><code>where</code></a>句を用いて境界を適用することもできます。場合によってはこちらの記法を使用したほうが読みやすくなる場合もあります。</p>
<h3 id="参照-39"><a class="header" href="#参照-39">参照</a></h3>
<p><a href="#フォーマットして出力"><code>std::fmt</code></a>, <a href="#構造体">構造体</a>, <a href="#トレイト-2">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="テストケース空トレイト"><a class="header" href="#テストケース空トレイト">テストケース：空トレイト</a></h1>
<p>トレイト境界の仕組みから、「トレイトがなにも機能を持っていなくとも境界条件として使用できることには変わりはない」という帰結がもたらされます。<code>Eq</code>と<code>Copy</code>は<code>std</code>ライブラリにおけるそのような例です。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// 以下の関数はトレイト境界を設けていますが、そのトレイトが空である
// か否かとは関係ありません。
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { "red" }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { "blue" }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // トレイト境界のため、`red`は`blue_jay`に対しては使用できません。
    // `blue`と`Cardinal`も同様です。
    println!("A cardinal is {}", red(&amp;cardinal));
    println!("A blue jay is {}", blue(&amp;blue_jay));
    //println!("A turkey is {}", red(&amp;_turkey));
    // ^ TODO: この行をアンコメントしてみましょう。
}</code></pre>
<h3 id="参照-40"><a class="header" href="#参照-40">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>std::marker::Copy</code></a>, <a href="#トレイト-2">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="複数の境界"><a class="header" href="#複数の境界">複数の境界</a></h1>
<p><code>+</code>を用いて1つの型に複数のトレイト境界を設けることができます。複数の引数を受け取るときは、通常時と同様、<code>,</code>で区切ります。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!("Debug: `{:?}`", t);
    println!("Display: `{}`", t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!("t: `{:?}`", t);
    println!("u: `{:?}`", u);
}

fn main() {
    let string = "words";
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // TODO ^ ここをアンコメントしてみましょう。

    compare_types(&amp;array, &amp;vec);
}</code></pre>
<h3 id="参照-41"><a class="header" href="#参照-41">参照</a></h3>
<p><a href="#フォーマットして出力"><code>std::fmt</code></a>, <a href="#トレイト-2">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="where句"><a class="header" href="#where句">Where句</a></h1>
<p>トレイト境界は、<code>{</code>の直前に<code>where</code>句を導入することでも設けることができます。<code>where</code>はさらに、型パラメータだけでなく任意の型に対して適用できます。</p>
<p><code>where</code>句のほうが有効なケースには例えば以下のようなものがあります。</p>
<ul>
<li>ジェネリック型とジェネリック境界に別々に制限を加えたほうが明瞭になる場合</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// `where`を用いてジェネリック境界を設けます。
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}</code></pre>
<ul>
<li><code>where</code>句の方が通常の構文より表現力が高い場合。この例では<code>where</code>句を使わずに書くことはできません。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Because we would otherwise have to express this as `T: Debug` or
// use another method of indirect approach, this requires a `where` clause:
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // 出力されるのが`Some(self)`であるため、この関数の
    // ジェネリック境界として`Option&lt;T&gt;: Debug`を使用したい。
    fn print_in_option(self) {
        println!("{:?}", Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}</code></pre>
<h3 id="参照-42"><a class="header" href="#参照-42">参照</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>, <a href="#構造体">構造体</a>, <a href="#トレイト-2">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ニュータイプイディオム"><a class="header" href="#ニュータイプイディオム">ニュータイプイディオム</a></h1>
<p>ニュータイプイディオムは正しい型の値が与えられていることをコンパイル時に保証することができます。</p>
<p>例えば、年齢を年単位で確認する<code>is_adult</code>には「Years」という型の値を <em>与えなければならない</em> ようにすることが可能です。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}

impl Days {
    /// 1年に満たない日付は切り捨て。
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn is_adult(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(25);
    let age_days = age.to_days();
    println!("Is an adult? {}", is_adult(&amp;age));
    println!("Is an adult? {}", is_adult(&amp;age_days.to_years()));
    // println!("Is an adult? {}", is_adult(&amp;age_days));
}</code></pre>
<p>最後の print文 のコメントを外して、与えられた型が <code>Years</code> でなければならないことを確認してください。</p>
<p><code>newtype</code>の元に使われている型のデータを取得するには、以下のようにタプルやデストラクト構文を用いることで取得できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Years(i64);

fn main() {
    let years = Years(42);
    let years_as_primitive_1: i64 = years.0; // タプル
    let Years(years_as_primitive_2) = years; // デストラクト
}</code></pre>
<h3 id="参照-43"><a class="header" href="#参照-43">参照</a></h3>
<p><a href="#構造体">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関連要素"><a class="header" href="#関連要素">関連要素</a></h1>
<p>関連要素とは複数の型の<a href="https://doc.rust-lang.org/reference/items.html">要素</a>に関係のある規則の総称です。トレイトの拡張機能であり、トレイトの中で新しい要素を定義することを可能にします。</p>
<p>そのように定義する要素の一つに <strong>関連型</strong> があります。これにより、ジェネリックなコンテナ型に対するトレイトを使用する際に、よりシンプルな書き方ができるようになります。</p>
<h3 id="参照-44"><a class="header" href="#参照-44">参照</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関連要素が必要になる状況"><a class="header" href="#関連要素が必要になる状況">関連要素が必要になる状況</a></h1>
<p>コンテナ型に、その要素に対してジェネリックなトレイトを実装した場合、そのトレイトを使用する者は全てのジェネリック型を明記 <em>しなくてはなりません</em> 。</p>
<p>以下の例では<code>Contains</code>トレイトはジェネリック型<code>A</code>と<code>B</code>の使用を許しています。その後、<code>Container</code>型に対して<code>Contains</code>を実装していますが、その際後に<code>fn difference()</code>が使用できるように、<code>A</code>、<code>B</code>はそれぞれ<code>i32</code>と明記されています。</p>
<p><code>Contains</code>はジェネリックトレイトなので、<code>fn difference()</code>では <strong>全ての</strong> ジェネリック型を宣言しなくてはなりません。実際のところ、<code>A</code>と<code>B</code>は <strong>引数</strong> である<code>C</code>によって決定されていて欲しいにも関わらず、です。これは次のページで紹介する関連型と呼ばれる機能によって可能です。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Container(i32, i32);

// ２つの要素がコンテナ型の中にあることをチェックするトレイト
// また、最初と最後の値を取得することもできます。
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // `A`と`B`両方を明示的に要求します。
    fn first(&amp;self) -&gt; i32; // `A`、`B`いずれも要求しません。
    fn last(&amp;self) -&gt; i32;  // `A`、`B`いずれも要求しません。
}

impl Contains&lt;i32, i32&gt; for Container {
    // コンテナ内の２つの要素が等しければTrueを返します。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // ひとつ目の値を取得。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 最後（2つめ）の値を取得。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `A`と`B`は`C`に保持されていることを考慮すると、`A`と`B`を
// ２度も書くのは面倒。
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!("Does container contain {} and {}: {}",
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!("First number: {}", container.first());
    println!("Last number: {}", container.last());

    println!("The difference is: {}", difference(&amp;container));
}</code></pre>
<h3 id="参照-45"><a class="header" href="#参照-45">参照</a></h3>
<p><a href="#構造体">構造体</a>, <a href="#トレイト-2">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関連型"><a class="header" href="#関連型">関連型</a></h1>
<p>関連型を使用すると、コンテナ型の中の要素をトレイトの中に <em>出力型</em> として書くことで、全体の可読性を上げることができます。トレイトを定義する際の構文は以下のようになります。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `A`と`B`は`type`キーワードを用いてトレイト内で宣言されています。
// （注意：この文脈で使用する`type`は型エイリアスを宣言する際の`type`とは
// 異なることに注意しましょう。）
trait Contains {
    type A;
    type B;

    // これらの新しい型をジェネリックに使用するために、構文が
    // アップデートされています。
    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<p><code>Contains</code>トレイトを使用する関数において、<code>A</code>と<code>B</code>を明示する必要がなくなっていることに注目しましょう。</p>
<pre><code class="language-rust ignore">// 関連型を使用しない場合
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// 使用する場合
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }</code></pre>
<p>前セクションの例を関連型を使用して書きなおしてみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Container(i32, i32);

// ２つの要素がコンテナ型の中にあることをチェックするトレイト
// また、最初と最後の値を取得することもできます。
trait Contains {
    // メソッドが使用できるジェネリック型を定義。
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // `A`と`B`がどの型であるかを明示。入力型（訳注：つまり`Self`の型）
    // が`Container(i32, i32)`である場合、出力型は`i32`と`i32`となります。
    type A = i32;
    type B = i32;

    // `&amp;i32`の代わりに`&amp;Self::A`または`&amp;Self::B`と書いても構いません
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // ひとつ目の値を取得。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 最後（2つめ）の値を取得。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!("Does container contain {} and {}: {}",
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!("First number: {}", container.first());
    println!("Last number: {}", container.last());

    println!("The difference is: {}", difference(&amp;container));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="幽霊型パラメータ"><a class="header" href="#幽霊型パラメータ">幽霊型パラメータ</a></h1>
<p>幽霊型とは実行時には存在しないけれども、コンパイル時に静的に型チェックされるような型のことです。</p>
<p>構造体などのデータ型は、ジェネリック型パラメータを一つ余分に持ち、それをマーカーとして使ったりコンパイル時の型検査に使ったりすることができます。このマーカーは実際の値を何も持たず、したがって実行時の挙動そのものにはいかなる影響ももたらしません。</p>
<p>以下の例では、そのようなマーカーとして幽霊型（<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a>）を用い、それぞれ異なった型の値を持つタプルを作成します。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::marker::PhantomData;

// ジェネリックなタプル構造体。2つ目のパラメータは幽霊型。
#[derive(PartialEq)] // 比較演算子（`==`）での比較を可能にします。
struct PhantomTuple&lt;A, B&gt;(A, PhantomData&lt;B&gt;);

// 同様に構造体を定義。
#[derive(PartialEq)] // 比較演算子（`==`）での比較を可能にします。
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// 注意点:  ジェネリック型Aに対してはメモリが割り当てられていますが、
//          Bには割り当てられていないため、計算に使うことはできません。

fn main() {
    // ここで `f32` と `f64` は隠しパラメータです。
    // &lt;char, f32&gt;と型宣言されたPhantomTupleを作成。
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // &lt;char, f64&gt;と型宣言されたPhantomTupleを作成。
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // &lt;char, f32&gt;の型が与えられた構造体を作成。
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // 同様に&lt;char, f64&gt;の構造体
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };

    // コンパイルエラー！型が違うので比較することができません！
    // println!("_tuple1 == _tuple2 yields: {}",
    //           _tuple1 == _tuple2);

    // コンパイルエラー! 型が違うので比較することができません!
    // println!("_struct1 == _struct2 yields: {}",
    //           _struct1 == _struct2);
}</code></pre>
<h3 id="参照-46"><a class="header" href="#参照-46">参照</a></h3>
<p><a href="#導出derive">Derive</a>, <a href="#構造体">struct</a>, and <a href="#タプル">tuple</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="テストケース単位を扱う"><a class="header" href="#テストケース単位を扱う">テストケース：単位を扱う</a></h1>
<p>共通の単位同士を扱う際のチェックのために、<code>Add</code>を幽霊型を用いた実装にすると便利な場合があります。その場合<code>Add</code>トレイトは以下のようになります。</p>
<pre><code class="language-rust ignore">// このように定義しておくと、`Self + RHS = Output`であることが保証され、
// かつ、impl時にRHSの型が明示されていない場合、デフォルトでSelfと同じに
// なります。
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output`は`T&lt;U&gt;`でなくてはならないので`T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`となります。
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}</code></pre>
<p>以下は全体を示した例です。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::ops::Add;
use std::marker::PhantomData;

/// 単位を定義するため、空の列挙型を作成。
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length`は`Unit`という幽霊型パラメータを持つ型ですが
/// 長さを表す型はジェネリック型ではなく`f64`です。
///
/// `f64`ははじめから`Clone`、`Copy`トレイトを持っています。
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// `Add`トレイトは加算演算子(`+`)の挙動を定義します。
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
    type Output = Length&lt;Unit&gt;;

    // add()は`Length`の新しいインスタンスを返します。
    // Lengthの中の値は合計値になっています。
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // ここでの`+`は`f64`の`Add`実装を呼び出します。
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // `one_foot`が幽霊型`Inch`を持つように明示します。
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter`が幽霊型`Mm`を持つように明示します。
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // 以下の`+`は上で定義した`Length&lt;Unit&gt;`用の`add()`メソッドを呼び出します。
    //
    // `Length`は`Copy`トレイトを持っているため、`add()`は`one_foot`と`one_meter`
    // を消費する代わりにそのコピーを作り、`self`、`rhs`として扱います。
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // 加算が問題なく実行されていることを確認。
    println!("one foot + one_foot = {:?} in", two_feet.0);
    println!("one meter + one_meter = {:?} mm", two_meters.0);

    // 異なる単位間の加算は意味を成さないので、
    // 以下はきちんとコンパイルエラーになります。
    // コンパイルエラー：タイプミスマッチ
    //let one_feter = one_foot + one_meter;
}</code></pre>
<h3 id="参照-47"><a class="header" href="#参照-47">参照</a></h3>
<p><a href="#借用">借用 (<code>&amp;</code>)</a>, <a href="#境界">境界 (<code>X: Y</code>)</a>, <a href="#列挙型">列挙型</a>, <a href="#関連関数とメソッド">impl &amp; self</a>, <a href="#演算子のオーバーロード">演算子のオーバーロード</a>, <a href="#refパターン">ref</a>, <a href="#トレイト-2">トレイト (<code>X for Y</code>)</a>, <a href="#構造体">タプル構造体</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="スコープの規則"><a class="header" href="#スコープの規則">スコープの規則</a></h1>
<p>所有権、借用、ライフタイムといったRustに特有の概念において、変数のスコープは重要な役割を果たします。すなわち、スコープの存在によってコンパイラは借用は可能か否か、メモリ上の資源は解放可能か、変数はいつ作成され、いつ破棄されるか。といったことを知るのです。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="raii"><a class="header" href="#raii">RAII</a></h1>
<p>Rustの変数は単にデータをスタック上に保持するだけのものではありません。例えばヒープメモリを確保する<code>Box&lt;T&gt;</code>のように、変数はメモリ上の資源を <em>保有</em> する場合もあるのです。Rustは<a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>(Resource Acquisition Is Initialization)を強制するので、オブジェクトがスコープを抜けると、必ずデストラクタが呼び出されてそのオブジェクトが保持していた資源が解放されます。</p>
<p>この振る舞いは <em>リソースリーク</em> バグを防ぐのに役立ちます。手動でメモリを解放したり、メモリリークバグにわずらわされたりすることはなくなるのです！簡単な例で説明しましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">// raii.rs
fn create_box() {
    // 整数をヒープ上に確保。
    let _box1 = Box::new(3i32);

    // `_box1`はここで破棄され、メモリは解放されます。
}

fn main() {
    // 整数をヒープ上に確保。
    let _box2 = Box::new(5i32);

    // ネストしたスコープ
    {
        // 整数をヒープ上に確保。
        let _box3 = Box::new(4i32);

        // `_box3`はここで破棄され、メモリは解放されます。
    }

    // お遊びで大量のボックスを作ります。
    // もちろん手動で開放する必要はないよ！
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2`はここで破棄され、メモリは解放されます。
}</code></pre>
<p><a href="http://valgrind.org/info/"><code>valgrind</code></a>を用いて、メモリエラーが起きていないか2重チェックすることももちろん可能です。</p>
<!-- REUSE-IgnoreStart -->
<!-- Prevent REUSE from parsing the copyright statement in the sample code -->
<pre><code class="language-shell">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<!-- REUSE-IgnoreEnd -->
<p>リークはないみたいですね！</p>
<h2 id="デストラクタ"><a class="header" href="#デストラクタ">デストラクタ</a></h2>
<p>Rustにおけるデストラクタの概念は<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>トレイトによって提供されています。デストラクタは資源がスコープを抜けるときに呼び出されます。<code>Drop</code>トレイトは型定義のたびに必ず実装する必要があるわけではなく、デストラクタに独自のロジックが必要な場合にのみ実装します。</p>
<p>下のコードを実行して、<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>トレイトの動作を確認してみましょう。<code>main</code>関数内の変数がスコープを抜けるときにカスタムデストラクタが呼び出されるはずです。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!("ToDrop is being dropped");
    }
}

fn main() {
    let x = ToDrop;
    println!("Made a ToDrop!");
}</code></pre>
<h3 id="参照-48"><a class="header" href="#参照-48">参照</a></h3>
<p><a href="#boxスタックとヒープ">Box</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="所有権とムーブ"><a class="header" href="#所有権とムーブ">所有権とムーブ</a></h1>
<p>変数には自身の保持する資源を開放する責任があるため、<strong>資源は一度に一つの所有者</strong> しか持つことができません。これはまた、資源を2度以上開放することができないということでもあります。ここで、全ての変数が資源を所有するわけではないということに注意しましょう。（e.g. <a href="#ポインタとref">参照</a>）</p>
<p>変数を代入する（<code>let x = y</code>）際や、関数に引数を値渡しする（<code>foo(x)</code>）際は、資源の <em>所有権</em> が移動します。Rustっぽく言うと、「 <em>ムーブ</em> 」です。</p>
<p>資源を移動すると、それまでの所有者（訳注：変数などのこと）を使用することはできなくなります。これによりダングリングポインタの発生を防げます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// この関数はヒープメモリ上の資源の所有権を取ります。
fn destroy_box(c: Box&lt;i32&gt;) {
    println!("Destroying a box that contains {}", c);

    // `c`は破棄されメモリは開放されます。
}

fn main() {
    // _スタック_上に置かれた整数
    let x = 5u32;

    // `x`を`y`に *コピー* します。元の値が移動するわけではありません。
    let y = x;

    // 両方の値はそれぞれ独立に使うことができます。
    println!("x is {}, and y is {}", x, y);

    // `a`は_ヒープ_上の整数へのポインタ。
    let a = Box::new(5i32);

    println!("a contains: {}", a);

    // `a`を`b`に *ムーブ* します。
    let b = a;
    // すなわち、`a`の指すメモリ上の番地が`b`にコピーされるため
    // いずれもヒープ上の同じ値を指すポインタとなります。
    // しかし所有権は`b`にあります。

    // エラー！`a`は所有権を持たないため、ヒープ上のデータにアクセスできません。
    //println!("a contains: {}", a);
    // TODO ^ 試しにここをアンコメントしてみましょう。

    // この関数はヒープメモリ上の所有権を`b`から取ります。
    destroy_box(b);

    // この時点でヒープメモリ上の資源は開放されているので、次の操作は
    // 解放済みメモリをデリファレンスすることになります。
    // しかしそれはコンパイラが許しません。
    // エラー！上述の理由より
    //println!("b contains: {}", b);
    // TODO ^ 試しにここをアンコメントしてみましょう。
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ミュータビリティ-1"><a class="header" href="#ミュータビリティ-1">ミュータビリティ</a></h1>
<p>データのミュータビリティは所有権を移譲した際に変更できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let immutable_box = Box::new(5u32);

    println!("immutable_box contains {}", immutable_box);

    // ミュータビリティエラー
    //*immutable_box = 4;

    // boxを *ムーブ* する、同時に所有権とミュータビリティを変更します。
    let mut mutable_box = immutable_box;

    println!("mutable_box contains {}", mutable_box);

    // boxの内容を変更。
    *mutable_box = 4;

    println!("mutable_box now contains {}", mutable_box);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="部分的ムーブ"><a class="header" href="#部分的ムーブ">部分的ムーブ</a></h1>
<p>Within the <a href="#デストラクト">destructuring</a> of a single variable, both <code>by-move</code> and <code>by-reference</code> pattern bindings can be used at the same time. Doing this will result in a <em>partial move</em> of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used. Note that types that implement the <a href="#ドロップ"><code>Drop</code> trait</a> cannot be partially moved from, because its <code>drop</code> method would use it afterwards as a whole.</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    // Error! cannot move out of a type which implements the `Drop` trait
    //impl Drop for Person {
    //    fn drop(&amp;mut self) {
    //        println!("Dropping the person struct {:?}", self)
    //    }
    //}
    // TODO ^ Try uncommenting these lines

    let person = Person {
        name: String::from("Alice"),
        age: Box::new(20),
    };

    // `name` は person からムーブしたが、 `age` は参照されています。
    let Person { name, ref age } = person;

    println!("The person's age is {}", age);

    println!("The person's name is {}", name);

    // エラー！部分的ムーブした値の借用：`person` では部分的ムーブが発生しています。
    //println!("The person struct is {:?}", person);

    // `person` は使用できませんが、
    // `person.age` はムーブしていないので使用できます。
    println!("The person's age from person struct is {}", person.age);
}</code></pre>
<p>この例では、<code>age</code>変数をヒープ上に保持し、部分的ムーブを説明しています。上記コードで<code>ref</code>を削除すると、<code>person.age</code>の所有権が<code>age</code>変数にムーブされるため、エラーになります。もしも<code>Person.age</code>がスタック上に保持されていたら、<code>age</code>の定義が<code>person.age</code>をムーブすることなくデータをコピーするので、<code>ref</code>は必須ではないのですが、実際にはヒープ上に保持されているため<code>ref</code>は必須です。</p>
<h3 id="参照-49"><a class="header" href="#参照-49">参照</a></h3>
<p><a href="#デストラクト">デストラクト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="借用"><a class="header" href="#借用">借用</a></h1>
<p>実際には、データの所有権を完全に受け渡すことなく一時的にアクセスしたいという場合がほとんどです。そのために、Rustでは <em>借用</em> という仕組みを用います。値そのもの（<code>T</code>）を受け渡すのではなく、その参照（<code>&amp;T</code>）を渡すのです。</p>
<p>コンパイラは借用チェッカを用いて参照が <em>常に</em> 有効なオブジェクトへの参照であることを、コンパイル時に保証します。つまり、あるオブジェクトへの参照が存在しているならば、そのオブジェクトを破壊することはできないということです。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// この関数はボックスの所有権を奪い、破棄します。
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!("Destroying box that contains {}", boxed_i32);
}

// この関数はi32を借用します。
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!("This int is: {}", borrowed_i32);
}

fn main() {
    // Create a boxed i32 in the heap, and an i32 on the stack
    // Remember: numbers can have arbitrary underscores added for readability
    // 5_i32 is the same as 5i32
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Boxの中身を借用。所有権を奪うわけではないため、
    // 直後にもう一度借用できます。
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // ボックス内の要素に対する参照を取得。
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // エラー!
        // ボックス内の要素が借用されているため、`boxed_i32`を破棄する
        // ことはできません。
        eat_box_i32(boxed_i32);
        // FIXME ^ この行をコメントアウトしましょう

        // Attempt to borrow `_ref_to_i32` after inner value is destroyed
        borrow_i32(_ref_to_i32);
        // ここで`_ref_to_i32`はスコープを抜け、借用もなくなります。
    }

    // `boxed_i32` can now give up ownership to `eat_box_i32` and be destroyed
    eat_box_i32(boxed_i32);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ミュータビリティ-2"><a class="header" href="#ミュータビリティ-2">ミュータビリティ</a></h1>
<p>ミュータブルなデータは<code>&amp;mut T</code>でミュータブルに（変更可能な形で）借用することができます。これは <em>ミュータブルな参照</em> と呼ばれ、読み込み・書き込みの権限を借用者に与えます。対照的に<code>&amp;T</code>はデータをイミュータブルな参照を介して借用し、借用した側はデータを読み込みはできますが書き込みはできません。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str`はread-onlyメモリ上の文字列への参照。
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// この関数はBook型への参照を取ります。
fn borrow_book(book: &amp;Book) {
    println!("I immutably borrowed {} - {} edition", book.title, book.year);
}

// この関数はミュータブルなBook型へのミュータブルな参照を取り、
// `year`を2014へ変更します。
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!("I mutably borrowed {} - {} edition", book.title, book.year);
}

fn main() {
    // `immutabook`という名のイミュータブルなBookを作成。
    let immutabook = Book {
        // 文字列リテラルは`&amp;'static str`型になります。
        author: "Douglas Hofstadter",
        title: "Gödel, Escher, Bach",
        year: 1979,
    };

    // `immutabook`のミュータブルなコピーを作成し、`mutabook`と名付けます。
    let mut mutabook = immutabook;

    // イミュータブルなオブジェクトをイミュータブルに借用します。
    borrow_book(&amp;immutabook);

    // ミュータブルなオブジェクトをイミュータブルに借用します。
    borrow_book(&amp;mutabook);

    // ミュータブルなオブジェクトをミュータブルに借用します。
    new_edition(&amp;mut mutabook);

    // エラー！イミュータブルなオブジェクトをミュータブルに借用できません。
    new_edition(&amp;mut immutabook);
    // FIXME ^ この行をコメントアウトしましょう
}</code></pre>
<h3 id="参照-50"><a class="header" href="#参照-50">参照</a></h3>
<p><a href="#スタティックライフタイム"><code>static</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="エイリアス-1"><a class="header" href="#エイリアス-1">エイリアス</a></h1>
<p>データは一度にいくつでもイミュータブルに借用することができますが、その間オリジナルのデータをミュータブルに借用することはできません。一方でミュータブルな借用は一度に <em>一つ</em> しか借用することができません。オリジナルのデータをもう一度借用できるのはミュータブルな参照が最後に使われた場所より <em>あとで</em> なければいけません。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &amp;point;
    let another_borrow = &amp;point;

    // データは元々の持ち主と参照の両方からアクセスすることができます。
    println!("Point has coordinates: ({}, {}, {})",
                borrowed_point.x, another_borrow.y, point.z);

    // エラー！pointはすでにイミュータブルに借用されているため、
    // ミュータブルに借用することができません。
    // let mutable_borrow = &amp;mut point;
    // TODO ^ この行をアンコメントしてみましょう。

    // 借用された値はここで再び利用されます。
    println!("Point has coordinates: ({}, {}, {})",
                borrowed_point.x, another_borrow.y, point.z);

    // イミュータブルな参照がこれ以降のコードで利用されていないため、
    // ミュータブルな参照として再借用できます。
    let mutable_borrow = &amp;mut point;

    // ミュータブルな参照を介してデータを変更します。
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // エラー！`point`はすでにミュータブルに借用されているため、
    // イミュータブルに借用することはできません。
    // let y = &amp;point.y;
    // TODO ^ この行をアンコメントしてみましょう。

    // エラー！`println!`はイミュータブルな参照を取るため、printできません。
    // println!("Point Z coordinate is {}", point.z);
    // TODO ^ この行をアンコメントしてみましょう。

    // OK！ミュータブルな参照は`println!`にイミュータブルな参照として渡せます。
    println!("Point has coordinates: ({}, {}, {})",
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // ミュータブルな参照がこれ以降のコードで未使用なので、再借用できます。
    let new_borrowed_point = &amp;point;
    println!("Point now has coordinates: ({}, {}, {})",
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="refパターン"><a class="header" href="#refパターン">refパターン</a></h1>
<p><code>let</code>を介してデストラクトやパターンマッチングを行う場合、<code>ref</code>キーワードを用いて構造体・タプルのフィールドへの参照を取得することができます。以下の例ではこれが有用になる例を幾つかお見せします。</p>
<pre class="playground"><code class="language-rust editable edition2021">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // 左辺に`ref`をつけることによる借用と、右辺に`&amp;`をつけることによる借用は等価。
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!("ref_c1 equals ref_c2: {}", *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref`は構造体をデストラクトする際にも有用。
    let _copy_of_x = {
        // `ref_to_x`は`point`の`x`フィールドへの参照。
        let Point { x: ref ref_to_x, y: _ } = point;

        // `point`の`x`フィールドへのコピーを返します。
        *ref_to_x
    };

    // `point`へのミュータブルなコピー
    let mut mutable_point = point;

    {
        // `ref`は`mut`とともに使い、ミュータブルな参照を取ることもできます。
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // `mutable_point`の`y`というミュータブルなフィールドの値を変更します。
        *mut_ref_to_y = 1;
    }

    println!("point is ({}, {})", point.x, point.y);
    println!("mutable_point is ({}, {})", mutable_point.x, mutable_point.y);

    // ポインタを含むミュータブルなタプル
    let mut mutable_tuple = (Box::new(5u32), 3u32);

    {
        // `mutable_tuple`をデストラクトして、`last`の値を変更。
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }

    println!("tuple is {:?}", mutable_tuple);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ライフタイム"><a class="header" href="#ライフタイム">ライフタイム</a></h1>
<p><em>ライフタイム</em> はコンパイラ（借用チェッカーと呼ばれる場合もあります）が、全ての借用に問題がないことを確認するために使用する仕組みです。正確にいうと、変数のライフタイムは作成時に開始し、破棄された時に終了します。ライフタイムとスコープは同時に語られることが多いですが、同じものではありません。</p>
<p>例として<code>&amp;</code>を用いて変数を借用する場合をあげましょう。借用のライフタイムは宣言時に決定し、そこから貸し手が破棄されるまで続きます。しかしながら、借用のスコープは参照が使われる際に決定します。</p>
<p>以下の例からこのセクションの残りでは、ライフタイムとスコープの関係、そしてそれらがいかに異なるものであるかを見ていきます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// Lifetimes are annotated below with lines denoting the creation
// and destruction of each variable.
// `i` has the longest lifetime because its scope entirely encloses
// both `borrow1` and `borrow2`. The duration of `borrow1` compared
// to `borrow2` is irrelevant since they are disjoint.
fn main() {
    let i = 3; // `i`のライフタイム開始 ───────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1`のライフタイム開始──┐│
        //                                                ││
        println!("borrow1: {}", borrow1); //              ││
    } // `borrow1` 終了 ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2`のライフタイム開始──┐│
        //                                                ││
        println!("borrow2: {}", borrow2); //              ││
    } // `borrow2` 終了 ──────────────────────────────────┘│
    //                                                     │
}   // ライフタイム終了 ───────────────────────────────────┘</code></pre>
<p>ここで、一切の名前や型がライフタイムに代入されていないことに注意しましょう。これにより、ライフタイムの使われ方がこれから見ていくようなやり方に制限されます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="明示的アノテーション"><a class="header" href="#明示的アノテーション">明示的アノテーション</a></h1>
<p>借用チェッカーは参照がどれだけの間有効かを決定するために、明示的なアノテーションを使用します。ライフタイムが省略<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>されなかった場合、Rustは参照のライフタイムがどのようなものであるか、明示的なアノテーションを必要とします。</p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo`は`'a`というライフタイムパラメータを持ちます。</code></pre>
<p><a href="#匿名型">クロージャ</a>と同様、ライフタイムの使用はジェネリクスを必要とします。もう少し詳しく言うと、この書き方は「<code>foo</code>のライフタイムは<code>'a</code>のそれを超えることはない。」ということを示しており、型を明示した場合<code>'a</code>は<code>&amp;'a T</code>となるということです。</p>
<p>ライフタイムが複数ある場合も、同じような構文になります。</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo`は`'a`と`'b`というライフタイムパラメータを持ちます。</code></pre>
<p>この場合は、<code>foo</code>のライフタイムは<code>'a</code>、<code>'b</code>の <em>いずれよりも</em> 長くなってはなりません。</p>
<p>以下はライフタイムを明示的に書く場合の例です。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// `print_refs`は`i32`への参照を2つとり、それぞれ`'a`と`'b`という
// ライフタイムを持ちます。これらのライフタイムは最短でも`print_refs`
// 関数と同じになります。
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!("x is {} and y is {}", x, y);
}

// 引数を取らないがライフタイムパラメータ`'a`を持つ関数
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // エラー：`_x`の寿命が短すぎる。
    let _y: &amp;'a i32 = &amp;_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation
    // inside the function will fail because the lifetime of `&amp;_x` is shorter
    // than that of `_y`. A short lifetime cannot be coerced into a longer one.
}

fn main() {
    // 下で借用するための変数を作成。
    let (four, nine) = (4, 9);

    // 2つの変数の借用（`&amp;`）が関数に渡されます。
    print_refs(&amp;four, &amp;nine);
    // Any input which is borrowed must outlive the borrower.
    // In other words, the lifetime of `four` and `nine` must
    // be longer than that of `print_refs`.

    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
}</code></pre>
<h3 id="参照-51"><a class="header" href="#参照-51">参照</a></h3>
<p><a href="#ジェネリクス">ジェネリクス</a>, <a href="#クロージャ">クロージャ</a></p>
<hr>
<ol class="footnote-definition">
<li id="footnote-1">
<p><a href="#省略">省略</a> はライフタイムが暗黙のうちに（プログラマから見えない形で）アノテートされることを指します。 <a href="#fr-1-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="関数-2"><a class="header" href="#関数-2">関数</a></h1>
<p><a href="#省略">省略</a>をしない場合、ライフタイムのシグネチャ（e.g. <code>&lt;'a&gt;</code>）を持つ関数にはいくつかの制限があります。</p>
<ul>
<li>全ての参照においてライフタイムを明示しなくてはなりません。</li>
<li>返り値となる参照はすべて引数と同じライフタイムか、<code>static</code>ライフタイムを持たなくてはなりません</li>
</ul>
<p>加えて、引数のない関数から参照を返すことは、それが結果的に無効なデータへの参照になるならば、禁止されています。ライフタイムを持つ関数の例をいくつか示します。</p>
<pre class="playground"><code class="language-rust editable edition2021">// 引数として`'a`のライフタイムで参照を一つ取ります。最低でもこの関数
// と同じだけの長さでなくてはなりません。
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!("`print_one`: x is {}", x);
}

// ミュータブルな参照でも同様。
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// 異なるライフタイムを持つ複数の引数がある場合。
// ここでは1種類のライフタイムでも問題ありませんが、より複雑なケースでは
// 異なるライフタイムが必要になる場合があります。
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

// 受け取った参照をそのまま返すことに問題ありませんが、適切なライフタイム
// でなくてはなりません。
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

// `'a`は関数より長くなくてはならないため上の関数は正しくありません。
// ここでは、`&amp;String::from("foo")`は`String`のデータとそれへの参照を作ります。
// その後データはスコープを抜けるとともに破棄されます。そのため、
// 不適切なデータに対する参照を返すことになってしまいます。

fn main() {
    let x = 7;
    let y = 9;

    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);

    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}</code></pre>
<h3 id="参照-52"><a class="header" href="#参照-52">参照</a></h3>
<p><a href="#関数">関数</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="メソッド"><a class="header" href="#メソッド">メソッド</a></h1>
<p>メソッドのライフタイムは関数に似ています。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Owner(i32);

impl Owner {
    // 通常の関数と同様にライフタイムを明示。
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!("`print`: {}", self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}</code></pre>
<h3 id="参照-53"><a class="header" href="#参照-53">参照</a></h3>
<p><a href="#関連関数とメソッド">メソッド</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="構造体-2"><a class="header" href="#構造体-2">構造体</a></h1>
<p>構造体におけるライフタイムも関数のそれと似ています。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `i32`への参照をメンバに持つ`Borrowed`型。
// 参照は`Borrowed`自体よりも長生きでなくてはなりません。
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// 同様に、ここでも参照は構造体よりも長生きでなくてはなりません。
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// `i32`、あるいは`i32`への参照のいずれかとなる列挙型
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!("x is borrowed in {:?}", single);
    println!("x and y are borrowed in {:?}", double);
    println!("x is borrowed in {:?}", reference);
    println!("y is *not* borrowed in {:?}", number);
}</code></pre>
<h3 id="参照-54"><a class="header" href="#参照-54">参照</a></h3>
<p><a href="#構造体">構造体</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="トレイト-1"><a class="header" href="#トレイト-1">トレイト</a></h1>
<p>トレイトのメソッドにおけるライフタイムのアノテーションは、基本的には関数に似ています。<code>impl</code>にもライフタイムのアノテーションがあることに注意してください。</p>
<pre class="playground"><code class="language-rust editable edition2021">// ライフタイムのアノテーションつき構造体
#[derive(Debug)]
struct Borrowed&lt;'a&gt; {
    x: &amp;'a i32,
}

// ライフタイムのアノテーションつきimpl
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!("b is {:?}", b);
}</code></pre>
<h3 id="参照-55"><a class="header" href="#参照-55">参照</a></h3>
<p><a href="#トレイト-2">トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="境界-1"><a class="header" href="#境界-1">境界</a></h1>
<p>ジェネリック型に境界を与え、特定のトレイトを実装していることを保証できるのと同様、ライフタイム（それ自身ジェネリック型）にも境界を与えることができます。<code>:</code>は、ここでは多少異なる意味を持ちますが<code>+</code>は同じです。以下の構文の意味をチェックしてください。</p>
<ol>
<li><code>T: 'a</code>：<code>T</code>内の <em>全ての</em> 参照は<code>'a</code>よりも長生きでなくてはなりません。</li>
<li><code>T: Trait + 'a</code>：上に加えて<code>T</code>は<code>Trait</code>という名のトレイトを実装してなくてはなりません。</li>
</ol>
<p>上記の構文を実際に動く例で見ていきましょう。<code>where</code>キーワードの後に注目してください。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Debug; // ライフタイムを紐付けるトレイト

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` contains a reference to a generic type `T` that has
// some lifetime `'a` unknown by `Ref`. `T` is bounded such that any
// *references* in `T` must outlive `'a`. Additionally, the lifetime
// of `Ref` may not exceed `'a`.

// `Debug`トレイトを利用して出力を行うジェネリック関数
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// `Debug`を実装している`T`への参照を取りません。`T`への *参照* は
// 必ず`'a`よりも長生きでなくてはなりません。さらに、`'a`は
// 関数自体よりも長生きでなくてはなりません。
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}</code></pre>
<h3 id="参照-56"><a class="header" href="#参照-56">参照</a></h3>
<p><a href="#ジェネリクス">ジェネリクス</a>, <a href="#境界">ジェネリック境界</a>, <a href="#複数の境界">複数の境界</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="強制"><a class="header" href="#強制">強制</a></h1>
<p>長いライフタイムは、短いものに圧縮することで、そのままでは動作しないスコープの中でも使用できるようになります。これは、Rustコンパイラが推論の結果として圧縮する場合と、複数のライフタイムを比較して圧縮する場合があります。</p>
<pre class="playground"><code class="language-rust editable edition2021">// ここではRustはライフタイムを出来る限り短く見積もり、
// 2つの参照をそのライフタイムに押し込めます。
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;`は「ライフタイム`'a`は最低でも`'b`と同じ長さ」と読めます。
// ここでは、`&amp;'a i32`をとり、`&amp;'b i32`に圧縮して返します。
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // 長いライフタイム

    {
        let second = 3; // 短いライフタイム

        println!("The product is {}", multiply(&amp;first, &amp;second));
        println!("{} is the first", choose_first(&amp;first, &amp;second));
    };
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="スタティックライフタイム"><a class="header" href="#スタティックライフタイム">スタティックライフタイム</a></h1>
<p>Rustにはいくつかの予約されたライフタイム名があります。その1つが<code>static</code>で、2つの状況で使用することがあります。</p>
<pre><code class="language-rust ignore">// A reference with 'static lifetime:
let s: &amp;'static str = "hello world";

// 'static as part of a trait bound:
fn generic&lt;T&gt;(x: T) where T: 'static {}</code></pre>
<p>2つの状況における<code>static</code>は微妙に異なる意味を持っており、Rustを学ぶときの混乱の元になっています。いくつかの例とともにそれぞれの使い方を見てみましょう。</p>
<h2 id="参照のライフタイム"><a class="header" href="#参照のライフタイム">参照のライフタイム</a></h2>
<p>参照のライフタイムが<code>'static</code>であることは、参照が指し示す値がプログラムの実行中に渡って生き続けることを示します。また、より短いライフタイムに圧縮することも可能です。</p>
<p><code>'static</code>ライフタイムを持つ変数を作るには下記の2つ方法があります。どちらの場合も、値は読み取り専用のメモリ領域に格納されます。</p>
<ul>
<li><code>static</code>宣言とともに定数を作成します。</li>
<li>文字列リテラルで<code>&amp;'static str</code>型を持つ変数を作成します。</li>
</ul>
<p>では、それぞれの方法の例を見ていきましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `'static`ライフタイムを持つ定数を作成。
static NUM: i32 = 18;

// `NUM`への参照を返します。ライフタイムは`'static`から引数の
// ライフタイムへと圧縮されています。
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // 文字列リテラルを用いて変数を作成し、出力します。
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // `static_string`がスコープから抜けると、参照は使用することが
        // できなくなりますが、データはバイナリ中に残ります。
    }

    {
        // `coerce_static`関数を呼び出すために、整数を作成。
        let lifetime_num = 9;

        // `NUM`を`lifetime_num`のライフタイムへと圧縮。
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!("coerced_static: {}", coerced_static);
    }

    println!("NUM: {} stays accessible!", NUM);
}</code></pre>
<p>Since <code>'static</code> references only need to be valid for the <em>remainder</em> of a program’s life, they can be created while the program is executed. Just to demonstrate, the below example uses <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> to dynamically create <code>'static</code> references. In that case it definitely doesn’t live for the entire duration, but only from the leaking point onward.</p>
<pre class="playground"><code class="language-rust editable compile_fail edition2021">extern crate rand;
use rand::Fill;

fn random_vec() -&gt; &amp;'static [u64; 100] {
    let mut rng = rand::rng();
    let mut boxed = Box::new([0; 100]);
    boxed.fill(&amp;mut rng);
    Box::leak(boxed)
}

fn main() {
    let first: &amp;'static [u64; 100] = random_vec();
    let second: &amp;'static [u64; 100] = random_vec();
    assert_ne!(first, second)
}</code></pre>
<h2 id="トレイト境界"><a class="header" href="#トレイト境界">トレイト境界</a></h2>
<p>トレイト境界としての<code>'static</code>は型が非静的な参照を含まないことを意味します。言い換えると、レシーバはその型をいくらでも長く保持することができ、意図的にドロップするまでは決して無効になることはないということです。</p>
<p>次のポイントを押さえておきましょう。所有権のある値が<code>'static</code>ライフタイム境界をパスするとしても、その値への参照が<code>'static</code>ライフタイム境界をパスするとは限りません。</p>
<pre class="playground"><code class="language-rust editable compile_fail edition2021">use std::fmt::Debug;

fn print_it(input: impl Debug + 'static) {
    println!("'static value passed in is: {:?}", input);
}

fn main() {
    // i は所有されていて、かつ参照を含まないので 'static。
    let i = 5;
    print_it(i);

    // おっと、&amp;i は main() のスコープで定義された
    // ライフタイムしかもたないため 'static ではありません。
    print_it(&amp;i);
}</code></pre>
<p>コンパイラのメッセージはこのようになります。</p>
<pre><code class="language-ignore">error[E0597]: `i` does not live long enough
  --&gt; src/lib.rs:15:15
   |
15 |     print_it(&amp;i);
   |     ---------^^--
   |     |         |
   |     |         borrowed value does not live long enough
   |     argument requires that `i` is borrowed for `'static`
16 | }
   | - `i` dropped here while still borrowed
</code></pre>
<h3 id="参照-57"><a class="header" href="#参照-57">参照</a></h3>
<p><a href="#定数"><code>'static</code> 定数</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="省略"><a class="header" href="#省略">省略</a></h1>
<p>ライフタイムのパターンのうちのいくつかは、他と比べてあまりにも一般的に使用されるため、タイプ量を減らし可読性を上げるために省くことができます。これは省略として知られており、それらのパターンが一般的であるというだけの理由で存在しています。</p>
<p>以下のコードでは省略の例を幾つかお見せします。より完全な説明を見たい場合は、「プログラミング言語Rust」の<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">ライフタイムの省略</a>の項を見てください。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `elided_input`のライフタイムはコンパイラによって自動的に付与されるため
// 以下の2つは同一のライフタイムシグネチャを持ちます。
fn elided_input(x: &amp;i32) {
    println!("`elided_input`: {}", x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!("`annotated_input`: {}", x);
}

// 同様に、以下の2つの関数も全く同じライフタイムシグネチャを持ちます。
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!("`elided_pass`: {}", elided_pass(&amp;x));
    println!("`annotated_pass`: {}", annotated_pass(&amp;x));
}</code></pre>
<h3 id="参照-58"><a class="header" href="#参照-58">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">省略</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="トレイト-2"><a class="header" href="#トレイト-2">トレイト</a></h1>
<p>トレイトとは任意の型となりうる<code>Self</code>に対して定義されたメソッドの集合のことです。同じトレイト内で宣言されたメソッド同士はお互いにアクセスすることができます。</p>
<p>トレイトはあらゆるデータ型に実装することができます。以下の例ではまず<code>Animal</code>というメソッドの集合を定義し、その後<code>Animal</code>トレイトを<code>Sheep</code>というデータ型に対して実装します。これにより<code>Animal</code>のメソッドを<code>Sheep</code>が使用することが可能になります。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // 関連関数のシグネチャ
    // `Self` はこのトレイトを実装している型になります。
    fn new(name: &amp;'static str) -&gt; Self;

    // メソッドのシグネチャ
    // これらの関数は文字列を返します。
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // メソッドのデフォルトの挙動を定義することもできます。
    fn talk(&amp;self) {
        println!("{} says {}", self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // メソッドをある型に実装する際に、その型のトレイトメソッドを
            // 使用することができます。
            println!("{} is already naked...", self.name());
        } else {
            println!("{} gets a haircut!", self.name);

            self.naked = true;
        }
    }
}

// `Animal`というトレイトを`Sheep`に実装します。
impl Animal for Sheep {
    // `Self`は実装対象の型：ここでは`Sheep`
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            "baaaaah?"
        } else {
            "baaaaah!"
        }
    }

    // デフォルトのトレイトメソッドはオーバーライドすることができます。
    fn talk(&amp;self) {
        // 例えば、静かに熟考させてみます。
        println!("{} pauses briefly... {}", self.name, self.noise());
    }
}

fn main() {
    // この場合、型アノテーションが必須。
    let mut dolly: Sheep = Animal::new("Dolly");
    // TODO ^ ここの型アノテーションを消してみましょう。

    dolly.talk();
    dolly.shear();
    dolly.talk();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="導出derive"><a class="header" href="#導出derive">導出(Derive)</a></h1>
<p>コンパイラには、<code>#[derive]</code><a href="#アトリビュート">アトリビュート</a>を用いることで型に対して特定のトレイトの標準的な実装を提供する機能があります。より複雑なことを行わせたい場合には、同名のトレイトを手動で実装することも可能です。</p>
<p>以下はderive可能なトレイトの一覧です。</p>
<ul>
<li>型の比較に関連するトレイト: <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>.</li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>：これはコピーによって<code>&amp;T</code>から<code>T</code>を作成するトレイト</li>
<li><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a>：これはムーブセマンティクスの代わりにコピーセマンティクスにするためのトレイト</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>：これは<code>&amp;T</code>からハッシュ値を計算するためのトレイト</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>：これは空っぽのインスタンスを作成するためのトレイト</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>：これは<code>{:?}</code>フォーマッタを利用して値をフォーマットするためのトレイト</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">// `Centimeters`は比較可能なタプルになります。
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`は出力可能なタプルになります。
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`には特にアトリビュートを付け加えません。
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // エラー：`Debug`トレイトを実装していないため`Seconds`は出力できません。
    //println!("One second looks like: {:?}", _one_second);
    // TODO ^ この行をアンコメントしてみましょう。

    // エラー`PartialEq`トレイトを実装していないため`Seconds`は比較できません。
    //let _this_is_true = (_one_second == _one_second);
    // TODO ^ この行をアンコメントしてみましょう。

    let foot = Inches(12);

    println!("One foot equals {:?}", foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            "smaller"
        } else {
            "bigger"
        };

    println!("One foot is {} than one meter.", cmp);
}</code></pre>
<h3 id="参照-59"><a class="header" href="#参照-59">参照</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#derive">導出</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dynを利用してトレイトを返す"><a class="header" href="#dynを利用してトレイトを返す"><code>dyn</code>を利用してトレイトを返す</a></h1>
<p>Rustのコンパイラはあらゆる関数のリターン型に必要なスペースを知っておく必要があります。つまり、すべての関数は具体的な型を返す必要があるのです。他の言語と違って、<code>Animal</code>のようなトレイトがある場合に、<code>Animal</code>を返す関数を書くことはできません。なぜなら、そのトレイトの異なる実装はそれぞれ別の量のメモリを必要とするからです。</p>
<p>しかし、簡単な回避策があります。直接トレイトオブジェクトを返す代わりに、<code>Animal</code>を <em>含む</em> <code>Box</code>を返すのです。<code>Box</code>はヒープ中のメモリへの単なる参照です。参照のサイズは静的に知ることができ、コンパイラは参照がヒープに割り当てられた<code>Animal</code>を指していると保証できるので、私たちは関数からトレイトを返すことができます。</p>
<p>ヒープにメモリを割り当てる際、Rustは可能な限り明示的であろうとします。なので、もしあなたの関数がヒープ上のトレイトへのポインタを返す場合、例えば<code>Box&lt;dyn Animal&gt;</code>のように、リターン型に<code>dyn</code>キーワードをつける必要があります。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Sheep {}
struct Cow {}

trait Animal {
    // インスタンスメソッドのシグネチャ
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// `Animal`というトレイトを`Sheep`に実装します。
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        "baaaaah!"
    }
}

// `Cow`に`Animal`トレイトを実装します。
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        "moooooo!"
    }
}

// Animalを実装した何らかの構造体を返します。
// ただし、コンパイル時にはどの実装か分かりません。
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!("You've randomly chosen an animal, and it says {}", animal.noise());
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="演算子のオーバーロード"><a class="header" href="#演算子のオーバーロード">演算子のオーバーロード</a></h1>
<p>Rustでは、多くの演算子はトレイトによってオーバーロードすることができます。つまり、一部の演算子は引数となる値の型に応じて異なる役割を果たすことができるということです。これが可能なのは、演算子が実際にはメソッド呼び出しの糖衣構文にすぎないからです。例えば<code>a + b</code>における<code>+</code>演算子は<code>add</code>メソッドを（<code>a.add(b)</code>の形で）呼び出します。この<code>add</code>メソッドは<code>Add</code>トレイトの一部です。それ故、<code>+</code>は<code>Add</code>トレイトを実装している全ての型に対して有効なのです。</p>
<p><code>Add</code>などの、演算子をオーバーロードするトレイトの一覧は<a href="https://doc.rust-lang.org/core/ops/"><code>core::ops</code></a>にあります。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// `std::ops::Add`トレイトは`+`の振る舞いを規定するために使用されます。
// ここでは`Foo`に対して`Add&lt;Bar&gt;`を実装します。これは加算時の右辺が`Bar`型
// の時に呼び出されるトレイトです。
// つまり以下は`Foo + Bar = FooBar`という振る舞いをもたらします。
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!("&gt; Foo.add(Bar) was called");

        FooBar
    }
}

// 型を反転することで、非可換の加算を実装できます。ここでは`Bar`に対して
// `Add&lt;Foo&gt;`を実装します。
// これは加算時の右辺が`Foo`型の時に呼び出されるメソッドです。
// つまり以下は`Bar + Foo = BarFoo`という結果をもたらします。
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!("&gt; Bar.add(Foo) was called");

        BarFoo
    }
}

fn main() {
    println!("Foo + Bar = {:?}", Foo + Bar);
    println!("Bar + Foo = {:?}", Bar + Foo);
}</code></pre>
<h3 id="参照-60"><a class="header" href="#参照-60">参照</a></h3>
<p><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a>, <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">構文の索引</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ドロップ"><a class="header" href="#ドロップ">ドロップ</a></h1>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>トレイトにはメソッドが一つだけしかありません。<code>drop</code>です。これは、オブジェクトがスコープから抜けた時に自動で呼ばれます。<code>Drop</code>トレイトの主な使用目的は、インスタンスが所有する資源を開放することです。</p>
<p><code>Drop</code>トレイトを実装している型の例としては<code>Box</code>、<code>Vec</code>、<code>String</code>、<code>File</code>、<code>Process</code>等があげられます。<code>Drop</code>トレイトは任意の型に対して手動で実装することができます。</p>
<p>以下の例では<code>drop</code>メソッドにコンソールへの出力を追加することで、<code>drop</code>が呼ばれたタイミングが分かるようにしています。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Droppable {
    name: &amp;'static str,
}

// このちょっとした実装で、`drop`にコンソール出力機能がつきます。
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!("&gt; Dropping {}", self.name);
    }
}

fn main() {
    let _a = Droppable { name: "a" };

    // block A
    {
        let _b = Droppable { name: "b" };

        // block B
        {
            let _c = Droppable { name: "c" };
            let _d = Droppable { name: "d" };

            println!("Exiting block B");
        }
        println!("Just exited block B");

        println!("Exiting block A");
    }
    println!("Just exited block A");

    // `drop`関数を用いて変数を手動で開放することもできます。
    drop(_a);
    // TODO ^ この行をコメントアウトしてみましょう。

    println!("end of the main function");

    // `_a`はここで`drop`されることは *ありません* 。なぜならば、上ですでに
    // （手動で）`drop`されているためです。
}</code></pre>
<p>For a more practical example, here’s how the <code>Drop</code> trait can be used to automatically clean up temporary files when they’re no longer needed:</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::path::PathBuf;

struct TempFile {
    file: File,
    path: PathBuf,
}

impl TempFile {
    fn new(path: PathBuf) -&gt; std::io::Result&lt;Self&gt; {
        // Note: File::create() will overwrite existing files
        let file = File::create(&amp;path)?;

        Ok(Self { file, path })
    }
}

// When TempFile is dropped:
// 1. First, our drop implementation will remove the file's name from the filesystem.
// 2. Then, File's drop will close the file, removing its underlying content from the disk.
impl Drop for TempFile {
    fn drop(&amp;mut self) {
        if let Err(e) = std::fs::remove_file(&amp;self.path) {
            eprintln!("Failed to remove temporary file: {}", e);
        }
        println!("&gt; Dropped temporary file: {:?}", self.path);
        // File's drop is implicitly called here because it is a field of this struct.
    }
}

fn main() -&gt; std::io::Result&lt;()&gt; {
    // Create a new scope to demonstrate drop behavior
    {
        let temp = TempFile::new("test.txt".into())?;
        println!("Temporary file created");
        // File will be automatically cleaned up when temp goes out of scope
    }
    println!("End of scope - file should be cleaned up");

    // We can also manually drop if needed
    let temp2 = TempFile::new("another_test.txt".into())?;
    drop(temp2); // Explicitly drop the file
    println!("Manually dropped file");

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="イテレータ"><a class="header" href="#イテレータ">イテレータ</a></h1>
<p><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>トレイトは、例えば配列のような、要素の集合に対してイテレータを実装するためのトレイトです。</p>
<p>このトレイトは<code>next</code>の要素に相当するものを決定するためのメソッドのみを要求します。このメソッドは<code>impl</code>ブロック内で手動で実装するか、あるいは（配列やrangeのように）自動で定義されます。</p>
<p>サッとイテレータを使いたい時は、<code>for</code>文で集合からイテレータを作成することが良くあります。これは<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iter()</code></a>メソッドを呼び出しています。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Fibonacci {
    curr: u32,
    next: u32,
}

// Implement `Iterator` for `Fibonacci`.
// The `Iterator` trait only requires a method to be defined for the `next` element,
// and an `associated type` to declare the return type of the iterator.
impl Iterator for Fibonacci {
    // We can refer to this type using Self::Item
    type Item = u32;

    // ここではイテレーションの流れを`.curr`と`.next`を使用して定義しています。
    // 返り値の型は`Option&lt;T&gt;`で、これは：
    //     * `Iterator`が終了した時は`None`を返します。
    //     * そうでなければ`Some`でラップされた値を返します。
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let current = self.curr;

        self.curr = self.next;
        self.next = current + self.next;

        // Since there's no endpoint to a Fibonacci sequence, the `Iterator`
        // will never return `None`, and `Some` is always returned.
        Some(current)
    }
}

// フィボナッチ数列のジェネレータを返します。
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    // `0..3`は0, 1, 2をジェネレートする`Iterator`。
    let mut sequence = 0..3;

    println!("Four consecutive `next` calls on 0..3");
    println!("&gt; {:?}", sequence.next());
    println!("&gt; {:?}", sequence.next());
    println!("&gt; {:?}", sequence.next());
    println!("&gt; {:?}", sequence.next());

    // `for`は`None`を返すまで、イテレータを舐めていき、出てきた`Some`を
    // アンラップして変数（ここでは`i`）に束縛します。
    println!("Iterate through 0..3 using `for`");
    for i in 0..3 {
        println!("&gt; {}", i);
    }

    // `take(n)`メソッドは`Iterator`を先頭から`n`番目の要素までに減らします。
    println!("The first four terms of the Fibonacci sequence are: ");
    for i in fibonacci().take(4) {
        println!("&gt; {}", i);
    }

    // `skip(n)`メソッドは`Iterator`の先頭から`n`番目までの要素をとばします。
    println!("The next four terms of the Fibonacci sequence are: ");
    for i in fibonacci().skip(4).take(4) {
        println!("&gt; {}", i);
    }

    let array = [1u32, 3, 3, 7];

    // `iter`メソッドは配列やスライスからイテレータを作成します。
    println!("Iterate the following array {:?}", &amp;array);
    for i in array.iter() {
        println!("&gt; {}", i);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="impl-trait"><a class="header" href="#impl-trait"><code>impl Trait</code></a></h1>
<p><code>impl Trait</code>は2つの利用方法があります：</p>
<ol>
<li>引数の型</li>
<li>リターン型</li>
</ol>
<h2 id="引数の型"><a class="header" href="#引数の型">引数の型</a></h2>
<p>あなたの関数がジェネリックなトレイトを使用していて、特定の型を意識していない場合、<code>impl Trait</code>を引数の型として利用して、関数宣言をシンプルにできます。</p>
<p>例えば、次のコードを考えてみましょう：</p>
<pre class="playground"><code class="language-rust editable edition2021">fn parse_csv_document&lt;R: std::io::BufRead&gt;(src: R) -&gt; std::io::Result&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt; {
    src.lines()
        .map(|line| {
            // ソースのそれぞれの行について
            line.map(|line| {
                // 行を読み込んだら処理します。そうでなければエラーを返します。
                line.split(',') // 行をカンマで分割します。
                    .map(|entry| String::from(entry.trim())) // 前後の空白を削除します。
                    .collect() // 各行の全ての文字列をVec&lt;String&gt;に集めます。
            })
        })
        .collect() // 全ての行をVec&lt;Vec&lt;String&gt;&gt;に集めます。
}</code></pre>
<p><code>parse_csv_document</code>はジェネリックなので、BufReadを実装する任意の型を取ることができます。例えば、<code>BufReader&lt;File&gt;</code>や<code>[u8]</code>です。<code>R</code>がどんな型かは重要ではなく、<code>src</code>の型宣言に使われているだけなので、この関数は以下のように書くこともできます：</p>
<pre class="playground"><code class="language-rust editable edition2021">fn parse_csv_document(src: impl std::io::BufRead) -&gt; std::io::Result&lt;Vec&lt;Vec&lt;String&gt;&gt;&gt; {
    src.lines()
        .map(|line| {
            // ソースのそれぞれの行について
            line.map(|line| {
                // 行を読み込んだら処理します。そうでなければエラーを返します。
                line.split(',') // 行をカンマで分割します。
                    .map(|entry| String::from(entry.trim())) // 前後の空白を削除します。
                    .collect() // 各行の全ての文字列をVec&lt;String&gt;に集めます。
            })
        })
        .collect() // 全ての行をVec&lt;Vec&lt;String&gt;&gt;に集めます。
}</code></pre>
<p><code>impl Trait</code>を引数の型として利用するということは、どのような形式の関数であるか明示できないので、注意してください。例えば、<code>parse_csv_document::&lt;std::io::Empty&gt;(std::io::empty())</code>は2番目の例では動作しません。</p>
<h2 id="リターン型"><a class="header" href="#リターン型">リターン型</a></h2>
<p>あなたの関数が<code>MyTrait</code>を実装する型を返す場合、リターン型を<code>-&gt; impl MyTrait</code>のように書けます。これで型シグネチャをとてもシンプルにできます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::iter;
use std::vec::IntoIter;

// この関数は2つの`Vec&lt;i32&gt;を組み合わせて、そのイテレータを返します。
// リターン型がとても複雑です！
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// これは全く同じ関数ですが、リターン型に`impl Trait`を使っています。
// とてもシンプルですね！
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!("all done");
}</code></pre>
<p>より重要なことに、Rustの型には書き表せないものがあるのです。例えば、あらゆるクロージャは独自の無名な具象型を持ちます。<code>impl Trait</code>構文がない時は、クロージャを返すにはヒープ上に置かねばなりませんでした。しかし今では次のようにすべて静的に行えます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// 入力に`y`を加える関数を返します。
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}</code></pre>
<p><code>impl Trait</code>を使って、<code>map</code>や<code>filter</code>クロージャを使うイテレータを返すこともできます。おかげで<code>map</code>や<code>filter</code>を簡単に使えます。クロージャ型は名前を持たないので、あなたの関数がクロージャを持つイテレータを返す場合、明示的なリターン型を書くことはできません。しかし<code>impl Trait</code>を使うことで簡単にできます：</p>
<pre class="playground"><code class="language-rust editable edition2021">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}

fn main() {
    let singles = vec![-3, -2, 2, 3];
    let doubles = double_positives(&amp;singles);
    assert_eq!(doubles.collect::&lt;Vec&lt;i32&gt;&gt;(), vec![4, 6]);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="clone-and-copy"><a class="header" href="#clone-and-copy">Clone and Copy</a></h1>
<p>メモリ上の資源を扱う際、変数束縛や関数呼び出しを介して移動させるのがデフォルトの挙動です。しかしながら、場合によっては資源のコピーを作るのが適切なこともあります。</p>
<p><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>トレイトはまさにこのためにあります。普通は<code>Clone</code>トレイトで定義されている<code>.clone()</code>を用います。</p>
<h2 id="copy-implicit-cloning"><a class="header" href="#copy-implicit-cloning">Copy: Implicit Cloning</a></h2>
<p>The <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait allows a type to be duplicated simply by copying bits, with no additional logic required. When a type implements <code>Copy</code>, assignments and function calls will implicitly copy the value instead of moving it.</p>
<p><strong>Important:</strong> <code>Copy</code> requires <code>Clone</code> - any type that implements <code>Copy</code> must also implement <code>Clone</code>. This is because <code>Copy</code> is defined as a subtrait: <code>trait Copy: Clone {}</code>. The <code>Clone</code> implementation for <code>Copy</code> types simply copies the bits.</p>
<p>Not all types can implement <code>Copy</code>. A type can only be <code>Copy</code> if:</p>
<ul>
<li>All of its components are <code>Copy</code></li>
<li>It doesn’t manage external resources (like heap memory, file handles, etc.)</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">// A unit struct without resources
// Note: Copy requires Clone, so we must derive both
#[derive(Debug, Clone, Copy)]
struct Unit;

// A tuple struct with resources that implements the `Clone` trait
// This CANNOT be Copy because Box&lt;T&gt; is not Copy
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // `Unit`のインスタンスを作成。
    let unit = Unit;
    // Copy `Unit` - this is an implicit copy, not a move!
    // Because Unit implements Copy, the value is duplicated automatically
    let copied_unit = unit;

    // いずれの`Unit`も独立に使用できます。
    println!("original: {:?}", unit);
    println!("copy: {:?}", copied_unit);

    // `Pair`のインスタンスを作成。
    let pair = Pair(Box::new(1), Box::new(2));
    println!("original: {:?}", pair);

    // Move `pair` into `moved_pair`, moves resources
    // Pair does not implement Copy, so this is a move
    let moved_pair = pair;
    println!("moved: {:?}", moved_pair);

    // エラー！`pair`は資源を失っています。
    //println!("original: {:?}", pair);
    // TODO ^ この行をアンコメントしてみましょう。

    // Clone `moved_pair` into `cloned_pair` (resources are included)
    // Unlike Copy, Clone is explicit - we must call .clone()
    let cloned_pair = moved_pair.clone();
    // std::mem::dropを用いて元のpairをドロップします。
    drop(moved_pair);

    // エラー！`moved_pair`はドロップされています。
    //println!("moved and dropped: {:?}", moved_pair);
    // TODO ^ この行をアンコメントしてみましょう。

    // .clone()した値はまだ使用可能！
    println!("clone: {:?}", cloned_pair);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="スーパートレイト"><a class="header" href="#スーパートレイト">スーパートレイト</a></h1>
<p>Rustには“継承“はありませんが、あるトレイトを別のトレイトの上位集合として定義できます。例えば：</p>
<pre class="playground"><code class="language-rust editable edition2021">trait Person {
    fn name(&amp;self) -&gt; String;
}

// PersonはStudentのスーパートレイトです。
// Studentを実装するにはPersonも実装する必要があります。
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) is a subtrait of both Programmer
// and Student. Implementing CompSciStudent requires you to impl both supertraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        "My name is {} and I attend {}. My favorite language is {}. My Git username is {}",
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

struct CSStudent {
    name: String,
    university: String,
    fav_language: String,
    git_username: String
}

impl Programmer for CSStudent {
    fn fav_language(&amp;self) -&gt; String {
        self.fav_language.clone()
    }
}

impl Student for CSStudent {
    fn university(&amp;self) -&gt; String {
        self.university.clone()
    }
}

impl Person for CSStudent {
    fn name(&amp;self) -&gt; String {
        self.name.clone()
    }
}

impl CompSciStudent for CSStudent {
    fn git_username(&amp;self) -&gt; String {
        self.git_username.clone()
    }
}

fn main() {
    let student = CSStudent {
        name: String::from("Alice"),
        university: String::from("MIT"),
        fav_language: String::from("Rust"),
        git_username: String::from("alice_codes"),
    };

    let greeting = comp_sci_student_greeting(&amp;student);
    println!("{}", greeting);
}</code></pre>
<h3 id="参照-61"><a class="header" href="#参照-61">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait">The Rust Programming Language chapter on supertraits</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="トレイトの曖昧性解決"><a class="header" href="#トレイトの曖昧性解決">トレイトの曖昧性解決</a></h1>
<p>A type can implement many different traits. What if two traits both require the same name for a function? For example, many traits might have a method named <code>get()</code>. They might even have different return types!</p>
<p>Good news: because each trait implementation gets its own <code>impl</code> block, it’s clear which trait’s <code>get</code> method you’re implementing.</p>
<p>What about when it comes time to <em>call</em> those methods? To disambiguate between them, we have to use Fully Qualified Syntax.</p>
<pre class="playground"><code class="language-rust editable edition2021">trait UsernameWidget {
    // Get the selected username out of this widget
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // Get the selected age out of this widget
    fn get(&amp;self) -&gt; u8;
}

// A form with both a UsernameWidget and an AgeWidget
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form {
        username: "rustacean".to_owned(),
        age: 28,
    };

    // If you uncomment this line, you'll get an error saying
    // "multiple `get` found". Because, after all, there are multiple methods
    // named `get`.
    // println!("{}", form.get());

    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!("rustacean".to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}</code></pre>
<h3 id="参照-62"><a class="header" href="#参照-62">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">The Rust Programming Language chapter on Fully Qualified syntax</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="macro_rules"><a class="header" href="#macro_rules"><code>macro_rules!</code></a></h1>
<p>Rustはメタプログラミングを可能にする、パワフルなマクロシステムを備えています。これまで見てきたように、マクロは<code>!</code>で終わることを除けば関数のように見えます。関数と違うのは関数呼び出しを生成する代わりに、ソースコード中に展開され、周囲のプログラムとともにコンパイルされる点です。しかし、Cやその他の言語のマクロが文字列のプリプロセッシングをするのと異なり、Rustのマクロは抽象構文木へと展開されるので、予期せぬ演算子の優先順位のバグに出くわすことがありません。</p>
<p>マクロを作成するには<code>macro_rules!</code>というマクロを使用します。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `say_hello`という名のシンプルなマクロ
macro_rules! say_hello {
    // `()`はマクロが引数をとらないことを示します。
    () =&gt; {
        // マクロは（訳注: プリコンパイルの段階で）
        // このブロックの内容に展開されます。
        println!("Hello!")
    };
}

fn main() {
    // この呼び出しは`println!("Hello!");`に置き換えられます。
    say_hello!()
}</code></pre>
<p>ではどうしてマクロは便利なのでしょうか？</p>
<ol>
<li>
<p>同じことを繰り返し書いてはいけないから。複数の場所で、別の型だけれど似たような機能が必要な時がよくあります。しばしば、マクロはコードを繰り返し書くのを避ける有用な手段なのです（あとで詳述）。</p>
</li>
<li>
<p>ドメイン特化言語であるから。マクロを使うと、特定の目的のための特定の構文を定義することができます（あとで詳述）。</p>
</li>
<li>
<p>可変個引数によるインターフェース。取る引数の数が可変であるようなインターフェースを定義したくなることもあるでしょう。例えば、<code>println!</code>は、フォーマット文字列に依存した任意の数の引数を取ることができます（あとで詳述）！</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="構文"><a class="header" href="#構文">構文</a></h1>
<p>以下のサブセクションでは、Rustにおいてマクロを定義する方法を示します。3つの基本的な考え方があります：</p>
<ul>
<li><a href="#識別子">パターンと識別子</a></li>
<li><a href="#オーバーロード">オーバーロード</a></li>
<li><a href="#繰り返し">繰り返し</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="識別子"><a class="header" href="#識別子">識別子</a></h1>
<p>macroの引数は<code>$</code>が頭につきます。型は <em>識別子</em> でアノテーションされます。</p>
<pre class="playground"><code class="language-rust editable edition2021">macro_rules! create_function {
    // このマクロは`ident`識別子に対応する値を引数として取り
    // `$func_name`という名の関数を作成します。
    // `ident`識別子は関数・変数の名前用の識別子です。
    ($func_name:ident) =&gt; {
        fn $func_name() {
            // `stringify!`というマクロは`ident`を文字列に変えます。
            println!("You called {:?}()",
                     stringify!($func_name));
        }
    };
}

// 上のマクロを利用して`foo`、`bar`という名の関数を作成します。
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // このマクロは`expr`識別子に対応する値を引数として取り、
    // その結果を文字列として出力します。
    // `expr`識別子は式に対応します。
    ($expression:expr) =&gt; {
        // `stringify!`は式を *そのままの形で* 文字列に変換します
        println!("{:?} = {:?}",
                 stringify!($expression),
                 $expression);
    };
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // ブロックも式の一種であることを思い出しましょう！
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}</code></pre>
<p>使用できる識別子には以下のようなものがあります。</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> 式に使用。</li>
<li><code>ident</code> 関数、変数の名前に使用。</li>
<li><code>item</code></li>
<li><code>literal</code> はリテラル定数。</li>
<li><code>pat</code>（<em>パターン</em>）</li>
<li><code>path</code></li>
<li><code>stmt</code>（<em>宣言</em>）</li>
<li><code>tt</code>（<em>トークンツリー</em>）</li>
<li><code>ty</code>（<em>型</em>）</li>
<li><code>vis</code>（<em>可視性修飾子</em>）（訳注：<code>pub (crate)</code>とか）</li>
</ul>
<p>完全なリストを見るには、<a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rustリファレンス</a>を読んでください。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="オーバーロード"><a class="header" href="#オーバーロード">オーバーロード</a></h1>
<p>マクロは異なる引数の組み合わせを取るようにオーバーロードすることができるため、<code>macro_rules!</code>はマッチと似たような使い方をすることができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `test!`は`$left`と`$right`を異なる呼び出し方に応じて
// 比較します。
macro_rules! test {
    // 引数はカンマで区切らなくても構いません。
    // テンプレートの形態は自由！
    ($left:expr; and $right:expr) =&gt; {
        println!("{:?} and {:?} is {:?}",
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // ^ それぞれの`=&gt;`節はセミコロンで終わる必要があります。
    ($left:expr; or $right:expr) =&gt; {
        println!("{:?} or {:?} is {:?}",
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="繰り返し"><a class="header" href="#繰り返し">繰り返し</a></h1>
<p>マクロは引数のリストの中で<code>+</code>を使うことができ、そうすることによって、引数が少なくとも1回以上繰り返されるということを示すことができます。同様に<code>*</code>の場合は、0以上を示します。</p>
<p>以下の例では、マッチ対象を <code>$(...),+</code>で囲むことにより、カンマで区切られた1つ以上の式とマッチします。最後のセミコロンは必須ではないことに注目しましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">// `find_min!`は引数として与えられた数字の中の最低の値を計算します。
macro_rules! find_min {
    // 基本となるケース
    ($x:expr) =&gt; ($x);
    // `$x`に少なくとも1つの`$y`が続く場合
    ($x:expr, $($y:expr),+) =&gt; (
        // `find_min!`を残りの`$y`に対して再帰的に適用。
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!("{}", find_min!(1));
    println!("{}", find_min!(1 + 2, 2));
    println!("{}", find_min!(5, 2 * 3, 4));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dry-dont-repeat-yourself"><a class="header" href="#dry-dont-repeat-yourself">DRY (Don’t Repeat Yourself)</a></h1>
<p>マクロは関数やテストなどにおいて、共通の部分を抽出することでDRYなコードを書くのに役立ちます。ここでは<code>Vec&lt;T&gt;</code>に<code>+=</code>、<code>*=</code>、<code>-=</code>を実装、テストするにあたって、マクロがどのように役立つかを見ていきます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // `tt` （トークン木）識別子は演算子とトークン用の識別子です。
    ($a:expr, $b:expr, $func:ident, $op:tt) =&gt; {
        assert!($a.len() == $b.len(),
                "{:?}: dimension mismatch: {:?} {:?} {:?}",
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    };
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    };
}

// `add_assign`、`mul_assign`、`sub_assign`、関数を実装
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func:ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        };
    }

    // `add_assign`と`mul_assign`と`sub_assign`をテスト
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}</code></pre>
<pre><code class="language-shell">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="domain-specific-languages-ドメイン特化言語dsls"><a class="header" href="#domain-specific-languages-ドメイン特化言語dsls">Domain Specific Languages (ドメイン特化言語、DSLs)</a></h1>
<p>ここで言うDSLとはRustマクロに埋め込まれた小さな「言語」のことです。マクロ機能は通常のRustのプログラムへと展開されるので、これは完全に正当なRustなのですが、まるで小さな言語であるかのように見えます。これにより、（一定の条件のもとで）なんらかの特定の機能のための簡潔・直感的な構文を定義することができるようになります。</p>
<p>ちょっとした計算機APIを定義したいとしましょう。式を与えると、出力がコンソールに書き出されるようにしたいです。</p>
<pre class="playground"><code class="language-rust editable edition2021">macro_rules! calculate {
    (eval $e:expr) =&gt; {
        {
            let val: usize = $e; // 型を整数に制約。
            println!("{} = {}", stringify!{$e}, val);
        }
    };
}

fn main() {
    calculate! {
        eval 1 + 2 // `eval`はRustのキーワード *じゃない* よね！
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}</code></pre>
<p>出力はこうなります：</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>これはとても単純な例ですが、<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a>や<a href="https://crates.io/crates/clap"><code>clap</code></a>のように、もっと複雑なインターフェースも開発されています。</p>
<p>また、マクロの中に2組の括弧があることにも注目してください。外側のは、<code>()</code>や<code>[]</code>に加え、<code>macro_rules!</code>の構文の一部です。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="可変個引数によるインターフェース"><a class="header" href="#可変個引数によるインターフェース">可変個引数によるインターフェース</a></h1>
<p>_可変個引数の_インターフェースとは、任意の数の引数を取るものです。例えば、<code>println!</code>は、フォーマット文字列の定義に従い、任意の数の引数を取ることができます。</p>
<p>前のセクションの<code>calculate!</code>マクロを、可変個引数に拡張することができます：</p>
<pre class="playground"><code class="language-rust editable edition2021">macro_rules! calculate {
    // 単一の`eval`のためのパターン
    (eval $e:expr) =&gt; {
        {
            let val: usize = $e; // 強制的に型を整数にします。
            println!("{} = {}", stringify!{$e}, val);
        }
    };

    // 複数の`eval`を再帰的に分解します。
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // ほら！可変な`calculate!`だよ！
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}</code></pre>
<p>出力はこうなります：</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="エラーハンドリング"><a class="header" href="#エラーハンドリング">エラーハンドリング</a></h1>
<p>エラーハンドリングとは失敗の起きる可能性を扱うプロセスのことです。例えば、ファイルを読み込むのに失敗した際、その <em>誤った</em> インプットを使い続けるのは明らかに問題です。そのようなエラーを通知して明示的に扱うことで、残りのプログラムに問題が波及することを防ぐことができるようになります。</p>
<p>Rustには、これからこの章で見ていく通り、エラーを処理するための様々な方法が存在します。それらは全て僅かに異なり、ユースケースも異なります。経験則として：</p>
<p>明示的な<code>panic</code>はテストや復旧不可能なエラーに対して効果的です。プロトタイプにも便利で、例えば未実装の関数を扱う時などに有効ですが、このような場合にはより叙述的な<code>unimplemented</code>の方が良いでしょう。テストにおいては<code>panic</code>は明示的にテストを失敗させるための良い手法になるでしょう。</p>
<p><code>Option</code>型は値があるとは限らない場合や、値が無いことがエラーの条件とならない場合に有効です。例えば親ディレクトリ（<code>/</code>や<code>C:</code>はそれを持ちません）などです。<code>Option</code>を扱う際は、<code>unwrap</code>がプロトタイプや値が確実に存在することが約束されるケースに使えます。しかし、<code>expect</code>の方が何かが上手くいかなかった際にエラーメッセージを指定することができるため、より便利でしょう。</p>
<p>何かが上手くいかない可能性があったり、呼び出し元が問題を処理しなければならない時は、<code>Result</code>を使いましょう。<code>unwrap</code>や<code>expect</code>を実行することもできます（テストや短期的なプロトタイプ以外では使わないでください）。</p>
<p>より詳細なエラーハンドリングに関する議論については、<a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">オフィシャルブック</a>の該当の章を参考にしてください。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic"><a class="header" href="#panic"><code>panic</code></a></h1>
<p><code>panic</code>は、最もシンプルなエラーハンドリングの仕組みです。エラーメッセージの出力、スタックの巻き戻し、そして多くの場合プログラムの終了を実行します。例として、エラー条件に対して明示的に<code>panic</code>を呼び出してみましょう。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn drink(beverage: &amp;str) {
    // You shouldn't drink too many sugary beverages.
    if beverage == "lemonade" { panic!("AAAaaaaa!!!!"); }

    println!("Some refreshing {} is all I need.", beverage);
}

fn main() {
    drink("water");
    drink("lemonade");
    drink("still water");
}</code></pre>
<p>The first call to <code>drink</code> works. The second panics and thus the third is never called.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="abort-and-unwind"><a class="header" href="#abort-and-unwind"><code>abort</code> and <code>unwind</code></a></h1>
<p>The previous section illustrates the error handling mechanism <code>panic</code>.  Different code paths can be conditionally compiled based on the panic setting. The current values available are <code>unwind</code> and <code>abort</code>.</p>
<p>Building on the prior lemonade example, we explicitly use the panic strategy to exercise different lines of code.</p>
<pre class="playground"><code class="language-rust editable mdbook-runnable edition2021">fn drink(beverage: &amp;str) {
    // 甘すぎる飲み物を飲むべきではありません。
    if beverage == "lemonade" {
        if cfg!(panic = "abort") {
            println!("This is not your party. Run!!!!");
        } else {
            println!("Spit it out!!!!");
        }
    } else {
        println!("Some refreshing {} is all I need.", beverage);
    }
}

fn main() {
    drink("water");
    drink("lemonade");
}</code></pre>
<p>Here is another example focusing on rewriting <code>drink()</code> and explicitly use the <code>unwind</code> keyword.</p>
<pre class="playground"><code class="language-rust editable edition2021">#[cfg(panic = "unwind")]
fn ah() {
    println!("Spit it out!!!!");
}

#[cfg(not(panic = "unwind"))]
fn ah() {
    println!("This is not your party. Run!!!!");
}

fn drink(beverage: &amp;str) {
    if beverage == "lemonade" {
        ah();
    } else {
        println!("Some refreshing {} is all I need.", beverage);
    }
}

fn main() {
    drink("water");
    drink("lemonade");
}</code></pre>
<p>The panic strategy can be set from the command line by using <code>abort</code> or <code>unwind</code>.</p>
<pre><code class="language-console">rustc  lemonade.rs -C panic=abort
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="optionとunwrap"><a class="header" href="#optionとunwrap"><code>Option</code>と<code>unwrap</code></a></h1>
<p>以前の例では、甘いレモネードを飲んだ際に<code>panic</code>を呼び出すことによって、自由にプログラムの実行を失敗させられることが分かりました。では、何らかの飲み物を期待しているにもかかわらず、何も受け取らなかったらどうなるでしょう？これは悲惨なケースになるので、エラーハンドリングする必要があります！</p>
<p>このケースに対して、レモネードと同じように、空文字列（<code>""</code>）と比較することもできますが、せっかくRustを使っているので、その代わりにコンパイラに飲み物がないケースを指摘させてみましょう。</p>
<p><code>std</code>ライブラリの中の、<code>Option&lt;T&gt;</code>と呼ばれる<code>enum</code>は、任意の型<code>T</code>である変数の値が存在しない可能性がある場合に用いられます。値の状態によって、下記２つのパターンのうちの１つとして扱われます。</p>
<ul>
<li><code>Some(T)</code>：型<code>T</code>の値がある場合</li>
<li><code>None</code>：値が存在しない場合</li>
</ul>
<p>これらは<code>match</code>を用いて明示的に扱うこともできますし、<code>unwrap</code>で暗黙に処理することもできます。後者は<code>Some</code>の中の値を返すか<code>panic</code>するかのどちらかです。</p>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>メソッドを用いて、<code>panic</code>を手動でカスタマイズできることに触れておきましょう。これは（<code>unwrap</code>をそのまま用いた場合よりも）内容が理解しやすいエラーメッセージを出力するのに役立ちます。次の例では、結果をより明示的に、可能ならいつでも<code>panic</code>できるように扱っていきます。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 大人は経験豊富なので、大体どんな飲み物にも対処できます。
// あらゆる飲み物は`match`を用いて手動で処理されます。
fn give_adult(drink: Option&lt;&amp;str&gt;) {
    // Specify a course of action for each case.
    match drink {
        Some("lemonade") =&gt; println!("Yuck! Too sugary."),
        Some(inner)   =&gt; println!("{}? How nice.", inner),
        None          =&gt; println!("No drink? Oh well."),
    }
}

// 他の人たちは甘い飲み物を飲む前に`panic`します。
// 全ての飲み物は`unwrap`を使って暗黙的に処理されます。
fn drink(drink: Option&lt;&amp;str&gt;) {
    // `unwrap`を使用すると値が`None`だった際に`panic`を返します。
    let inside = drink.unwrap();
    if inside == "lemonade" { panic!("AAAaaaaa!!!!"); }

    println!("I love {}s!!!!!", inside);
}

fn main() {
    let water  = Some("water");
    let lemonade = Some("lemonade");
    let void  = None;

    give_adult(water);
    give_adult(lemonade);
    give_adult(void);

    let coffee = Some("coffee");
    let nothing = None;

    drink(coffee);
    drink(nothing);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="によるoptionのアンパック"><a class="header" href="#によるoptionのアンパック"><code>?</code>による<code>Option</code>のアンパック</a></h1>
<p><code>Option</code>をアンパックするには<code>match</code>文を使うこともできますが、<code>?</code>を使う方が簡単になることが多いでしょう。<code>Option</code>の<code>x</code>があるとすると、<code>x?</code>を評価した値は、<code>x</code>が<code>Some</code>の場合は<code>x</code>に格納された値となり、そうでなければ実行中の関数を終了させ、<code>None</code>を返します。</p>
<pre><code class="language-rust ignore">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
    // If `current_age` is `None`, this returns `None`.
    // If `current_age` is `Some`, the inner `u8` value + 1
    // gets assigned to `next_age`
    let next_age: u8 = current_age? + 1;
    Some(format!("Next year I will be {}", next_age))
}</code></pre>
<p>多くの<code>?</code>を共に使うことで、リーダブルなコードを書くことができます。</p>
<pre class="playground"><code class="language-rust editable edition2021">struct Person {
    job: Option&lt;Job&gt;,
}

#[derive(Clone, Copy)]
struct Job {
    phone_number: Option&lt;PhoneNumber&gt;,
}

#[derive(Clone, Copy)]
#[allow(dead_code)]
struct PhoneNumber {
    area_code: Option&lt;u8&gt;,
    number: u32,
}

impl Person {

    // その人の市外局番が存在する場合、取得します。
    fn work_phone_area_code(&amp;self) -&gt; Option&lt;u8&gt; {
        // `?`がなければ、多くのネストされた`match`文を必要とするため、
        // より長いコードとなります。
        // 実際に書いて、どちらの方が簡単か確かめてみましょう。
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="コンビネータmap"><a class="header" href="#コンビネータmap">コンビネータ：<code>map</code></a></h1>
<p><code>match</code>は<code>Option</code>を扱うのに適したメソッドです。しかし、大量にこれを使用しているとじきに億劫になってくるでしょう。引数の値が有効である（訳注: この場合は<code>None</code>でない）必要がある関数を扱う際には特にそうです。そうした場合には、<a href="https://doc.rust-lang.org/reference/glossary.html#combinator">コンビネータ</a>を使うと、処理の流れをモジュール化されたやり方で管理できます。</p>
<p><code>Some -&gt; Some</code>あるいは<code>None -&gt; None</code>の単純な操作を適用する必要がある場合には、<code>Option</code>は<code>map()</code>というビルトインのメソッドを提供していますので、これを使用しましょう。<code>map()</code>のフレキシビリティは、複数の<code>map()</code>をチェインしなければならない場合にさらに際立ちます。</p>
<p>以下の例では、<code>process()</code>が直前の関数全てを用いた場合と同じ機能を、よりコンパクトに果たしているのがわかります。</p>
<pre class="playground"><code class="language-rust editable edition2021">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// 食べ物の皮をむく。存在しない場合は単純に`None`を返します。
// そうでなければ皮を向いた食べ物を返します。
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// 上と同じように、食べ物を切る前に、皮を向いた食べ物の有無を知る必要があります。
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// 上のチェックと同様ですが`match`の代わりに`map()`を使用しています。
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// 複数の`map()`をチェインさせて、上のプロセスをシンプルにすることもできます。
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// 食べる前に、食べ物の有無をチェックするのは大事ですよね!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!("Mmm. I love {:?}", food),
        None       =&gt; println!("Oh no! It wasn't edible."),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // よりシンプルな見た目の`process()`を使用しましょう。
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}</code></pre>
<h3 id="参照-63"><a class="header" href="#参照-63">参照</a></h3>
<p><a href="#クロージャ">クロージャ</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="コンビネータand_then"><a class="header" href="#コンビネータand_then">コンビネータ：<code>and_then</code></a></h1>
<p>先ほどは<code>map()</code>を、チェイン構文を用いて<code>match</code>文を単純化する物として説明しました。しかし<code>Option&lt;T&gt;</code>を返す関数に対しての<code>map()</code>の使用はネストした<code>Option&lt;Option&lt;T&gt;&gt;</code>を生じさせます。ですので、複数の関数呼び出しをチェインさせることは混乱を招く場合があります。そんな時こそ<code>and_then()</code>の出番です。他の言語ではflatmapと呼ばれることもあります。</p>
<p><code>and_then()</code>は引数として与えられた関数にラップされた値を渡しますが、その値が<code>None</code>だった場合は<code>None</code>を返します。</p>
<p>以下の例では<code>cookable_v3()</code>は<code>Option&lt;Food&gt;</code>を返すため、<code>and_then()</code>ではなく<code>map()</code>を使用すると最終的に<code>Option&lt;Option&lt;Food&gt;&gt;</code>になります。これは<code>eat()</code>には不適切な型です。</p>
<pre class="playground"><code class="language-rust editable edition2021">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// 我々は寿司の材料を持っていません。
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// コルドン・ブルーのレシピも持っていません。
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// 料理を作るためには、材料とレシピの両方が必要。
// ロジックの流れを`match`のチェインで表します。
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_recipe(food) {
        None       =&gt; None,
        Some(food) =&gt; have_ingredients(food),
    }
}

// `and_then()`を用いることで、同じことをよりコンパクトに表現できます。
fn cookable_v3(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
}

// Otherwise we'd need to `flatten()` an `Option&lt;Option&lt;Food&gt;&gt;`
// to get an `Option&lt;Food&gt;`:
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).map(have_ingredients).flatten()
}

fn eat(food: Food, day: Day) {
    match cookable_v3(food) {
        Some(food) =&gt; println!("Yay! On {:?} we get to eat {:?}.", day, food),
        None       =&gt; println!("Oh no. We don't get to eat on {:?}?", day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}</code></pre>
<h3 id="参照-64"><a class="header" href="#参照-64">参照</a></h3>
<p><a href="#クロージャ">クロージャ</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.flatten"><code>Option::flatten()</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unpacking-options-and-defaults"><a class="header" href="#unpacking-options-and-defaults">Unpacking options and defaults</a></h1>
<p>There is more than one way to unpack an <code>Option</code> and fall back on a default if it is <code>None</code>. To choose the one that meets our needs, we need to consider the following:</p>
<ul>
<li>do we need eager or lazy evaluation?</li>
<li>do we need to keep the original empty value intact, or modify it in place?</li>
</ul>
<h2 id="or-is-chainable-evaluates-eagerly-keeps-empty-value-intact"><a class="header" href="#or-is-chainable-evaluates-eagerly-keeps-empty-value-intact"><code>or()</code> is chainable, evaluates eagerly, keeps empty value intact</a></h2>
<p><code>or()</code>is chainable and eagerly evaluates its argument, as is shown in the following example. Note that because <code>or</code>’s arguments are evaluated eagerly, the variable passed to <code>or</code> is moved.</p>
<pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Fruit { Apple, Orange, Banana, Kiwi, Lemon }

fn main() {
    let apple = Some(Fruit::Apple);
    let orange = Some(Fruit::Orange);
    let no_fruit: Option&lt;Fruit&gt; = None;

    let first_available_fruit = no_fruit.or(orange).or(apple);
    println!("first_available_fruit: {:?}", first_available_fruit);
    // first_available_fruit: Some(Orange)

    // `or` moves its argument.
    // In the example above, `or(orange)` returned a `Some`, so `or(apple)` was not invoked.
    // But the variable named `apple` has been moved regardless, and cannot be used anymore.
    // println!("Variable apple was moved, so this line won't compile: {:?}", apple);
    // TODO: uncomment the line above to see the compiler error
}</code></pre>
<h2 id="or_else-is-chainable-evaluates-lazily-keeps-empty-value-intact"><a class="header" href="#or_else-is-chainable-evaluates-lazily-keeps-empty-value-intact"><code>or_else()</code> is chainable, evaluates lazily, keeps empty value intact</a></h2>
<p>Another alternative is to use <code>or_else</code>, which is also chainable, and evaluates lazily, as is shown in the following example:</p>
<pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Fruit { Apple, Orange, Banana, Kiwi, Lemon }

fn main() {
    let no_fruit: Option&lt;Fruit&gt; = None;
    let get_kiwi_as_fallback = || {
        println!("Providing kiwi as fallback");
        Some(Fruit::Kiwi)
    };
    let get_lemon_as_fallback = || {
        println!("Providing lemon as fallback");
        Some(Fruit::Lemon)
    };

    let first_available_fruit = no_fruit
        .or_else(get_kiwi_as_fallback)
        .or_else(get_lemon_as_fallback);
    println!("first_available_fruit: {:?}", first_available_fruit);
    // Providing kiwi as fallback
    // first_available_fruit: Some(Kiwi)
}</code></pre>
<h2 id="get_or_insert-evaluates-eagerly-modifies-empty-value-in-place"><a class="header" href="#get_or_insert-evaluates-eagerly-modifies-empty-value-in-place"><code>get_or_insert()</code> evaluates eagerly, modifies empty value in place</a></h2>
<p>To make sure that an <code>Option</code> contains a value, we can use <code>get_or_insert</code> to modify it in place with a fallback value, as is shown in the following example. Note that <code>get_or_insert</code> eagerly evaluates its parameter, so variable <code>apple</code> is moved:</p>
<pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Fruit { Apple, Orange, Banana, Kiwi, Lemon }

fn main() {
    let mut my_fruit: Option&lt;Fruit&gt; = None;
    let apple = Fruit::Apple;
    let first_available_fruit = my_fruit.get_or_insert(apple);
    println!("first_available_fruit is: {:?}", first_available_fruit);
    println!("my_fruit is: {:?}", my_fruit);
    // first_available_fruit is: Apple
    // my_fruit is: Some(Apple)
    //println!("Variable named `apple` is moved: {:?}", apple);
    // TODO: uncomment the line above to see the compiler error
}</code></pre>
<h2 id="get_or_insert_with-evaluates-lazily-modifies-empty-value-in-place"><a class="header" href="#get_or_insert_with-evaluates-lazily-modifies-empty-value-in-place"><code>get_or_insert_with()</code> evaluates lazily, modifies empty value in place</a></h2>
<p>Instead of explicitly providing a value to fall back on, we can pass a closure to <code>get_or_insert_with</code>, as follows:</p>
<pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum Fruit { Apple, Orange, Banana, Kiwi, Lemon }

fn main() {
    let mut my_fruit: Option&lt;Fruit&gt; = None;
    let get_lemon_as_fallback = || {
        println!("Providing lemon as fallback");
        Fruit::Lemon
    };
    let first_available_fruit = my_fruit
        .get_or_insert_with(get_lemon_as_fallback);
    println!("first_available_fruit is: {:?}", first_available_fruit);
    println!("my_fruit is: {:?}", my_fruit);
    // Providing lemon as fallback
    // first_available_fruit is: Lemon
    // my_fruit is: Some(Lemon)

    // If the Option has a value, it is left unchanged, and the closure is not invoked
    let mut my_apple = Some(Fruit::Apple);
    let should_be_apple = my_apple.get_or_insert_with(get_lemon_as_fallback);
    println!("should_be_apple is: {:?}", should_be_apple);
    println!("my_apple is unchanged: {:?}", my_apple);
    // The output is a follows. Note that the closure `get_lemon_as_fallback` is not invoked
    // should_be_apple is: Apple
    // my_apple is unchanged: Some(Apple)
}</code></pre>
<h3 id="参照-65"><a class="header" href="#参照-65">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html"><code>closures</code></a>, <a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.get_or_insert"><code>get_or_insert</code></a>, <a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.get_or_insert_with"><code>get_or_insert_with</code></a>, <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"><code>moved variables</code></a>, <a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.or"><code>or</code></a>, <a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.or_else"><code>or_else</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="result"><a class="header" href="#result"><code>Result</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>は、リッチなバージョンの<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>型で_値の不在_の可能性の代わりに_エラー_の可能性を示します。</p>
<p>つまり、<code>Result&lt;T, E&gt;</code>は以下の２つの結果を持ちます。</p>
<ul>
<li><code>Ok&lt;T&gt;</code>：要素<code>T</code>が見つかった場合</li>
<li><code>Err&lt;E&gt;</code>：要素<code>E</code>とともにエラーが見つかった場合</li>
</ul>
<p>慣例により、<code>Ok</code>が期待される結果であり、<code>Err</code>は期待されない結果です。</p>
<p><code>Option</code>と同様、<code>Result</code>は多くのメソッドを持ちます。例えば<code>unwrap()</code>は、<code>T</code>もしくは<code>panic</code>をもたらします。エラーハンドリングでは、<code>Result</code>と<code>Option</code>で重複するコンビネータが多くあります。</p>
<p>Rustを書いていく中で、<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>メソッドなど、<code>Result</code>型を返すメソッドを目にするでしょう。文字列を他の型にパースすることは必ずしも成功する訳ではないため、<code>Result</code>を返すことで失敗するケースについてもカバーできるのです。</p>
<p>早速、文字列を<code>parse()</code>した場合の成功例と失敗例を見てみましょう。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // `unwrap()`で数字を取り出してみましょう。痛い目を見るでしょうか？
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply("10", "2");
    println!("double is {}", twenty);

    let tt = multiply("t", "2");
    println!("double is {}", tt);
}</code></pre>
<p>失敗例では、<code>parse()</code>がエラーを返すため<code>unwrap()</code>がパニックします。そして、<code>panic</code>はプログラムを終了させて不快なエラーメッセージを出力します。</p>
<p>エラーメッセージを改善するために、リターン型に対してもっと明確になるべきで、またエラーを明示的に処理することを考えるべきです。</p>
<h2 id="main内で使うresult"><a class="header" href="#main内で使うresult"><code>main</code>内で使う<code>Result</code></a></h2>
<p><code>Result</code>型は、明示的な指定により<code>main</code>関数のリターン型にもなります。一般に、<code>main</code>関数は以下のような形になるでしょう。</p>
<pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello World!");
}</code></pre>
<p>一方<code>main</code>で<code>Result</code>をリターン型とすることも可能です。エラーが<code>main</code>関数内で発生した時、エラーコードを返し、エラーに関するデバッグ表記を（<a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>トレイトを使って）出力します。以下の例ではそのようなシナリオを示し、<a href="#早期リターン">この先の節</a>でカバーする内容に触れていきます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = "10";
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!("{}", number);
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="resultのmap"><a class="header" href="#resultのmap"><code>Result</code>の<code>map</code></a></h1>
<p>前の例で見た<code>multiply</code>でのパニックは、コードを強固にするためには書きません。一般に、呼び出した側がエラーをどのように対処するべきかを自由に決められるように、エラーを呼び出した場所に返すのが好ましいです。</p>
<p>まずは、どのようなエラー型を扱っているのかを知る必要があります。<code>Err</code>型を定めるために、<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>に対し<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>トレイトを使って実装された<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>を見てみましょう。結果、<code>Err</code>型は<a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>というものであることが分かります。</p>
<p>以下の例では、単純な<code>match</code>文が全体として扱いづらいコードにしています。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// リターン型を再度記述することで、パターンマッチングを`unwrap()`なしで行います。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    // ここは以前と変わらず、妥当な解を与えます。
    let twenty = multiply("10", "2");
    print(twenty);

    // こちらは今度は有益なエラーメッセージを与えます。
    let tt = multiply("t", "2");
    print(tt);
}</code></pre>
<p>幸運にも、<code>Option</code>の<code>map</code>、<code>and_then</code>、その他多くのコンビネータも<code>Result</code>のために実装されています。<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>に全てのリストが記載されています。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// `Option`と同様、`map()`などのコンビネータを使うことができます。
// この関数は`map()`を使っている点以外は上記の関数と同じで、
// 両方の値がstrからパース可能であればそれらを乗算し、無効であればエラーをそのまま見送ります。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    // ここは以前と変わらず、妥当な解を与えます。
    let twenty = multiply("10", "2");
    print(twenty);

    // こちらは今度は有益なエラーメッセージを与えます。
    let tt = multiply("t", "2");
    print(tt);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="resultに対するエイリアス"><a class="header" href="#resultに対するエイリアス"><code>Result</code>に対するエイリアス</a></h1>
<p>特定の<code>Result</code>型を何度も使いたくなるのはどんな時でしょう？Rustは<a href="#エイリアス">エイリアス</a>の作成をサポートしていたことを思い出してください。便利なことに、特定の<code>Result</code>型に対しても定義することができます。</p>
<p>モジュールレベルでは、エイリアスの作成は非常に役に立ちます。特定のモジュールで見られるエラーは同じ<code>Err</code>型を持つため、単一のエイリアスで簡潔に<code>Results</code>に関わる_全て_を定義できます。<code>std</code>ライブラリが提供するもの（<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>）もあるほど有益なのです！</p>
<p>簡単な例で構文を見てみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// `ParseIntError`を`Err`の型として持つ全ての`Result`のジェネリックエイリアス
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// 上で定義したエイリアス（この場所特有の`Result`型）を使用。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// もう一度使用。エイリアスによって再度明記する必要性がありません。
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}</code></pre>
<h3 id="参照-66"><a class="header" href="#参照-66">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="早期リターン"><a class="header" href="#早期リターン">早期リターン</a></h1>
<p>前の例では、コンビネータの活用によりエラーを明示的に処理しました。場合分けに対する別の対処法として、<code>match</code>文と早期リターンを組み合わせて使うこともできます。</p>
<p>つまり、エラーが発生した時点で関数の実行を止め、エラーを返してしまうという単純な方法が使えるということです。この方法の方がより読みやすく書きやすい場合があります。早期リターンを使って実装された、前の例の新たなバージョンを考えてみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}</code></pre>
<p>ここまでで、コンビネータと早期リターンによる明示的なエラーハンドリングについて学びました。しかし、パニックは一般に避けたいですが、全てのエラーを明示的に処理するのも厄介でしょう。</p>
<p>次の節では、<code>panic</code>を発生させずに<code>unwrap</code>する必要があるケースのための<code>?</code>について紹介していきます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="の導入"><a class="header" href="#の導入"><code>?</code>の導入</a></h1>
<p>時には<code>panic</code>の可能性を無視して、<code>unwrap</code>のシンプルさを活用したいこともあるでしょう。今までの<code>unwrap</code>は、値を_取り出す_ためだけであろうとも、ネストを深く書くことを要求しました。そして、これがまさに<code>?</code>の目的です。</p>
<p><code>Err</code>を見つけるにあたり、２つのとるべき行動があります。</p>
<ol>
<li>可能な限り避けたいと決めた<code>panic!</code></li>
<li><code>Err</code>は処理できないことを意味するため<code>return</code></li>
</ol>
<p><code>?</code>は_ほぼ_<sup class="footnote-reference" id="fr-†-1"><a href="#footnote-†">1</a></sup>まさしく、<code>Err</code>に対して<code>panic</code>するより<code>return</code>するという点で<code>unwrap</code>と同等です。コンビネータを使った以前の例をどれだけ簡潔に書けるか見てみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}</code></pre>
<h2 id="tryマクロ"><a class="header" href="#tryマクロ"><code>try!</code>マクロ</a></h2>
<p><code>?</code>ができる前、同様の動作を<code>try!</code>マクロによって行うことができました。現在は<code>?</code>演算子が推奨されていますが、古いコードでは<code>try!</code>に出会うこともあります。<code>try!</code>を使って前の例と同じ<code>multiply</code>関数を実装すると、以下のようになるでしょう。</p>
<pre class="playground"><code class="language-rust editable edition2015">// To compile and run this example without errors, while using Cargo, change the value
// of the `edition` field, in the `[package]` section of the `Cargo.toml` file, to "2015".

use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}</code></pre>
<hr>
<ol class="footnote-definition">
<li id="footnote-†">
<p>詳細は<a href="#の他の活用法">re-enter ?</a>を参照。 <a href="#fr-†-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="複数のエラー型"><a class="header" href="#複数のエラー型">複数のエラー型</a></h1>
<p><code>Result</code>が他の<code>Result</code>と連携したり、<code>Option</code>が他の<code>Option</code>と連携するなど、今までの例はとても便利な物でした。</p>
<p>時には<code>Option</code>が<code>Result</code>と連携したり、<code>Result&lt;T, Error1&gt;</code>が<code>Result&lt;T, Error2&gt;</code>と連携する必要もあるでしょう。そのような場面では、異なるエラー型を構成しやすく、かつ連携しやすく管理したいです。</p>
<p>以下のコードは<code>unwrap</code>の２つのインスタンスが異なるエラー型を生成します。<code>Vec::first</code>は<code>Option</code>を返し、一方で<code>parse::&lt;i32&gt;</code>は<code>Result&lt;i32, ParseIntError&gt;</code>を返しています。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // エラー１の生成
    2 * first.parse::&lt;i32&gt;().unwrap() // エラー２の生成
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    println!("The first doubled is {}", double_first(numbers));

    println!("The first doubled is {}", double_first(empty));
    // エラー１：入力が空ベクタ

    println!("The first doubled is {}", double_first(strings));
    // エラー２：要素が数字としてパースできない。
}</code></pre>
<p>この先の節では、これらの問題を処理する方法について見ていきます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="optionからresultを取り出す"><a class="header" href="#optionからresultを取り出す"><code>Option</code>から<code>Result</code>を取り出す</a></h1>
<p>混在するエラー型に対する最も基本的な対処法は、単にお互いを埋め込んでしまうことです。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    println!("The first doubled is {:?}", double_first(numbers));

    println!("The first doubled is {:?}", double_first(empty));
    // エラー１：入力が空ベクタ

    println!("The first doubled is {:?}", double_first(strings));
    // エラー２：要素が数字としてパースできない。
}</code></pre>
<p>There are times when we’ll want to stop processing on errors (like with <a href="#の導入"><code>?</code></a>) but keep going when the <code>Option</code> is <code>None</code>. The <code>transpose</code> function comes in handy to swap the <code>Result</code> and <code>Option</code>.</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.transpose()
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    println!("The first doubled is {:?}", double_first(numbers));
    println!("The first doubled is {:?}", double_first(empty));
    println!("The first doubled is {:?}", double_first(strings));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="エラー型を定義する"><a class="header" href="#エラー型を定義する">エラー型を定義する</a></h1>
<p>異なるエラー型をマスクし単一のエラー型として扱えるようにすると、コードがシンプルになる場合があります。ここでは自前のエラー型でそれを示してみます。</p>
<p>Rustはユーザーによる新たなエラー型の定義をサポートします。一般に「良い」エラー型は、</p>
<ul>
<li>異なるエラーをまとめて同じ型として扱う。</li>
<li>ユーザーに優しいエラーメッセージを提供する。</li>
<li>他の型との比較を楽にする。
<ul>
<li>良い例：<code>Err(EmptyVec)</code></li>
<li>悪い例：<code>Err("Please use a vector with at least one element".to_owned())</code></li>
</ul>
</li>
<li>エラーについての情報を保持できる。
<ul>
<li>良い例：<code>Err(BadChar(c, position))</code></li>
<li>悪い例：<code>Err("+ cannot be used here".to_owned())</code></li>
</ul>
</li>
<li>他のエラーと問題なく連携できる。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

// 自前のエラー型の定義。エラーハンドリングのケースの応じてカスタマイズできます。
// ここで新たなエラーを書くことができ、元のエラーの実装に処理を委譲したり、
// その手前で何らかの処理を挟むことができます。
#[derive(Debug, Clone)]
struct DoubleError;

// エラーの生成は、それがどのように表示されるかとは別物です。
// そのため、エラーの表示スタイルに関する複雑なロジックを煩雑になる
// などと気にする必要はありません。
//
// エラーに関する余分な情報を持たせていないことに注意してください。
// どの文字列がパースに失敗したかなどを出力することは、
// その情報を保持させるようにエラーの定義を修正しない限りできません。
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "invalid first item to double")
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        // エラーを新たな型に変更します。
        .ok_or(DoubleError)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // ここでも新たなエラー型に更新します。
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="エラーをboxする"><a class="header" href="#エラーをboxする">エラーを<code>Box</code>する</a></h1>
<p>元のエラーを維持しながらシンプルなコードを書くには、<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>してしまうと良いでしょう。欠点として、元のエラー型はランタイムまで判明せず、<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">静的に決定</a>されないことが挙げられます。</p>
<p>標準ライブラリは<code>Box</code>に、<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>を介してあらゆる<code>Error</code>トレイトを実装した型から<code>Box&lt;Error&gt;</code>トレイトオブジェクトへの変換を実装させることで、エラーをboxしやすくしてくれます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::error;
use std::fmt;

// エイリアスを`Box&lt;error::Error&gt;`に変更します。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "invalid first item to double")
    }
}

impl error::Error for EmptyVec {}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Converts to Box using Into trait.
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(From::from) // Converts to Box using From::from fn pointer.
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}</code></pre>
<h3 id="参照-67"><a class="header" href="#参照-67">参照</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">動的ディスパッチ</a>, <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> トレイト</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="の他の活用法"><a class="header" href="#の他の活用法"><code>?</code>の他の活用法</a></h1>
<p>以前の例では<code>parse</code>の呼び出しに対するその場での対応として、エラーをライブラリのエラーからboxされたエラーへと<code>map</code>していました。</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;())
    .map_err(|e| e.into())</code></pre>
<p>簡単でよくあるオペレーションのため、可能なら省略してしまえると便利だったでしょう。でも残念、<code>and_then</code>が十分にフレキシブルでないため、それはできません。ただその代わり、<code>?</code>なら使えます。</p>
<p><code>?</code>の挙動は、<code>unwrap</code>または<code>return Err(err)</code>として説明されていました。これはほぼ正解で、本当は<code>unwrap</code>、もしくは<code>return Err(From::from(err))</code>という意味があります。<code>From::from</code>は異なる型の間での変換ユーティリティであることから、エラーがリターン型に変換可能な場合に<code>?</code>を使うことで、その変換を自動的に行ってくれます。</p>
<p>前の例を<code>?</code>を使ったものに書き換えてみましょう。その結果、<code>From::from</code>がエラー型に実装されている時<code>map_err</code>は消えてなくなります。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::error;
use std::fmt;

// エイリアスを`Box&lt;error::Error&gt;`に変更します。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "invalid first item to double")
    }
}

impl error::Error for EmptyVec {}

// 前と同じ構造ですが、`Results`と`Option`を繋げていく代わりに、
// `?`で内部の値をその場で取得します。
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}</code></pre>
<p>これでかなり綺麗になりました。元の<code>panic</code>と比べ、リターン型が<code>Result</code>であることを除けば、<code>unwrap</code>の呼び出しを<code>?</code>で置き換えたものに非常に似ています。結果、その<code>Result</code>は上のレベルで分解されなければなりません。</p>
<h3 id="参照-68"><a class="header" href="#参照-68">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a>, <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"><code>?</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="エラーをラップする"><a class="header" href="#エラーをラップする">エラーをラップする</a></h1>
<p>Boxする方法の代替として、エラーを自前のエラー型としてラップする方法もあります。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::error;
use std::error::Error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // パースエラーの実装まで処理を委譲します。
    // 追加の情報を提供するには、型により多くのデータを追加する必要があります。
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, "please use a vector with at least one element"),
            // ラップされたエラーは追加情報を含み、
            // source メソッドから取り出すことができます。
            DoubleError::Parse(..) =&gt;
                write!(f, "the provided string could not be parsed as int"),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // 元の実装のエラー型が原因。
            // `&amp;error::Error`トレイトオブジェクトに暗にキャストされます。
            // 元となる型が`Error`トレイトをすでに実装しているため問題ありません。
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// `ParseIntError`から`DoubleError`への変換の実装。
// `ParseIntError`が`DoubleError`に変換される必要がある時、
// 自動的に`?`から呼び出されます。
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    // Here we implicitly use the `ParseIntError` implementation of `From` (which
    // we defined above) in order to create a `DoubleError`.
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; {
            println!("Error: {}", e);
            if let Some(source) = e.source() {
                println!("  Caused by: {}", source);
            }
        },
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}</code></pre>
<p>これはエラーの処理のボイラープレートを増やしてしまい、全てのアプリケーションで必要になる訳では無いでしょう。これらのボイラープレートの処理を代わりにやってくれるようなライブラリもあります。</p>
<h3 id="参照-69"><a class="header" href="#参照-69">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a>, <a href="#列挙型">列挙型</a></p>
<p><a href="https://crates.io/keywords/error-handling"><code>Crates for handling errors</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="resultをイテレートする"><a class="header" href="#resultをイテレートする"><code>Result</code>をイテレートする</a></h1>
<p><code>Iter::map</code>オペレーションは失敗することもあります。例えば、</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!("Results: {:?}", numbers);
}</code></pre>
<p>ここでは、この対処法についてみてみましょう。</p>
<h2 id="filter_mapを使って失敗した要素のみを無視する"><a class="header" href="#filter_mapを使って失敗した要素のみを無視する"><code>filter_map()</code>を使って失敗した要素のみを無視する</a></h2>
<p><code>filter_map</code>は関数を呼び出し、結果が<code>None</code>になるものだけ取り除きます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .filter_map(|s| s.parse::&lt;i32&gt;().ok())
        .collect();
    println!("Results: {:?}", numbers);
}</code></pre>
<h2 id="collect-the-failed-items-with-map_err-and-filter_map"><a class="header" href="#collect-the-failed-items-with-map_err-and-filter_map">Collect the failed items with <code>map_err()</code> and <code>filter_map()</code></a></h2>
<p><code>map_err</code> calls a function with the error, so by adding that to the previous <code>filter_map</code> solution we can save them off to the side while iterating.</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec!["42", "tofu", "93", "999", "18"];
    let mut errors = vec![];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;u8&gt;())
        .filter_map(|r| r.map_err(|e| errors.push(e)).ok())
        .collect();
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}</code></pre>
<h2 id="collectで処理全体を失敗させる"><a class="header" href="#collectで処理全体を失敗させる"><code>collect()</code>で処理全体を失敗させる</a></h2>
<p><code>Result</code>は、それらのベクタ(<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)からベクタのそれ(<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>)へと変換できるようにするため、<code>FromIterator</code>を実装します。<code>Result::Err</code>が見つかり次第、イテレーションは終了します。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!("Results: {:?}", numbers);
}</code></pre>
<p>同じテクニックは、<code>Option</code>を用いて行うこともできます。</p>
<h2 id="partitionを使って全ての正常な値と失敗をまとめる"><a class="header" href="#partitionを使って全ての正常な値と失敗をまとめる"><code>partition()</code>を使って全ての正常な値と失敗をまとめる</a></h2>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}</code></pre>
<p>結果を見てみると、まだ全て<code>Result</code>にラップされていることに気づくでしょう。もう少しのボイラープレートが必要です。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let strings = vec!["tofu", "93", "18"];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!("Numbers: {:?}", numbers);
    println!("Errors: {:?}", errors);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="標準ライブラリの型"><a class="header" href="#標準ライブラリの型">標準ライブラリの型</a></h1>
<p><code>std</code>ライブラリは、基本データ型を劇的に拡張するカスタム型を数多く提供します。例えば以下です。</p>
<ul>
<li>拡張可能な文字列である<code>String</code>。例えば：<code>"hello world"</code></li>
<li>growable vectors: <code>[1, 2, 3]</code></li>
<li>オプション型：<code>Option&lt;i32&gt;</code></li>
<li>エラーハンドリング用の<code>Result&lt;i32, i32&gt;</code></li>
<li>ヒープ上の資源へのポインタ：<code>Box&lt;i32&gt;</code></li>
</ul>
<h3 id="参照-70"><a class="header" href="#参照-70">参照</a></h3>
<p><a href="#基本データ型">基本データ型</a>, <a href="https://doc.rust-lang.org/std/"><code>std</code> ライブラリ</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="boxスタックとヒープ"><a class="header" href="#boxスタックとヒープ">Box、スタックとヒープ</a></h1>
<p>Rustにおいて、すべての値はデフォルトでスタックに割り当てられます。<code>Box&lt;T&gt;</code>を作成することで、値を <em>ボックス化</em> 、すなわちヒープ上に割り当てることができます。ボックスとは正確にはヒープ上におかれた<code>T</code>の値へのスマートポインタです。ボックスがスコープを抜けると、デストラクタが呼ばれて内包するオブジェクトが破棄され、ヒープメモリが解放されます。</p>
<p>ボックス化された値は<code>*</code>演算子を用いてデリファレンスすることができます。これにより一段と直接的な操作が可能になります。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

// A Rectangle can be specified by where its top left and bottom right
// corners are in space
#[allow(dead_code)]
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // このPointをヒープ上に割り当て、ポインタを返します。
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // （以下では型を全て明示していますが、必須ではありません。）
    // この変数ははすべてスタック上に割り当てられます。
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 }
    };

    // ヒープ上に割り当てられたRectangle
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 },
    });

    // 関数の返り値をボックス化。
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // 間にもう一つポインタを挟みます。
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!("Point occupies {} bytes on the stack",
             mem::size_of_val(&amp;point));
    println!("Rectangle occupies {} bytes on the stack",
             mem::size_of_val(&amp;rectangle));

    // ボックスのサイズはポインタのサイズに等しい。
    println!("Boxed point occupies {} bytes on the stack",
             mem::size_of_val(&amp;boxed_point));
    println!("Boxed rectangle occupies {} bytes on the stack",
             mem::size_of_val(&amp;boxed_rectangle));
    println!("Boxed box occupies {} bytes on the stack",
             mem::size_of_val(&amp;box_in_a_box));

    // `boxed_point`の保持するデータを`unboxed_point`にコピーします。
    let unboxed_point: Point = *boxed_point;
    println!("Unboxed point occupies {} bytes on the stack",
             mem::size_of_val(&amp;unboxed_point));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ベクタ型"><a class="header" href="#ベクタ型">ベクタ型</a></h1>
<p>「ベクタ」はサイズを変更可能な配列です。スライスと同様、そのサイズはコンパイル時には不定ですが、いつでも要素を追加したり削除したりすることができます。ベクタは3つの要素で、その特徴が完全に決まります。</p>
<ul>
<li>データへのポインタ</li>
<li>長さ</li>
<li>容量</li>
</ul>
<p>ベクタはその容量を超えない限りにおいて長くしていくことができます。超えた場合には、より大きな容量を持つように割り当てなおされます。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">fn main() {
    // イテレータは要素を収集してベクタにすることができます。
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!("Collected (0..10) into: {:?}", collected_iterator);

    // ベクタの初期化には`vec!`マクロが使用できます。
    let mut xs = vec![1i32, 2, 3];
    println!("Initial vector: {:?}", xs);

    // 新しい要素をベクタの最後に挿入することができます。
    println!("Push 4 into the vector");
    xs.push(4);
    println!("Vector: {:?}", xs);

    // エラー！イミュータブルなベクタは成長できません
    collected_iterator.push(0);
    // FIXME ^ この行をコメントアウトしましょう

    // `len`メソッドは現在のベクタのサイズを返します。
    println!("Vector length: {}", xs.len());

    // 鍵括弧を用いてインデックスによる要素へのアクセスができます。
    // （インデックスは0から開始する）
    println!("Second element: {}", xs[1]);

    // `pop`はベクタの最後の要素を削除すると同時に返します。
    println!("Pop last element: {:?}", xs.pop());

    // 不正なインデックスアクセスはpanicを引き起こします。
    println!("Fourth element: {}", xs[3]);
    // FIXME ^ この行をコメントアウトしましょう

    // `Vector`は簡単にイテレートできます。
    println!("Contents of xs:");
    for x in xs.iter() {
        println!("&gt; {}", x);
    }

    // `Vector`をイテレートしながら、
    // イテレーションの回数を別の変数（`i`）に列挙することもできます。
    for (i, x) in xs.iter().enumerate() {
        println!("In position {} we have value {}", i, x);
    }

    // `iter_mut`を使うと、ミュータブルな`Vector`をイテレートし、
    // それぞれの値を修正することができます。
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!("Updated vector: {:?}", xs);
}</code></pre>
<p><code>Vec</code>型のメソッドの一覧は<a href="https://doc.rust-lang.org/std/vec/">std::vec</a>モジュールを見てください。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="文字列"><a class="header" href="#文字列">文字列</a></h1>
<p>Rustには文字列を扱う型が2つあります。<code>String</code>と<code>&amp;str</code>です。</p>
<p><code>String</code>は有効なUTF-8の配列であることを保証されたバイトのベクタ(<code>Vec&lt;u8&gt;</code>)として保持されます。ヒープ上に保持され、伸長可能で、末端にnull文字を含みません。</p>
<p><code>&amp;str</code>は有効なUTF-8の配列のスライス（<code>&amp;[u8]</code>）で、いつでも<code>String</code>に変換することができます。<code>&amp;[T]</code>がいつでも<code>Vec&lt;T&gt;</code>に変換できるのと同様です。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // （以下の例では型を明示していますが、これらは必須ではありません。）
    // read only memory上に割り当てられた文字列への参照
    let pangram: &amp;'static str = "the quick brown fox jumps over the lazy dog";
    println!("Pangram: {}", pangram);

    // 単語を逆順にイテレートします。新しい文字列の割り当ては起こりません。
    println!("Words in reverse");
    for word in pangram.split_whitespace().rev() {
        println!("&gt; {}", word);
    }

    // 文字をベクタにコピー。ソートして重複を除去。
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // 中身が空で、伸長可能な`String`を作成。
    let mut string = String::new();
    for c in chars {
        // 文字を文字列の末端に挿入。
        string.push(c);
        // 文字列を文字列の末端に挿入。
        string.push_str(", ");
    }

    // 文字列のトリミング（特定文字種の除去）はオリジナルの文字列のスライスを
    // 返すので、新規のメモリ割り当ては発生しません。
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!("Used characters: {}", trimmed_str);

    // 文字列をヒープに割り当てます。
    let alice = String::from("I like dogs");
    // 新しくメモリを確保し、変更を加えた文字列をそこに割り当てます。
    let bob: String = alice.replace("dog", "cat");

    println!("Alice says: {}", alice);
    println!("Bob says: {}", bob);
}</code></pre>
<p><code>str</code>/<code>String</code>のメソッドをもっと見たい場合は<a href="https://doc.rust-lang.org/std/str/">std::str</a>、<a href="https://doc.rust-lang.org/std/string/">std::string</a>モジュールを参照してください。</p>
<h2 id="literals-and-escapes"><a class="header" href="#literals-and-escapes">Literals and escapes</a></h2>
<p>There are multiple ways to write string literals with special characters in them. All result in a similar <code>&amp;str</code> so it’s best to use the form that is the most convenient to write. Similarly there are multiple ways to write byte string literals, which all result in <code>&amp;[u8; N]</code>.</p>
<p>Generally special characters are escaped with a backslash character: <code>\</code>. This way you can add any character to your string, even unprintable ones and ones that you don’t know how to type. If you want a literal backslash, escape it with another one: <code>\\</code></p>
<p>String or character literal delimiters occurring within a literal must be escaped: <code>"\""</code>, <code>'\''</code>.</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = "I'm writing \x52\x75\x73\x74!";
    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";

    println!("Unicode character {} (U+211D) is called {}",
                unicode_codepoint, character_name );


    let long_string = "String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!";
    println!("{}", long_string);
}</code></pre>
<p>Sometimes there are just too many characters that need to be escaped or it’s just much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    // If you need "# in your string, just use more #s in the delimiter.
    // You can use up to 255 #s.
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
}</code></pre>
<p>Want a string that’s not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8). Or maybe you want an array of bytes that’s mostly text? Byte strings to the rescue!</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b"this is a byte string";

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!("A byte string: {:?}", bytestring);

    // Byte strings can have byte escapes...
    let escaped = b"\x52\x75\x73\x74 as bytes";
    // ...but no unicode escapes
    // let escaped = b"\u{211D} is not allowed";
    println!("Some escaped bytes: {:?}", escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("And the same as text: '{}'", my_str);
    }

    let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb"; // "ようこそ" in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!("Conversion successful: '{}'", my_str),
        Err(e) =&gt; println!("Conversion failed: {:?}", e),
    };
}</code></pre>
<p>For conversions between character encodings check out the <a href="https://crates.io/crates/encoding">encoding</a> crate.</p>
<p>A more detailed listing of the ways to write string literals and escape characters is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">‘Tokens’ chapter</a> of the Rust Reference.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="option"><a class="header" href="#option"><code>Option</code></a></h1>
<p>プログラムの一部が失敗した際、<code>panic!</code>するよりも、エラーを捕捉する方が望ましい場合があります。これは<code>Option</code>という列挙型を用いることで可能になります。</p>
<p>列挙型<code>Option&lt;T&gt;</code>には2つの値があります。</p>
<ul>
<li><code>None</code>、これは実行の失敗か値の欠如を示します。</li>
<li><code>Some(value)</code>、型<code>T</code>の<code>value</code>をラップするタプルです。</li>
</ul>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// `panic!`を起こさない整数の割り算
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // 失敗は`None`としてあらわされます。
        None
    } else {
        // 結果は`Some`にラップされます。
        Some(dividend / divisor)
    }
}

// この関数は失敗する割り算を扱うことができます。
fn try_division(dividend: i32, divisor: i32) {
    // `Option` の値は、他のあらゆる列挙型と同様パターンマッチに使用できます。
    match checked_division(dividend, divisor) {
        None =&gt; println!("{} / {} failed!", dividend, divisor),
        Some(quotient) =&gt; {
            println!("{} / {} = {}", dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // `None`を変数に代入する際は、型を明示しなくてはなりません。
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // `Some`をアンラップすると中の値を取得できます。
    println!("{:?} unwraps to {:?}", optional_float, optional_float.unwrap());

    // `None`をアンラップしようとすると`panic!`します。
    println!("{:?} unwraps to {:?}", none, none.unwrap());
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="result-1"><a class="header" href="#result-1"><code>Result</code></a></h1>
<p>これまでの例で、失敗する可能性のある関数の返り値として、列挙型<code>Option</code>が使用でき、失敗時の返り値には<code>None</code>を用いることを見てきました。しかし、時には <strong>なぜ</strong> そのオペレーションが失敗したのかを明示することが重要な場合があります。そのためには<code>Result</code>列挙型を使用します。</p>
<p>列挙型<code>Result&lt;T, E&gt;</code>は2つの値をとりえます。</p>
<ul>
<li><code>Ok(value)</code> … これはオペレーションが成功したことを意味し、返り値<code>value</code>をラップします。（<code>value</code>は型<code>T</code>を持ちます。）</li>
<li><code>Err(why)</code> … これはオペレーションの失敗を意味します。<code>why</code>をラップしており、ここには失敗した理由が（必ずではありませんが）書かれています。（<code>why</code>の型は<code>E</code>です。）</li>
</ul>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">mod checked {
    // 捕捉対象としたい、数学的な「エラー」
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // 分母が0なので、このオペレーションは普通に行えば失敗します。
            // 代わりに`Err`でラップされた失敗の理由を返しましょう。
            Err(MathError::DivisionByZero)
        } else {
            // このオペレーションは問題がないので、
            // 結果を`Ok`でラップして返しましょう。
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // 3段階の`match`ピラミッド！
    match checked::div(x, y) {
        Err(why) =&gt; panic!("{:?}", why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!("{:?}", why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!("{:?}", why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // これは失敗するでしょうか？
    println!("{}", op(1.0, 10.0));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id=""><a class="header" href="#"><code>?</code></a></h1>
<p>マッチを利用して結果をチェインするのは中々面倒です。幸いなことに、<code>?</code>マクロを使用すればイケてるコードに戻すことができます。<code>?</code>は<code>Result</code>を返す式の末尾で使います。<code>Err(err)</code>の分岐が<code>return Err(From::from(err))</code>という早期リターンに展開され、<code>Ok(ok)</code>の分岐が<code>ok</code>の式に展開されるようなマッチ式と等価です。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // 中間関数
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // `div`が"失敗"したら、`DivisionByZero`が`return`されます。
        let ratio = div(x, y)?;

        // もし`ln`が"失敗"したら、`NonPositiveLogarithm`が`return`されます。
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!("{}", match why {
                MathError::NonPositiveLogarithm
                    =&gt; "logarithm of non-positive number",
                MathError::DivisionByZero
                    =&gt; "division by zero",
                MathError::NegativeSquareRoot
                    =&gt; "square root of negative number",
            }),
            Ok(value) =&gt; println!("{}", value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}</code></pre>
<p><a href="https://doc.rust-lang.org/std/result/index.html">公式ドキュメント</a>をチェックすることをオススメします。<code>Result</code>型を扱う関数や<code>Result</code>型のメソッドが多く挙げられています。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="panic-1"><a class="header" href="#panic-1"><code>panic!</code></a></h1>
<p><code>panic!</code>マクロはパニックを生成し、スタックの巻き戻しを開始するために使用することができます。巻き戻しの間、ランタイムは、（訳注: panicを起こした）スレッドが <strong>所有権を持つ</strong> 全ての資源のデストラクタを呼び出し、メモリ上から解放します。</p>
<p>今回はシングルスレッドのプログラムを実行しているので、<code>panic!</code>はプログラムにパニックメッセージを表示させ、exitします。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">// 整数の除法(/)の再実装
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // ゼロによる除算はパニックを引き起こします。
        panic!("division by zero");
    } else {
        dividend / divisor
    }
}

// `main`のタスク
fn main() {
    // ヒープ上の整数
    let _x = Box::new(0i32);

    // このオペレーションはタスクの失敗を引き起こします。
    division(3, 0);

    println!("This point won't be reached!");

    // `_x`はここに到達する前に破棄されます。
}</code></pre>
<p><code>panic!</code>がメモリリークを引き起こさないことを確認しましょう。</p>
<!-- REUSE-IgnoreStart -->
<!-- Prevent REUSE from parsing the copyright statement in the sample code -->
<pre><code class="language-shell">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401==
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401==
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401==
==4401== All heap blocks were freed -- no leaks are possible
==4401==
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<!-- REUSE-IgnoreEnd -->
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ハッシュマップ"><a class="header" href="#ハッシュマップ">ハッシュマップ</a></h1>
<p>ベクタ型が値を整数のインデックスで保持するのに対し、<code>HashMap</code>ではキーで保持します。<code>HashMap</code>のキーはブーリアン、整数、文字列等の<code>Eq</code>と<code>Hash</code>トレイトを保持する型なら何でもOKです。次のセクションでより詳しく見ていきます。</p>
<p>ベクタ型と同様、伸長可能ですが、<code>HashMap</code>の場合さらに、スペースが余っているときには小さくすることも可能です。<code>HashMap</code>を一定の容量のエリアに作成するときは<code>HashMap::with_capacity(uint)</code>を、デフォルトの容量で作成するときは<code>HashMap::new()</code>を用います。後者が推奨されています。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        "798-1364" =&gt; "We're sorry, the call cannot be completed as dialed.
            Please hang up and try again.",
        "645-7689" =&gt; "Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?",
        _ =&gt; "Hi! Who is this again?"
    }
}

fn main() {
    let mut contacts = HashMap::new();

    contacts.insert("Daniel", "798-1364");
    contacts.insert("Ashley", "645-7689");
    contacts.insert("Katie", "435-8291");
    contacts.insert("Robert", "956-1745");

    // 参照をとり、Option&lt;&amp;V&gt;を返します。
    match contacts.get(&amp;"Daniel") {
        Some(&amp;number) =&gt; println!("Calling Daniel: {}", call(number)),
        _ =&gt; println!("Don't have Daniel's number."),
    }

    // `HashMap::insert()`は
    // insertされた値が新しい場合は`None`を
    // そうでなければ`Some(value)`を返します。
    contacts.insert("Daniel", "164-6743");

    match contacts.get(&amp;"Ashley") {
        Some(&amp;number) =&gt; println!("Calling Ashley: {}", call(number)),
        _ =&gt; println!("Don't have Ashley's number."),
    }

    contacts.remove(&amp;"Ashley");

    // `HashMap::iter()` returns an iterator that yields
    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.
    for (contact, &amp;number) in contacts.iter() {
        println!("Calling {}: {}", contact, call(number));
    }
}</code></pre>
<p>ハッシングやハッシュマップ（ハッシュテーブルと呼ばれることもあります）の仕組みについて、より詳しく知りたい場合は<a href="https://en.wikipedia.org/wiki/Hash_table">Wikipediaのハッシュテーブルのページ</a>を見てください。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="キー型の変種"><a class="header" href="#キー型の変種">キー型の変種</a></h1>
<p><code>Eq</code>と<code>Hash</code>トレイトを実装している型ならば、なんでも<code>HashMap</code>のキーになることができます。例えば以下です。</p>
<ul>
<li><code>bool</code> （キーになりうる値が2つしかないので実用的ではないですが…）</li>
<li><code>int</code>、<code>uint</code>、あるいは他の整数型</li>
<li><code>String</code>と<code>&amp;str</code>（Tips：<code>String</code>をキーにしたハッシュマップを作製した場合、<code>.get()</code>メソッドの引数に<code>&amp;str</code>を与えて値を取得することができます。）</li>
</ul>
<p><code>f32</code>と<code>f64</code>は<code>Hash</code>を実装して <strong>いない</strong> ことに注意しましょう。おそらくこれは<a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">浮動小数点演算時に誤差が発生する</a>ため、キーとして使用すると、恐ろしいほどエラーの元となるためです。</p>
<p>集合型は、その要素となっている全ての型が<code>Eq</code>を、あるいは<code>Hash</code>を実装している場合、必ず同じトレイトを実装しています。例えば、<code>Vec&lt;T&gt;</code>は<code>T</code>が<code>Hash</code>を実装している場合、<code>Hash</code>を実装します。</p>
<p>独自の型に<code>Eq</code>あるいは<code>Hash</code>を実装するのは簡単です。以下の一行で済みます。<code>#[derive(PartialEq, Eq, Hash)]</code></p>
<p>後はコンパイラがよしなにしてくれます。これらのトレイトの詳細をコントロールしたい場合、<code>Eq</code>や<code>Hash</code>を自分で実装することもできます。この文書では<code>Hash</code>トレイトを実装する方法の詳細については触れません。</p>
<p><code>struct</code>を<code>HashMap</code>で扱う際の例として、とてもシンプルなユーザーログインシステムを作成してみましょう。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

// Eqトレイトを使用する時は、PartialEqをderiveする必要があります。
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!("Username: {}", username);
    println!("Password: {}", password);
    println!("Attempting logon...");

    let logon = Account {
        username,
        password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!("Successful logon!");
            println!("Name: {}", account_info.name);
            println!("Email: {}", account_info.email);
        },
        _ =&gt; println!("Login failed!"),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: "j.everyman",
        password: "password123",
    };

    let account_info = AccountInfo {
        name: "John Everyman",
        email: "j.everyman@email.com",
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, "j.everyman", "psasword123");

    try_logon(&amp;accounts, "j.everyman", "password123");
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ハッシュ集合"><a class="header" href="#ハッシュ集合">ハッシュ集合</a></h1>
<p>値がなく、キーだけの<code>HashMap</code>を想像してみてください。これはハッシュ集合（<code>HashSet</code>）と呼ばれるものです。（<code>HashSet&lt;T&gt;</code>は、実際には<code>HashMap&lt;T, ()&gt;</code>のラッパーです。）</p>
<p>「何の意味があるの？フツーにキーを<code>Vec</code>に入れればいいじゃん」そう思いましたね？</p>
<p>それは、<code>HashSet</code>独自の機能として、要素に重複がないということが保証されるためです。これは全ての集合型がもつ機能です。<code>HashSet</code>はその実装の1つであり、他には<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>等があります。</p>
<p><code>HashSet</code>に、すでに存在する値を加えようとすると、（すなわち、加えようとしている値のハッシュ値と、要素中のいずれかの値のハッシュ値が等しい場合、）新しい値によって古い値が上書きされます。</p>
<p>これは、同じ値を2つ以上欲しくない場合や、すでにある値を持っているか知りたい場合にとても有効です。</p>
<p>しかし、集合型の機能はそれだけではありません。</p>
<p>集合型には4つの主要なメソッドがあり、（すべてイテレータを返します。）</p>
<ul>
<li>
<p><code>union</code>：2つの集合型のどちらか一方にある値を全て取得。</p>
</li>
<li>
<p><code>difference</code>：1つ目の集合にあり、かつ2つ目には存在しない値を全て取得。</p>
</li>
<li>
<p><code>intersection</code>：両方の集合にある値のみを取得。</p>
</li>
<li>
<p><code>symmetric_difference</code>：どちらか一方の集合には存在するが、両方には <strong>ない</strong> 値を取得。</p>
</li>
</ul>
<p>以下の例でこれらをすべて見ていきましょう。</p>
<pre class="playground"><code class="language-rust editable ignore mdbook-runnable edition2021">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec![1i32, 2, 3].into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec![2i32, 3, 4].into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // 既に存在する値を追加しようとすると
    // `HashSet::insert()`はfalseを返します。
    assert!(b.insert(4), "Value 4 is already in set B!");
    // FIXME ^ この行をコメントアウトしましょう

    b.insert(5);

    // 集合の要素が、`Debug`を実装している型の場合、
    // 集合そのものも`Debug`を実装します。
    // 通常は`[elem1, elem2, ...]`のように要素を出力します。
    println!("A: {:?}", a);
    println!("B: {:?}", b);

    // [1, 2, 3, 4, 5]を順不同に出力。
    println!("Union: {:?}", a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // これは[1]を出力。
    println!("Difference: {:?}", a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // [2, 3, 4]を順不同に出力。
    println!("Intersection: {:?}", a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // [1, 5]を出力。
    println!("Symmetric Difference: {:?}",
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}</code></pre>
<p>例は<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">公式ドキュメント</a>から持ってきています。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rc"><a class="header" href="#rc"><code>Rc</code></a></h1>
<p>When multiple ownership is needed, <code>Rc</code>(Reference Counting) can be used. <code>Rc</code> keeps track of the number of the references which means the number of owners of the value wrapped inside an <code>Rc</code>.</p>
<p>Reference count of an <code>Rc</code> increases by 1 whenever an <code>Rc</code> is cloned, and decreases by 1 whenever one cloned <code>Rc</code> is dropped out of the scope. When an <code>Rc</code>’s reference count becomes zero (which means there are no remaining owners), both the <code>Rc</code> and the value are all dropped.</p>
<p>Cloning an <code>Rc</code> never performs a deep copy. Cloning creates just another pointer to the wrapped value, and increments the count.</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::rc::Rc;

fn main() {
    let rc_examples = "Rc examples".to_string();
    {
        println!("--- rc_a is created ---");

        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!("Reference Count of rc_a: {}", Rc::strong_count(&amp;rc_a));

        {
            println!("--- rc_a is cloned to rc_b ---");

            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!("Reference Count of rc_b: {}", Rc::strong_count(&amp;rc_b));
            println!("Reference Count of rc_a: {}", Rc::strong_count(&amp;rc_a));

            // Two `Rc`s are equal if their inner values are equal
            println!("rc_a and rc_b are equal: {}", rc_a.eq(&amp;rc_b));

            // We can use methods of a value directly
            println!("Length of the value inside rc_a: {}", rc_a.len());
            println!("Value of rc_b: {}", rc_b);

            println!("--- rc_b is dropped out of scope ---");
        }

        println!("Reference Count of rc_a: {}", Rc::strong_count(&amp;rc_a));

        println!("--- rc_a is dropped out of scope ---");
    }

    // Error! `rc_examples` already moved into `rc_a`
    // And when `rc_a` is dropped, `rc_examples` is dropped together
    // println!("rc_examples: {}", rc_examples);
    // TODO ^ Try uncommenting this line
}</code></pre>
<h3 id="参照-71"><a class="header" href="#参照-71">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/rc/index.html">std::rc</a> and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">std::sync::arc</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arc"><a class="header" href="#arc">Arc</a></h1>
<p>When shared ownership between threads is needed, <code>Arc</code>(Atomically Reference Counted) can be used. This struct, via the <code>Clone</code> implementation can create a reference pointer for the location of a value in the memory heap while increasing the reference counter. As it shares ownership between threads, when the last reference pointer to a value is out of scope, the variable is dropped.</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::time::Duration;
use std::sync::Arc;
use std::thread;

fn main() {
    // This variable declaration is where its value is specified.
    let apple = Arc::new("the same apple");

    for _ in 0..10 {
        // Here there is no value specification as it is a pointer to a
        // reference in the memory heap.
        let apple = Arc::clone(&amp;apple);

        thread::spawn(move || {
            // As Arc was used, threads can be spawned using the value allocated
            // in the Arc variable pointer's location.
            println!("{:?}", apple);
        });
    }

    // Make sure all Arc instances are printed from spawned threads.
    thread::sleep(Duration::from_secs(1));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="標準ライブラリのその他"><a class="header" href="#標準ライブラリのその他">標準ライブラリのその他</a></h1>
<p>他にも、様々な型がstdライブラリの中で提供されています。例えば以下の機能を果たすための物があります。</p>
<ul>
<li>スレッド</li>
<li>チャネル</li>
<li>ファイル I/O</li>
</ul>
<p>これらにより<a href="#基本データ型">基本データ型</a>の提供する機能よりも遥かに豊かなことが実現できます。</p>
<h3 id="参照-72"><a class="header" href="#参照-72">参照</a></h3>
<p><a href="#基本データ型">基本データ型</a>, <a href="https://doc.rust-lang.org/std/"><code>std</code> ライブラリ</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="スレッド"><a class="header" href="#スレッド">スレッド</a></h1>
<p>Rustは<code>spawn</code>関数を用いてOSのネイティブスレッドを開始することができます。この関数の引数はmoveクロージャ（訳注: 参照ではなく値を取るクロージャ）です。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::thread;

const NTHREADS: u32 = 10;

// この関数は`main`スレッドで実行されます。
fn main() {
    // spawnされるクロージャを保持するためのベクタ
    let mut children = vec![];

    for i in 0..NTHREADS {
        // 新しいスレッドを起動。
        children.push(thread::spawn(move || {
            println!("this is thread number {}", i);
        }));
    }

    for child in children {
        // 子スレッドが終了するのを待ち、結果を返します。
        let _ = child.join();
    }
}</code></pre>
<p>これらのスレッドのスケジューリングはOSによって行われます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="テストケースmap-reduce"><a class="header" href="#テストケースmap-reduce">テストケース：map-reduce</a></h1>
<p>Rust makes it very easy to parallelize data processing, without many of the headaches traditionally associated with such an attempt.</p>
<p>The standard library provides great threading primitives out of the box. These, combined with Rust’s concept of Ownership and aliasing rules, automatically prevent data races.</p>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent you from manipulating state that is visible to other threads. (Where synchronization is needed, there are synchronization primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<p>In this example, we will calculate the sum of all digits in a block of numbers. We will do this by parcelling out chunks of the block into different threads. Each thread will sum its tiny block of digits, and subsequently we will sum the intermediate sums produced by each thread.</p>
<p>Note that, although we’re passing references across thread boundaries, Rust understands that we’re only passing read-only references, and that thus no unsafety or data races can occur. Also because the references we’re passing have <code>'static</code> lifetimes, Rust understands that our data won’t be destroyed while these threads are still running. (When you need to share non-<code>static</code> data between threads, you can use a smart pointer like <code>Arc</code> to keep the data alive and avoid non-<code>static</code> lifetimes.)</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::thread;

// この関数は`main`スレッドで実行されます。
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = "86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668";

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * "Map" phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple "(index, element)" is then immediately
    // "destructured" into two variables, "i" and "data_segment" with a
    // "destructuring assignment"
    for (i, data_segment) in chunked_data.enumerate() {
        println!("data segment {} is \"{}\"", i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect("should be a digit"))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!("processed segment {}, result={}", i, result);

            // "return" not needed, because Rust is an "expression language", the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * "Reduce" phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // combine each thread's intermediate results into a single final sum.
    //
    // we use the "turbofish" ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly
    // specifying the type of final_result
    let final_result = children.into_iter().map(|c| c.join().unwrap()).sum::&lt;u32&gt;();

    println!("Final sum result: {}", final_result);
}</code></pre>
<h3 id="assignments"><a class="header" href="#assignments">Assignments</a></h3>
<p>It is not wise to let our number of threads depend on user inputted data. What if the user decides to insert a lot of spaces? Do we <em>really</em> want to spawn 2,000 threads? Modify the program so that the data is always chunked into a limited number of chunks, defined by a static constant at the beginning of the program.</p>
<h3 id="参照-73"><a class="header" href="#参照-73">参照</a></h3>
<ul>
<li><a href="#スレッド">スレッド</a></li>
<li><a href="#ベクタ型">ベクタ型</a>, <a href="#イテレータ">イテレータ</a></li>
<li><a href="#クロージャ">クロージャ</a>, <a href="#所有権とムーブ">move</a> semantics and <a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code> クロージャ</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">デストラクト</a> 代入</li>
<li>型推論を補助する <a href="https://doc.rust-lang.org/book/appendix-02-operators.html?highlight=turbofish">ターボフィッシュ記法</a></li>
<li><a href="#optionとunwrap">unwrap と expect</a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="チャネル"><a class="header" href="#チャネル">チャネル</a></h1>
<p>Rustは、スレッド間のコミュニケーションのために、非同期のチャネルを提供しています。チャネルは2つのエンドポイント、すなわち送信者と受信者を介して、情報の一方向への流れを作り出すことを可能にしています。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // チャネルには`Sender&lt;T&gt;`と`Receiver&lt;T&gt;`という2つのエンドポイントがあります。
    // ここで、`T`は送信されるメッセージの型です。
    // （型アノテーションは必須ではありません。）
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // 送信者エンドポイントはコピーすることができます。
        let thread_tx = tx.clone();

        // ここでは、それぞれのスレッドが自身のIDを送信しています。
        let child = thread::spawn(move || {
            // スレッドは`thread_tx`の所有権をとり、それぞれのスレッドは
            // メッセージをチャネルにキューイングします。
            thread_tx.send(id).unwrap();

            // 送信はノンブロッキングなオペレーションなので、
            // メッセージを送信した後もすぐに実行を継続します。
            println!("thread {} finished", id);
        });

        children.push(child);
    }

    // ここで、全てのメッセージが収集されます。
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // `recv`メソッドはチャネルからメッセージを取り出します。
        // もし取り出せるメッセージが存在しない場合、`recv`は
        // 現在のスレッドをブロックします。
        ids.push(rx.recv());
    }

    // Wait for the threads to complete any remaining work
    for child in children {
        child.join().expect("oops! the child thread panicked");
    }

    // メッセージが送信された順番を表示。
    println!("{:?}", ids);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ファイルパス"><a class="header" href="#ファイルパス">ファイルパス</a></h1>
<p>The <code>Path</code> type represents file paths in the underlying filesystem. Across all platforms there is a single <code>std::path::Path</code> that abstracts over platform-specific path semantics and separators. Bring it into scope with <code>use std::path::Path;</code> when needed.</p>
<p><code>Path</code>は<code>OsStr</code>から作ることができます。そうすればそのパスが指すファイル・ディレクトリの情報を取得するためのメソッドがいくつか使えるようになります。</p>
<p><code>Path</code>はイミュータブルです。<code>Path</code>の所有権ありのバージョンが<code>PathBuf</code>です。<code>Path</code>と<code>PathBuf</code>の関係は、<code>str</code>と<code>String</code>の関係に似ています。<code>PathBuf</code>はそのまま変更でき、<code>Path</code>にデリファレンスすることができます。</p>
<p><code>Path</code>の実態はUTF-8の文字列 <strong>ではなく</strong> 、<code>OsString</code>であることに注意しましょう。したがって、<code>Path</code>を<code>&amp;str</code>に変換するのは無条件 <strong>ではなく</strong> 、失敗する可能性があります。それゆえ<code>Option</code>型が返されます。しかし<code>Path</code>から<code>OsString</code>あるいは<code>&amp;OsStr</code>への変換はそれぞれ<code>into_os_string</code>と<code>as_os_str</code>によって無条件でできます。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::path::Path;

fn main() {
    // `&amp;'static str`から`Path`を作成。
    let path = Path::new(".");

    // `display`メソッドは`Display`可能な構造体を返します。
    let _display = path.display();

    // `join`はOS固有のセパレータによってバイトのコンテナ型であるパス
    // を結合し、`PathBuf`を返します。
    let mut new_path = path.join("a").join("b");

    // `push`は`PathBuf`を`&amp;Path`で拡張します。
    new_path.push("c");
    new_path.push("myfile.tar.gz");

    // `set_file_name`は`PathBuf`のファイル名を更新します。
    new_path.set_file_name("package.tgz");

    // `PathBuf`を文字列のスライスに変換します。
    match new_path.to_str() {
        None =&gt; panic!("new path is not a valid UTF-8 sequence"),
        Some(s) =&gt; println!("new path is {}", s),
    }
}</code></pre>
<p>Be sure to check other <code>Path</code> methods and the <code>Metadata</code> struct.</p>
<h3 id="参照-74"><a class="header" href="#参照-74">参照</a></h3>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a>, <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ファイル-io"><a class="header" href="#ファイル-io">ファイル I/O</a></h1>
<p><code>File</code>構造体は開かれたファイルを表し（実際にはファイルディスクリプタのラッパーです）、読み込み・書き込み権限のどちらか一方、あるいは両方を提供します。</p>
<p>Since many things can go wrong when doing file I/O, all the <code>File</code> methods return the <code>io::Result&lt;T&gt;</code> type, which is an alias for <code>Result&lt;T, io::Error&gt;</code>.</p>
<p>これはI/Oに関するオペレーションの失敗をより明瞭にします。このおかげでプログラマは直面した失敗を全て見ることができ、より生産的な方法でそれらを扱うことが可能になります。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="open"><a class="header" href="#open"><code>open</code></a></h1>
<p><code>open</code>関数を用いることで読み込み専用モードでファイルを開くことが可能です。</p>
<p><code>File</code>はファイルディスクリプタという資源を保持しており、<code>drop</code>時にはファイルを閉じるところまで面倒を見てくれます。</p>
<pre><code class="language-rust editable ignore">use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // 目的ファイルに対する`Path`を作成
    let path = Path::new("hello.txt");
    let display = path.display();

    // pathを読み込み専用モードで開きます。これは`io::Result&lt;File&gt;`を返します。
    let mut file = match File::open(&amp;path) {
        Err(why) =&gt; panic!("couldn't open {}: {}", display, why),
        Ok(file) =&gt; file,
    };

    // ファイルの中身を文字列に読み込みます。`io::Result&lt;usize&gt;`を返します。
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!("couldn't read {}: {}", display, why),
        Ok(_) =&gt; print!("{} contains:\n{}", display, s),
    }

    // `file`がスコープから抜け、"hello.txt"が閉じられます。
}</code></pre>
<p>以下が成功時に期待されるアウトプットです。</p>
<pre><code class="language-shell">$ echo "Hello World!" &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>（気が向いたなら、上記の例を様々な形で失敗させてみましょう。例えば<code>hello.txt</code>が存在しないとか、読み込み権限がないとか、そういった状況で実行してみてください。）</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="create"><a class="header" href="#create"><code>create</code></a></h1>
<p><code>create</code>関数はファイルを書き込み専用モードで開きます。すでにファイルが存在している場合、破棄して新しい物を作成します。</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;str =
    "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
";

use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    let path = Path::new("lorem_ipsum.txt");
    let display = path.display();

    // ファイルを書き込み専用モードで開きます。返り値は`io::Result&lt;File&gt;`。
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!("couldn't create {}: {}", display, why),
        Ok(file) =&gt; file,
    };

    // `LOREM_IPSUM`の文字列を`file`に書き込みます。返り値は`io::Result&lt;()&gt;`。
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; panic!("couldn't write to {}: {}", display, why),
        Ok(_) =&gt; println!("successfully wrote to {}", display),
    }
}</code></pre>
<p>以下が成功時に期待されるアウトプットです。</p>
<pre><code class="language-shell">$ rustc create.rs &amp;&amp; ./create
successfully wrote to lorem_ipsum.txt

$ cat lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>前項の例と同じように、様々な失敗パターンをためしてみることをオススメします。</p>
<p><a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>OpenOptions</code></a>構造体を利用して、ファイルの開き方を設定できます。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="read-lines"><a class="header" href="#read-lines"><code>read lines</code></a></h1>
<h2 id="単純なやり方"><a class="header" href="#単純なやり方">単純なやり方</a></h2>
<p>テキストファイルの行を読み込むのを、初心者が初めて実装した場合、以下のようになるでしょう。</p>
<pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::read_to_string;

fn read_lines(filename: &amp;str) -&gt; Vec&lt;String&gt; {
    let mut result = Vec::new();

    for line in read_to_string(filename).unwrap().lines() {
        result.push(line.to_string())
    }

    result
}
<span class="boring">}</span></code></pre>
<p><code>lines()</code>メソッドはファイルの各行のイテレータを返すので、インラインでマップを実行し結果を収集することもできます。そうすると、より簡潔で読みやすい表現となります。</p>
<pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::read_to_string;

fn read_lines(filename: &amp;str) -&gt; Vec&lt;String&gt; {
    read_to_string(filename)
        .unwrap()  // ファイル読み込みエラーの場合はパニックします。
        .lines()  // 文字列のスライスのイテレータに分割します。
        .map(String::from)  // スライスを文字列に変換します。
        .collect()  // ベクタにまとめます。
}
<span class="boring">}</span></code></pre>
<p>上の例では、<code>lines()</code>から返された<code>&amp;str</code>をそれぞれ<code>to_string()</code>と<code>String::from</code>を使って、所有権のある<code>String</code>型に変換しなければならない点に注意してください。</p>
<h2 id="より効率的なやり方"><a class="header" href="#より効率的なやり方">より効率的なやり方</a></h2>
<p>ここでは、開いた<code>File</code>の所有権を<code>BufReader</code>構造体に渡します。<code>BufReader</code>は内部的なバッファを使い、中間のメモリ割り当てを削減します。</p>
<p><code>read_lines</code>を更新して、それぞれの行に対してメモリ上に新しい<code>String</code>オブジェクトを割り当てるのではなく、イテレータを返すようにします。</p>
<pre class="playground"><code class="language-rust no_run edition2021">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // hosts.txtファイルは現在のパスに存在しなければなりません。
    if let Ok(lines) = read_lines("./hosts.txt") {
        // イテレータを消費し、Option型のStringを返します。
        for line in lines.map_while(Result::ok) {
            println!("{}", line);
        }
    }
}

// 出力はResult型にラップされ、エラーをマッチできるようになります。
// ファイルの各行のReaderへのイテレータを返します。
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}</code></pre>
<p>このプログラムを実行すると、単に各行を出力します。</p>
<pre><code class="language-shell">$ echo -e "127.0.0.1\n192.168.0.1\n" &gt; hosts.txt
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p><code>File::open</code>はジェネリックな<code>AsRef&lt;Path&gt;</code>を引数にとるので、ジェネリックな<code>read_lines</code>メソッドも、<code>where</code>キーワードを使って、同じジェネリックな制約を持たせています。</p>
<p>この処理は、ファイルの中身全てをメモリ上の<code>String</code>にするよりも効率的です。メモリ上に<code>String</code>を作ると、より大きなファイルを取り扱う際に、パフォーマンスの問題につながります。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="子プロセス"><a class="header" href="#子プロセス">子プロセス</a></h1>
<p><code>process::Output</code>構造体は終了したプロセスのアウトプットを表し、<code>process::Command</code>構造体はプロセスの作成を行います。</p>
<pre><code class="language-rust editable ignore">use std::process::Command;

fn main() {
    let output = Command::new("rustc")
        .arg("--version")
        .output().unwrap_or_else(|e| {
            panic!("failed to execute process: {}", e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!("rustc succeeded and stdout was:\n{}", s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!("rustc failed and stderr was:\n{}", s);
    }
}</code></pre>
<p>（余裕があれば、上の例で<code>rustc</code>に不正なフラグを渡し、どうなるか見てみましょう）</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="パイプ"><a class="header" href="#パイプ">パイプ</a></h1>
<p>The <code>std::process::Child</code> struct represents a child process, and exposes the <code>stdin</code>, <code>stdout</code> and <code>stderr</code> handles for interaction with the underlying process via pipes.</p>
<pre><code class="language-rust ignore">use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
"the quick brown fox jumps over the lazy dog\n";

fn main() {
    // `wc`コマンドを起動します。
    let mut cmd = if cfg!(target_family = "windows") {
        let mut cmd = Command::new("powershell");
        cmd.arg("-Command").arg("$input | Measure-Object -Line -Word -Character");
        cmd
    } else {
        Command::new("wc")
    };
    let process = match cmd
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!("couldn't spawn wc: {}", why),
        Ok(process) =&gt; process,
    };

    // `wc`の`stdin`に文字列を書き込みます。
    //
    // `stdin`は`Option&lt;ChildStdin&gt;`型を持ちますが、今回は値を持っていることが
    // 確かなので、いきなり`unwrap`してしまって構いません。
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!("couldn't write to wc stdin: {}", why),
        Ok(_) =&gt; println!("sent pangram to wc"),
    }

    // `stdin`は上のプロセスコールのあとには有効でないので、`drop`され、
    // パイプはcloseされます。
    //
    // これは非常に重要です。というのもcloseしないと`wc`は
    // 送った値の処理を開始しないからです。

    // `stdout`フィールドも`Option&lt;ChildStdout&gt;`型なのでアンラップする必要があります
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!("couldn't read wc stdout: {}", why),
        Ok(_) =&gt; print!("wc responded with:\n{}", s),
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ドロップの延期"><a class="header" href="#ドロップの延期">ドロップの延期</a></h1>
<p><code>process::Child</code>が終了するのを待ちたい場合は、<code>process::ExitStatus</code>を返す<code>Child::wait</code>を呼び出さなくてはなりません。</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new("sleep").arg("5").spawn().unwrap();
    let _result = child.wait().unwrap();

    println!("reached end of main");
}</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
# `wait`は`sleep 5`コマンドが終了するまで5秒間実行され続けます。
reached end of main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ファイルシステムとのやり取り"><a class="header" href="#ファイルシステムとのやり取り">ファイルシステムとのやり取り</a></h1>
<p><code>std::fs</code>モジュールはファイルシステムとやり取りするための関数をいくつか持っています。</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
#[cfg(target_family = "unix")]
use std::os::unix;
#[cfg(target_family = "windows")]
use std::os::windows;
use std::path::Path;

// `% cat path`のシンプルな実装
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// `% echo s &gt; path`の簡単な実装
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// `% touch path`の簡単な実装（すでにファイルが存在しても無視します。）
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!("`mkdir a`");
    // ディレクトリを作成します。返り値は`io::Result&lt;()&gt;`。
    match fs::create_dir("a") {
        Err(why) =&gt; println!("! {:?}", why.kind()),
        Ok(_) =&gt; {},
    }

    println!("`echo hello &gt; a/b.txt`");
    // 上のmatchは`unwrap_or_else`をメソッドを用いて簡略化できます。
    echo("hello", &amp;Path::new("a/b.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`mkdir -p a/c/d`");
    // 再帰的にディレクトリを作成します。返り値は`io::Result&lt;()&gt;`。
    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`touch a/c/e.txt`");
    touch(&amp;Path::new("a/c/e.txt")).unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`ln -s ../b.txt a/c/b.txt`");
    // シンボリックリンクを作成、返り値は`io::Result&lt;()&gt;`。
    #[cfg(target_family = "unix")] {
        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {
            println!("! {:?}", why.kind());
        });
    }
    #[cfg(target_family = "windows")] {
        windows::fs::symlink_file("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {
            println!("! {:?}", why.to_string());
        });
    }

    println!("`cat a/c/b.txt`");
    match cat(&amp;Path::new("a/c/b.txt")) {
        Err(why) =&gt; println!("! {:?}", why.kind()),
        Ok(s) =&gt; println!("&gt; {}", s),
    }

    println!("`ls a`");
    // ディレクトリの内容を読み込みます。返り値は`io::Result&lt;Vec&lt;Path&gt;&gt;`。
    match fs::read_dir("a") {
        Err(why) =&gt; println!("! {:?}", why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!("&gt; {:?}", path.unwrap().path());
        },
    }

    println!("`rm a/c/e.txt`");
    // ファイルを削除。返り値は`io::Result&lt;()&gt;`。
    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });

    println!("`rmdir a/c/d`");
    // 空のディレクトリを削除。返り値は`io::Result&lt;()&gt;`。
    fs::remove_dir("a/c/d").unwrap_or_else(|why| {
        println!("! {:?}", why.kind());
    });
}</code></pre>
<p>以下が成功時に期待されるアウトプットです。</p>
<pre><code class="language-shell">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; "a/b.txt"
&gt; "a/c"
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>最終的な<code>a</code>ディレクトリの状態は以下です。</p>
<pre><code class="language-shell">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}</code></pre>
<h3 id="参照-75"><a class="header" href="#参照-75">参照</a></h3>
<p><a href="#cfg"><code>cfg!</code></a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="引数処理"><a class="header" href="#引数処理">引数処理</a></h1>
<h2 id="標準ライブラリ"><a class="header" href="#標準ライブラリ">標準ライブラリ</a></h2>
<p>コマンドライン引数は<code>std::env::args</code>を介して取得できます。これはそれぞれの引数を文字列として生成するイテレータを返します。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // ひとつ目の引数はプログラムを呼び出す際に使用したパス。
    println!("My path is {}.", args[0]);

    // 残りはプログラムに渡されたコマンドラインパラメータ。
    // プログラムはこんなふうに呼び出します。
    //   $ ./args arg1 arg2
    println!("I got {:?} arguments: {:?}.", args.len() - 1, &amp;args[1..]);
}</code></pre>
<pre><code class="language-shell">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: ["1", "2", "3"].
</code></pre>
<h2 id="クレート-2"><a class="header" href="#クレート-2">クレート</a></h2>
<p>Alternatively, there are numerous crates that can provide extra functionality when creating command-line applications. One of the more popular command line argument crates being <a href="https://rust-cli.github.io/book/tutorial/cli-args.html#parsing-cli-arguments-with-clap"><code>clap</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="引数のパース"><a class="header" href="#引数のパース">引数のパース</a></h1>
<p>matchを用いて簡単な引数をパースできます。</p>
<pre><code class="language-rust ignore">use std::env;

fn increase(number: i32) {
    println!("{}", number + 1);
}

fn decrease(number: i32) {
    println!("{}", number - 1);
}

fn help() {
    println!("usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.");
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // 引数がない場合
        1 =&gt; {
            println!("My name is 'match_args'. Try passing some arguments!");
        },
        // 引数が1つの場合
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!("This is the answer!"),
                _ =&gt; println!("This is not the answer."),
            }
        },
        // コマンドが一つと引数が一つの場合
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // 数字をパース。
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!("error: second argument not an integer");
                    help();
                    return;
                },
            };
            // コマンドをパース。
            match &amp;cmd[..] {
                "increase" =&gt; increase(number),
                "decrease" =&gt; decrease(number),
                _ =&gt; {
                    eprintln!("error: invalid command");
                    help();
                },
            }
        },
        // その他の場合
        _ =&gt; {
            // ヘルプメッセージを表示。
            help();
        }
    }
}</code></pre>
<p>If you named your program <code>match_args.rs</code> and compile it like this <code>rustc match_args.rs</code>, you can execute it as follows:</p>
<pre><code class="language-shell">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="他言語関数インターフェイス"><a class="header" href="#他言語関数インターフェイス">他言語関数インターフェイス</a></h1>
<p>RustはCのライブラリを呼び出すために他言語関数インターフェイス（Foreign Function Interface, FFI）を持っています。他言語の関数を使用する際には、そのライブラリ名を<code>#[link]</code>アトリビュートに渡し、更にそれでアノテーションされた<code>extern</code>ブロック内で宣言する必要があります。</p>
<pre><code class="language-rust ignore">use std::fmt;

// このexternブロックはlibmライブラリをリンクします。
#[cfg(target_family = "windows")]
#[link(name = "msvcrt")]
extern {
    // 他言語の関数宣言。
    // この関数は単精度浮動小数の複素数型の平方根を計算するためのものです。
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}
#[cfg(target_family = "unix")]
#[link(name = "m")]
extern {
    // 他言語の関数宣言。
    // この関数は単精度浮動小数の複素数型の平方根を計算するためのものです。
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}

// 型安全にするためのラッパ
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // calling a foreign function is an unsafe operation
    let z_sqrt = unsafe { csqrtf(z) };

    println!("the square root of {:?} is {:?}", z, z_sqrt);

    // calling safe API wrapped around unsafe operation
    println!("cos({:?}) = {:?}", z, cos(z));
}

// 単精度浮動小数の複素数型の最小限の実装
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, "{}-{}i", self.re, -self.im)
        } else {
            write!(f, "{}+{}i", self.re, self.im)
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="テスト-1"><a class="header" href="#テスト-1">テスト</a></h1>
<p>Rustはとても正確性を配慮したプログラミング言語であり、ソフトウェアテストを書くためのサポートを言語自身が含んでいます。</p>
<p>テストには3つの種類があります。</p>
<ul>
<li><a href="#ユニットテスト">単体テスト</a></li>
<li><a href="#ドキュメンテーションテスト">ドキュメンテーションテスト</a></li>
<li><a href="#統合テスト">結合テスト</a></li>
</ul>
<p>またRustではテストのために追加の依存パッケージを指定することもできます。</p>
<ul>
<li><a href="#開発中の依存関係">Dev-dependencies</a></li>
</ul>
<h2 id="参照-76"><a class="header" href="#参照-76">参照</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">The Book</a> のテストの章</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on doc-testing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ユニットテスト"><a class="header" href="#ユニットテスト">ユニットテスト</a></h1>
<p>テストは、テスト以外のコードが想定通りに動いているかを確かめるRustの関数です。一般にテスト関数は、準備をしてからテストしたいコードを実行し、そしてその結果が期待したものであるか確認します。</p>
<p>大抵の場合ユニットテストは<code>#[cfg(test)]</code><a href="#アトリビュート">アトリビュート</a>を付けた<code>tests</code><a href="#モジュール">モジュール</a>に配置されます。テスト関数には<code>#[test]</code>アトリビュートを付与します。</p>
<p>テスト関数内部で<a href="#panic-1">パニック</a>するとテストは失敗となります。次のような<a href="#macro_rules">マクロ</a>が用意されています。</p>
<ul>
<li><code>assert!(expression)</code> - 式を評価した結果が<code>false</code>であればパニックします。</li>
<li><code>assert_eq!(left, right)</code>と<code>assert_ne!(left, right)</code> - 左右の式を評価した結果が、それぞれ等しくなること、ならないことをテストします。</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// 誤った加算をする関数がテストに通らないことを示します。
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // 外部のスコープから（mod testsに）名前をインポートする便利なイディオム。
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // このアサーションはパニックして、テストは失敗します。
        // プライベートな関数もテストすることができます。
        assert_eq!(bad_add(1, 2), 3);
    }
}</code></pre>
<p><code>cargo test</code>でテストを実行できます。</p>
<pre><code class="language-shell">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="テストと"><a class="header" href="#テストと">テストと<code>?</code></a></h2>
<p>ここまでに例示したユニットテストは返り値の型を持っていませんでしたが、Rust 2018ではユニットテストが<code>Result&lt;()&gt;</code>を返し、内部で<code>?</code>を使えるようになりました！これにより、ユニットテストをさらに簡潔に記述できます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn sqrt(number: f64) -&gt; Result&lt;f64, String&gt; {
    if number &gt;= 0.0 {
        Ok(number.powf(0.5))
    } else {
        Err("negative floats don't have square roots".to_owned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() -&gt; Result&lt;(), String&gt; {
        let x = 4.0;
        assert_eq!(sqrt(x)?.powf(2.0), x);
        Ok(())
    }
}</code></pre>
<p>詳細は<a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html">エディションガイド</a>を参照してください。</p>
<h2 id="パニックをテストする"><a class="header" href="#パニックをテストする">パニックをテストする</a></h2>
<p>ある条件下でパニックすべき関数をテストするには、<code>#[should_panic]</code>アトリビュートを使います。このアトリビュートはパニックメッセージをオプションの引数<code>expected =</code>で受け取れます。パニックの原因が複数あるときに、想定した原因でパニックが発生したことを確認できます。</p>
<p><strong>Note</strong>: Rust also allows a shorthand form <code>#[should_panic = "message"]</code>, which works exactly like <code>#[should_panic(expected = "message")]</code>. Both are valid; the latter is more commonly used and is considered more explicit.</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    } else if a &lt; b {
        panic!("Divide result is zero");
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = "Divide result is zero")]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }

    #[test]
    #[should_panic = "Divide result is zero"] // This also works
    fn test_specific_panic_shorthand() {
        divide_non_zero_result(1, 10);
    }
}</code></pre>
<p>テストを実行すると、次の結果を得られます。</p>
<pre><code class="language-shell">$ cargo test

running 4 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok
test tests::test_specific_panic_shorthand ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="実行するテストを指定する"><a class="header" href="#実行するテストを指定する">実行するテストを指定する</a></h2>
<p><code>cargo test</code>にテストの名前を与えると、そのテストだけが実行されます。</p>
<pre><code class="language-shell">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>テスト名の一部を指定すると、それにマッチするすべてのテストが実行されます。</p>
<pre><code class="language-shell">$ cargo test panic
running 3 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok
test tests::test_specific_panic_shorthand ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="テストを除外する"><a class="header" href="#テストを除外する">テストを除外する</a></h2>
<p>テストを実行から除外するには、<code>#[ignore]</code>アトリビュートを使います。また、<code>cargo test -- --ignored</code>で、除外したテストのみを実行できます。</p>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}</code></pre>
<pre><code class="language-shell">$ cargo test
running 3 tests
test tests::ignored_test ... ignored
test tests::test_add ... ok
test tests::test_add_hundred ... ok

test result: ok. 2 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ドキュメンテーションテスト"><a class="header" href="#ドキュメンテーションテスト">ドキュメンテーションテスト</a></h1>
<p>Rustのプロジェクトでは、ソースコードに注釈する形でドキュメントを書くのが主流です。ドキュメンテーションコメントの記述は<a href="https://commonmark.org/">CommonMark Markdown specification</a>で行い、コードブロックも使えます。Rustは正確性を重視しているので、コードブロックもコンパイルされ、テストとして使われます。</p>
<pre><code class="language-rust ignore">/// 最初の行には関数の機能の短い要約を書きます。
///
/// 以降で詳細なドキュメンテーションを記述します。コードブロックは三重のバッククォートで始まり、
/// 暗黙的に`fn main()`と`extern crate &lt;クレート名&gt;`で囲われます。
/// `playground`クレートをテストしたいときには、次のように記述します。
///
/// ```
/// let result = playground::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// 一般的に、ドキュメンテーションコメントは
/// "Examples", "Panics", "Failures" という章から成ります。
///
/// 次の関数は除算を実行します。
///
/// # Examples
///
/// ```
/// let result = playground::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// 第2引数がゼロであればパニックします。
///
/// ```rust,should_panic
/// // ゼロで除算するとパニックします
/// playground::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}</code></pre>
<p>ドキュメンテーションコメント中のコードブロックは、<code>cargo test</code>コマンドで自動的にテストされます。</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests playground

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="ドキュメンテーションテストの目的"><a class="header" href="#ドキュメンテーションテストの目的">ドキュメンテーションテストの目的</a></h2>
<p>ドキュメンテーションテストの主な目的は、実行例を示すことであり、これは最も大切な<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">ガイドライン</a>の一つにもなっています。これにより、ドキュメントの例を実際に動くコードとして使うことができます。しかしながら、<code>main</code>が<code>()</code>を返すために、<code>?</code>を使うとコンパイルに失敗してしまいます。ドキュメンテーションでコードブロックの一部を隠す機能で、この問題に対処できます。つまり、<code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code>を定義しておきながらそれを隠し、暗黙の<code>main</code>の内部で<code>unwrap</code>するのです。複雑なので、例を見てみましょう。</p>
<pre><code class="language-rust ignore">/// ドキュメンテーションテストで、`try_main`を隠して使います。
///
/// ```
/// # // 行頭に `#` を置くと行が隠されるが、コンパイルには成功します。
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // ドキュメントの本体を囲う行
/// let res = playground::try_div(10, 2)?;
/// # Ok(()) // try_mainから値を返します
/// # }
/// # fn main() { // unwrap()を実行します。
/// #    try_main().unwrap(); // try_mainを呼びunwrapすると、エラーの場合にパニックします。
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from("Divide-by-zero"))
    } else {
        Ok(a / b)
    }
}</code></pre>
<h2 id="参照-77"><a class="header" href="#参照-77">参照</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a> ドキュメンテーションのスタイルについて</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> ドキュメンテーションのガイドラインについて</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="統合テスト"><a class="header" href="#統合テスト">統合テスト</a></h1>
<p><a href="#ユニットテスト">ユニットテスト</a>は、独立したモジュールを一つずつテストするものであり、テストは小さく、プライベートなコードについてもテストすることができます。統合テストはクレートの外側にあるもので、他の外部のコードと同様に、パブリックなインタフェースだけを使います。統合テストの目的は、ライブラリのそれぞれのモジュールが連携して正しく動作するかどうかテストすることです。</p>
<p>Cargoは、<code>src</code>ディレクトリと並んで配置された<code>tests</code>ディレクトリを統合テストとして扱います。</p>
<p>ファイル<code>src/lib.rs</code>：</p>
<pre><code class="language-rust ignore">// `adder`という名前のクレートの内部で、次の関数を定義します。
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}</code></pre>
<p>テストを含むファイル<code>tests/integration_test.rs</code>：</p>
<pre><code class="language-rust ignore">#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}</code></pre>
<p><code>cargo test</code>コマンドでテストを実行します。</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>tests</code>ディレクトリにあるRustのソースファイルは別のクレートとしてコンパイルされます。統合テストの間でコードを共有するには、パブリックな関数をモジュールに入れて、それぞれのテストでインポートして利用する方法があります。</p>
<p>ファイル<code>tests/common.rs</code>：</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // 必要なファイル・ディレクトリの作成やサーバの起動といった準備を行うコードを記述します。
}</code></pre>
<p>テストを含むファイル<code>tests/integration_test.rs</code>：</p>
<pre><code class="language-rust ignore">// 共通のモジュールをインポートします。
mod common;

#[test]
fn test_add() {
    // 共通のコードを利用します。
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}</code></pre>
<p>モジュールを<code>tests/common.rs</code>に記述することも可能ですが、<code>tests/common.rs</code>中のテストも自動的に実行されてしまうため非推奨です。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="開発中の依存関係"><a class="header" href="#開発中の依存関係">開発中の依存関係</a></h1>
<p>テスト（あるいは例やベンチマーク）のためだけに、あるクレートに依存しなければならないことがあります。このような依存関係は、<code>Cargo.toml</code>の<code>[dev-dependencies]</code>セクションに追加します。このセクションに追加した依存関係は、このパッケージに依存するパッケージには適用されません。</p>
<p>One such example is <a href="https://docs.rs/pretty_assertions/1.0.0/pretty_assertions/index.html"><code>pretty_assertions</code></a>, which extends standard <code>assert_eq!</code> and <code>assert_ne!</code> macros, to provide colorful diff. File <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># 本節の内容に関係のない行は省略しています。
[dev-dependencies]
pretty_assertions = "1"
</code></pre>
<p>ファイル<code>src/lib.rs</code>：</p>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq; // テストのためのクレートであり、
                                      // テスト以外のコードには使えません。

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}</code></pre>
<h2 id="参照-78"><a class="header" href="#参照-78">参照</a></h2>
<p><a href="http://doc.crates.io/specifying-dependencies.html">Cargo</a> 依存関係の指定について</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="安全でない操作"><a class="header" href="#安全でない操作">安全でない操作</a></h1>
<p>この章の内容を見る前に、<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">公式ドキュメント</a>から引用した次の文章をお読みください。「コードベース中の、アンセーフな操作をするコードの量は、可能な限り小さく無くてはならない。」この戒めを頭に叩き込んだ上で、さあはじめましょう！Rustにおいて、アンセーフなブロックはコンパイラのチェックをスルーするために使われます。具体的には以下の4つの主要なユースケースがあります。</p>
<ul>
<li>生ポインタのデリファレンス</li>
<li>安全でない関数やメソッドの呼び出し(FFI経由の関数の呼び出しを含む (詳細は <a href="#他言語関数インターフェイス">本書のFFIに関する説明</a> を参照ください))</li>
<li>静的なミュータブル変数へのアクセスや変更</li>
<li>安全でないトレイトの実装</li>
</ul>
<h3 id="生ポインタ"><a class="header" href="#生ポインタ">生ポインタ</a></h3>
<p>生ポインタ<code>*</code>と参照<code>&amp;T</code>はよく似た機能を持ちますが、後者は必ず有効なデータを指していることが借用チェッカーによって保証されているので、常に安全です。生ポインタのデリファレンスはアンセーフなブロックでしか実行できません。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}</code></pre>
<h3 id="安全でない関数呼び出し"><a class="header" href="#安全でない関数呼び出し">安全でない関数呼び出し</a></h3>
<p>関数は <code>unsafe</code> として宣言できます。これはコンパイラの代わりにプログラマの責任で正しさを保証することを意味します。例として <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a>があります。この関数は最初の要素へのポインタと長さを指定してスライスを作成します。</p>
<pre class="playground"><code class="language-rust editable edition2021">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);

        assert_eq!(some_vector.as_slice(), my_slice);
    }
}</code></pre>
<p><code>slice::from_raw_parts</code> は、次のふたつの仮定に基づいて処理します。ひとつは渡されたポインタが有効なメモリ位置を指していること、もうひとつはそのメモリに格納された値が正しい型であることです。この仮定を満たさない場合、プログラムの動作は不定となり、何が起こるかわかりません。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="インラインアセンブリ"><a class="header" href="#インラインアセンブリ">インラインアセンブリ</a></h1>
<p>Rustは<code>asm!</code>マクロによってインラインアセンブリをサポートしています。コンパイラが生成するアセンブリに、手書きのアセンブリを埋め込むことができます。一般的には必要ありませんが、要求されるパフォーマンスやタイミングを達成するために必要な場合があります。カーネルコードのような、低レベルなハードウェアの基本要素にアクセスする場合にも、この機能が必要でしょう。</p>
<blockquote>
<p><strong>注意</strong>: 以下の例はx86/x86-64アセンブリで書かれていますが、他のアーキテクチャもサポートされています。</p>
</blockquote>
<p>インラインアセンブリは現在以下のアーキテクチャでサポートされています。</p>
<ul>
<li>x86とx86-64</li>
<li>ARM</li>
<li>AArch64</li>
<li>RISC-V</li>
</ul>
<h2 id="基本的な使い方"><a class="header" href="#基本的な使い方">基本的な使い方</a></h2>
<p>最も単純な例から始めましょう。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

unsafe {
    asm!("nop");
}
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>これは、コンパイラが生成したアセンブリに、NOP（no operation）命令を挿入します。すべての<code>asm!</code>呼び出しは、<code>unsafe</code>ブロックの中になければいけません。インラインアセンブリは任意の命令を挿入でき、不変条件を壊してしまうからです。挿入される命令は、文字列リテラルとして<code>asm!</code>マクロの第一引数に列挙されます。</p>
<h2 id="入力と出力"><a class="header" href="#入力と出力">入力と出力</a></h2>
<p>何もしない命令を挿入しても面白くありません。実際にデータを操作してみましょう。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let x: u64;
unsafe {
    asm!("mov {}, 5", out(reg) x);
}
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>これは<code>u64</code>型の変数<code>x</code>に<code>5</code>の値を書き込んでいます。命令を指定するために利用している文字列リテラルが、実はテンプレート文字列になっています。これはRustの<a href="https://doc.rust-lang.org/std/fmt/#syntax">フォーマット文字列</a>と同じルールに従います。ですが、テンプレートに挿入される引数は、みなさんがよく知っているものとは少し違っています。まず、変数がインラインアセンブリの入力なのか出力なのかを指定する必要があります。上記の例では出力となっています。<code>out</code>と書くことで出力であると宣言しています。また、アセンブリが変数をどの種類のレジスタに格納するかについても指定する必要があります。上の例では、<code>reg</code>を指定して任意の汎用レジスタに格納しています。コンパイラはテンプレートに挿入する適切なレジスタを選び、インラインアセンブリの実行終了後、そのレジスタから変数を読みこみます。</p>
<p>入力を利用する別の例を見てみましょう。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        "mov {0}, {1}",
        "add {0}, 5",
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>この例では、変数<code>i</code>の入力に<code>5</code>を加え、その結果を変数<code>o</code>に書き込んでいます。このアセンブリ特有のやり方として、はじめに<code>i</code>の値を出力にコピーし、それから<code>5</code>を加えています。</p>
<p>この例はいくつかのことを示します。</p>
<p>まず、<code>asm!</code>では複数のテンプレート文字列を引数として利用できます。それぞれの文字列は、改行を挟んで結合されたのと同じように、独立したアセンブリコードとして扱われます。このおかげで、アセンブリコードを容易にフォーマットできます。</p>
<p>つぎに、入力は<code>out</code>ではなく<code>in</code>と書くことで宣言されています。</p>
<p>そして、他のフォーマット文字列と同じように引数を番号や名前で指定できます。インラインアセンブリのテンプレートでは、引数が2回以上利用されることが多いため、これは特に便利です。より複雑なインラインアセンブリを書く場合、この機能を使うのが推奨されます。可読性が向上し、引数の順序を変えることなく命令を並べ替えることができるからです。</p>
<p>上記の例をさらに改善して、<code>mov</code>命令をやめることもできます。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!("add {0}, 5", inout(reg) x);
}
assert_eq!(x, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p><code>inout</code>で入力でもあり出力でもある引数を指定しています。こうすることで、入力と出力を個別に指定する場合と違って、入出力が同じレジスタに割り当てられることが保証されます。</p>
<p><code>inout</code>のオペランドとして、入力と出力それぞれに異なる変数を指定することも可能です。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!("add {0}, 5", inout(reg) x =&gt; y);
}
assert_eq!(y, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<h2 id="遅延出力オペランド"><a class="header" href="#遅延出力オペランド">遅延出力オペランド</a></h2>
<p>Rustコンパイラはオペランドの割り当てに保守的です。<code>out</code>はいつでも書き込めるので、他の引数とは場所を共有できません。しかし、最適なパフォーマンスを保証するためには、できるだけ少ないレジスタを使うことが重要です。そうすることで、インラインアセンブリブロックの前後でレジスタを保存したり再読み込みしたりする必要がありません。これを達成するために、Rustは<code>lateout</code>指定子を提供します。全ての入力が消費された後でのみ書き込まれる出力に利用できます。この指定子には<code>inlateout</code>という変化形もあります。</p>
<p>以下は、<code>release</code>モードやその他の最適化された場合に、<code>inlateout</code>を利用 <em>できない</em> 例です。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        "add {0}, {1}",
        "add {0}, {2}",
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>In unoptimized cases (e.g. <code>Debug</code> mode), replacing <code>inout(reg) a</code> with <code>inlateout(reg) a</code> in the above example can continue to give the expected result. However, with <code>release</code> mode or other optimized cases, using <code>inlateout(reg) a</code> can instead lead to the final value <code>a = 16</code>, causing the assertion to fail.</p>
<p>というのも、最適化されている場合、コンパイラは<code>b</code>と<code>c</code>が同じ値だと知っているので、<code>b</code>と<code>c</code>の入力に同じレジスタを割り当てる場合があります。もし<code>inlateout</code>が使われていたら、<code>a</code>と<code>c</code>に同じレジスタが割り当てられ、最初の<code>add</code>命令によって<code>c</code>の値が上書きされるでしょう。<code>inout(reg) a</code>の使用により<code>a</code>に対する独立したレジスタ割り当てが保証されるのとは対照的です。</p>
<p>しかし、次の例では、全ての入力レジスタが読み込まれた後でのみ出力が変更されるので、<code>inlateout</code>を利用できます。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!("add {0}, {1}", inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>このアセンブリコードは、<code>a</code>と<code>b</code>が同じレジスタに割り当てられても、正しく動作します。</p>
<h2 id="明示的なレジスタオペランド"><a class="header" href="#明示的なレジスタオペランド">明示的なレジスタオペランド</a></h2>
<p>いくつかの命令では、オペランドが特定のレジスタにある必要があります。したがって、Rustのインラインアセンブリでは、より具体的な制約指定子を提供しています。<code>reg</code>は一般的にどのアーキテクチャでも利用可能ですが、明示的レジスタはアーキテクチャに強く依存しています。たとえば、x86の汎用レジスタである<code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code>、<code>ebp</code>、<code>esi</code>、<code>edi</code>などは、その名前で指定できます。</p>
<pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!("out 0x64, eax", in("eax") cmd);
}
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>この例では、<code>out</code>命令を呼び出して、<code>cmd</code>変数の中身を<code>0x64</code>ポートに出力しています。<code>out</code>命令は<code>eax</code>とそのサブレジスタのみをオペランドとして受け取るため、<code>eax</code>の制約指定子を使わなければなりません。</p>
<blockquote>
<p><strong>注意</strong>: 他のオペランドタイプと異なり、明示的なレジスタオペランドはテンプレート文字列中で利用できません。<code>{}</code>を使えないので、レジスタの名前を直接書く必要があります。また、オペランドのリストの中で他のオペランドタイプの一番最後に置かれなくてはなりません。</p>
</blockquote>
<p>x86の<code>mul</code>命令を使った次の例を考えてみましょう。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

fn mul(a: u64, b: u64) -&gt; u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // x86のmul命令はraxを暗黙的な入力に取り、
            // 128ビットの乗算結果をrax:rdxに書き込みます。
            "mul {}",
            in(reg) a,
            inlateout("rax") b =&gt; lo,
            lateout("rdx") hi
        );
    }

    ((hi as u128) &lt;&lt; 64) + lo as u128
}
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p><code>mul</code>命令を使って2つの64ビットの入力を128ビットの結果に出力しています。唯一の明示的なオペランドはレジスタで、変数<code>a</code>から入力します。2つ目のオペランドは暗黙的であり、<code>rax</code>レジスタである必要があります。変数<code>b</code>から<code>rax</code>レジスタに入力します。計算結果の下位64ビットは<code>rax</code>レジスタに保存され、そこから変数<code>lo</code>に出力されます。上位64ビットは<code>rdx</code>レジスタに保存され、そこから変数<code>hi</code>に出力されます。</p>
<h2 id="クロバーレジスタ"><a class="header" href="#クロバーレジスタ">クロバーレジスタ</a></h2>
<p>多くの場合、インラインアセンブリは出力として必要のない状態を変更することがあります。これは普通、アセンブリでスクラッチレジスタを利用する必要があったり、私たちがこれ以上必要としていない状態を命令が変更したりするためです。この状態を一般的に“クロバー“（訳注：上書き）と呼びます。私たちはコンパイラにこのことを伝える必要があります。なぜならコンパイラは、インラインアセンブリブロックの前後で、この状態を保存して復元しなくてはならない可能性があるからです。</p>
<pre class="playground"><code class="language-rust edition2021">use std::arch::asm;

<span class="boring">#[cfg(target_arch = "x86_64")]
</span>fn main() {
    // 4バイトのエントリー3つ
    let mut name_buf = [0_u8; 12];
    // 文字列はasciiとしてebx, edx, ecxの順に保存されています。
    // ebxは予約されているので、アセンブリはebxの値を維持する必要があります。
    // 従ってメインのアセンブリの前後でプッシュおよびポップを行います。
    // （以下は64ビットプロセッサの64ビットモードの場合。32ビットプロセッサはebxを利用します。）

    unsafe {
        asm!(
            "push rbx",
            "cpuid",
            "mov [rdi], ebx",
            "mov [rdi + 4], edx",
            "mov [rdi + 8], ecx",
            "pop rbx",
            // いくつかのアセンブリ命令を追加してRustのコードを単純化するために
            // 値を格納する配列へのポインタを利用します。
            // しかし、`out("ecx") val`のような明示的なレジスタの出力とは違い、
            // アセンブリの動作をより明示的にします。
            // *ポインタそのもの* は後ろに書かれていても入力にすぎません。
            in("rdi") name_buf.as_mut_ptr(),
            // cpuid 0を選択し、eaxをクロバーに指定します。
            inout("eax") 0 =&gt; _,
            // cpuidは以下のレジスタもクロバーします。
            out("ecx") _,
            out("edx") _,
        );
    }

    let name = core::str::from_utf8(&amp;name_buf).unwrap();
    println!("CPU Manufacturer ID: {}", name);
}

<span class="boring">#[cfg(not(target_arch = "x86_64"))]
</span><span class="boring">fn main() {}</span></code></pre>
<p>上の例では、<code>cpuid</code>命令を使い、CPUベンタIDを読み込んでいます。この命令は<code>eax</code>にサポートされている最大の<code>cpuid</code>引数を書き込み、<code>ebx</code>、<code>edx</code>、<code>ecx</code>の順にCPUベンダIDをASCIIコードとして書き込みます。</p>
<p><code>eax</code>は読み込まれることはありません。しかし、コンパイラがアセンブリ以前にこれらのレジスタにあった値を保存できるように、レジスタが変更されたことをコンパイラに伝える必要があります。そのために、変数名の代わりに<code>_</code>を用いて出力を宣言し、出力の値が破棄されるということを示しています。</p>
<p>このコードは<code>ebx</code>がLLVMによって予約されたレジスタであるという制約を回避しています。LLVMは、自身がレジスタを完全にコントロールし、アセンブリブロックを抜ける前に元の状態を復元しなくてはならないと考えています。そのため、コンパイラが<code>in(reg)</code>のような汎用レジスタクラスを満たすために使用する場合 <strong>を除いて</strong> <code>ebx</code>を入力や出力として利用できません。つまり、予約されたレジスタを利用する場合に、<code>reg</code>オペランドは危険なのです。入力と出力が同じレジスタを共有しているので、知らないうちに入力や出力を破壊してしまうかもしれません。</p>
<p>これを回避するために、<code>rdi</code>を用いて出力の配列へのポインタを保管し、<code>push</code>で<code>ebx</code>を保存し、アセンブリブロック内で<code>ebx</code>から読み込んで配列に書き込み、<code>pop</code>で<code>ebx</code>を元の状態に戻しています。<code>push</code>と<code>pop</code>は完全な64ビットの<code>rbx</code>レジスタを使って、レジスタ全体を確実に保存しています。32ビットの場合、<code>push</code>と<code>pop</code>において<code>ebx</code>がかわりに利用されるでしょう。</p>
<p>アセンブリコード内部で利用するスクラッチレジスタを獲得するために、汎用レジスタクラスとともに使用することもできます。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

// シフト演算と加算を利用してxに6をかけます。
let mut x: u64 = 4;
unsafe {
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<h2 id="シンボルオペランドとabiクロバー"><a class="header" href="#シンボルオペランドとabiクロバー">シンボル・オペランドとABIクロバー</a></h2>
<p>デフォルトでは、<code>asm!</code>は、出力として指定されていないレジスタはアセンブリコードによって中身が維持される、と考えます。<code>asm!</code>に渡される<a href="https://doc.rust-lang.org/stable/reference/inline-assembly.html#abi-clobbers"><code>clobber_abi</code></a>引数は、与えられた呼び出し規約のABIに従って、必要なクロバーオペランドを自動的に挿入するようコンパイラに伝えます。そのABIで完全に保存されていないレジスタは、クロバーとして扱われます。複数の <code>clobber_abi</code> 引数を指定すると、指定されたすべてのABIのクロバーが挿入されます。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

extern "C" fn foo(arg: i32) -&gt; i32 {
    println!("arg = {}", arg);
    arg * 2
}

fn call_foo(arg: i32) -&gt; i32 {
    unsafe {
        let result;
        asm!(
            "call {}",
            // 呼び出す関数ポインタ
            in(reg) foo,
            // 最初の引数はrdiにあります。
            in("rdi") arg,
            // 戻り値はraxにあります。
            out("rax") result,
            // "C"の呼び出し規約で保存されていないすべてのレジスタをクロバーに指定。
            clobber_abi("C"),
        );
        result
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<h2 id="レジスタテンプレート修飾子"><a class="header" href="#レジスタテンプレート修飾子">レジスタテンプレート修飾子</a></h2>
<p>テンプレート文字列に挿入されるレジスタの名前のフォーマット方法について、細かい制御が必要な場合があります。アーキテクチャのアセンブリ言語が、同じレジスタに別名を持っている場合です。典型的な例としては、レジスタの部分集合に対する“ビュー“があります（例：64ビットレジスタの下位32ビット）。</p>
<p>デフォルトでは、コンパイラは常に完全なレジスタサイズの名前を選択します（例：x86-64では<code>rax</code>、x86では<code>eax</code>、など）。</p>
<p>この挙動は、フォーマット文字列と同じように、テンプレート文字列のオペランドに修飾子を利用することで上書きできます。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let mut x: u16 = 0xab;

unsafe {
    asm!("mov {0:h}, {0:l}", inout(reg_abcd) x);
}

assert_eq!(x, 0xabab);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>この例では、<code>reg_abcd</code>レジスタクラスを用いて、レジスタアロケータを4つのレガシーなx86レジスタ（<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>）に制限しています。このうち最初の2バイトは独立して指定できます。</p>
<p>レジスタアロケータが<code>x</code>を<code>ax</code>レジスタに割り当てることにしたと仮定しましょう。<code>h</code>修飾子はそのレジスタの上位バイトのレジスタ名を出力し、<code>l</code>修飾子は下位バイトのレジスタ名を出力します。したがって、このアセンブリコードは<code>mov ah, al</code>に展開され、値の下位バイトを上位バイトにコピーします。</p>
<p>より小さなデータ型（例：<code>u16</code>）をオペランドに利用し、テンプレート修飾子を使い忘れた場合、コンパイラは警告を出力し、正しい修飾子を提案してくれます。</p>
<h2 id="メモリアドレスオペランド"><a class="header" href="#メモリアドレスオペランド">メモリアドレスオペランド</a></h2>
<p>アセンブリ命令はオペランドがメモリアドレスやメモリロケーション経由で渡される必要なこともあります。そのときは手動で、ターゲットのアーキテクチャによって指定されたメモリアドレスのシンタックスを利用しなくてはなりません。例えば、Intelのアセンブリシンタックスを使うx86/x86_64の場合、入出力を<code>[]</code>で囲んで、メモリオペランドであることを示さなくてはなりません。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

fn load_fpu_control_word(control: u16) {
    unsafe {
        asm!("fldcw [{}]", in(reg) &amp;control, options(nostack));
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<h2 id="ラベル"><a class="header" href="#ラベル">ラベル</a></h2>
<p>名前つきラベルの再利用は、ローカルかそうでないかに関わらず、アセンブラやリンカのエラーを引き起こしたり、変な挙動の原因となります。名前つきラベルの再利用は以下のようなケースがあります。</p>
<ul>
<li>明示的再利用：同じラベルを1つの<code>asm!</code>ブロック中で、または複数のブロック中で2回以上利用する場合です。</li>
<li>インライン化による暗黙の再利用：コンパイラは<code>asm!</code>ブロックの複数のコピーをインスタンス化する場合があります。例えば、<code>asm!</code>ブロックを含む関数が複数箇所でインライン化される場合です。</li>
<li>LTO（訳注：Link Time Optimizationの略）による暗黙の再利用：LTOは <em>他のクレート</em> のコードを同じコード生成単位に配置するため、同じ名前のラベルを持ち込む場合があります。</li>
</ul>
<p>そのため、インラインアセンブリコードの中では、GNUアセンブラの <strong>数値型</strong><a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">ローカルラベル</a>のみ使用してください。アセンブリコード内でシンボルを定義すると、シンボル定義の重複により、アセンブラやリンカのエラーが発生する可能性があります。</p>
<p>さらに、x86でデフォルトのIntel構文を使用する場合、<a href="https://bugs.llvm.org/show_bug.cgi?id=36144">LLVMのバグ</a>によって、<code>0</code>、<code>11</code>、<code>101010</code>といった<code>0</code>と<code>1</code>だけで構成されたラベルは、バイナリ値として解釈されてしまうため、使用してはいけません。<code>options(att_syntax)</code>を使うと曖昧さを避けられますが、<code>asm!</code>ブロック <em>全体</em> の構文に影響します。（<code>options</code>については、後述の<a href="#options">オプション</a>を参照してください。）</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let mut a = 0;
unsafe {
    asm!(
        "mov {0}, 10",
        "2:",
        "sub {0}, 1",
        "cmp {0}, 3",
        "jle 2f",
        "jmp 2b",
        "2:",
        "add {0}, 2",
        out(reg) a
    );
}
assert_eq!(a, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>このコードは、<code>{0}</code>のレジスタの値を10から3にデクリメントし、2を加え、<code>a</code>にその値を保存します。</p>
<p>この例は、以下のことを示しています。</p>
<ul>
<li>まず、ラベルとして同じ数字を複数回、同じインラインブロックで利用できます。</li>
<li>つぎに、数字のラベルが参照として(例えば、命令のオペランドに)利用された場合、“b”（“後方”）や“f“（“前方”）の接尾辞が数字のラベルに追加されなくてはなりません。そうすることで、この数字の指定された方向の最も近いラベルを参照できます。</li>
</ul>
<h2 id="options"><a class="header" href="#options">オプション</a></h2>
<p>デフォルトでは、インラインアセンブリブロックは、カスタム呼び出し規約をもつ外部のFFI関数呼び出しと同じように扱われます:メモリを読み込んだり書き込んだり、観測可能な副作用を持っていたりするかもしれません。しかし、多くの場合、アセンブリコードが実際に何をするかという情報を多く与えて、より最適化できる方が望ましいでしょう。</p>
<p>先ほどの<code>add</code>命令の例を見てみましょう。</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(
        "add {0}, {1}",
        inlateout(reg) a, in(reg) b,
        options(pure, nomem, nostack),
    );
}
assert_eq!(a, 8);
<span class="boring">}
</span><span class="boring">}</span></code></pre>
<p>オプションは<code>asm!</code>マクロの最後の任意引数として渡されます。ここでは3つのオプションを利用しました：</p>
<ul>
<li><code>pure</code>は、アセンブリコードが観測可能な副作用を持っておらず、出力は入力のみに依存することを意味します。これにより、コンパイラオプティマイザはインラインアセンブリの呼び出し回数を減らしたり、インラインアセンブリを完全に削除したりできます。</li>
<li><code>nomem</code>は、アセンブリコードがメモリの読み書きをしないことを意味します。デフォルトでは、インラインアセンブリはアクセス可能なメモリアドレス（例えばオペランドとして渡されたポインタや、グローバルなど）の読み書きを行うとコンパイラは仮定しています。</li>
<li><code>nostack</code>は、アセンブリコードがスタックにデータをプッシュしないことを意味します。これにより、コンパイラはx86-64のスタックレッドゾーンなどの最適化を利用し、スタックポインタの調整を避けることができます。</li>
</ul>
<p>これにより、コンパイラは、出力が全く必要とされていない純粋な<code>asm!</code>ブロックを削除するなどして、<code>asm!</code>を使ったコードをより最適化できます。</p>
<p>利用可能なオプションとその効果の一覧は<a href="https://doc.rust-lang.org/stable/reference/inline-assembly.html">リファレンス</a>を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="互換性"><a class="header" href="#互換性">互換性</a></h1>
<p>The Rust language is evolving rapidly, and because of this certain compatibility issues can arise, despite efforts to ensure forwards-compatibility wherever possible.</p>
<ul>
<li><a href="#生識別子">生識別子</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="生識別子"><a class="header" href="#生識別子">生識別子</a></h1>
<p>Rustは多くのプログラミング言語と同様に、「キーワード」の概念を持っています。これらの識別子は言語にとって何かしらの意味を持ちますので、変数名や関数名、その他の場所で使用することはできません。生識別子は、通常は許されない状況でキーワードを使用することを可能にします。これは、新しいキーワードを導入したRustと、古いエディションのRustを使用したライブラリが同じ名前の変数や関数を持つ場合に特に便利です。</p>
<p>例えば、2015年エディションのRustでコンパイルされたクレート<code>foo</code>が<code>try</code>という名前の関数をエクスポートしているとします。このキーワードは2018年エディションで新機能として予約されていますので、生識別子がなければ、この関数を名付ける方法がありません。</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}</code></pre>
<p>このエラーが出ます：</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>これは生識別子を使って書くことができます：</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="周辺情報"><a class="header" href="#周辺情報">周辺情報</a></h1>
<p>この章では、プログラミングそれ自体に関係はないけれども、色々と人々の役に立つ機能やインフラについて説明していきます。例えば：</p>
<ul>
<li><a href="#ドキュメンテーション">ドキュメンテーション</a>: Rust付属コマンド<code>rustdoc</code>を用いて、ライブラリのドキュメントを生成します。</li>
<li><a href="#プレイグラウンド">プレイグラウンド</a>: あなたのドキュメンテーションにRust Playgroundを組み込めます。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ドキュメンテーション"><a class="header" href="#ドキュメンテーション">ドキュメンテーション</a></h1>
<p>Use <code>cargo doc</code> to build documentation in <code>target/doc</code>, <code>cargo doc --open</code> will automatically open it in your web browser.</p>
<p>Use <code>cargo test</code> to run all tests (including documentation tests), and <code>cargo test --doc</code> to only run documentation tests.</p>
<p>These commands will appropriately invoke <code>rustdoc</code> (and <code>rustc</code>) as required.</p>
<h2 id="ドキュメンテーションコメント"><a class="header" href="#ドキュメンテーションコメント">ドキュメンテーションコメント</a></h2>
<p>ドキュメンテーションコメントとは<code>rustdoc</code>を使用した際にドキュメントにコンパイルされるコメントのことです。<code>///</code>によって普通のコメントと区別され、ここでは<a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>を使用することができます。ドキュメンテーションコメントは大規模なプロジェクトの際に非常に有用です。</p>
<pre><code class="language-rust editable ignore">#![crate_name = "doc"]

/// あらゆる人物はここに代表されます。
pub struct Person {
    /// ジュリエットがどんなに名前というものを嫌っていようと、
    /// 人物には名前が必要です。
    name: String,
}

impl Person {
    /// 与えられた名前を持つpersonを返します。
    ///
    /// # Examples
    ///
    /// ```
    /// // バッククォートによってRustのコードをコメント中に挟むこと
    /// // もできます。`rustdoc`に--testを渡せば、テストも行えます！
    /// // （訳注: pythonのdoctestと同じです。）
    /// use doc::Person;
    /// let person = Person::new("name");
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// フレンドリーに挨拶しましょう！
    ///
    /// このメソッドを呼び出した`Person`に対して
    /// "Hello, [name](Person::name)"と話しかけます。
    pub fn hello(&amp;self) {
        println!("Hello, {}!", self.name);
    }
}

fn main() {
    let john = Person::new("John");

    john.hello();
}</code></pre>
<p>To run the tests, first build the code as a library, then tell <code>rustdoc</code> where to find the library so it can link it into each doctest program:</p>
<pre><code class="language-shell">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc="libdoc.rlib" doc.rs
</code></pre>
<h2 id="doc-attributes"><a class="header" href="#doc-attributes">Doc attributes</a></h2>
<p>Below are a few examples of the most common <code>#[doc]</code> attributes used with <code>rustdoc</code>.</p>
<h3 id="inline"><a class="header" href="#inline"><code>inline</code></a></h3>
<p>Used to inline docs, instead of linking out to separate page.</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;

/// bar docs
pub mod bar {
    /// the docs for Bar
    pub struct Bar;
}</code></pre>
<h3 id="no_inline"><a class="header" href="#no_inline"><code>no_inline</code></a></h3>
<p>Used to prevent linking out to separate page or anywhere.</p>
<pre><code class="language-rust ignore">// Example from libcore/prelude
#[doc(no_inline)]
pub use crate::mem::drop;</code></pre>
<h3 id="hidden"><a class="header" href="#hidden"><code>hidden</code></a></h3>
<p>Using this tells <code>rustdoc</code> not to include this in documentation:</p>
<pre><code class="language-rust editable ignore">// Example from the futures-rs library
#[doc(hidden)]
pub use self::async_await::*;</code></pre>
<p>For documentation, <code>rustdoc</code> is widely used by the community. It’s what is used to generate the <a href="https://doc.rust-lang.org/std/">std library docs</a>.</p>
<h3 id="参照-79"><a class="header" href="#参照-79">参照</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="プレイグラウンド"><a class="header" href="#プレイグラウンド">プレイグラウンド</a></h1>
<p><a href="https://play.rust-lang.org/">Rust Playground</a>では、RustのコードをWebのインターフェースを通じて実験できます。</p>
<h2 id="mdbookと組み合わせる"><a class="header" href="#mdbookと組み合わせる"><code>mdbook</code>と組み合わせる</a></h2>
<p><a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a>では、コード例を実行・編集可能にできます。</p>
<pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!("Hello World!");
}</code></pre>
<p>これにより、読者はあなたのコード例を実行するだけでなく、変更することもできます。<code>editable</code>という単語をカンマで区切って、あなたのコードブロックに追加するのがキーです。</p>
<pre><code class="language-markdown">```rust,editable
//...place your code here
```
</code></pre>
<p>加えて、<code>mdbook</code>がビルドやテストを実行するときに、あなたのコードをスキップさせたい場合は、<code>ignore</code>を追加できます。</p>
<pre><code class="language-markdown">```rust,editable,ignore
//...place your code here
```
</code></pre>
<h2 id="ドキュメントと組み合わせる"><a class="header" href="#ドキュメントと組み合わせる">ドキュメントと組み合わせる</a></h2>
<p><a href="https://doc.rust-lang.org/core/">Rustの公式ドキュメント</a>には、「実行(Run)」ボタンがある場合があります。クリックすると、新しいタブでRust Playgroundが開き、コード例が表示されます。この機能は、#[doc]アトリビュートの<a href="https://doc.rust-lang.org/rustdoc/write-documentation/the-doc-attribute.html#html_playground_url"><code>html_playground_url</code></a>の値で有効化できます。</p>
<pre><code class="language-text">#![doc(html_playground_url = "https://play.rust-lang.org/")]
//! ```
//! println!("Hello World");
//! ```
</code></pre>
<h3 id="参照-80"><a class="header" href="#参照-80">参照</a></h3>
<ul>
<li><a href="https://play.rust-lang.org/">The Rust Playground</a></li>
<li><a href="https://github.com/integer32llc/rust-playground/">The Rust Playground On Github</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">The rustdoc Book</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
